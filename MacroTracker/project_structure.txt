.gitignore
app.json
App.tsx
assets/
  adaptive-icon.png
  favicon.png
  icon.png
  splash.png
components/
eas.json
index.ts
package.json
projectToFile.js
src/
  components/
    AddEntryModal.tsx
    AddFoodModal.tsx
    ConfirmationModal.tsx
    DailyGoalsInput.tsx
    DailyProgress.tsx
    DataManagementButtons.tsx
    FoodItem.tsx
    StatisticsChart.tsx
    ThemeSwitch.tsx
  navigation/
    AppNavigator.tsx
  screens/
    DailyEntryScreen.tsx
    FoodListScreen.tsx
    SettingsScreen.tsx
  services/
    foodService.ts
    storageService.ts
  types/
    dailyEntry.ts
    food.ts
    openRouterTypes.ts
    settings.ts
  utils/
    ai.ts
    dateUtils.ts
    iconUtils.ts
    macros.ts
    units.ts
    validationUtils.ts
tsconfig.json

---------- .gitignore ----------
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

---------- END .gitignore ----------


---------- app.json ----------

{
  "expo": {
    "name": "MacroTracker",
    "slug": "MacroTracker",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "automatic", 
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#000000"
    },
    "androidStatusBar": {
      "backgroundColor": "#000000",
      "translucent": false,
      "barStyle": "light-content"
    },
    "assetBundlePatterns": [
      "**/*"
    ],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.yourcompany.macrotracker",
      "infoPlist": { 
        "UIStatusBarStyle": "UIStatusBarStyleAutomatic" 
      }
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "package": "com.yourcompany.macrotracker",
      "userInterfaceStyle": "automatic", 
      "statusBar": { 
        "backgroundColor": "#00000000",  
        "translucent": true,             
        "barStyle": "auto"
      }
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      [
        "expo-document-picker",
        {
          "appleTeamId": "YOUR_TEAM_ID"
        }
      ]
    ],
    "extra": {
      "eas": {
        "projectId": "25ac2bcf-78a3-4f2c-a635-4fcaae7b93f1"
      }
    }
  }
}
---------- END app.json ----------


---------- App.tsx ----------
// App.tsx (Modified - Removed AppState-triggered remount)
import "react-native-get-random-values"; // MUST BE FIRST
import Toast from "react-native-toast-message";
import React, { useState, useEffect } from "react";
import AppNavigator from "./src/navigation/AppNavigator";
import { SafeAreaProvider, SafeAreaView } from "react-native-safe-area-context";
import { ThemeProvider, createTheme } from "@rneui/themed";
import { loadSettings, saveSettings } from "./src/services/storageService";
import {
  useColorScheme,
  AppState,
  AppStateStatus,
  Platform,
} from "react-native";
import {
  NavigationContainer,
  DefaultTheme,
  DarkTheme,
} from "@react-navigation/native";
import { Colors } from "@rneui/base";
import { Settings } from "./src/types/settings";
import { LogBox, View, Text } from "react-native"; //Import view for debug
import { StatusBar } from "expo-status-bar"; // changed import

LogBox.ignoreLogs(["Function components cannot be given refs"]);

declare module "@rneui/themed" {
  export interface Colors {
    text: string;
    card: string; // Added for better card styling
    successLight: string; // Lighter success color
  }
}

interface MyTheme {
  mode: "light" | "dark";
  colors: Colors;
}

const lightTheme: MyTheme = {
  mode: "light",
  colors: {
    primary: "#2e86de",
    secondary: "#6c757d",
    background: "#f8f9fa",
    grey5: "#e9ecef",
    white: "#ffffff",
    grey4: "#ced4da",
    success: "#28a745",
    successLight: "#d4edda",
    black: "#000000",
    text: "#212529",
    card: "#ffffff",
    error: "#dc3545",
    warning: "#ffc107",
    disabled: "#6c757d",
    divider: "#ced4da",
    platform: {
      ios: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      android: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      web: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      default: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
    },
    // Complete the missing grey colors
    grey0: "#f8f9fa", // Very light, almost white
    grey1: "#e9ecef", // Light grey, same as grey5 (can adjust)
    grey2: "#dee2e6", // Medium-light grey
    grey3: "#ced4da", // Medium grey, same as grey4
    greyOutline: "#adb5bd", // Slightly darker for outlines
    searchBg: "#ffffff", // Background for search input, usually white
  },
};

const darkTheme: MyTheme = {
  mode: "dark",
  colors: {
    primary: "#2e86de",
    secondary: "#adb5bd",
    background: "#121212",
    grey5: "#2c2c2c",
    white: "#ffffff",
    grey4: "#343a40",
    success: "#28a745",
    successLight: "#1f5139",
    black: "#000000",
    text: "#f8f9fa",
    card: "#1e1e1e",
    error: "#dc3545",
    warning: "#ffc107",
    disabled: "#6c757d",
    divider: "#343a40",
    platform: {
      ios: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      android: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      web: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      default: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
    },
    // Complete the missing grey colors
    grey0: "#212529", // Very dark, almost black
    grey1: "#2c2c2c", // Dark grey, same as grey5
    grey2: "#343a40", // Medium-dark grey, same as grey4
    grey3: "#495057", // Medium grey
    greyOutline: "#6c757d", // Lighter grey for outlines, same as disabled
    searchBg: "#1e1e1e", // Background for search, dark to match card
  },
};

const App = () => {
  const [themeMode, setThemeMode] = useState<"light" | "dark" | "system">(
    "system"
  );
  const [loadedSettings, setLoadedSettings] = useState<Settings | null>(null);
  const colorScheme = useColorScheme();
  // --- REMOVED: reloadKey state is no longer needed for AppState changes ---
  // const [reloadKey, setReloadKey] = useState(0);
  const [appState, setAppState] = useState(AppState.currentState); // AppState
  const [themeCheck, setThemeCheck] = useState(0); //Added theme check

  // Load initial settings
  useEffect(() => {
    const initializeApp = async () => {
      const settings = await loadSettings();
      setThemeMode(settings.theme);
      setLoadedSettings(settings);
    };
    initializeApp();
  }, []);

  // --- REMOVED: triggerReload function is no longer needed ---
  // const triggerReload = () => {
  //   setReloadKey((prevKey) => prevKey + 1);
  // };

  // --- MODIFIED: Removed triggerReload() from AppState listener ---
  useEffect(() => {
    const handleAppStateChange = (nextAppState: AppStateStatus) => {
      // --- REMOVED THIS BLOCK ---
      // This block caused the entire navigator to remount when the app
      // returned from the background (e.g., after image picker closed),
      // which prematurely closed the AddFoodModal.
      /*
      if (appState.match(/inactive|background/) && nextAppState === "active") {
        // App has come to the foreground, DON'T trigger reload anymore
        console.log("App came to foreground - Reload Trigger REMOVED");
        // triggerReload(); // <<< REMOVED THIS LINE
      }
      */
      // --- END REMOVED BLOCK ---

      setAppState(nextAppState); // Still track app state if needed elsewhere
    };

    const subscription = AppState.addEventListener(
      "change",
      handleAppStateChange
    );

    return () => {
      subscription.remove();
    };
  }, [appState]); // Keep appState dependency if you still use setAppState

  const updateTheme = (newThemeMode: "light" | "dark" | "system") => {
    const isDark =
      newThemeMode === "system"
        ? colorScheme === "dark"
        : newThemeMode === "dark";
    return isDark ? darkTheme : lightTheme;
  };

  const handleThemeChange = async (newTheme: "light" | "dark" | "system") => {
    setThemeMode(newTheme);
    if (loadedSettings) {
      const updatedSettings: Settings = {
        ...loadedSettings,
        theme: newTheme,
      };
      await saveSettings(updatedSettings);
      setLoadedSettings(updatedSettings);
    }
    setThemeCheck((t) => t + 1);
  };

  const currentTheme = updateTheme(themeMode);

  const navigationTheme = {
    dark: {
      ...DarkTheme,
      colors: {
        ...DarkTheme.colors,
        primary: currentTheme.colors.primary,
        background: currentTheme.colors.background,
        card: currentTheme.colors.card,
        text: currentTheme.colors.text,
        border: currentTheme.colors.divider,
        notification: currentTheme.colors.successLight,
      },
    },
    light: {
      ...DefaultTheme,
      colors: {
        ...DefaultTheme.colors,
        primary: currentTheme.colors.primary,
        background: currentTheme.colors.background,
        card: currentTheme.colors.card,
        text: currentTheme.colors.text,
        border: currentTheme.colors.divider,
        notification: currentTheme.colors.success,
      },
    },
  };

  // Determine status bar style based on theme
  const statusBarTheme = themeMode === "system" ? colorScheme : themeMode;

  const backgroundColor = currentTheme.colors.background;

  return (
    // --- REMOVED: key={themeMode} - Re-evalute if needed, usually not necessary for theme changes handled internally ---
    // <ThemeProvider theme={createTheme(currentTheme)} key={themeMode}>
    <ThemeProvider theme={createTheme(currentTheme)}>
      {/* Added to try force to behave like a normal text */}
      <SafeAreaView style={{ flex: 1, backgroundColor: backgroundColor }}>
        {/* Enclose everything in SafeAreaView */}
        <StatusBar
          style={statusBarTheme === "dark" ? "light" : "dark"} // Text color
          backgroundColor={backgroundColor} // Background color from theme
          translucent={false} // Disable translucency for now (easier debugging)
        />
        <NavigationContainer
          theme={
            currentTheme.mode === "dark"
              ? navigationTheme.dark
              : navigationTheme.light
          }
        >
          {/* --- REMOVED: key={reloadKey} - Navigator no longer forced to remount --- */}
          {/* <AppNavigator onThemeChange={handleThemeChange} key={reloadKey} /> */}
          <AppNavigator onThemeChange={handleThemeChange} />
        </NavigationContainer>
        <Toast />
      </SafeAreaView>
    </ThemeProvider>
  );
};

export default App;
---------- END App.tsx ----------


---------- adaptive-icon.png ----------
(Image file - content not included)
---------- END adaptive-icon.png ----------


---------- favicon.png ----------
(Image file - content not included)
---------- END favicon.png ----------


---------- icon.png ----------
(Image file - content not included)
---------- END icon.png ----------


---------- splash.png ----------
(Image file - content not included)
---------- END splash.png ----------


---------- eas.json ----------
{
  "cli": {
    "version": ">= 13.4.1",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal"
    },
    "preview": {
      "android": {
        "buildType": "apk"
      }
    },
    "production": {
      "autoIncrement": true
    }
  },
  "submit": {
    "production": {}
  }
}

---------- END eas.json ----------


---------- index.ts ----------
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);

---------- END index.ts ----------


---------- package.json ----------
{
  "name": "macrotracker",
  "license": "0BSD",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@react-native-async-storage/async-storage": "^2.1.2",
    "@react-native-community/datetimepicker": "8.2.0",
    "@react-navigation/bottom-tabs": "^7.3.1",
    "@react-navigation/native": "^7.0.17",
    "@rneui/base": "^4.0.0-rc.7",
    "@rneui/themed": "^4.0.0-rc.8",
    "@types/d3-scale": "^4.0.9",
    "d3-scale": "^4.0.2",
    "date-fns": "^4.1.0",
    "expo": "~52.0.40",
    "expo-document-picker": "^13.0.3",
    "expo-file-system": "^18.0.12",
    "expo-image-picker": "^16.0.6",
    "expo-sharing": "~13.0.1",
    "expo-status-bar": "~2.0.1",
    "react": "18.3.1",
    "react-native": "0.76.7",
    "react-native-config": "^1.5.5",
    "react-native-get-random-values": "^1.11.0",
    "react-native-mime-types": "^2.5.0",
    "react-native-reanimated": "~3.16.1",
    "react-native-safe-area-context": "^4.14.1",
    "react-native-screens": "^4.9.2",
    "react-native-svg": "^15.11.2",
    "react-native-toast-message": "^2.2.1",
    "react-native-uuid": "^2.0.3",
    "react-native-webview": "^13.13.4",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/react": "~18.3.12",
    "@types/react-native": "^0.73.0",
    "@types/react-native-svg-charts": "^5.0.16",
    "@types/uuid": "^10.0.0",
    "typescript": "^5.3.3",
    "victory": "^37.3.6"
  },
  "private": true
}

---------- END package.json ----------


---------- projectToFile.js ----------
const fs = require('fs');
const path = require('path');

async function generateProjectStructureAndContent(projectRoot, outputFile) {
    const excludedDirs = ['node_modules', '.git', '.expo', 'android', 'ios', '__tests__', 'dist', 'build', '.vscode'];
    const excludedFiles = ['.DS_Store', 'package-lock.json', 'yarn.lock', 'bun.lockb', 'metro.config.js', 'babel.config.js'];
    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.webp', '.ico']; // Add more if needed

    let fileStructureTree = '';  // For the initial tree structure
    let fileContents = '';      // For the file contents

    async function traverseDirectory(dir, indent = '') {
        const entries = await fs.promises.readdir(dir, { withFileTypes: true });

        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);

            if (excludedDirs.includes(entry.name)) {
                continue;
            }

            if (entry.isDirectory()) {
                fileStructureTree += `${indent}${entry.name}/\n`;
                await traverseDirectory(fullPath, indent + '  ');
            } else if (entry.isFile()) {
                if (excludedFiles.includes(entry.name)) {
                    continue;
                }
                fileStructureTree += `${indent}${entry.name}\n`;
                const fileExtension = path.extname(entry.name).toLowerCase();

                if (!imageExtensions.includes(fileExtension)) {
                    fileContents += `\n---------- ${entry.name} ----------\n`;
                    try {
                        const fileContent = await fs.promises.readFile(fullPath, 'utf-8');
                        fileContents += `${fileContent}\n`;
                    } catch (readError) {
                        fileContents += `ERROR READING FILE: ${readError.message}\n`;
                    }
                    fileContents += `---------- END ${entry.name} ----------\n\n`;
                } else {
                     fileContents += `\n---------- ${entry.name} ----------\n`;
                     fileContents += `(Image file - content not included)\n`;
                     fileContents += `---------- END ${entry.name} ----------\n\n`;
                }
            }
        }
    }

    try {
        await traverseDirectory(projectRoot);
        const fullOutput = fileStructureTree + fileContents;

        await fs.promises.writeFile(outputFile, fullOutput);
        console.log(`Project structure and content written to ${outputFile}`);

    } catch (error) {
        console.error('An error occurred:', error);
        process.exit(1);
    }
}

// --- Main execution ---

const projectRoot = process.cwd(); // Use the current working directory
const outputFile = 'project_structure.txt';

// Check if the projectRoot exists.
fs.stat(projectRoot, (err, stats) => {
    if (err) {
        console.error(`Error: Project root directory "${projectRoot}" not found or not accessible.`);
        process.exit(1);
    }

    if (!stats.isDirectory()) {
        console.error(`Error: "${projectRoot}" is not a directory.`);
        process.exit(1);
    }

    generateProjectStructureAndContent(projectRoot, outputFile);
});
---------- END projectToFile.js ----------


---------- AddEntryModal.tsx ----------
// src/components/AddEntryModal.tsx
import React, { useEffect, useState, useMemo, useCallback } from "react";
import {
    View,
    FlatList,
    KeyboardAvoidingView,
    Platform,
    TouchableOpacity,
    ScrollView,
    Dimensions,
    Image,
    StyleSheet,
    ActivityIndicator,
    Alert,
    Pressable, // Use Pressable for better checkbox-like interaction
} from "react-native";
import {
    Button,
    Input,
    Text,
    ListItem,
    Overlay,
    SearchBar,
    makeStyles,
    useTheme,
    Icon,
    ButtonGroup,
    CheckBox, // Import CheckBox
} from "@rneui/themed";
import { Food } from "../types/food";
import { isValidNumberInput } from "../utils/validationUtils";
import { loadRecentFoods, saveRecentFoods } from "../services/storageService";
import { getFoodIconUrl } from "../utils/iconUtils";
import { getGramsFromNaturalLanguage } from "../utils/units";
import Toast from "react-native-toast-message";
import * as ImagePicker from "expo-image-picker";
import { EstimatedFoodItem, getMultipleFoodsFromImage } from "../utils/macros"; // Import new types/functions
import { v4 as uuidv4 } from 'uuid'; // Import uuid

interface AddEntryModalProps {
    isVisible: boolean;
    toggleOverlay: () => void;
    selectedFood: Food | null;
    grams: string;
    setGrams: (grams: string) => void;
    handleAddEntry: () => void; // For single entry add/update
    handleAddMultipleEntries: (entries: { food: Food, grams: number }[]) => void; // NEW: For quick add
    foods: Food[];
    handleSelectFood: (item: Food | null) => void;
    updateSearch: (search: string) => void;
    search: string;
    isEditMode: boolean;
    initialGrams?: string;
}

const KEYBOARD_VERTICAL_OFFSET = Platform.OS === 'ios' ? 80 : 0;

type UnitMode = 'grams' | 'auto';
type ModalMode = 'normal' | 'quickAddSelect'; // NEW: Control modal display

const AddEntryModal: React.FC<AddEntryModalProps> = ({
    isVisible,
    toggleOverlay,
    selectedFood,
    grams,
    setGrams,
    handleAddEntry,
    handleAddMultipleEntries, // Destructure new prop
    foods,
    handleSelectFood,
    updateSearch,
    search,
    isEditMode,
    initialGrams
}) => {
    const { theme } = useTheme();
    const styles = useStyles();
    const [recentFoods, setRecentFoods] = useState<Food[]>([]);
    const MAX_RECENT_FOODS = 5;
    const [foodIcons, setFoodIcons] = useState<{ [foodName: string]: string | null }>({});

    const [unitMode, setUnitMode] = useState<UnitMode>('grams');
    const [autoInput, setAutoInput] = useState("");
    const [isAiLoading, setIsAiLoading] = useState(false); // For text AI

    // --- Quick Add State ---
    const [modalMode, setModalMode] = useState<ModalMode>('normal');
    const [quickAddLoading, setQuickAddLoading] = useState(false);
    const [quickAddItems, setQuickAddItems] = useState<EstimatedFoodItem[]>([]);
    const [selectedQuickAddIndices, setSelectedQuickAddIndices] = useState<Set<number>>(new Set());
    // --- End Quick Add State ---

    const screenWidth = Dimensions.get('window').width;

    // Filtered foods based on search
    const filteredFoods = useMemo(() => {
        if (!search) return []; // Don't filter if search is empty
        return foods.filter((food) =>
            food.name.toLowerCase().includes(search.toLowerCase())
        );
    }, [foods, search]);

    // Effect to handle state resets based on visibility, edit mode, and selected food changes
    useEffect(() => {
        if (!isVisible) {
            // Reset everything when modal closes
            handleSelectFood(null);
            setGrams("");
            updateSearch("");
            setUnitMode('grams');
            setAutoInput("");
            setIsAiLoading(false);
            // Reset Quick Add State on close
            setModalMode('normal');
            setQuickAddItems([]);
            setSelectedQuickAddIndices(new Set());
            setQuickAddLoading(false);
        } else {
             // When modal becomes visible, ensure it's in normal mode unless already loading quick add
             if (!quickAddLoading) {
                 setModalMode('normal');
             }
            // Only reset autoInput if not loading AI/QuickAdd
            if (!isAiLoading && !quickAddLoading) {
                 setAutoInput("");
             }

            // Determine the correct initial grams value and unit mode based on mode/food
            let targetGrams = grams; // Start with current grams
            let targetUnitMode = unitMode; // Start with current unit mode

            if (isEditMode && selectedFood && initialGrams) {
                // If editing the *same* item for which we have initial grams, restore it.
                targetGrams = initialGrams;
                targetUnitMode = 'grams'; // Default to grams view when editing existing value
            } else if (!isEditMode && selectedFood) {
                targetUnitMode = 'grams'; // Switch to grams mode when a food is selected
            } else if (!selectedFood) {
                targetGrams = ""; // Clear grams if no food is selected
                targetUnitMode = 'grams'; // Default mode
            }
            // Apply the determined state changes *only if they are different* to avoid loops
            if (grams !== targetGrams) {
                setGrams(targetGrams);
            }
             // Only change unit mode if not loading AI/QuickAdd
            if (unitMode !== targetUnitMode && !isAiLoading && !quickAddLoading) {
                 setUnitMode(targetUnitMode);
            }
        }

    // Dependencies: Trigger when visibility, edit mode, selected food, or initial grams change.
    // Also added quickAddLoading dependency to ensure state reset doesn't happen prematurely.
    }, [isVisible, isEditMode, selectedFood, initialGrams, quickAddLoading, handleSelectFood, updateSearch]);


    // Load recent foods when modal becomes visible
    useEffect(() => {
        const loadRecents = async () => {
            const loadedRecentFoods = await loadRecentFoods();
            setRecentFoods(loadedRecentFoods);
        };
        if (isVisible) {
            loadRecents();
        }
    }, [isVisible]);

    // Load icons for visible foods (recent or filtered)
    useEffect(() => {
        const loadIcons = async () => {
            const iconsToLoad: { [foodName: string]: string | null } = {};
            // Only consider relevant foods based on current view (search or recent)
            const relevantFoods = search ? filteredFoods : recentFoods;
            // Create a Map to easily get unique foods by ID
            const uniqueFoodsMap = new Map(relevantFoods.map(food => [food.id, food]));

            let shouldUpdateState = false;
            for (const food of uniqueFoodsMap.values()) {
                // Check if icon state is unknown (undefined) for this food name
                if (foodIcons[food.name] === undefined) {
                    try {
                        const iconUrl = await getFoodIconUrl(food.name);
                        iconsToLoad[food.name] = iconUrl; // Store URL or null if fetch was ok but no result
                        shouldUpdateState = true;
                    } catch (error) {
                         console.warn(`Failed to load icon for ${food.name}:`, error);
                         iconsToLoad[food.name] = null; // Store null explicitly on fetch failure
                         shouldUpdateState = true;
                    }
                }
                 // If already fetched (exists in foodIcons, even if null), don't re-fetch
            }

            if (shouldUpdateState) {
                 setFoodIcons(prevIcons => ({ ...prevIcons, ...iconsToLoad }));
            }
        };

        // Only load if modal is visible and in normal mode
        if (isVisible && modalMode === 'normal' && (foods.length > 0 || recentFoods.length > 0)) {
           loadIcons();
        }
        // Dependencies: isVisible, modalMode, search, filteredFoods, recentFoods, foods
        // Avoid dependency on foodIcons itself to prevent infinite loop
    }, [isVisible, modalMode, search, filteredFoods, recentFoods, foods]);


    const addToRecentFoods = async (food: Food) => {
        // Ensure food and food.id exist before proceeding
        if (!food || !food.id) {
            console.warn("Attempted to add invalid food to recents:", food);
            return;
        }
        // If the most recent food is already the one being added, do nothing
        if (recentFoods.length > 0 && recentFoods[0].id === food.id) return;

        // Filter out the food if it already exists in the list to avoid duplicates
        const updatedRecentFoods = recentFoods.filter(recentFood => recentFood.id !== food.id);
        // Add the new food to the beginning of the list
        updatedRecentFoods.unshift(food);
        // Trim the list to the maximum allowed size
        const trimmedRecentFoods = updatedRecentFoods.slice(0, MAX_RECENT_FOODS);
        // Update the state and save to storage
        setRecentFoods(trimmedRecentFoods);
        await saveRecentFoods(trimmedRecentFoods);
    };


    // Serving size suggestions based on selected food
    const servingSizeSuggestions = useMemo(() => {
        if (!selectedFood) return [];
        return [
            { label: "50g", value: "50" },
            { label: "100g", value: "100" },
            { label: "150g", value: "150" },
            { label: "200g", value: "200" },
        ];
    }, [selectedFood]);

    // Handler for AI gram estimation (Text)
    const handleEstimateGrams = async () => {
        if (!selectedFood || !autoInput.trim()) {
            Alert.alert("Input Missing", "Please select a food and enter a quantity description (e.g., '1 cup', '2 medium').");
            return;
        }

        setIsAiLoading(true);
        try {
            const estimatedGrams = await getGramsFromNaturalLanguage(selectedFood.name, autoInput);
            const roundedGrams = String(Math.round(estimatedGrams));

            setGrams(roundedGrams); // Update the grams state
            setUnitMode('grams'); // Switch view back to grams input
            Toast.show({
                type: 'success',
                text1: 'Grams Estimated',
                text2: `Estimated ${roundedGrams}g for ${selectedFood.name}`,
                position: 'bottom',
                visibilityTime: 3000,
            });
        } catch (error: any) {
            console.error("AI Estimation Error:", error);
            Alert.alert("AI Estimation Failed", error.message || "Could not estimate grams. Please enter manually.");
             // Keep unitMode as 'auto' on failure so user can retry or see input
        } finally {
            setIsAiLoading(false); // Ensure loading state is turned off
        }
    };

    // Handler for adding or updating a SINGLE entry (from normal mode)
    const handleAddOrUpdateSingleEntry = async () => {
        if (!selectedFood) {
             Alert.alert("Food Not Selected", "Please select a food item.");
             return;
        }
        const numericGrams = parseFloat(grams);
        if (!isValidNumberInput(grams) || numericGrams <= 0) {
             Alert.alert(
                "Invalid Amount",
                "Please enter a valid positive number for grams."
            );
            return;
        }

        // Prevent adding if AI or QuickAdd is still loading
        if (isAiLoading || quickAddLoading) return;

        handleAddEntry(); // Call the original prop function for single add/update
        // Add to recents *after* the main action (assuming handleAddEntry doesn't close modal immediately)
        await addToRecentFoods(selectedFood);
        // Note: The modal closing is typically handled within the handleAddEntry implementation
        // in the parent component (DailyEntryScreen) after the state is updated there.
    };


    // Handler for selecting a food item in NORMAL mode
    const handleInternalSelectFood = (item: Food | null) => {
        // If the same food is selected again, do nothing
        if (selectedFood?.id === item?.id) return;

        handleSelectFood(item); // Call the prop function to update parent state

        // When a food is selected/changed (and not in edit mode with initial grams):
        if (item && (!isEditMode || !initialGrams)) {
            // Always switch to grams mode when selecting a food
            setUnitMode('grams');
            setAutoInput(""); // Clear any previous auto input
        } else if (!item) {
             // If food is deselected (set to null)
             setGrams(""); // Clear grams
             setUnitMode('grams');
             setAutoInput("");
        }
        // If isEditMode and initialGrams exist, the main useEffect will handle setting grams.
    };


    // --- Quick Add Functions ---

    const handleQuickAddImage = async () => {
        Alert.alert(
            "Quick Add from Image",
            "Identify multiple foods from a single image.",
            [
                { text: "Cancel", style: "cancel" },
                { text: "Camera", onPress: () => pickImageAndAnalyze('camera') },
                { text: "Gallery", onPress: () => pickImageAndAnalyze('gallery') },
            ]
        );
    };

    const pickImageAndAnalyze = async (source: 'camera' | 'gallery') => {
        let permissionResult;
        let pickerResult: ImagePicker.ImagePickerResult;

        setQuickAddLoading(true); // Start loading indicator

        try {
            if (source === 'camera') {
                permissionResult = await ImagePicker.requestCameraPermissionsAsync();
                if (!permissionResult.granted) {
                    Alert.alert("Permission Required", "Camera access needed.");
                    setQuickAddLoading(false);
                    return;
                }
                pickerResult = await ImagePicker.launchCameraAsync({ quality: 0.6 });
            } else { // gallery
                permissionResult = await ImagePicker.requestMediaLibraryPermissionsAsync();
                if (!permissionResult.granted) {
                    Alert.alert("Permission Required", "Gallery access needed.");
                    setQuickAddLoading(false);
                    return;
                }
                pickerResult = await ImagePicker.launchImageLibraryAsync({
                    mediaTypes: ImagePicker.MediaTypeOptions.Images,
                    quality: 0.6,
                });
            }

            // Handle cancellation
            if (pickerResult.canceled) {
                 console.log("Image selection/capture cancelled for Quick Add.");
                 setQuickAddLoading(false);
                 return; // Exit without changing modal mode
            }

            // Process selected asset
            if (pickerResult.assets && pickerResult.assets.length > 0) {
                const asset = pickerResult.assets[0];
                console.log("Quick Add Image acquired:", asset.uri);

                const fileInfoForApi = {
                    uri: asset.uri,
                    fileName: asset.fileName ?? `quickadd_${Date.now()}.jpg`,
                    type: asset.mimeType ?? 'image/jpeg'
                };

                // --- Call the multi-food analysis function ---
                const results = await getMultipleFoodsFromImage(fileInfoForApi);
                // ---------------------------------------------

                if (results.length === 0) {
                    Alert.alert("No Foods Found", "The AI couldn't identify any food items in the image. Try again or add manually.");
                    setQuickAddItems([]);
                    // Keep loading false, stay in normal mode
                } else {
                    console.log("Quick Add Results:", results);
                    setQuickAddItems(results);
                    setSelectedQuickAddIndices(new Set()); // Reset selection for the new items
                    setModalMode('quickAddSelect'); // << SWITCH TO SELECTION MODE >>

                     // Clear single food selection state when entering quick add
                    handleSelectFood(null);
                    setGrams("");
                    updateSearch("");
                    setUnitMode('grams');
                    setAutoInput("");
                }

            } else {
                 console.log("No assets selected or returned for Quick Add.");
                 Alert.alert("Error", "Could not select image.");
                 // Keep loading false, stay in normal mode
            }

        } catch (error: any) {
            console.error("Error during Quick Add image process:", error);
            Alert.alert(
                "Quick Add Failed",
                `Could not analyze the image. ${error.message || "Please try again."}`
            );
             // Reset state on error and return to normal mode
             setModalMode('normal');
             setQuickAddItems([]);
             setSelectedQuickAddIndices(new Set());
        } finally {
            // Ensure loading state is turned off, possibly after a short delay for UI update
            setTimeout(() => setQuickAddLoading(false), 100);
        }
    };


    const handleToggleQuickAddItem = (index: number) => {
        setSelectedQuickAddIndices(prev => {
            const newSet = new Set(prev);
            if (newSet.has(index)) {
                newSet.delete(index);
            } else {
                newSet.add(index);
            }
            return newSet;
        });
    };

    const handleConfirmQuickAdd = () => {
        if (selectedQuickAddIndices.size === 0) {
            Alert.alert("No Items Selected", "Please select at least one item to add.");
            return;
        }

        // Create the array of entries to pass back to DailyEntryScreen
        const entriesToAdd = Array.from(selectedQuickAddIndices).map(index => {
            const item = quickAddItems[index];
            // Create a temporary Food object for this entry
            // IMPORTANT: This food object is NOT saved to the main food list in storage
            const quickFood: Food = {
                id: uuidv4(), // Generate a temporary UUID for the DailyEntryItem linkage
                name: item.foodName,
                // Round macro values obtained from AI
                calories: Math.round(item.calories_per_100g),
                protein: Math.round(item.protein_per_100g),
                carbs: Math.round(item.carbs_per_100g),
                fat: Math.round(item.fat_per_100g),
            };
             // Round estimated grams as well, ensure it's at least 1g
            const entryGrams = Math.max(1, Math.round(item.estimatedWeightGrams));
            return { food: quickFood, grams: entryGrams };
        });

        // Call the new prop function provided by DailyEntryScreen
        handleAddMultipleEntries(entriesToAdd);

        // Close the modal after successfully initiating the add process
        toggleOverlay();
    };

    // --- End Quick Add Functions ---

    // Combined loading state check
    const isActionDisabled = isAiLoading || quickAddLoading;

    // Disable Add/Update button logic
    const isAddButtonDisabled = modalMode !== 'normal' || !selectedFood || !isValidNumberInput(grams) || parseFloat(grams) <= 0 || isActionDisabled;
    // Disable AI Estimate button logic
    const isAiButtonDisabled = modalMode !== 'normal' || !selectedFood || !autoInput.trim() || isActionDisabled;
    // Disable Quick Add Confirm button logic
    const isQuickAddConfirmDisabled = modalMode !== 'quickAddSelect' || selectedQuickAddIndices.size === 0 || isActionDisabled;


    // Prepare styles and theme
    const combinedOverlayStyle = StyleSheet.flatten([
        styles.overlayStyle,
        { backgroundColor: theme.colors.background }
    ]);

    return (
        <Overlay
            isVisible={isVisible}
            onBackdropPress={!isActionDisabled ? toggleOverlay : undefined} // Prevent closing while loading
            animationType="slide"
            overlayStyle={styles.overlayContainer}
        >
            <KeyboardAvoidingView
                behavior={Platform.OS === "ios" ? "padding" : "height"}
                style={styles.keyboardAvoidingView}
                keyboardVerticalOffset={KEYBOARD_VERTICAL_OFFSET}
            >
                {/* Main content view inside KeyboardAvoidingView */}
                <View style={combinedOverlayStyle}>
                    {/* Header */}
                    <View style={styles.header}>
                         {/* Close Button */}
                         <TouchableOpacity onPress={!isActionDisabled ? toggleOverlay : undefined} style={styles.closeIconTouchable} disabled={isActionDisabled}>
                            <Icon
                                name="close"
                                type="material"
                                size={28}
                                color={isActionDisabled ? theme.colors.grey3 : theme.colors.text}
                            />
                        </TouchableOpacity>

                        {/* Title */}
                        <Text h4 h4Style={[styles.overlayTitle, isEditMode && modalMode === 'normal' && styles.editModeTitle]} numberOfLines={1} ellipsizeMode="tail">
                            {modalMode === 'quickAddSelect'
                                ? "Select Items to Add"
                                : isEditMode
                                ? "Edit Entry"
                                : "Add Entry"}
                        </Text>

                         {/* Conditional Header Actions */}
                         {modalMode === 'normal' && (
                            <>
                                {/* Quick Add Icon Button */}
                                <TouchableOpacity onPress={handleQuickAddImage} disabled={isActionDisabled} style={styles.headerIcon}>
                                    {quickAddLoading ? (
                                        <ActivityIndicator size="small" color={theme.colors.primary} />
                                     ) : (
                                        <Icon
                                            name="camera-burst" // Icon for quick add image feature
                                            type="material-community"
                                            size={26}
                                            color={isActionDisabled ? theme.colors.grey3 : theme.colors.primary}
                                        />
                                    )}
                                </TouchableOpacity>

                                {/* Add/Update Button (Single Entry) */}
                                <Button
                                    title={isEditMode ? "Update" : "Add"}
                                    onPress={handleAddOrUpdateSingleEntry}
                                    disabled={isAddButtonDisabled}
                                    buttonStyle={[styles.addButton, isEditMode && styles.updateButton]}
                                    titleStyle={styles.buttonTitle}
                                    // No loading needed here as DailyEntryScreen handles it
                                />
                             </>
                         )}
                         {modalMode === 'quickAddSelect' && (
                            /* Confirm Quick Add Button */
                            <Button
                                title={`Add ${selectedQuickAddIndices.size}`} // Show count
                                onPress={handleConfirmQuickAdd}
                                disabled={isQuickAddConfirmDisabled}
                                buttonStyle={[styles.addButton, { backgroundColor: theme.colors.success }]} // Use success color
                                titleStyle={styles.buttonTitle}
                                // Loading is handled by the global indicator
                            />
                         )}
                    </View>

                    {/* --- Loading Indicators (Centered) --- */}
                    {(isAiLoading || quickAddLoading) && (
                        <View style={styles.loadingContainer}>
                            <ActivityIndicator size="large" color={theme.colors.primary} />
                             <Text style={styles.loadingText}>
                                {quickAddLoading ? "Analyzing Image..." : "Estimating Grams..."}
                             </Text>
                        </View>
                    )}

                    {/* --- Conditional Content (Normal Mode) --- */}
                    {!isActionDisabled && modalMode === 'normal' && (
                         <>
                            {/* Search Bar */}
                            <SearchBar
                                placeholder="Search Foods..."
                                onChangeText={updateSearch}
                                value={search}
                                platform={Platform.OS === "ios" ? "ios" : "android"}
                                containerStyle={styles.searchBarContainer}
                                inputContainerStyle={styles.searchBarInputContainer}
                                inputStyle={styles.searchInputStyle}
                                onCancel={() => updateSearch('')}
                                // No need to disable search while AI loading, handled by isActionDisabled check
                            />

                            {/* Recent Foods (Only show if NOT searching) */}
                            {!search && recentFoods.length > 0 && (
                                <View style={styles.recentFoodsSection}>
                                     <Text style={styles.sectionTitle}>Recent</Text>
                                        <FlatList
                                            data={recentFoods}
                                            keyExtractor={(item) => `recent-${item.id}`}
                                            horizontal
                                            showsHorizontalScrollIndicator={false}
                                            contentContainerStyle={styles.recentFoodsContainer}
                                            renderItem={({ item }) => (
                                                <TouchableOpacity
                                                    style={[
                                                        styles.recentFoodItem,
                                                        screenWidth < 350 && styles.smallRecentFoodItem,
                                                        selectedFood?.id === item.id && styles.selectedRecentFoodItem,
                                                    ]}
                                                    onPress={() => handleInternalSelectFood(item)}
                                                    // Disabled handled by isActionDisabled check
                                                >
                                                    {/* Icon Loading/Display Logic */}
                                                    {foodIcons[item.name] !== undefined ? ( // Check if status is known
                                                        foodIcons[item.name] ? ( // Check if URL exists
                                                            <Image
                                                                source={{ uri: foodIcons[item.name] as string }}
                                                                style={styles.foodIconSmall}
                                                                onError={() => setFoodIcons(prev => ({...prev, [item.name]: null}))} // Mark failed
                                                            />
                                                        ) : ( // URL is null (fetch failed or no icon found)
                                                             <View style={[styles.foodIconSmall, styles.iconPlaceholderSmall]}>
                                                                 <Icon name="fastfood" type="material" size={12} color={theme.colors.grey2} />
                                                             </View>
                                                        )
                                                    ) : ( // Undefined: Still loading
                                                        <ActivityIndicator size="small" color={theme.colors.grey3} style={styles.foodIconSmall} />
                                                    )}
                                                    <Text
                                                        style={[styles.recentFoodText, screenWidth < 350 && styles.smallRecentFoodText]}
                                                        numberOfLines={1}
                                                        ellipsizeMode="tail"
                                                    >
                                                        {item.name}
                                                    </Text>
                                                </TouchableOpacity>
                                            )}
                                        />
                                </View>
                            )}

                            {/* Food Search Results List (Only show IF searching) */}
                             {search && (
                                <FlatList
                                    data={filteredFoods}
                                    keyExtractor={(item) => `search-${item.id}`}
                                    renderItem={({ item }) => (
                                        <TouchableOpacity onPress={() => handleInternalSelectFood(item)} >
                                            <ListItem
                                                bottomDivider
                                                containerStyle={[
                                                    styles.listItemContainer,
                                                    selectedFood?.id === item.id && styles.selectedListItem,
                                                ]}
                                            >
                                                {/* Icon Loading/Display Logic */}
                                                {foodIcons[item.name] !== undefined ? (
                                                    foodIcons[item.name] ? (
                                                        <Image
                                                            source={{ uri: foodIcons[item.name] as string }}
                                                            style={styles.foodIcon}
                                                            onError={() => setFoodIcons(prev => ({...prev, [item.name]: null}))}
                                                        />
                                                    ) : (
                                                        <View style={styles.defaultIconContainer}>
                                                            <Icon name="restaurant" type="material" size={18} color={theme.colors.grey3} />
                                                        </View>
                                                    )
                                                ) : (
                                                     <ActivityIndicator size="small" color={theme.colors.grey3} style={styles.foodIcon} />
                                                )}
                                                <ListItem.Content>
                                                    <ListItem.Title style={styles.listItemTitle}>{item.name}</ListItem.Title>
                                                </ListItem.Content>
                                                {selectedFood?.id === item.id && (
                                                    <Icon name="checkmark-circle" type="ionicon" color={theme.colors.primary} size={24} />
                                                )}
                                            </ListItem>
                                        </TouchableOpacity>
                                    )}
                                    style={styles.foodList}
                                    ListEmptyComponent={
                                        <Text style={styles.noFoodsText}>No foods found matching "{search}".</Text>
                                    }
                                    initialNumToRender={10}
                                    maxToRenderPerBatch={10}
                                    windowSize={5}
                                    keyboardShouldPersistTaps="handled"
                                />
                             )}

                            {/* Amount Input Section (Only show if a food is selected) */}
                            {selectedFood && (
                                <View style={styles.amountSection}>
                                     {/* Unit Mode Selector */}
                                     <View style={styles.unitSelectorContainer}>
                                        <Text style={styles.inputLabel}>Amount</Text>
                                        <ButtonGroup
                                            buttons={['Grams', 'Auto (AI)']}
                                            selectedIndex={unitMode === 'grams' ? 0 : 1}
                                            onPress={(index) => {
                                                const newMode = index === 0 ? 'grams' : 'auto';
                                                if (unitMode !== newMode) {
                                                     setUnitMode(newMode);
                                                    // Optional: Clear auto input when switching to it?
                                                    // if (newMode === 'auto') setAutoInput("");
                                                }
                                            }}
                                            containerStyle={styles.buttonGroupContainer}
                                            selectedButtonStyle={{ backgroundColor: theme.colors.primary }}
                                            textStyle={styles.buttonGroupText}
                                            selectedTextStyle={{ color: theme.colors.white }}
                                            // Disabled handled by isActionDisabled check
                                        />
                                     </View>

                                    {/* Conditional Input Field */}
                                    {unitMode === 'grams' && (
                                        <>
                                             {/* Serving Size Suggestions */}
                                             {servingSizeSuggestions.length > 0 && (
                                                <View style={styles.servingSizeRow}>
                                                    <Text style={styles.servingSizeLabel}>Quick Add:</Text>
                                                    <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={styles.servingSizeContainer}>
                                                        {servingSizeSuggestions.map((suggestion) => (
                                                            <TouchableOpacity
                                                                key={suggestion.label}
                                                                style={styles.servingSizeButton}
                                                                onPress={() => {
                                                                    if (grams !== suggestion.value) {
                                                                        setGrams(suggestion.value);
                                                                    }
                                                                }}
                                                                // Disabled handled by isActionDisabled check
                                                            >
                                                                <Text style={styles.servingSizeButtonTitle}>{suggestion.label}</Text>
                                                            </TouchableOpacity>
                                                        ))}
                                                    </ScrollView>
                                                </View>
                                             )}
                                            {/* Grams Input */}
                                            <Input
                                                placeholder="Enter exact grams (e.g., 150)"
                                                keyboardType="numeric"
                                                value={grams} // Value is correctly bound to state
                                                onChangeText={(text) => {
                                                    // Allow only numbers and one decimal point
                                                    const cleanedText = text.replace(/[^0-9.]/g, "").replace(/(\..*)\./g, '$1');
                                                    if (grams !== cleanedText) { // Prevent unnecessary state updates
                                                        setGrams(cleanedText);
                                                    }
                                                }}
                                                inputStyle={styles.gramInputStyle}
                                                inputContainerStyle={styles.gramInputContainerStyle}
                                                errorMessage={!isValidNumberInput(grams) && grams !== "" && grams !== "." ? "Enter a valid number" : ""}
                                                errorStyle={{ color: theme.colors.error }}
                                                rightIcon={<Text style={styles.unitText}> g</Text>}
                                                // Disabled handled by isActionDisabled check
                                                containerStyle={{ paddingHorizontal: 0 }}
                                                key={`grams-input-${selectedFood?.id}`}
                                            />
                                        </>
                                    )}

                                    {unitMode === 'auto' && (
                                        <View style={styles.autoInputRow}>
                                            <Input
                                                placeholder="Describe quantity (e.g., 1 cup cooked)"
                                                value={autoInput}
                                                onChangeText={setAutoInput}
                                                inputStyle={[styles.gramInputStyle, styles.autoInputField]}
                                                inputContainerStyle={styles.gramInputContainerStyle}
                                                containerStyle={styles.autoInputContainer}
                                                multiline={false}
                                                // Disabled handled by isActionDisabled check
                                                onSubmitEditing={handleEstimateGrams} // Trigger estimation on submit
                                                key={`auto-input-${selectedFood?.id}`}
                                            />
                                            <Button
                                                onPress={handleEstimateGrams}
                                                disabled={isAiButtonDisabled}
                                                loading={isAiLoading} // Show loading indicator on the button itself
                                                buttonStyle={styles.aiButton}
                                                icon={
                                                    isAiLoading ? (
                                                        <ActivityIndicator size="small" color={theme.colors.white} />
                                                    ) : (
                                                        <Icon name="calculator-variant" type="material-community" size={20} color={theme.colors.white} />
                                                    )
                                                }
                                            />
                                        </View>
                                    )}
                                </View>
                            )}
                         </>
                    )}

                    {/* --- Conditional Content (Quick Add Selection Mode) --- */}
                    {!isActionDisabled && modalMode === 'quickAddSelect' && (
                        <>
                          {/* Header for Quick Add section */}
                          <View style={styles.quickAddHeader}>
                            <Text style={styles.sectionTitle}>Select Items from Image</Text>
                             <Button
                                type="clear"
                                title="Back"
                                onPress={() => {
                                     setModalMode('normal'); // Go back to normal mode
                                     // Optionally reset quick add state when going back
                                     setQuickAddItems([]);
                                     setSelectedQuickAddIndices(new Set());
                                }}
                                titleStyle={{ color: theme.colors.primary, fontSize: 14 }}
                                icon={<Icon name="arrow-back" type="ionicon" size={18} color={theme.colors.primary} />}
                                // Disabled handled by isActionDisabled check
                             />
                          </View>
                            {/* List of identified items */}
                            <FlatList
                                data={quickAddItems}
                                keyExtractor={(item, index) => `quickadd-${index}-${item.foodName}`}
                                renderItem={({ item, index }) => {
                                    const isSelected = selectedQuickAddIndices.has(index);
                                    const estimatedCalories = Math.round((item.calories_per_100g / 100) * item.estimatedWeightGrams);
                                    return (
                                         // Use Pressable for the whole row to enable toggling selection easily
                                        <Pressable onPress={() => handleToggleQuickAddItem(index)}>
                                            <ListItem
                                                bottomDivider
                                                containerStyle={[
                                                    styles.quickAddItemContainer,
                                                    isSelected && styles.quickAddItemSelected // Apply highlight style if selected
                                                ]}
                                            >
                                                 {/* Checkbox visual indicator */}
                                                <CheckBox
                                                    checked={isSelected}
                                                    onPress={() => handleToggleQuickAddItem(index)} // Allow direct toggle too
                                                    containerStyle={styles.quickAddCheckbox}
                                                    checkedColor={theme.colors.primary}
                                                    // Disabled handled by isActionDisabled check
                                                />
                                                {/* Item Details */}
                                                <ListItem.Content>
                                                    <ListItem.Title style={styles.quickAddItemTitle}>{item.foodName}</ListItem.Title>
                                                    <ListItem.Subtitle style={styles.quickAddItemSubtitle}>
                                                        {`Est: ${Math.round(item.estimatedWeightGrams)}g • ~${estimatedCalories} kcal`}
                                                    </ListItem.Subtitle>
                                                     {/* Optional: Show more detailed macros per serving if needed */}
                                                     {/*
                                                     <Text style={styles.quickAddMacroDetail}>
                                                         P: {Math.round((item.protein_per_100g / 100) * item.estimatedWeightGrams)}g,
                                                         C: {Math.round((item.carbs_per_100g / 100) * item.estimatedWeightGrams)}g,
                                                         F: {Math.round((item.fat_per_100g / 100) * item.estimatedWeightGrams)}g
                                                     </Text>
                                                     */}
                                                </ListItem.Content>
                                                {/* Optional: Chevron or other visual cue */}
                                            </ListItem>
                                        </Pressable>
                                    );
                                }}
                                ListEmptyComponent={
                                    // Show message if AI returned an empty array initially
                                     <View style={styles.emptyListContainer}>
                                         <Text style={styles.emptyListText}>No identifiable foods found in the image.</Text>
                                         <Text style={styles.emptyListSubText}>Try another image or add manually.</Text>
                                     </View>
                                }
                                style={styles.quickAddList} // Apply specific styles for this list
                            />
                        </>
                    )}

                     {/* Spacer at the bottom for padding */}
                     <View style={{ height: 20 }} />
                </View>
            </KeyboardAvoidingView>
             {/* Toast component for notifications */}
             <Toast />
        </Overlay>
    );
};

// --- Styles ---
const useStyles = makeStyles((theme) => ({
    // --- Existing Styles (Keep ALL of these) ---
    overlayContainer: {
        backgroundColor: 'transparent',
        width: '90%',
        maxWidth: 500,
        padding: 0,
        borderRadius: 15,
        shadowColor: "#000",
        shadowOffset: { width: 0, height: 3 },
        shadowOpacity: 0.2,
        shadowRadius: 5,
        elevation: 6,
        overflow: 'hidden', // Changed from 'visible' to 'hidden'
    },
    overlayStyle: {
        width: '100%',
        borderRadius: 15,
        padding: 15,
        paddingBottom: 0, // Reset paddingBottom here, add spacing view instead
        maxHeight: Dimensions.get('window').height * 0.85,
        // backgroundColor applied dynamically using theme
    },
    keyboardAvoidingView: {
         width: "100%",
    },
    header: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: 15,
        paddingHorizontal: 5,
    },
     closeIconTouchable: {
        padding: 5, // Make hitbox larger
        zIndex: 1,
    },
    overlayTitle: {
        color: theme.colors.text,
        fontWeight: 'bold',
        fontSize: 20,
        textAlign: 'center',
        flex: 1, // Allow title to take space but shrink if needed
        marginHorizontal: 5,
    },
    editModeTitle: {
        color: theme.colors.warning, // Keep warning color for edit mode title
    },
     headerIcon: { // Style for the quick add icon button in header
        padding: 5,
        marginHorizontal: 5, // Space around the icon
        zIndex: 1,
    },
    addButton: {
        borderRadius: 20,
        paddingHorizontal: 15,
        paddingVertical: 8,
        minWidth: 70, // Ensure button has minimum width
        marginLeft: 5, // Space from title/quick add icon
        backgroundColor: theme.colors.primary, // Default color
        zIndex: 1,
    },
     updateButton: {
        backgroundColor: theme.colors.warning, // Specific color for update
    },
    buttonTitle: {
        color: theme.colors.white,
        fontWeight: '600',
        fontSize: 15,
    },
    searchBarContainer: {
        backgroundColor: "transparent",
        borderBottomColor: "transparent",
        borderTopColor: "transparent",
        paddingHorizontal: 0,
        marginBottom: 10,
    },
    searchBarInputContainer: {
        borderRadius: 25,
        backgroundColor: theme.colors.searchBg || theme.colors.grey5,
        height: 40,
    },
    searchInputStyle: {
        color: theme.colors.text,
        fontSize: 15,
    },
    recentFoodsSection: {
        marginBottom: 15,
    },
    sectionTitle: {
        fontWeight: '600',
        marginBottom: 8,
        color: theme.colors.grey1,
        fontSize: 14,
        marginLeft: 5,
        textTransform: 'uppercase',
    },
     recentFoodsContainer: {
        paddingHorizontal: 5,
        paddingVertical: 2,
    },
    recentFoodItem: {
        paddingHorizontal: 10,
        paddingVertical: 6,
        borderRadius: 16,
        backgroundColor: theme.colors.grey5,
        marginRight: 8,
        flexDirection: 'row',
        alignItems: 'center',
        borderWidth: 1.5,
        borderColor: 'transparent', // Default border
    },
    selectedRecentFoodItem: {
        borderColor: theme.colors.primary, // Highlight selected recent food
    },
    smallRecentFoodItem: { // Adjustments for smaller screens
        paddingHorizontal: 8,
        paddingVertical: 5,
    },
    foodIconSmall: { // Style for small icons (recents)
        width: 20,
        height: 20,
        marginRight: 6,
        borderRadius: 10,
        resizeMode: "contain",
        alignItems: 'center', // Center potential activity indicator
        justifyContent: 'center', // Center potential activity indicator
        backgroundColor: theme.colors.grey4, // Background for loading/placeholder state
    },
     iconPlaceholderSmall: { // Specific style for placeholder background/icon
        backgroundColor: theme.colors.grey4,
        alignItems: 'center',
        justifyContent: 'center',
    },
    recentFoodText: {
        color: theme.colors.text,
        fontSize: 13,
        maxWidth: 80, // Limit text width
    },
    smallRecentFoodText: {
        fontSize: 12,
        maxWidth: 70,
    },
    foodList: { // Style for the search results list
        maxHeight: Dimensions.get('window').height * 0.3,
        minHeight: 60,
        flexGrow: 0, // Prevent infinite growth
        marginBottom: 15,
    },
    listItemContainer: { // Style for search result items
        backgroundColor: 'transparent',
        paddingVertical: 8,
        paddingHorizontal: 5,
        borderBottomColor: theme.colors.divider,
    },
    selectedListItem: { // Highlight selected search result
        backgroundColor: theme.colors.grey5,
        borderRadius: 8,
    },
     defaultIconContainer: { // Placeholder for larger icons (search results)
        width: 35,
        height: 35,
        marginRight: 12,
        borderRadius: 17.5,
        backgroundColor: theme.colors.grey5,
        alignItems: 'center',
        justifyContent: 'center',
    },
    foodIcon: { // Style for larger icons (search results)
        width: 35,
        height: 35,
        marginRight: 12,
        borderRadius: 17.5,
        resizeMode: "contain",
        backgroundColor: theme.colors.grey5, // Background for loading state
        alignItems: 'center', // Center potential activity indicator
        justifyContent: 'center', // Center potential activity indicator
    },
    listItemTitle: {
        color: theme.colors.text,
        fontSize: 16,
        fontWeight: '500',
    },
    noFoodsText: {
        color: theme.colors.grey2,
        fontStyle: 'italic',
        textAlign: 'center',
        marginTop: 20,
        marginBottom: 10,
        paddingHorizontal: 10,
    },
    amountSection: { // Container for amount input (grams/auto)
        marginTop: 10,
        borderTopWidth: 1,
        borderTopColor: theme.colors.divider,
        paddingTop: 15,
    },
    unitSelectorContainer: { // Row for "Amount" label and Unit ButtonGroup
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
        marginBottom: 15,
        paddingHorizontal: 5,
    },
    inputLabel: {
        fontWeight: '600',
        color: theme.colors.grey1,
        fontSize: 14,
        marginRight: 10,
        textTransform: 'uppercase',
    },
    buttonGroupContainer: { // Style for the Unit ButtonGroup ('Grams', 'Auto')
        flex: 0.7,
        maxWidth: 220,
        height: 35,
        borderRadius: 8,
        backgroundColor: theme.colors.background, // Match modal background
    },
     buttonGroupText: { // Text style inside the ButtonGroup
        fontSize: 14,
        color: theme.colors.text,
    },
     servingSizeRow: { // Row for "Quick Add:" label and serving size buttons
        flexDirection: 'row',
        alignItems: 'center',
        marginBottom: 12,
        paddingHorizontal: 5,
    },
    servingSizeLabel: {
        color: theme.colors.grey2,
        fontSize: 13,
        marginRight: 8,
    },
    servingSizeContainer: { // Container for the horizontal scroll of serving sizes
        flexGrow: 0,
    },
    servingSizeButton: { // Style for individual serving size buttons (e.g., "50g")
      backgroundColor: theme.colors.grey4,
      borderRadius: 15,
      marginRight: 8,
      paddingHorizontal: 12,
      paddingVertical: 5,
      justifyContent: 'center',
      alignItems: 'center',
      height: 30,
    },
    servingSizeButtonTitle: {
        color: theme.colors.text,
        fontSize: 13,
    },
    gramInputStyle: { // Style for the text *inside* the Input components
        color: theme.colors.text,
        fontSize: 16,
        paddingVertical: 8,
        height: 40, // Consistent height
    },
    gramInputContainerStyle: { // Style for the container *around* the Input (underline, etc.)
        borderBottomColor: theme.colors.grey3,
        paddingHorizontal: 5,
    },
    unitText: { // Style for the "g" unit text in Grams input
        color: theme.colors.grey2,
        fontSize: 15,
        fontWeight: '500',
        paddingRight: 5,
    },
     autoInputRow: { // Row containing the Auto (AI) input and button
        flexDirection: 'row',
        alignItems: 'center',
    },
    autoInputContainer: { // Container for the Auto input field
       flex: 1, // Take available space
       paddingHorizontal: 0,
       marginRight: 10, // Space before AI button
    },
    autoInputField: { // Specific style adjustments for Auto input text if needed
       height: 40,
    },
    aiButton: { // Style for the AI ('calculator') button
        backgroundColor: theme.colors.secondary,
        borderRadius: 20,
        width: 40,
        height: 40,
        padding: 0,
        justifyContent: 'center',
        alignItems: 'center',
    },

    // --- Loading Indicator Styles ---
    loadingContainer: {
        // Styles for the view containing the ActivityIndicator and text
        position: 'absolute', // Position it over the content
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.1)', // Slight overlay dim
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 10, // Ensure it's above other content
        borderRadius: 15, // Match modal border radius
    },
    loadingText: {
        marginTop: 10,
        color: theme.colors.text, // Use theme text color
        fontSize: 16,
        fontWeight: '500',
    },

     // --- Quick Add Styles ---
     quickAddHeader: { // Container for "Select Items" title and Back button
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: 10,
        paddingHorizontal: 5,
        borderBottomWidth: 1, // Add separator
        borderBottomColor: theme.colors.divider,
        paddingBottom: 8,
     },
     quickAddList: { // Style for the FlatList containing selectable items
        maxHeight: Dimensions.get('window').height * 0.5, // Limit height
        flexGrow: 0,
        marginBottom: 10,
     },
     quickAddItemContainer: { // Style for each row (ListItem) in the quick add list
        paddingVertical: 10,
        paddingHorizontal: 5,
        backgroundColor: theme.colors.background,
        borderBottomColor: theme.colors.divider,
     },
     quickAddItemSelected: { // Style applied when a quick add item is selected
        backgroundColor: theme.colors.successLight, // Use a light success color for selection
        // Or use: theme.colors.grey5 if successLight is too strong
     },
      quickAddCheckbox: { // Style for the CheckBox component
        padding: 0,
        margin: 0,
        marginRight: 10,
        backgroundColor: 'transparent',
        borderWidth: 0,
     },
     quickAddItemTitle: { // Title (food name) in the quick add list item
        fontWeight: 'bold',
        color: theme.colors.text,
        fontSize: 16,
     },
     quickAddItemSubtitle: { // Subtitle (estimated grams, calories)
        color: theme.colors.grey1,
        fontSize: 13,
        marginTop: 2,
     },
     quickAddMacroDetail: { // Optional text for detailed macros
        color: theme.colors.grey3,
        fontSize: 11,
        marginTop: 4,
     },
      emptyListContainer: { // Re-using style for empty list messages
        alignItems: 'center',
        paddingVertical: 30,
        paddingHorizontal: 15, // Add horizontal padding
    },
    emptyListText: {
        color: theme.colors.grey2,
        fontSize: 16,
        textAlign: 'center',
    },
    emptyListSubText: { // Added style for sub-text in empty lists
        fontSize: 14,
        color: theme.colors.grey3,
        textAlign: 'center',
        marginTop: 5,
    },
}));

export default AddEntryModal;
---------- END AddEntryModal.tsx ----------


---------- AddFoodModal.tsx ----------
// components/AddFoodModal.tsx
import React, { useState, useEffect } from "react";
import {
  View,
  KeyboardAvoidingView,
  Platform,
  ActivityIndicator,
  Alert,
  ScrollView,
  StyleSheet, // Import StyleSheet
  TouchableOpacity, // Import TouchableOpacity for icon button
} from "react-native";
import {
  Button,
  Input,
  Text,
  Overlay,
  makeStyles,
  useTheme,
  Icon,
} from "@rneui/themed";
import { Food } from "../types/food";
import { MaterialCommunityIcons } from "@expo/vector-icons";
import Toast from "react-native-toast-message";
// Import the necessary functions
import { getMacrosForRecipe, getMacrosForImageFile } from "../utils/macros";
import * as ImagePicker from "expo-image-picker";
// Import the type explicitly if needed for clarity, although often inferred
import { ImagePickerAsset, ImagePickerResult } from 'expo-image-picker';
import { isValidNumberInput, isNotEmpty } from "../utils/validationUtils"; // Added validation imports

interface AddFoodModalProps {
  isVisible: boolean;
  toggleOverlay: () => void;
  newFood: Omit<Food, "id">;
  editFood: Food | null;
  errors: { [key: string]: string };
  handleInputChange: (
    key: keyof Omit<Food, "id">,
    value: string,
    isEdit: boolean
  ) => void;
  handleCreateFood: () => void;
  handleUpdateFood: () => void;
  validateFood: (food: Omit<Food, "id">) => { [key: string]: string } | null;
  setErrors: React.Dispatch<React.SetStateAction<{ [key: string]: string }>>;
}

// Define a keyboard offset (adjust value based on testing, e.g., header height)
const KEYBOARD_VERTICAL_OFFSET = Platform.OS === "ios" ? 60 : 0;

const AddFoodModal: React.FC<AddFoodModalProps> = ({
  isVisible,
  toggleOverlay,
  newFood,
  editFood,
  errors,
  handleInputChange,
  handleCreateFood,
  handleUpdateFood,
  validateFood,
  setErrors,
}) => {
  const { theme } = useTheme();
  const styles = useStyles();
  const [loading, setLoading] = useState(false); // For save/update
  const [apiLoading, setApiLoading] = useState(false); // Keep or remove based on need for global overlay
  const [mode, setMode] = useState<"normal" | "ingredients">("normal");
  const [ingredients, setIngredients] = useState("");
  const [aiButtonLoading, setAiButtonLoading] = useState(false); // For ingredient AI
  const [imageLoading, setImageLoading] = useState(false); // For image analysis (camera/gallery)

  useEffect(() => {
    if (isVisible) {
      setErrors({});
      setMode("normal");
      setIngredients("");
      // Reset loading states when modal opens
      setAiButtonLoading(false);
      setImageLoading(false);
      setLoading(false);
    }
  }, [isVisible, setErrors]);

  const getValue = (key: keyof Omit<Food, "id">) => {
    // Ensure numeric fields default to empty string for input if 0
    const value = (editFood && editFood[key]) ?? newFood[key] ?? "";
    // Keep 0 as "0" if it's the initial state for a new food
    if (!editFood && typeof value === 'number' && value === 0 && key !== 'name') {
        return ""; // Show empty input for new food numeric fields initially
    }
    if (editFood && typeof value === 'number' && value === 0 && key !== 'name') {
        return "0"; // Show "0" if editing and value is actually 0
    }
    return String(value); // Always return string for Input component
  };


  const handleCreateOrUpdate = async (isUpdate: boolean) => {
    setLoading(true);
    const foodData = isUpdate ? editFood : newFood;
    if (!foodData) {
        setLoading(false);
        return; // Should not happen in practice
    }

     // Ensure numeric fields are numbers before validation/saving
     // Use parseFloat which handles empty strings as NaN, then default to 0
     const dataToValidate: Omit<Food, "id"> = {
        ...foodData,
        name: String(foodData.name).trim(), // Trim name
        // Use getValue to ensure consistency with displayed value before parsing
        calories: parseFloat(getValue("calories")) || 0,
        protein: parseFloat(getValue("protein")) || 0,
        carbs: parseFloat(getValue("carbs")) || 0,
        fat: parseFloat(getValue("fat")) || 0,
    };


    const validationErrors = validateFood(dataToValidate);

    if (validationErrors) {
      setErrors(validationErrors);
      setLoading(false);
      Toast.show({
        type: "error",
        text1: "Please fix the errors",
        position: 'bottom',
      });
      return;
    }
    // Clear errors if validation passes
    setErrors({});

    try {
      // Assumes handleUpdateFood/handleCreateFood use the respective state (editFood/newFood)
      // which was updated via handleInputChange. They need to handle parsing strings back to numbers if needed.
      if (isUpdate) {
          await handleUpdateFood();
      } else {
          await handleCreateFood();
      }

      Toast.show({
        type: "success",
        text1: `Food ${isUpdate ? "Updated" : "Created"} Successfully!`,
        position: 'bottom',
      });
      toggleOverlay();
    } catch (error: any) {
      Alert.alert(
        "Error",
        error.message || `Failed to ${isUpdate ? "update" : "create"} food.`
      );
    } finally {
      setLoading(false);
    }
  };

  const handleAiButtonClick = async () => {
    const foodName = getValue("name");
     // Require name only when switching to ingredients mode or submitting from it
    if (!foodName && mode === 'ingredients') {
      Alert.alert("Missing Name", "Please enter a food name first.");
      return;
    }

    if (mode === "normal") {
      setMode("ingredients");
      // Clear macro fields when switching to ingredients mode
      handleInputChange("calories", "", !!editFood);
      handleInputChange("protein", "", !!editFood);
      handleInputChange("carbs", "", !!editFood);
      handleInputChange("fat", "", !!editFood);
    } else if (mode === "ingredients") {
       // Ensure name exists before proceeding (should be caught above, but good failsafe)
      const currentFoodName = getValue("name");
      if (!currentFoodName) {
        Alert.alert("Missing Name", "Please enter a food name before calculating macros.");
        return;
      }

      setAiButtonLoading(true);
      try {
        const macros = await getMacrosForRecipe(currentFoodName, ingredients);

        // Update fields with AI results (rounded)
        handleInputChange("calories", String(Math.round(macros.calories)), !!editFood);
        handleInputChange("protein", String(Math.round(macros.protein)), !!editFood);
        handleInputChange("carbs", String(Math.round(macros.carbs)), !!editFood);
        handleInputChange("fat", String(Math.round(macros.fat)), !!editFood);

        setMode("normal"); // Switch back to normal mode to show results
         Toast.show({ type: 'info', text1: 'Macros estimated from ingredients.', position: 'bottom' });
      } catch (error) {
        console.error("AI Macro fetch error (recipe):", error);
        Alert.alert(
          "AI Error",
           `Could not calculate macros from text. ${error instanceof Error ? error.message : "Please try again or input manually."}`
        );
      } finally {
        setAiButtonLoading(false);
      }
    }
  };

  // --- Function to handle image acquisition (Camera or Gallery) and analysis ---
  const handleGetImageAndAnalyze = async () => {

    const processImage = async (pickerResult: ImagePickerResult) => {
        if (pickerResult.canceled) {
            console.log("Image selection/capture cancelled");
            return; // Exit if cancelled
        }

        if (pickerResult.assets && pickerResult.assets.length > 0) {
            const asset = pickerResult.assets[0]; // asset is of type ImagePickerAsset
            console.log("Image acquired:", asset.uri);
            setImageLoading(true); // Start loading indicator *before* analysis

            const fileInfoForApi = {
                uri: asset.uri,
                fileName: asset.fileName ?? `photo_${Date.now()}.jpg`, // Provide a default filename if null
                type: asset.mimeType ?? 'image/jpeg' // Provide a default mimetype if null
            };

            try {
                const result = await getMacrosForImageFile(fileInfoForApi);

                // Update form fields with results
                handleInputChange("name", result.foodName, !!editFood); // Update name too
                handleInputChange("calories", String(Math.round(result.calories)), !!editFood);
                handleInputChange("protein", String(Math.round(result.protein)), !!editFood);
                handleInputChange("carbs", String(Math.round(result.carbs)), !!editFood);
                handleInputChange("fat", String(Math.round(result.fat)), !!editFood);

                // Switch back to normal mode if in ingredients mode
                setMode("normal");
                setIngredients(""); // Clear ingredients if image analysis was successful

                Toast.show({
                    type: 'success',
                    text1: 'Food Identified!',
                    text2: `Identified as ${result.foodName}. Macros estimated.`,
                    position: 'bottom',
                });

            } catch (analysisError) {
                console.error("Error during image analysis:", analysisError);
                Alert.alert(
                    "Analysis Failed",
                    `Could not get macros from the image. ${analysisError instanceof Error ? analysisError.message : "Please try again or enter manually."}`
                );
            } finally {
                 // Stop loading indicator regardless of success/failure
                 // Delay slightly to allow UI update before loading stops visually
                 setTimeout(() => setImageLoading(false), 100);
            }
        } else {
            console.log("No assets selected or returned.");
            // Optional: show a message if no asset was returned unexpectedly
        }
    }; // end processImage

    // --- Present choice to user ---
    Alert.alert(
      "Get Image",
      "Choose a source for the food image:",
      [
        {
          text: "Cancel",
          style: "cancel",
        },
        {
          text: "Camera",
          onPress: async () => {
            setImageLoading(true); // Indicate loading for permission/camera launch
            try {
                // Request Camera Permissions
                const permissionResult = await ImagePicker.requestCameraPermissionsAsync();
                if (permissionResult.granted === false) {
                    Alert.alert("Permission Required", "Camera access is needed to take a photo.");
                    setImageLoading(false);
                    return;
                }
                // Launch Camera
                const cameraResult = await ImagePicker.launchCameraAsync({
                    quality: 0.6, // Keep quality reasonable
                    allowsEditing: false, // Optional: allow editing after capture
                });
                await processImage(cameraResult); // Process the result from camera
            } catch (error) {
                console.error("Error launching camera:", error);
                Alert.alert("Camera Error", "Could not open the camera.");
                setImageLoading(false); // Ensure loading is stopped on error
            }
            // Note: setImageLoading(false) is handled within processImage's finally block on success/analysis error
          },
        },
        {
          text: "Gallery",
          onPress: async () => {
            setImageLoading(true); // Indicate loading for permission/gallery launch
            try {
                // Request Media Library Permissions
                const permissionResult = await ImagePicker.requestMediaLibraryPermissionsAsync();
                if (permissionResult.granted === false) {
                    Alert.alert("Permission Required", "Gallery access is needed to choose an image.");
                    setImageLoading(false);
                    return;
                }
                // Launch Image Library
                const libraryResult = await ImagePicker.launchImageLibraryAsync({
                    mediaTypes: ImagePicker.MediaTypeOptions.Images,
                    quality: 0.6,
                });
                await processImage(libraryResult); // Process the result from gallery
            } catch (error) {
                console.error("Error launching image library:", error);
                Alert.alert("Gallery Error", "Could not open the image library.");
                 setImageLoading(false); // Ensure loading is stopped on error
            }
             // Note: setImageLoading(false) is handled within processImage's finally block on success/analysis error
          },
        },
      ],
      { cancelable: true } // Allow dismissing the alert by tapping outside
    );
  };


    // Combine theme-dependent and static styles
    const combinedOverlayStyle = StyleSheet.flatten([
        styles.overlayStyle, // Get base styles from useStyles
        { backgroundColor: theme.colors.background } // Apply theme background color here
    ]);

  return (
    <Overlay
      isVisible={isVisible}
      onBackdropPress={!imageLoading && !aiButtonLoading && !loading ? toggleOverlay : undefined} // Prevent closing while loading
      animationType="fade"
      overlayStyle={styles.overlayContainer} // Use container style
    >
      {/* KeyboardAvoidingView now directly inside Overlay */}
      <KeyboardAvoidingView
        behavior={Platform.OS === "ios" ? "padding" : "height"}
        style={styles.keyboardAvoidingView}
        keyboardVerticalOffset={KEYBOARD_VERTICAL_OFFSET} // Added offset
      >
        {/* This View now acts as the visible modal background and content container */}
        <View style={combinedOverlayStyle}>
          <View style={styles.header}>
            <Text h4 style={styles.overlayTitle}>
              {editFood ? "Edit Food" : "Add New Food"}
            </Text>
            <Button
              title={editFood ? "Update" : "Add"}
              onPress={() => handleCreateOrUpdate(!!editFood)}
              buttonStyle={[
                styles.button,
                {
                  backgroundColor: editFood
                    ? theme.colors.warning
                    : theme.colors.primary,
                },
              ]}
              titleStyle={{ color: theme.colors.white, fontWeight: "600" }}
              loading={loading} // Use the specific loading state
              disabled={loading || aiButtonLoading || imageLoading} // Disable while any operation is running
              containerStyle={styles.buttonContainer}
            />
             {/* Disable close button when loading */}
            <Icon
              name="close"
              type="material"
              size={28}
              color={theme.colors.text}
              onPress={!imageLoading && !aiButtonLoading && !loading ? toggleOverlay : undefined}
              containerStyle={styles.closeIcon}
              disabled={imageLoading || aiButtonLoading || loading}
              disabledStyle={{ backgroundColor: 'transparent' }} // Prevent visual change on disable
            />
          </View>

          {/* Use ScrollView to ensure content is scrollable, especially with keyboard */}
          <ScrollView keyboardShouldPersistTaps="handled">
             {/* --- Food Name Input with Image Icon --- */}
            <View style={styles.inputRow}>
                <Input
                    label="Food Name"
                    labelStyle={{ color: theme.colors.text }}
                    value={getValue("name")}
                    onChangeText={(text) =>
                        handleInputChange("name", text, !!editFood)
                    }
                    errorMessage={errors.name}
                    inputContainerStyle={[styles.inputContainerStyle, styles.inputContainerFlex]} // Adjust style
                    inputStyle={styles.inputStyle}
                    containerStyle={{ flex: 1 }} // Make input take available space
                    leftIcon={
                        <MaterialCommunityIcons
                        name="food-apple"
                        size={24}
                        color={errors.name ? theme.colors.error : theme.colors.grey1} // Use less prominent color when no error
                        />
                    }
                />
                {/* --- Image Picker/Camera Icon Button --- */}
                <TouchableOpacity
                    onPress={handleGetImageAndAnalyze} // Updated function call
                    disabled={imageLoading || aiButtonLoading || loading} // Disable while loading
                    style={styles.iconButtonContainer}
                 >
                    {imageLoading ? (
                        <ActivityIndicator size="small" color={theme.colors.primary} />
                    ) : (
                        <Icon
                            name="camera-enhance-outline" // Icon represents getting an image (camera or gallery)
                            type="material-community"
                            size={28}
                            color={theme.colors.primary}
                        />
                    )}
                </TouchableOpacity>
            </View>
            {/* --- End Food Name Input with Image Icon --- */}

            {mode === "normal" && (
              <>
                <Input
                  label="Calories (per 100g)"
                  labelStyle={{ color: theme.colors.text }}
                  keyboardType="numeric"
                  value={getValue("calories")}
                  onChangeText={(text) =>
                    handleInputChange(
                      "calories",
                      // Allow only numbers and one decimal point
                      text.replace(/[^0-9.]/g, "").replace(/(\..*)\./g, "$1"),
                      !!editFood
                    )
                  }
                  errorMessage={errors.calories}
                  inputContainerStyle={styles.inputContainerStyle}
                  inputStyle={styles.inputStyle}
                  leftIcon={
                    <MaterialCommunityIcons
                      name="fire"
                      size={24}
                      color={
                        errors.calories
                          ? theme.colors.error
                          : theme.colors.grey1
                      }
                    />
                  }
                />

                <Input
                  label="Protein (per 100g)"
                  labelStyle={{ color: theme.colors.text }}
                  keyboardType="numeric"
                  value={getValue("protein")}
                  onChangeText={(text) =>
                    handleInputChange(
                      "protein",
                      // Allow only numbers and one decimal point
                      text.replace(/[^0-9.]/g, "").replace(/(\..*)\./g, "$1"),
                      !!editFood
                    )
                  }
                  errorMessage={errors.protein}
                  inputContainerStyle={styles.inputContainerStyle}
                  inputStyle={styles.inputStyle}
                  leftIcon={
                    <MaterialCommunityIcons
                      name="food-drumstick"
                      size={24}
                      color={
                        errors.protein
                          ? theme.colors.error
                          : theme.colors.grey1
                      }
                    />
                  }
                />

                <Input
                  label="Carbs (per 100g)"
                  labelStyle={{ color: theme.colors.text }}
                  keyboardType="numeric"
                  value={getValue("carbs")}
                  onChangeText={(text) =>
                    handleInputChange(
                      "carbs",
                      // Allow only numbers and one decimal point
                      text.replace(/[^0-9.]/g, "").replace(/(\..*)\./g, "$1"),
                      !!editFood
                    )
                  }
                  errorMessage={errors.carbs}
                  inputContainerStyle={styles.inputContainerStyle}
                  inputStyle={styles.inputStyle}
                  leftIcon={
                    <MaterialCommunityIcons
                      name="bread-slice"
                      size={24}
                      color={
                        errors.carbs ? theme.colors.error : theme.colors.grey1
                      }
                    />
                  }
                />
                <Input
                  label="Fat (per 100g)"
                  labelStyle={{ color: theme.colors.text }}
                  keyboardType="numeric"
                  value={getValue("fat")}
                  onChangeText={(text) =>
                    handleInputChange(
                      "fat",
                      // Allow only numbers and one decimal point
                      text.replace(/[^0-9.]/g, "").replace(/(\..*)\./g, "$1"),
                      !!editFood
                    )
                  }
                  errorMessage={errors.fat}
                  inputContainerStyle={styles.inputContainerStyle}
                  inputStyle={styles.inputStyle}
                  leftIcon={
                    <MaterialCommunityIcons
                      name="oil" // Changed icon to 'oil'
                      size={24}
                      color={
                        errors.fat ? theme.colors.error : theme.colors.grey1
                      }
                    />
                  }
                />
              </>
            )}

            {mode === "ingredients" && (
              <>
                <View style={styles.backButtonContainer}>
                  <Icon
                    name="arrow-left"
                    type="material-community"
                    size={24}
                    color={theme.colors.primary}
                    onPress={() => !aiButtonLoading && setMode("normal")} // Prevent switching during AI call
                    disabled={aiButtonLoading}
                    containerStyle={styles.backIcon}
                  />
                  <Text style={[styles.backButtonText, aiButtonLoading && styles.disabledText]} onPress={() => !aiButtonLoading && setMode("normal")}>
                      Back to Manual Input
                  </Text>
                </View>

                <Input
                  label="Ingredients (Optional - Add if known)" // Updated label
                  labelStyle={{ color: theme.colors.text }}
                  value={ingredients}
                  onChangeText={setIngredients}
                  multiline={true}
                  numberOfLines={4} // Suggests height but allows expansion
                  inputContainerStyle={[
                    styles.inputContainerStyle,
                    styles.multilineInputContainer,
                  ]}
                  inputStyle={[styles.inputStyle, styles.multilineInput]}
                  placeholder="e.g.\n100g Chicken Breast\n50g Rice\n1 tbsp Olive Oil"
                  placeholderTextColor={theme.colors.grey3}
                  leftIcon={
                    <MaterialCommunityIcons
                      name="format-list-bulleted" // Better icon for list
                      size={24}
                      color={theme.colors.grey1}
                      style={styles.multilineIcon} // Adjust icon position if needed
                    />
                  }
                />
              </>
            )}
            {/* --- AI (Text) Button --- */}
            <Button
              title={
                mode === "normal"
                  ? "Calculate with AI (Recipe/Text)" // Clarify it's for text
                  : ingredients // Check if ingredients have been entered
                  ? "Get Macros from Ingredients"
                  : "Get Macros from Name Only" // New title
              }
              onPress={handleAiButtonClick}
              buttonStyle={[
                styles.button,
                styles.aiButton, // Specific style for AI button
                { backgroundColor: theme.colors.secondary },
              ]}
              titleStyle={[styles.aiButtonTitle, { color: theme.colors.white }]}
              loading={aiButtonLoading} // Use specific loading state
              disabled={aiButtonLoading || imageLoading || loading} // Disable while other ops run
              icon={
                mode === "normal" ? (
                  <MaterialCommunityIcons
                    name="text-box-search-outline" // Changed icon
                    size={18}
                    color={theme.colors.white}
                    style={{ marginRight: 8 }}
                  />
                ) : undefined
              }
              containerStyle={[styles.buttonContainer, { marginTop: 15 }]}
            />

            <View style={styles.futureInputContainer}>
              <Text style={styles.futureInputLabel}>
                Barcode Input (Coming Soon)
              </Text>
            </View>
          </ScrollView>
        </View>
      </KeyboardAvoidingView>
      {/* Optional: Central loading overlay (can be removed if specific indicators are sufficient) */}
      {apiLoading && ( // You might not need this if button indicators are enough
        <View style={styles.loadingOverlay}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
        </View>
      )}
    </Overlay>
  );
};


// --- Styles (Includes previous fixes and new styles for image icon) ---
const useStyles = makeStyles((theme) => ({
  // Style for the Overlay container itself (positioning, width)
  overlayContainer: {
    backgroundColor: 'transparent', // Make the overlay container transparent
    width: '90%',
    maxWidth: 500, // Max width for larger screens
    padding: 0, // Remove padding from overlay itself
    borderRadius: 15,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2, },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
    overflow: 'hidden', // Prevent content spilling before borderRadius
  },
  // Style for the main content View inside KeyboardAvoidingView (visuals, padding)
  overlayStyle: {
    width: '100%', // Takes width from overlayContainer
    borderRadius: 15,
    padding: 20,
    paddingBottom: 30, // Add extra padding at the bottom
    maxHeight: '90%', // Limit max height
    // backgroundColor is applied dynamically based on theme
  },
  keyboardAvoidingView: {
    width: "100%",
    // Let KAV manage its size based on content and keyboard
  },
  header: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 20,
    paddingBottom: 10, // Add padding below header
    borderBottomWidth: 1, // Add a separator
    borderBottomColor: theme.colors.divider,
  },
  overlayTitle: {
    color: theme.colors.text,
    fontWeight: "bold",
    fontSize: 20, // Slightly smaller
    flexShrink: 1,
    marginRight: 10,
  },
  closeIcon: {
    padding: 5,
    marginLeft: 10,
  },
  // *** Styles for Input Row with Icon Button ***
  inputRow: {
    flexDirection: 'row',
    alignItems: 'flex-end', // Align items to bottom (aligns icon with input line)
    marginBottom: 5, // Consistent margin like other inputs
  },
  inputContainerFlex: {
    flex: 1, // Allow input container to grow
    marginRight: 10, // Space between input and icon button
    marginBottom: 0, // Remove margin bottom from container inside row
  },
  iconButtonContainer: {
    height: 40, // Match input height approximately
    width: 40,  // Make it square
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 10, // Align button bottom with input field bottom roughly (adjust if needed)
    // backgroundColor: theme.colors.grey5, // Optional: Subtle background
    // borderRadius: 20, // Optional: Make it circular
  },
  // *** End Styles for Input Row ***
  inputContainerStyle: {
    borderBottomWidth: 1,
    borderBottomColor: theme.colors.grey4,
    marginBottom: 5, // Reduced margin
    paddingBottom: 2, // Add slight padding for input line
  },
  inputStyle: {
    color: theme.colors.text,
    marginLeft: 10,
    fontSize: 16,
  },
  multilineInputContainer: {
    borderWidth: 1, // Add border for multiline
    borderColor: theme.colors.grey4,
    borderRadius: 8,
    paddingVertical: 8,
    paddingHorizontal: 5, // Add horizontal padding
    marginBottom: 10,
    borderBottomWidth: 1, // Keep consistent border style
    borderBottomColor: theme.colors.grey4, // Keep consistent border style
  },
  multilineInput: {
    marginLeft: 5,
    textAlignVertical: 'top', // Align text top in multiline
    minHeight: 80, // Ensure a minimum height
    fontSize: 16, // Consistent font size
    color: theme.colors.text, // Ensure text color
  },
  multilineIcon: {
      marginTop: 8, // Adjust vertical position to align better with text
      marginRight: 5,
  },
  futureInputContainer: {
    backgroundColor: theme.colors.grey5,
    padding: 15,
    borderRadius: 10,
    marginTop: 20, // Increased margin
    marginBottom: 10, // Add bottom margin
    alignItems: "center",
  },
  futureInputLabel: {
    color: theme.colors.grey2,
    fontStyle: "italic",
  },
  buttonContainer: {
    // No specific style needed now
  },
  button: {
    borderRadius: 8,
    paddingHorizontal: 15,
    paddingVertical: 10,
  },
  aiButton: {
     paddingVertical: 12,
  },
  aiButtonTitle: {
      fontWeight: "600",
      fontSize: 15,
      textAlign: 'center', // Center button text
  },
  loadingOverlay: { // For general overlay if needed
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    justifyContent: "center",
    alignItems: "center",
    zIndex: 10,
    borderRadius: 15, // Match overlay border radius
  },
  backButtonContainer: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 15, // Add space below
    marginTop: 5,
  },
  backIcon: {
    marginRight: 5,
    padding: 5, // Make icon easier to tap
  },
  backButtonText: {
    color: theme.colors.primary, // Make text match icon color
    fontSize: 16,
    fontWeight: '500',
  },
  disabledText: {
      color: theme.colors.grey3, // Style for disabled text
  }
}));


export default AddFoodModal;
---------- END AddFoodModal.tsx ----------


---------- ConfirmationModal.tsx ----------
// components/ConfirmationModal.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Overlay, Button, Input, Text, useTheme } from '@rneui/themed';

interface ConfirmationModalProps {
  isVisible: boolean;
  onCancel: () => void;
  onConfirm: () => void;
  confirmationText: string;
  setConfirmationText: (text: string) => void;
  title?: string; // Optional title
  message?: string;  //Optional message
}

const ConfirmationModal: React.FC<ConfirmationModalProps> = ({
  isVisible,
  onCancel,
  onConfirm,
  confirmationText,
  setConfirmationText,
  title = "Confirm Action", //default title
  message = "Are you sure you want to perform this action?"
}) => {
  const { theme } = useTheme();

  return (
    <Overlay
      isVisible={isVisible}
      onBackdropPress={onCancel}
      overlayStyle={styles.overlay}
      backdropStyle={styles.backdrop} // Add the backdropStyle
    >
      <View style={[styles.container, {backgroundColor: theme.colors.background}]}>
        <Text style={[styles.title, {color: theme.colors.text}]}>{title}</Text>
        <Text style={[styles.message, {color: theme.colors.text}]}>{message}</Text>
        <Input
          placeholder="Enter confirmation text"
          placeholderTextColor={theme.colors.text}
          value={confirmationText}
          onChangeText={setConfirmationText}
          containerStyle={styles.inputContainer}
          inputStyle={{ color: theme.colors.text }}
          inputContainerStyle={{borderBottomColor: theme.colors.text}}
        />
        <View style={styles.buttonContainer}>
          <Button title="Cancel" onPress={onCancel} type="outline" buttonStyle={styles.button} />
          <Button
            title="Confirm"
            onPress={onConfirm}
            color="error"
            buttonStyle={styles.button}
            disabled={confirmationText === ""}  //Disable when empty
          />
        </View>
      </View>
    </Overlay>
  );
};

const styles = StyleSheet.create({
    overlay: {
        borderRadius: 10,
        width: '80%', // Responsive width
        padding: 6,
        backgroundColor: 'rgba(200, 200, 200, 0.5)'
    },
  container: {
    padding: 20,
    borderRadius: 7,
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 10,
    textAlign: 'center', //center align
  },
  message: {
    marginBottom: 15,
    textAlign: 'center'
  },
  inputContainer: {
    marginBottom: 20,
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
  },
  button: {
    width: 100,
    padding: 10,
  },
  backdrop: {  // Add styles for the backdrop
    backgroundColor: 'rgba(0, 0, 0, 0.5)', // Semi-transparent black
  },
});

export default ConfirmationModal;
---------- END ConfirmationModal.tsx ----------


---------- DailyGoalsInput.tsx ----------
// components/DailyGoalsInput.tsx
import React from "react";
import { Input, Text } from "@rneui/themed";
import { MacroType } from "../types/settings";
import { useTheme } from "@rneui/themed";


interface DailyGoalsInputProps {
    dailyGoals: { [key in MacroType]: number };
    onGoalChange: (goalType: MacroType, value: string) => void;
}

const DailyGoalsInput: React.FC<DailyGoalsInputProps> = ({
  dailyGoals,
  onGoalChange,
}) => {

    const { theme } = useTheme();

  return (
    <>
      {["calories", "protein", "carbs", "fat"].map((macro) => (
        <Input
          key={macro}
          label={<Text style={{ color: theme.colors.text }}>{`${macro.charAt(0).toUpperCase() + macro.slice(1)} Goal`}</Text>} // Wrap label in <Text>
          keyboardType="numeric"
          value={dailyGoals?.[macro as MacroType]?.toString() || ""}
          onChangeText={(value) => onGoalChange(macro as MacroType, value)}
          style={{ color: theme.colors.text }}
          inputContainerStyle={{ borderBottomColor: theme.colors.text }}
          labelStyle={{ color: theme.colors.text }}
        />
      ))}
    </>
  );
};

export default DailyGoalsInput;
---------- END DailyGoalsInput.tsx ----------


---------- DailyProgress.tsx ----------
// components/DailyProgress.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, useTheme } from '@rneui/themed';

interface DailyProgressProps {
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
  goals: {
    calories?: number;
    protein?: number;
    carbs?: number;
    fat?: number;
  };
}

const DailyProgress: React.FC<DailyProgressProps> = ({
  calories,
  protein,
  carbs,
  fat,
  goals,
}) => {
  const { theme } = useTheme();

  const calculateProgress = (current: number, goal?: number) => {
    if (!goal || goal <= 0) return 0; // Avoid division by zero and handle undefined goals
    return Math.min(current / goal, 1); // Cap at 100%
  };

  const renderProgressBar = (label: string, current: number, goal: number | undefined, color: string) => {
      const progress = calculateProgress(current, goal);
      return (
          <View style={styles.macroContainer} key={label}>
              <View style={styles.labelContainer}>
                    <Text style={[styles.macroLabel, {color: theme.colors.text}]}>{label}:</Text>
                    <Text style={[styles.macroValue, {color: theme.colors.text}]}>
                        {`${Math.round(current)} / ${goal || 0}`}
                    </Text>
              </View>
              <View style={styles.progressBarContainer}>
                  <View style={[styles.progressBar, { width: `${progress * 100}%`, backgroundColor: color }]} />
              </View>
          </View>
      )
  }


  return (
    <View style={styles.container}>
        {renderProgressBar('Calories', calories, goals.calories, theme.colors.primary)}
        {renderProgressBar('Protein', protein, goals.protein, 'green')}
        {renderProgressBar('Carbs', carbs, goals.carbs, 'orange')}
        {renderProgressBar('Fat', fat, goals.fat, 'blue')}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: 20,
    padding: 10,
    borderRadius: 8, // Rounded corners for the container
    //backgroundColor: '#f0f0f0', // Light background for contrast Removed for theme consistency
  },
  macroContainer: {
    marginBottom: 10,
  },
  labelContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 5,
  },
  macroLabel: {
    fontWeight: 'bold',
  },
  macroValue: {},
  progressBarContainer: {
      backgroundColor: '#e0e0e0', //Light grey for track
      borderRadius: 5,
      height: 10
  },
  progressBar: {
    height: 10,
    borderRadius: 5,
  },
});

export default DailyProgress;
---------- END DailyProgress.tsx ----------


---------- DataManagementButtons.tsx ----------
// components/DataManagementButtons.tsx (Modified callback)

import React, { useState } from "react";
import { Alert, Platform } from "react-native"; // Import Platform
import { Button } from "@rneui/themed";
import * as DocumentPicker from "expo-document-picker";
import * as FileSystem from "expo-file-system";
import * as Sharing from 'expo-sharing'; // Import Sharing
import { formatDate } from "../utils/dateUtils";
import {
  clearAllData,
  loadDailyEntries,
  saveDailyEntries,
  loadFoods,
  saveFoods,
  loadSettings,
  saveSettings
} from "../services/storageService";
import ConfirmationModal from "./ConfirmationModal";
import { DailyEntry } from "../types/dailyEntry";
import { Food } from "../types/food";
import { Settings } from "../types/settings";
import { useTheme } from "@rneui/themed";


interface DataManagementButtonsProps {
  onDataOperation: () => void; // Changed prop name
}

const DataManagementButtons: React.FC<DataManagementButtonsProps> = ({
    onDataOperation
}) => {
  const [isConfirmationVisible, setIsConfirmationVisible] = useState(false);
  const [confirmationText, setConfirmationText] = useState("");
  const { theme } = useTheme();

  const handleExportData = async () => {
    try {
      const dailyEntries = await loadDailyEntries();
      const foods = await loadFoods();
      const settings = await loadSettings();

      const exportData = {
        dailyEntries,
        foods,
        settings
      };

      const exportDataString = JSON.stringify(exportData);
      const formattedDate = formatDate(new Date()).replace(/\//g, '-'); // Replace slashes
      const fileName = `macro_data_${formattedDate}.json`;
      const fileUri = FileSystem.documentDirectory + fileName;

      await FileSystem.writeAsStringAsync(fileUri, exportDataString, {
        encoding: FileSystem.EncodingType.UTF8,
      });

      // Use expo-sharing to share the file
      if (!(await Sharing.isAvailableAsync())) {
        Alert.alert('Sharing is not available on your platform');
        return;
      }

      await Sharing.shareAsync(fileUri);
      onDataOperation(); // Trigger reload after export

    } catch (error: any) {
      console.error(error);
      Alert.alert(
        "Export Failed",
        error.message || "An error occurred while exporting data."
      );
    }
  };

  const handleImportData = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: ["application/json"], // Only accept JSON files
      });

      if (result.assets && result.assets.length > 0) {
        const file = result.assets[0];

        // Check file extension
        if (!file.name?.toLowerCase().endsWith(".json")) {
          Alert.alert("Invalid File", "Please select a JSON file.");
          return;
        }

        const fileContent = await FileSystem.readAsStringAsync(file.uri, {
          encoding: FileSystem.EncodingType.UTF8,
        });


        try {
          const importedData = JSON.parse(fileContent);

          // Basic structure validation:
          if (
            !importedData.hasOwnProperty("dailyEntries") ||
            !importedData.hasOwnProperty("foods") ||
            !importedData.hasOwnProperty("settings")
          ) {
            Alert.alert(
              "Import Failed",
              "The imported file is missing required data (dailyEntries, foods, or settings)."
            );
            return;
          }


          await saveDailyEntries(importedData.dailyEntries);
          await saveFoods(importedData.foods);
          await saveSettings(importedData.settings)
          Alert.alert("Import Successful", "Data imported and saved.");
          onDataOperation(); //trigger reload

        } catch (parseError) {
          Alert.alert(
            "Import Failed",
            "The imported file is not valid JSON."
          );
          return;
        }


      } else {
        // Explicitly check for cancelled
        if (result.canceled) {
          // User cancelled, do nothing
        } else {
          Alert.alert("Import Failed", "Invalid file selected.");
        }
      }
    } catch (error: any) {
      console.error("Import Error:", error);
      Alert.alert(
        "Import Failed",
        error.message || "An unknown error occurred."
      );
    }
  };

  const handleClearData = () => setIsConfirmationVisible(true);

  const confirmClearData = async () => {
    if (confirmationText === "CLEAR DATA") {
      try {
        await clearAllData();
        Alert.alert("Data Cleared", "All data has been cleared.");
        onDataOperation(); // Trigger reload after clearing
      } catch (error) {
        Alert.alert("Error", "Failed to clear data.");
      } finally {
        setConfirmationText("");
        setIsConfirmationVisible(false);
      }
    } else {
      Alert.alert("Error", "Incorrect confirmation text.");
    }
  };

  return (
    <>
      <Button
        title="Export Data"
        onPress={handleExportData}
        buttonStyle={{ marginBottom: 10, backgroundColor: theme.colors.primary }}
      />
      <Button
        title="Import Data"
        onPress={handleImportData}
        buttonStyle={{ marginBottom: 10, backgroundColor: theme.colors.primary }}
      />
      <Button
        title="Clear All Data"
        onPress={handleClearData}
        color="error"
        buttonStyle={{ marginBottom: 10 }}
      />

      <ConfirmationModal
        isVisible={isConfirmationVisible}
        onCancel={() => setIsConfirmationVisible(false)}
        onConfirm={confirmClearData}
        confirmationText={confirmationText}
        setConfirmationText={setConfirmationText}
        title="Clear All Data?"
        message="This action cannot be undone. Confirmation Text: CLEAR DATA"
      />
    </>
  );
};

export default DataManagementButtons;
---------- END DataManagementButtons.tsx ----------


---------- FoodItem.tsx ----------
// FoodItem.tsx (Corrected with forwardRef and Icon Handling)
import React, { forwardRef } from "react"; // Import forwardRef
import { StyleSheet, View, Image } from "react-native"; // Import View and Image
import { ListItem, Icon, useTheme, Button } from "@rneui/themed";
import { Food } from "../types/food";
import Toast from "react-native-toast-message";

interface FoodItemProps {
  food: Food;
  onEdit: (food: Food) => void;
  onDelete: (foodId: string) => void;
  onUndoDelete: (food: Food) => void;
  foodIconUrl: string | null; // Add foodIconUrl prop
}

// Use forwardRef to receive the ref from the parent
const FoodItem = forwardRef<any, FoodItemProps>(
  ({ food, onEdit, onDelete, onUndoDelete, foodIconUrl }, ref) => {
    const { theme } = useTheme();

    const handleDelete = () => {
      onDelete(food.id);
      Toast.show({
        type: "success",
        text1: `${food.name} deleted`,
        text2: "Tap to undo",
        position: "bottom",
        bottomOffset: 80,
        onPress: () => onUndoDelete(food), // Call undo function
        visibilityTime: 3000, // Show for 3 seconds
      });
    };

    return (
      // Attach the received ref to ListItem.Swipeable
      <ListItem.Swipeable
        ref={ref} // Pass the forwarded ref here!
        bottomDivider
        leftContent={(reset) => (
          <Button
            title="Edit"
            onPress={() => {
              onEdit(food);
              reset();
            }}
            icon={{ name: "edit", color: "white" }}
            buttonStyle={styles.swipeButtonEdit}
          />
        )}
        rightContent={(reset) => (
          <Button
            title="Delete"
            onPress={handleDelete} // Call handleDelete
            icon={{ name: "delete", color: "white" }}
            buttonStyle={styles.swipeButtonDelete}
          />
        )}
        containerStyle={[
          styles.listItemContainer,
          { backgroundColor: theme.colors.background },
        ]}
      >
        {/* Use Image component if foodIconUrl exists, otherwise use default Icon */}
        {foodIconUrl ? (
          <Image source={{ uri: foodIconUrl }} style={styles.foodIcon} />
        ) : (
          <Icon
            name="fast-food-outline"
            type="ionicon"
            color={theme.colors.text}
          />
        )}
        <ListItem.Content>
          <ListItem.Title style={[styles.title, { color: theme.colors.text }]}>
            {food.name}
          </ListItem.Title>
          <ListItem.Subtitle style={{ color: theme.colors.text }}>
            {`Cal: ${food.calories}, P: ${food.protein}g, C: ${food.carbs}g, F: ${food.fat}g`}
          </ListItem.Subtitle>
        </ListItem.Content>
        <ListItem.Chevron />
      </ListItem.Swipeable>
    );
  }
);

const styles = StyleSheet.create({
  listItemContainer: {
    paddingVertical: 15,
    borderRadius: 0,
    marginVertical: 0,
  },
  title: {
    fontWeight: "bold",
    fontSize: 16,
  },
  swipeButtonEdit: {
    minHeight: "100%",
    backgroundColor: "orange",
  },
  swipeButtonDelete: {
    minHeight: "100%",
    backgroundColor: "red",
  },
  foodIcon: {
    width: 30,
    height: 30,
    marginRight: 10,
    borderRadius: 15,
    resizeMode: "stretch", // Or 'cover', or 'stretch', see below
  },
});

export default FoodItem;

---------- END FoodItem.tsx ----------


---------- StatisticsChart.tsx ----------
// components/StatisticsChart.tsx (Modified)
import React from "react";
import { View, StyleSheet } from "react-native";
import { WebView } from "react-native-webview";
import { Statistics, MacroType, macros } from "../types/settings"; // Import types
import { useTheme } from "@rneui/themed";


interface StatisticsChartProps {
  statistics: Statistics;
}

const StatisticsChart: React.FC<StatisticsChartProps> = ({ statistics }) => {

  const { theme } = useTheme();

  const generateChartHTML = () => {
    const chartData = macros.reduce((acc, macro) => {
      // Prepare data for each macro, including goal if applicable
      acc[macro] = statistics[macro].map((series) =>
        series.map((item) => [item.x / 1000, item.y])
      );
      return acc;
    }, {} as { [key in MacroType]: number[][][] });

    const textColor = theme.colors.text;
    const gridColor = theme.colors.grey5; // Lighter grid
    const axisColor = theme.colors.grey3; // Slightly darker axis
    const fontFamily = "Helvetica, Arial, sans-serif";

    // Define color palette for the lines, using theme colors if possible
    const lineColors = {
      calories: theme.colors.primary,
      protein: theme.colors.success,
      carbs: theme.colors.warning,
      fat: theme.colors.error,
    };


    // Re-enabled caching, but *only* cache the HTML itself, not the data.  The data is now dynamic.
    return `
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>Macro Charts</title>
            <style>
            body { font-family: ${fontFamily}; margin: 0; padding: 0; background-color: ${theme.colors.background}; color: ${textColor};}
                .chart-container { width: 95%; height: 250px; margin: 10px auto; }
            </style>
            <link rel="stylesheet" href="https://unpkg.com/uplot@1.6.27/dist/uPlot.min.css">
            <script src="https://unpkg.com/uplot@1.6.27/dist/uPlot.iife.min.js"></script>
        </head>
        <body>
            ${macros
      .map((macro) => {
        const isCalories = macro === "calories";
        const seriesCount = isCalories ? 2 : 1; // Two series for calories (intake, goal)

        const seriesConfig = isCalories
          ? `[
                      {},
                      {
                        stroke: "${lineColors[macro] || theme.colors.primary}",
                        width: 2,
                        label: "Intake",
                        points: { show: false }
                      },
                      {
                        stroke: "red",
                        width: 1,
                        dash: [5, 5],
                        label: "Goal",
                        points: { show: false }
                      }
                    ]`
          : `[
                      {},
                      {
                        stroke: "${lineColors[macro] || theme.colors.primary}",
                        width: 2,
                        label: "${macro.charAt(0).toUpperCase() + macro.slice(1)}",
                        points: { show: false }
                      }
                    ]`;


        const uPlotData =
          seriesCount === 2
            ? `[data[0].map(d => d[0]), data[0].map(d => d[1]), data[1].map(d => d[1])]`
            : `[data[0].map(d => d[0]), data[0].map(d => d[1])]`;



        return `
                <div id="${macro}-chart" class="chart-container"></div>
                <script>
                    const data = ${JSON.stringify(chartData[macro])};
                    const opts = {
                        title: "${macro.charAt(0).toUpperCase() + macro.slice(1)}",
                        width: window.innerWidth * 0.95,
                        height: 250,
                        scales: {
                            x: { time: true },
                            y: { },
                        },
                        axes: [
                            {
                                stroke: "${textColor}",
                                font: "14px ${fontFamily}",
                            grid: {
                                    stroke: "${gridColor}",
                                    width: 1
                                },
                                ticks: {
                                    stroke: "${gridColor}",
                                    width: 1
                                }
                            },
                            {
                                stroke: "${textColor}",
                                font: "14px ${fontFamily}",
                                grid: {
                                    stroke: "${gridColor}",
                                    width: 1
                                },
                                ticks: {
                                    stroke: "${gridColor}",
                                    width: 1
                                }
                            }
                        ],
                        series: ${seriesConfig},
                        cursor: {
                            drag: { setScale: false },
                            points: {
                                size: 6,
                                fill: (self, i) => self.series[i]._stroke,
                                stroke: (self, i) => self.series[i]._stroke,
                            }
                        },
                        ${isCalories ? `
                        hooks: {
                            draw: [
                                (u) => {
                                   const ctx = u.ctx;
                                    u.series.forEach((series, seriesIdx) => {
                                      if (seriesIdx === 1) {
                                        const intakeData = data[0];
                                        const goalData = data[1];

                                        ctx.beginPath();
                                        ctx.fillStyle = "rgba(255, 0, 0, 0.3)"; // Semi-transparent red

                                        for (let i = 0; i < intakeData.length; i++) {
                                          const intakeY = intakeData[i][1];
                                          const goalY = goalData[i][1];
                                          const x = u.valToPos(intakeData[i][0], "x", true);
                                          
                                           // Check if intake exceeds the goal
                                            if(intakeY > goalY){
                                                const intakeYPos = u.valToPos(intakeY, 'y', true);
                                                const goalYPos = u.valToPos(goalY, 'y', true);
                                               
                                                //if this is the first point or last point, move to x, other wise line to x
                                                if(i === 0){
                                                   ctx.moveTo(x, intakeYPos);
                                                }else{
                                                  ctx.lineTo(x, intakeYPos);
                                                }
                                            }
                                        }
                                        //go back along the goal data
                                         for (let i = intakeData.length-1; i >= 0; i--) {
                                            const intakeY = intakeData[i][1];
                                            const goalY = goalData[i][1];
                                             const x = u.valToPos(intakeData[i][0], "x", true);
                                               // Check if intake exceeds the goal
                                            if(intakeY > goalY){
                                                 const goalYPos = u.valToPos(goalY, 'y', true);
                                                ctx.lineTo(x, goalYPos);
                                            }
                                         }

                                        ctx.closePath();
                                        ctx.fill();
                                        }

                                    });

                                }
                            ]
                        }
                        ` : ''}
                    };
                    new uPlot(opts, ${uPlotData}, document.getElementById('${macro}-chart'));
                </script>
            `;
      })
      .join("")}
        </body>
        </html>
        `;

  };

  return (
    <View style={styles.webViewContainer}>
      <WebView
        originWhitelist={["*"]}
        source={{ html: generateChartHTML() }}
        style={styles.webView}
        scalesPageToFit={false}
        scrollEnabled={false}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  webViewContainer: {
    height: 'auto',
    width: "100%",
    marginTop: 10,
  },
  webView: {
    height: 340, // Explicit height, adjust as needed.
  },
});

export default StatisticsChart;
---------- END StatisticsChart.tsx ----------


---------- ThemeSwitch.tsx ----------
// components/ThemeSwitch.tsx (Corrected)
import React from "react";
import { ListItem, Switch } from "@rneui/themed";
import { useTheme } from "@rneui/themed";

interface ThemeSwitchProps {
  currentTheme: 'light' | 'dark' | 'system'; // Use theme string
  onToggle: (theme: 'light' | 'dark' | 'system') => void; // Pass the theme string
}

const ThemeSwitch: React.FC<ThemeSwitchProps> = ({ currentTheme, onToggle }) => {
  const { theme } = useTheme();

  return (
    <ListItem
      bottomDivider
      containerStyle={{ backgroundColor: theme.colors.background }}
    >
      <ListItem.Content>
        <ListItem.Title style={{ color: theme.colors.text }}>
          Dark Mode
        </ListItem.Title>
      </ListItem.Content>
      <Switch
        value={currentTheme === 'dark'} // Correctly reflect theme
        onValueChange={(newValue) => {
          onToggle(newValue ? 'dark' : 'light'); // Toggle between 'light' and 'dark'
        }}
      />
    </ListItem>
  );
};

export default ThemeSwitch;
---------- END ThemeSwitch.tsx ----------


---------- AppNavigator.tsx ----------
// navigation/AppNavigator.tsx
import React, { useState, useCallback } from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { Icon, useTheme } from '@rneui/themed';
import DailyEntryScreen from '../screens/DailyEntryScreen';
import FoodListScreen from '../screens/FoodListScreen';
import SettingsScreen from '../screens/SettingsScreen';

const Tab = createBottomTabNavigator();

interface AppNavigatorProps {
  onThemeChange: (theme: 'light' | 'dark' | 'system') => void;
}

const AppNavigator: React.FC<AppNavigatorProps> = ({ onThemeChange }) => {
  const { theme } = useTheme();
  const [foodListRefresh, setFoodListRefresh] = useState(false);

  const handleFoodChange = useCallback(() => {
    setFoodListRefresh(prev => !prev); // Toggle the state to trigger refresh
  }, []);

  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        tabBarIcon: ({ focused, color, size }) => {
          let iconName: string = '';
          let type: string = '';

          if (route.name === 'Daily Entry') {
            iconName = focused ? 'calendar' : 'calendar-outline';
            type = 'ionicon';
          } else if (route.name === 'Foods') {
            iconName = focused ? 'fast-food' : 'fast-food-outline';
            type = 'ionicon'; // Consistent icon set
          } else if (route.name === 'Settings') {
            iconName = focused ? 'settings' : 'settings-outline';
            type = 'ionicon';
          }

          return <Icon name={iconName} type={type} size={size} color={color} />;
        },
        tabBarActiveTintColor: theme.colors.primary,
        tabBarInactiveTintColor: theme.colors.secondary, // Use secondary color
        headerShown: false,
        tabBarStyle: {
          backgroundColor: theme.colors.background,
          borderTopColor: theme.colors.divider, // Add a subtle border
        },
        tabBarLabelStyle: {
          fontWeight: 'bold', // Make labels more prominent
        }
      })}
    >
      <Tab.Screen name="Daily Entry">
        {() => <DailyEntryScreen key={foodListRefresh ? 'refresh' : 'normal'} />}
      </Tab.Screen>
      <Tab.Screen name="Foods">
        {() => <FoodListScreen onFoodChange={handleFoodChange} />}
      </Tab.Screen>
      <Tab.Screen name="Settings">
        {() => <SettingsScreen onThemeChange={onThemeChange} onDataOperation={function (): void {
          throw new Error('Function not implemented.');
        } } />}
      </Tab.Screen>
    </Tab.Navigator>
  );
};

export default AppNavigator;
---------- END AppNavigator.tsx ----------


---------- DailyEntryScreen.tsx ----------
// src/screens/DailyEntryScreen.tsx
import React, { useState, useEffect, useCallback, useMemo } from "react";
import { View, FlatList, Alert, Platform, Image, StyleSheet, TouchableOpacity, ActivityIndicator } from "react-native";
import { DailyEntry, DailyEntryItem } from "../types/dailyEntry";
import { Food } from "../types/food";
import { getFoods } from "../services/foodService";
import {
    saveDailyEntries,
    loadDailyEntries,
    loadSettings,
} from "../services/storageService";
import {
    formatDate, // Keep this if used elsewhere, but formatISO is used for storage/keys
    formatDateReadable,
    getTodayDateString,
} from "../utils/dateUtils";
import { isValidNumberInput } from "../utils/validationUtils";
import DailyProgress from "../components/DailyProgress";
import {
    Button,
    Text,
    ListItem,
    FAB,
    makeStyles,
    useTheme,
    Divider,
    Input,
} from "@rneui/themed";
import DateTimePicker from "@react-native-community/datetimepicker";
import { addDays, subDays, parseISO, formatISO } from "date-fns";
import { Icon } from "@rneui/base";
import { SafeAreaView } from "react-native-safe-area-context";
import AddEntryModal from "../components/AddEntryModal";
import "react-native-get-random-values"; // Ensure this is imported before uuid
import Toast from "react-native-toast-message";
import { useFocusEffect } from '@react-navigation/native';
import { getFoodIconUrl } from "./../utils/iconUtils"; // Import the icon helper function

// Interface for daily goals structure
interface DailyGoals {
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
}

const DailyEntryScreen: React.FC = () => {
    // State variables
    const [dailyEntries, setDailyEntries] = useState<DailyEntry[]>([]);
    const [selectedDate, setSelectedDate] = useState<string>(getTodayDateString()); // YYYY-MM-DD format
    const [foods, setFoods] = useState<Food[]>([]); // Holds the permanent food list from storage
    const [selectedFood, setSelectedFood] = useState<Food | null>(null); // Food selected in the modal for single add/edit
    const [grams, setGrams] = useState(""); // Grams input value in the modal
    const [isOverlayVisible, setIsOverlayVisible] = useState(false); // Modal visibility
    const [showDatePicker, setShowDatePicker] = useState(false); // Date picker visibility
    const [dailyGoals, setDailyGoals] = useState<DailyGoals>({
        calories: 2000, protein: 50, carbs: 200, fat: 70, // Default goals
    });
    const [editingIndex, setEditingIndex] = useState<number | null>(null); // Index for *inline* editing (original index)
    const [tempGrams, setTempGrams] = useState(""); // Temporary grams for inline editing
    const [search, setSearch] = useState(""); // Search query in the modal
    const [editIndex, setEditIndex] = useState<number | null>(null); // Index for *modal* editing (reversed index)
    const [foodIcons, setFoodIcons] = useState<{ [foodName: string]: string | null }>({}); // Cache for food icons { foodName: url | null }

    const { theme } = useTheme();
    const styles = useStyles();

    // --- Data Loading and Icon Fetching ---

    // Function to load main data (entries, foods, settings) and pre-fetch icons
    const loadData = useCallback(async () => {
        try {
            const [loadedFoods, loadedEntries, loadedSettings] = await Promise.all([
                getFoods(),
                loadDailyEntries(),
                loadSettings(),
            ]);

            if (loadedSettings.dailyGoals) {
                setDailyGoals(loadedSettings.dailyGoals);
            }

            setFoods(loadedFoods);
            setDailyEntries(loadedEntries);

            // --- Icon Pre-fetching ---
            const iconsToFetch: { [foodName: string]: Promise<string | null> } = {};
            const allRelevantFoods: Food[] = [...loadedFoods]; // Start with all permanent foods

            // Add foods from the currently selected day's entries
            const currentOriginalEntry = loadedEntries.find((entry) => entry.date === selectedDate);
            if (currentOriginalEntry) {
                currentOriginalEntry.items.forEach(item => {
                    // Add food to the list if not already present based on name (more robust would be ID if available)
                    if (!allRelevantFoods.some(f => f.name === item.food.name)) {
                        allRelevantFoods.push(item.food);
                    }
                });
            }

            // Identify icons needing fetch (not already in state or null)
            for (const food of allRelevantFoods) {
                if (foodIcons[food.name] === undefined) { // Only fetch if status is unknown
                    iconsToFetch[food.name] = getFoodIconUrl(food.name).catch(err => {
                        console.warn(`Icon fetch failed for ${food.name}:`, err);
                        return null; // Return null on error
                    });
                }
            }

            // Execute fetches and update state
            if (Object.keys(iconsToFetch).length > 0) {
                const results = await Promise.all(Object.values(iconsToFetch));
                const newIcons: { [foodName: string]: string | null } = {};
                Object.keys(iconsToFetch).forEach((name, index) => {
                    newIcons[name] = results[index];
                });
                setFoodIcons(prevIcons => ({ ...prevIcons, ...newIcons }));
            }
            // --- End Icon Pre-fetching ---

        } catch (error) {
            console.error("Error loading data:", error);
            Alert.alert("Error", "Failed to load necessary data.");
            // Handle error state appropriately, maybe set empty arrays?
            setFoods([]);
            setDailyEntries([]);
        }
    }, [selectedDate]); // Depend on selectedDate to reload icons for that day

    // Load data when the screen comes into focus
    useFocusEffect(
        useCallback(() => {
            loadData();
            // Cleanup function when screen loses focus
            return () => {
                setSearch(''); // Clear search in modal
                setIsOverlayVisible(false); // Ensure modal is closed
                setEditingIndex(null); // Cancel any inline edit
                setTempGrams('');
            };
        }, [loadData]) // loadData callback already includes selectedDate dependency
    );

    // --- List and Index Management ---

    // Memoized reversed list for display purposes
    const currentEntryItems = useMemo(() => {
        const entry = dailyEntries.find((e) => e.date === selectedDate);
        // Create a shallow copy and reverse it for display
        return entry ? [...entry.items].reverse() : [];
    }, [dailyEntries, selectedDate]);

    // Helper to get the *original* index from the *reversed* display index
    const getOriginalIndex = (reversedIndex: number): number => {
         const entry = dailyEntries.find((e) => e.date === selectedDate);
         if (!entry || reversedIndex < 0 || reversedIndex >= entry.items.length) {
             console.error(`Could not find original index for reversedIndex: ${reversedIndex} on date: ${selectedDate}`);
             return -1; // Invalid index or entry not found
         }
         // Calculate original index: (total items - 1) - reversed index
         return entry.items.length - 1 - reversedIndex;
    }

    // --- State Update Helper ---

    // Central function to update dailyEntries state and save to AsyncStorage
    const updateAndSaveEntries = async (updatedEntries: DailyEntry[]) => {
        setDailyEntries(updatedEntries); // Update state immediately for UI responsiveness
        try {
            await saveDailyEntries(updatedEntries); // Persist changes
        } catch (error) {
            console.error("Failed to save updated entries:", error);
            Alert.alert("Save Error", "Could not save changes. Please try again.");
            // Optionally revert state here if save fails critically
            // loadData(); // Or reload data to ensure consistency
        }
    };

    // --- Inline Editing Handlers ---
    const handleStartEditing = (reversedIndex: number) => {
        const originalIndex = getOriginalIndex(reversedIndex);
        if (originalIndex === -1) return; // Safety check

        const currentEntry = dailyEntries.find((e) => e.date === selectedDate);
        if (!currentEntry) return;

        setEditingIndex(originalIndex); // Store the original index
        setTempGrams(String(currentEntry.items[originalIndex].grams));
    };

    const handleSaveInlineEdit = async () => {
        if (editingIndex === null) return; // No item being edited

        const trimmedGrams = tempGrams.trim();
        if (!isValidNumberInput(trimmedGrams) || parseFloat(trimmedGrams) <= 0) {
            Alert.alert(
                "Invalid Input",
                "Please enter a valid, positive number for grams."
            );
            return;
        }
        const newGramsValue = parseFloat(trimmedGrams);

        const currentEntry = dailyEntries.find((e) => e.date === selectedDate);
        // Double check entry and index validity before modifying
        if (!currentEntry || editingIndex < 0 || editingIndex >= currentEntry.items.length) {
            console.error("Error saving inline edit: Invalid entry or index.");
            setEditingIndex(null); // Reset editing state
            setTempGrams("");
            return;
        }

        // Create updated items array
        const updatedItems = currentEntry.items.map((item, index) => {
            if (index === editingIndex) {
                return { ...item, grams: newGramsValue };
            }
            return item;
        });

        // Create updated entries array
        const updatedEntries = dailyEntries.map((entry) =>
            entry.date === selectedDate ? { ...entry, items: updatedItems } : entry
        );

        await updateAndSaveEntries(updatedEntries);

        // Reset editing state
        setEditingIndex(null);
        setTempGrams("");
    };

    const handleCancelInlineEdit = () => {
        setEditingIndex(null);
        setTempGrams("");
    };
    // --- End Inline Editing ---

    // --- Add/Update/Remove Entry Handlers ---

    // Handles adding a single new entry OR updating an existing one (triggered from modal)
    const handleSingleEntryAction = async () => {
        // Validate selected food and grams input
        if (!selectedFood || !selectedFood.id) { // Check for food and id
             Alert.alert("Food Not Selected", "Please select a valid food item.");
             return;
        }
        const trimmedGrams = grams.trim();
        if (!isValidNumberInput(trimmedGrams) || parseFloat(trimmedGrams) <= 0) {
            Alert.alert(
                "Invalid Amount",
                "Please enter a valid positive number for grams."
            );
            return;
        }
        const numericGrams = parseFloat(trimmedGrams);

        // Prepare the new/updated entry item
        const entryItem: DailyEntryItem = {
            food: selectedFood, // Use the selected food object
            grams: numericGrams,
        };

        // Find if an entry already exists for the selected date
        const existingEntryIndex = dailyEntries.findIndex((entry) => entry.date === selectedDate);
        let updatedEntries: DailyEntry[];

        if (existingEntryIndex > -1) {
            // Entry for the date exists
            const existingEntry = dailyEntries[existingEntryIndex];
            let updatedItems;

            if (editIndex !== null) {
                // --- Editing an existing item via MODAL ---
                const originalEditIndex = getOriginalIndex(editIndex); // Convert reversed modal index to original
                if (originalEditIndex === -1) {
                    console.error("Error updating entry: Could not find original index for editing.");
                    setIsOverlayVisible(false); // Close modal on error
                    return; // Exit if index mapping failed
                }
                // Replace the item at the original index
                updatedItems = existingEntry.items.map((item, index) =>
                    index === originalEditIndex ? entryItem : item
                );
                console.log(`Updated item at original index ${originalEditIndex} on ${selectedDate}`);

            } else {
                // --- Adding a new single item ---
                updatedItems = [...existingEntry.items, entryItem]; // Add to the end of the original array
                console.log(`Added new item to ${selectedDate}`);
            }
            // Create the updated entry object
            const updatedEntry = { ...existingEntry, items: updatedItems };
            // Map over entries to replace the modified one
            updatedEntries = dailyEntries.map((entry) =>
                entry.date === selectedDate ? updatedEntry : entry
            );
        } else {
            // --- No entry for this date yet, create a new one ---
            console.log(`Creating new entry for ${selectedDate}`);
            const newDailyEntry: DailyEntry = {
                date: selectedDate,
                items: [entryItem], // Start with the new item
            };
            updatedEntries = [...dailyEntries, newDailyEntry];
             // Optional: Sort if date order matters after adding
             updatedEntries.sort((a, b) => a.date.localeCompare(b.date));
        }

        // Save the updated entries list
        await updateAndSaveEntries(updatedEntries);

        // --- Post-Action: Fetch Icon & Reset Modal State ---
        // Attempt to load icon for the newly added/edited food if not already loaded/failed
        if (foodIcons[selectedFood.name] === undefined) {
             try {
                 const iconUrl = await getFoodIconUrl(selectedFood.name);
                 setFoodIcons(prev => ({...prev, [selectedFood.name]: iconUrl})); // Store URL or null
             } catch {
                 setFoodIcons(prev => ({...prev, [selectedFood.name]: null})); // Mark as failed on error
             }
         }

        // Reset modal state and close it
        setSelectedFood(null);
        setGrams("");
        setEditIndex(null); // Clear modal edit index
        setIsOverlayVisible(false);
        setSearch(""); // Clear search
    };


    // --- NEW FUNCTION: Handle Adding Multiple Entries (from Quick Add) ---
    const handleAddMultipleEntries = async (entriesToAdd: { food: Food, grams: number }[]) => {
        if (!entriesToAdd || entriesToAdd.length === 0) {
            console.log("handleAddMultipleEntries called with no entries to add.");
            return; // Nothing to add
        }

        // Map the input to the DailyEntryItem format
        const newItems: DailyEntryItem[] = entriesToAdd.map(entry => ({
            food: entry.food, // Uses the temporary Food object created in the modal
            grams: entry.grams,
        }));

        console.log(`Attempting to add ${newItems.length} items from Quick Add to ${selectedDate}`);

        // Find if an entry already exists for the selected date
        const existingEntryIndex = dailyEntries.findIndex((entry) => entry.date === selectedDate);
        let updatedEntries: DailyEntry[];

        if (existingEntryIndex > -1) {
            // --- Add to existing entry ---
            const existingEntry = dailyEntries[existingEntryIndex];
            // Append the new items to the existing items array
            const updatedItems = [...existingEntry.items, ...newItems];
            const updatedEntry = { ...existingEntry, items: updatedItems };
            // Map over entries to replace the modified one
            updatedEntries = dailyEntries.map((entry, index) =>
                index === existingEntryIndex ? updatedEntry : entry
            );
            console.log(`Appended ${newItems.length} items to existing entry on ${selectedDate}`);
        } else {
            // --- Create new entry for this date ---
            console.log(`Creating new entry with ${newItems.length} items for ${selectedDate}`);
            const newDailyEntry: DailyEntry = {
                date: selectedDate,
                items: newItems, // Start with the array of new items
            };
            updatedEntries = [...dailyEntries, newDailyEntry];
             // Optional: Sort if date order matters after adding
             updatedEntries.sort((a, b) => a.date.localeCompare(b.date));
        }

        // Save the updated entries list
        await updateAndSaveEntries(updatedEntries);

        // --- Post-Action: Fetch Icons & Show Toast ---
        // Attempt to load icons for the newly added foods if not already known
        const iconsToLoad: { [foodName: string]: Promise<string | null> } = {};
        for (const item of newItems) {
            if (foodIcons[item.food.name] === undefined) { // Check if status is unknown
                 iconsToLoad[item.food.name] = getFoodIconUrl(item.food.name).catch(() => null);
            }
        }
         // Fetch and update icon state if needed
        if (Object.keys(iconsToLoad).length > 0) {
            const results = await Promise.all(Object.values(iconsToLoad));
            const newIcons: { [foodName: string]: string | null } = {};
            Object.keys(iconsToLoad).forEach((name, index) => {
                newIcons[name] = results[index];
            });
            setFoodIcons(prevIcons => ({ ...prevIcons, ...newIcons }));
        }

        // Show a success message
        Toast.show({
            type: 'success',
            text1: `${entriesToAdd.length} item(s) added`,
            position: 'bottom',
            visibilityTime: 2500,
        });

        // Modal closing is handled by the modal itself after calling this function
    };
    // --- End NEW FUNCTION ---

    // Selects a food in the modal (for single add/edit)
    const handleSelectFood = (item: Food | null) => {
        setSelectedFood(item);
        // If selecting a food for *adding* (not editing), maybe clear grams?
        // if (item && editIndex === null) {
        //      setGrams('');
        // }
    };

    // Removes an entry from the list (triggered by swipe)
    const handleRemoveEntry = async (reversedIndex: number) => {
        const originalIndex = getOriginalIndex(reversedIndex);
         if (originalIndex === -1) {
            console.error("Cannot remove entry: Invalid index.");
            return; // Safety check
         }

        const currentEntry = dailyEntries.find((e) => e.date === selectedDate);
        if (!currentEntry || originalIndex >= currentEntry.items.length) {
            console.error("Cannot remove entry: Entry not found or index out of bounds.");
            return; // Should not happen if index mapping is correct
        }

        // Get item details *before* filtering for the undo message
        const itemToRemove = currentEntry.items[originalIndex];

        // Filter out the item using the original index
        const updatedItems = currentEntry.items.filter((_, i) => i !== originalIndex);

        let finalEntries: DailyEntry[];

        // Check if removing the item leaves the entry for the day empty
        if (updatedItems.length === 0) {
            // If empty, remove the entire DailyEntry object for that date
            console.log(`Removing empty entry for ${selectedDate}`);
            finalEntries = dailyEntries.filter((entry) => entry.date !== selectedDate);
        } else {
            // Otherwise, just update the items array for the current date's entry
            console.log(`Removing item at original index ${originalIndex} from ${selectedDate}`);
            const updatedEntry = { ...currentEntry, items: updatedItems };
            finalEntries = dailyEntries.map((entry) =>
                entry.date === selectedDate ? updatedEntry : entry
            );
        }

        // Update state and save *before* showing the undo toast
        await updateAndSaveEntries(finalEntries);

        // Show toast with Undo option
        Toast.show({
            type: 'info', // Using info style for delete/undo action
            text1: `${itemToRemove.food.name} entry deleted`,
            text2: 'Tap here to undo',
            position: 'bottom',
            bottomOffset: 80, // Adjust offset if needed
            visibilityTime: 4000, // Give user time to react
            onPress: () => handleUndoRemoveEntry(itemToRemove, selectedDate, originalIndex), // Pass necessary info for undo
        });
    };


    // Restores a previously deleted entry (triggered by toast press)
    const handleUndoRemoveEntry = async (
        itemToRestore: DailyEntryItem,
        entryDate: string, // The date the item was removed from
        originalIndex: number // The original position it occupied
    ) => {
        console.log(`Undoing removal of ${itemToRestore.food.name} at index ${originalIndex} on ${entryDate}`);
        // Find the index of the DailyEntry object for the given date (it might have been removed)
        const existingEntryIndex = dailyEntries.findIndex(e => e.date === entryDate);

        let updatedEntries;

        if (existingEntryIndex > -1) {
            // --- Entry for the date still exists ---
            const entryToUpdate = dailyEntries[existingEntryIndex];
            const updatedItems = [...entryToUpdate.items];
            // Insert the item back at its original position
            updatedItems.splice(originalIndex, 0, itemToRestore);
            // Create the updated entry object
            const restoredEntry = { ...entryToUpdate, items: updatedItems };
            // Map over entries and replace the updated one
            updatedEntries = dailyEntries.map((entry, index) =>
                index === existingEntryIndex ? restoredEntry : entry
            );
        } else {
            // --- Entry was removed because it became empty, need to re-create it ---
            console.log(`Re-creating entry for ${entryDate} to restore item.`);
            const newEntry: DailyEntry = { date: entryDate, items: [itemToRestore] };
            // Add the newly created entry back to the list
            updatedEntries = [...dailyEntries, newEntry];
            // Optional: Sort entries by date if adding back causes order issues
            updatedEntries.sort((a, b) => a.date.localeCompare(b.date));
        }

        // Save the restored state
        await updateAndSaveEntries(updatedEntries);

        // Hide the "undo" toast and show a confirmation
        Toast.hide();
        Toast.show({ type: 'success', text1: 'Entry restored!', visibilityTime: 1500, position: 'bottom' });
    };
    // --- End Remove/Undo Logic ---

    // Updates the search query state in the modal
    const updateSearch = (search: string) => setSearch(search);

    // --- Modal Toggle Logic ---
    // Toggles the visibility of the Add/Edit modal
    const toggleOverlay = (
        itemToEdit: DailyEntryItem | null = null, // Item to populate modal for editing
        reversedIndex: number | null = null // The index *from the reversed list* if editing
    ) => {
        // Always reset modal state when opening/closing for ADD or explicitly closing
        setSelectedFood(null);
        setGrams("");
        setEditIndex(null);
        setSearch("");
        // Keep quick add state reset in modal's useEffect on !isVisible

        if (itemToEdit && reversedIndex !== null) {
            // --- Setup for MODAL EDIT ---
            console.log(`Opening modal to edit item at reversed index ${reversedIndex}`);
            setSelectedFood(itemToEdit.food);
            setGrams(String(itemToEdit.grams));
            setEditIndex(reversedIndex); // Store the reversed index for context within the modal
            setIsOverlayVisible(true); // Show modal after setting state
        } else {
            // --- Setup for ADD or Closing ---
            console.log("Toggling modal for Add or Closing.");
            setIsOverlayVisible(!isOverlayVisible); // Toggle visibility
        }
    };


    // Handles the "Edit" action from the swipe menu, triggering modal opening
    const handleEditEntryViaModal = (item: DailyEntryItem, reversedIndex: number) => {
        toggleOverlay(item, reversedIndex); // Open modal populated for editing
    };
    // --- End Modal Toggle ---

    // --- Date Navigation Handlers ---
    const handleDateChange = (event: any, selectedDateValue?: Date) => {
        const isAndroidDismiss = Platform.OS === 'android' && event.type === 'dismissed';
        setShowDatePicker(Platform.OS === 'ios'); // Keep iOS picker open until done/cancel

        if (!isAndroidDismiss && event.type === "set" && selectedDateValue) {
            // Format the selected date to YYYY-MM-DD string for consistency
            const formattedDate = formatISO(selectedDateValue, { representation: 'date' });
            // Only update state if the date actually changed
            if (formattedDate !== selectedDate) {
                console.log(`Date changed to: ${formattedDate}`);
                setSelectedDate(formattedDate);
                // Data reloading (including icons) is handled by useFocusEffect/loadData dependency
            }
        } else if (Platform.OS === 'android') {
             setShowDatePicker(false); // Close Android picker on dismiss/cancel
        }
    };


    const handlePreviousDay = () => {
        try {
            const currentDate = parseISO(selectedDate); // Parse the YYYY-MM-DD string
            const newDate = subDays(currentDate, 1);
            setSelectedDate(formatISO(newDate, { representation: 'date' }));
        } catch (e) {
             console.error("Error parsing date for previous day:", selectedDate, e);
        }
    }

    const handleNextDay = () => {
        try {
            const currentDate = parseISO(selectedDate);
            const newDate = addDays(currentDate, 1);
            setSelectedDate(formatISO(newDate, { representation: 'date' }));
        } catch (e) {
            console.error("Error parsing date for next day:", selectedDate, e);
        }
    }
    // --- End Date Navigation ---

    // --- Totals Calculation ---
     const calculateTotals = useMemo(() => {
        const currentOriginalEntry = dailyEntries.find((entry) => entry.date === selectedDate);
        let [totalCalories, totalProtein, totalCarbs, totalFat] = [0, 0, 0, 0];

        if (currentOriginalEntry) {
            currentOriginalEntry.items.forEach((item) => {
                // Ensure food object and properties exist before calculation
                if (item.food && typeof item.food.calories === 'number') {
                    totalCalories += (item.food.calories / 100) * item.grams;
                }
                if (item.food && typeof item.food.protein === 'number') {
                    totalProtein += (item.food.protein / 100) * item.grams;
                }
                if (item.food && typeof item.food.carbs === 'number') {
                    totalCarbs += (item.food.carbs / 100) * item.grams;
                }
                if (item.food && typeof item.food.fat === 'number') {
                    totalFat += (item.food.fat / 100) * item.grams;
                }
            });
        }

        // Return rounded totals
        return {
            totalCalories: Math.round(totalCalories),
            totalProtein: Math.round(totalProtein),
            totalCarbs: Math.round(totalCarbs),
            totalFat: Math.round(totalFat),
        };
    }, [dailyEntries, selectedDate]); // Recalculate only when entries or date change

    // --- Render ---
    return (
        <SafeAreaView style={styles.container} edges={['top', 'left', 'right']}>
            {/* Date Navigation Header */}
            <View style={styles.dateNavigation}>
                <Button
                    type="clear"
                    onPress={handlePreviousDay}
                    icon={
                        <Icon name="chevron-back-outline" type="ionicon" color={theme.colors.text} size={28}/>
                    }
                    buttonStyle={styles.navButton}
                />
                {/* Make the date text pressable to show the picker */}
                <TouchableOpacity onPress={() => setShowDatePicker(true)}>
                    <Text h4 style={styles.dateText}>
                        {formatDateReadable(selectedDate)}
                    </Text>
                </TouchableOpacity>
                <Button
                    type="clear"
                    onPress={handleNextDay}
                    icon={
                        <Icon name="chevron-forward-outline" type="ionicon" color={theme.colors.text} size={28}/>
                    }
                     buttonStyle={styles.navButton}
                />
            </View>

            {/* Date Picker Component */}
            {showDatePicker && (
                <DateTimePicker
                    value={parseISO(selectedDate)} // Current value needs to be a Date object
                    mode="date"
                    display={Platform.OS === 'ios' ? 'spinner' : 'default'}
                    onChange={handleDateChange}
                    // Optional: Set max date, etc.
                    // maximumDate={new Date()}
                />
            )}

            {/* Daily Progress Bars */}
            <DailyProgress
                calories={calculateTotals.totalCalories}
                protein={calculateTotals.totalProtein}
                carbs={calculateTotals.totalCarbs}
                fat={calculateTotals.totalFat}
                goals={dailyGoals} // Pass the loaded daily goals
            />
            <Divider style={styles.divider} />

            <Text h4 style={[styles.sectionTitle, { color: theme.colors.text }]}>
                Today's Entries
            </Text>

            {/* Entries List - Renders the reversed list */}
            <FlatList
                // Use the memoized reversed list for display
                data={currentEntryItems}
                // Key needs to be unique and stable across renders/edits
                keyExtractor={(item, index) => `entry-${item.food.id}-${index}-${item.grams}`}
                renderItem={({ item, index: reversedIndex }) => {
                    // Determine if the current item is being inline-edited
                    const originalIndex = getOriginalIndex(reversedIndex);
                    const isInlineEditing = editingIndex === originalIndex;

                     // Get icon status and URL
                     const iconUrl = foodIcons[item.food.name]; // Could be string, null, or undefined
                     const isLoadingIcon = iconUrl === undefined; // True if fetch hasn't completed

                    return (
                        <ListItem.Swipeable
                            bottomDivider
                            leftContent={(reset) => (
                                <Button
                                    title="Edit"
                                    // Pass reversed index to modal edit handler
                                    onPress={() => {
                                        handleEditEntryViaModal(item, reversedIndex);
                                        reset(); // Close swipe menu
                                    }}
                                    icon={{ name: "edit", color: "white" }}
                                    buttonStyle={{ minHeight: "100%", backgroundColor: theme.colors.warning }}
                                />
                            )}
                            rightContent={(reset) => (
                                <Button
                                    title="Delete"
                                    // Pass reversed index to remove handler
                                    onPress={() => {
                                        handleRemoveEntry(reversedIndex);
                                        reset(); // Close swipe menu
                                    }}
                                    icon={{ name: "delete", color: "white" }}
                                    buttonStyle={{ minHeight: "100%", backgroundColor: theme.colors.error }}
                                />
                            )}
                            containerStyle={{ backgroundColor: theme.colors.background }}
                        >
                            {/* Food Icon - Conditional rendering based on loading/success/failure */}
                            {isLoadingIcon ? (
                                <ActivityIndicator size="small" color={theme.colors.grey3} style={styles.foodIcon} />
                            ) : iconUrl ? (
                                <Image
                                    source={{ uri: iconUrl }}
                                    style={styles.foodIcon}
                                    // Add onError to mark as failed if image load fails *after* successful fetch
                                    onError={() => {
                                         console.warn(`Image component failed to load: ${iconUrl}`);
                                         // Update state to null only if it wasn't already null
                                         if (foodIcons[item.food.name] !== null) {
                                             setFoodIcons(prev => ({ ...prev, [item.food.name]: null }));
                                         }
                                    }}
                                />
                            ) : (
                                // Icon fetch completed but resulted in null (no icon found or fetch error)
                                <Icon
                                    name="restaurant-outline" // Default placeholder icon
                                    type="ionicon"
                                    color={theme.colors.grey3}
                                    containerStyle={styles.defaultIconContainer} // Use container for consistent sizing
                                />
                            )}
                             {/* List Item Content (Title and Subtitle/Inline Edit) */}
                            <ListItem.Content>
                                <ListItem.Title style={styles.listItemTitle}>
                                    {item.food.name}
                                </ListItem.Title>
                                {isInlineEditing ? (
                                    // --- Inline Edit View ---
                                    <View style={styles.inlineEditContainer}>
                                        <Input
                                            value={tempGrams}
                                            onChangeText={setTempGrams}
                                            keyboardType="numeric"
                                            containerStyle={styles.inlineInputContainer}
                                            inputContainerStyle={styles.inlineInputInnerContainer}
                                            inputStyle={styles.inlineInput}
                                            autoFocus // Focus when editing starts
                                            selectTextOnFocus // Select text for easy replacement
                                            maxLength={6} // Limit input length
                                            onSubmitEditing={handleSaveInlineEdit} // Save on keyboard submit
                                            onBlur={handleSaveInlineEdit} // Also save on blur (losing focus) - check if needed
                                        />
                                        <Text style={styles.inlineInputSuffix}>g</Text>
                                        {/* Save Button */}
                                        <Button
                                            type="clear"
                                            onPress={handleSaveInlineEdit}
                                            icon={<Icon name="checkmark-circle" type="ionicon" color={theme.colors.success} size={24} />}
                                            containerStyle={styles.inlineButtonContainer}
                                        />
                                        {/* Cancel Button */}
                                        <Button
                                            type="clear"
                                            onPress={handleCancelInlineEdit}
                                            icon={<Icon name="close-circle" type="ionicon" color={theme.colors.error} size={24} />}
                                            containerStyle={styles.inlineButtonContainer}
                                        />
                                    </View>
                                ) : (
                                    // --- Display View ---
                                    <ListItem.Subtitle
                                        style={styles.listItemSubtitle}
                                        // Trigger inline editing on press
                                        onPress={() => handleStartEditing(reversedIndex)}
                                    >
                                        {/* Show grams and calculated calories */}
                                        {`${item.grams}g • ${Math.round((item.food.calories / 100) * item.grams)} kcal`}
                                    </ListItem.Subtitle>
                                )}
                            </ListItem.Content>
                            {/* Optional: Chevron shown only in display mode */}
                           {!isInlineEditing && <ListItem.Chevron color={theme.colors.grey3} />}
                        </ListItem.Swipeable>
                    )
                }}
                // Message shown when the list is empty
                ListEmptyComponent={
                    <View style={styles.emptyListContainer}>
                        <Icon name="leaf-outline" type="ionicon" size={40} color={theme.colors.grey3} />
                        <Text style={styles.emptyListText}>No entries for this day yet.</Text>
                        <Text style={styles.emptyListSubText}>Tap the '+' button to add food.</Text>
                    </View>
                }
                // Optimization props for FlatList
                initialNumToRender={10}
                maxToRenderPerBatch={5}
                windowSize={11}
            />

            {/* FAB (Floating Action Button) to add new entry */}
            <FAB
                icon={<Icon name="add" color="white" />}
                color={theme.colors.primary}
                onPress={() => toggleOverlay()} // Opens modal in 'add' mode
                placement="right"
                size="large"
                style={styles.fab} // Use style for positioning
            />

            {/* Add/Edit Entry Modal Component */}
            <AddEntryModal
                isVisible={isOverlayVisible}
                toggleOverlay={toggleOverlay}
                selectedFood={selectedFood}
                grams={grams}
                setGrams={setGrams}
                foods={foods} // Pass the permanent food list for searching
                handleAddEntry={handleSingleEntryAction} // Handler for single add/update
                handleAddMultipleEntries={handleAddMultipleEntries} // Handler for quick add confirm
                handleSelectFood={handleSelectFood} // Handler for selecting food in modal search
                search={search}
                updateSearch={updateSearch}
                isEditMode={editIndex !== null} // Pass whether modal is in edit mode
                // initialGrams prop removed as it was redundant
            />
        </SafeAreaView>
    );
};

// Styles definition using makeStyles
const useStyles = makeStyles((theme) => ({
    container: {
        flex: 1,
        backgroundColor: theme.colors.background,
    },
    dateNavigation: {
        flexDirection: "row",
        alignItems: "center",
        justifyContent: "space-between",
        paddingVertical: 8,
        paddingHorizontal: 5, // Reduced horizontal padding for buttons
        borderBottomWidth: 1,
        borderBottomColor: theme.colors.divider,
    },
    navButton: { // Style for the arrow buttons
        paddingHorizontal: 8, // Give arrows some horizontal tap space
    },
    dateText: {
        fontSize: 18,
        fontWeight: "bold",
        color: theme.colors.text,
        textAlign: 'center', // Center the date text
        paddingVertical: 5, // Add vertical padding for touchability
    },
    foodIcon: { // Consistent style for list item icons
        width: 40,
        height: 40,
        marginRight: 15,
        borderRadius: 20, // Circular
        resizeMode: "contain", // Ensure icon fits well
        backgroundColor: theme.colors.grey5, // Background shown while loading/if error
        alignItems: 'center', // Center activity indicator if shown
        justifyContent: 'center', // Center activity indicator if shown
        overflow: 'hidden', // Hide overflow for clean look
    },
    defaultIconContainer: { // Container used when icon fetch fails or returns null
        width: 40,
        height: 40,
        marginRight: 15,
        borderRadius: 20,
        backgroundColor: theme.colors.grey5,
        alignItems: 'center',
        justifyContent: 'center',
    },
    listItemTitle: {
        color: theme.colors.text,
        fontWeight: 'bold',
        fontSize: 16, // Slightly larger title
    },
    listItemSubtitle: {
        color: theme.colors.grey1, // Subtitle color
        fontSize: 14,
        marginTop: 3, // Space below title
    },
    divider: {
        marginVertical: 10,
    },
    sectionTitle: {
        marginTop: 15, // Increased top margin
        marginBottom: 8,
        paddingHorizontal: 15,
        fontWeight: '600', // Slightly less bold than h3 default
        fontSize: 18, // Adjust font size
        color: theme.colors.grey1, // Subtler title color
    },
    fab: { // Style for the FAB component itself
        position: 'absolute', // Keep absolute positioning
        margin: 16, // Standard margin
        right: 10, // Adjust position slightly
        bottom: 10, // Adjust position slightly
    },
     emptyListContainer: { // Styling for the empty list message
        flex: 1, // Allow it to take space if needed
        alignItems: 'center',
        justifyContent: 'center',
        marginTop: 50,
        paddingHorizontal: 30, // More padding
    },
    emptyListText: {
        fontSize: 17, // Slightly larger text
        color: theme.colors.grey2,
        textAlign: 'center',
        marginTop: 10, // Space below icon
    },
     emptyListSubText: {
        fontSize: 14,
        color: theme.colors.grey3,
        textAlign: 'center',
        marginTop: 8,
    },
    // --- Inline Editing Styles ---
    inlineEditContainer: { // Container for the input and buttons during inline edit
        flexDirection: "row",
        alignItems: "center",
        marginTop: 5, // Space below the title
        width: '100%', // Take full width of content area
    },
    inlineInputContainer: { // RNE Input component's outer container
        // Removed flex: 1 to use fixed width
        width: 80, // Fixed width for the input area
        height: 38, // Match button height approximately
        paddingHorizontal: 0, // Remove default padding
    },
    inlineInputInnerContainer: { // RNE Input component's inner container (handles underline)
        borderBottomWidth: 1,
        borderColor: theme.colors.primary,
        paddingHorizontal: 6,
        height: '100%',
        paddingVertical: 0, // Remove vertical padding if any
        justifyContent: 'center', // Center text vertically
    },
    inlineInput: { // Style for the text *inside* the inline input
        fontSize: 14, // Match subtitle size
        color: theme.colors.text, // Use theme text color
        textAlign: 'right', // Align number to the right
        paddingVertical: 0, // No extra vertical padding
    },
    inlineInputSuffix: { // Style for the "g" text next to the input
         fontSize: 14,
         color: theme.colors.grey1,
         marginLeft: 4,
         marginRight: 10, // Space before buttons
    },
     inlineButtonContainer: { // Container for the checkmark/cross buttons
        padding: 0, // Remove padding
        marginLeft: 0, // Remove default margins if any
        minWidth: 30, // Ensure decent tap area
        justifyContent: 'center',
        alignItems: 'center',
    },
}));

export default DailyEntryScreen;
---------- END DailyEntryScreen.tsx ----------


---------- FoodListScreen.tsx ----------
// FoodListScreen.tsx (Corrected)

import React, { useState, useEffect, useCallback } from "react";
import { View, FlatList, Alert, Platform, Image } from "react-native";
import {
    createFood,
    getFoods,
    updateFood,
    deleteFood,
} from "../services/foodService";
import { Food } from "../types/food";
import { isValidNumberInput, isNotEmpty } from "../utils/validationUtils";
import FoodItem from "../components/FoodItem";
import { Button, SearchBar, useTheme, makeStyles } from "@rneui/themed";
import { FAB } from "@rneui/base";
import { SafeAreaView } from "react-native-safe-area-context";
import AddFoodModal from "../components/AddFoodModal";
import Toast from "react-native-toast-message";
import { useFocusEffect } from "@react-navigation/native";
import { Icon } from "@rneui/base";
import { getFoodIconUrl } from "./../utils/iconUtils";

interface FoodListScreenProps {
    onFoodChange?: () => void;
}

const FoodListScreen: React.FC<FoodListScreenProps> = ({ onFoodChange }) => {
    const [foods, setFoods] = useState<Food[]>([]);
    const [foodIcons, setFoodIcons] = useState<{ [foodName: string]: string | null }>({});
    const [isOverlayVisible, setIsOverlayVisible] = useState(false);
    const [search, setSearch] = useState("");
    const [newFood, setNewFood] = useState<Omit<Food, "id">>({
        name: "",
        calories: 0,
        protein: 0,
        carbs: 0,
        fat: 0,
    });
    const [editFood, setEditFood] = useState<Food | null>(null);
    const [errors, setErrors] = useState<{ [key: string]: string }>({});
    const { theme } = useTheme();
    const styles = useStyles();

    const loadFoodData = useCallback(async () => {
        const loadedFoods = await getFoods();
        setFoods(loadedFoods);
    }, []);

    useFocusEffect(
        useCallback(() => {
            loadFoodData();
        }, [loadFoodData])
    );
    useEffect(() => {
        const loadIcons = async () => {
            const icons: { [foodName: string]: string | null } = {};
            for (const food of foods) {
                const iconUrl = await getFoodIconUrl(food.name);
                icons[food.name] = iconUrl;
            }
            setFoodIcons(icons);
        };

        loadIcons();
    }, [foods]);

    const validateFood = (food: Omit<Food, "id">) => {
        const newErrors: { [key: string]: string } = {};
        if (!isNotEmpty(food.name)) newErrors.name = "Name is required";
        if (!isValidNumberInput(String(food.calories)))
            newErrors.calories = "Invalid input";
        if (!isValidNumberInput(String(food.protein)))
            newErrors.protein = "Invalid input";
        if (!isValidNumberInput(String(food.carbs)))
            newErrors.carbs = "Invalid input";
        if (!isValidNumberInput(String(food.fat)))
            newErrors.fat = "Invalid input";

        return Object.keys(newErrors).length === 0 ? null : newErrors;
    };

    const handleCreateFood = async () => {
        const validationErrors = validateFood(newFood);
        if (validationErrors) {
            setErrors(validationErrors);
            return;
        }
        setErrors({});
        try {
            const createdFood = await createFood(newFood);
            setFoods([...foods, createdFood]);
            setNewFood({
                name: "",
                calories: 0,
                protein: 0,
                carbs: 0,
                fat: 0,
            });
            setIsOverlayVisible(false);
            onFoodChange && onFoodChange();
        } catch (error: any) {
            Alert.alert("Error", error.message || "Failed to create food.");
        }
    };

    const handleUpdateFood = async () => {
        if (!editFood) return;
        const validationErrors = validateFood(editFood);
        if (validationErrors) {
            setErrors(validationErrors);
            return;
        }
        setErrors({});
        try {
            const updated = await updateFood(editFood);
            setFoods(foods.map((f) => (f.id === updated.id ? updated : f)));
            setEditFood(null);
            setIsOverlayVisible(false);
            onFoodChange && onFoodChange();
        } catch (error: any) {
            Alert.alert("Error", error.message || "Failed to update food.");
        }
    };

    const handleDeleteFood = async (foodId: string) => {
        const foodToDelete = foods.find((f) => f.id === foodId);
        if (!foodToDelete) return;
        setFoods(foods.filter((f) => f.id !== foodId));

        try {
            await deleteFood(foodId);
            Toast.show({
                type: "success",
                text1: `${foodToDelete.name} deleted`,
                text2: "Tap to undo",
                position: "bottom",
                bottomOffset: 80,
                onPress: () => handleUndoDeleteFood(foodToDelete),
                visibilityTime: 3000,
            });
            onFoodChange && onFoodChange();
        } catch (error) {
            setFoods((prevFoods) => [...prevFoods, foodToDelete]);
            Alert.alert("Error", "Failed to delete food.");
        }
    };

    const handleUndoDeleteFood = (food: Food) => {
        setFoods((prevFoods) => [...prevFoods, food]);
        Toast.hide();
        onFoodChange && onFoodChange();
    };

    const toggleOverlay = (food?: Food) => {
        if (food) {
            setEditFood(food);
        } else {
            setEditFood(null);
            setNewFood({
                name: "",
                calories: 0,
                protein: 0,
                carbs: 0,
                fat: 0,
            });
        }
        setErrors({});
        setIsOverlayVisible(!isOverlayVisible);
    };

    const updateSearch = (search: string) => setSearch(search);

    const filteredFoods = foods.filter((food) =>
        food.name.toLowerCase().includes(search.toLowerCase())
    );

   const handleInputChange = (
        key: keyof Omit<Food, "id">,
        value: string,
        isEdit: boolean
    ) => {
        if (isEdit) {
            setEditFood((prevEditFood) => {
                if (!prevEditFood) return null; // Or some default empty Food object
                return {
                    ...prevEditFood,
                    [key]: key === "name" ? value : value === "" ? 0 : parseFloat(value),
                };
            });
        } else {
            setNewFood((prevNewFood) => ({
                ...prevNewFood,
                [key]: key === "name" ? value : value === "" ? 0 : parseFloat(value),
            }));
        }
    };

    return (
        <SafeAreaView style={styles.container}>
            <SearchBar
                placeholder="Search Foods..."
                onChangeText={updateSearch}
                value={search}
                platform={Platform.OS === "ios" ? "ios" : "android"}
                containerStyle={styles.searchBarContainer}
                inputContainerStyle={[
                    styles.searchBarInputContainer,
                    { backgroundColor: theme.colors.grey5 },
                ]}
                inputStyle={{ color: theme.colors.text }}
            />
            <FlatList
                data={filteredFoods}
                keyExtractor={(item) => item.id}
                renderItem={({ item }) => (
                    <FoodItem
                        food={item}
                        onEdit={toggleOverlay}
                        onDelete={handleDeleteFood}
                        onUndoDelete={handleUndoDeleteFood}
                        foodIconUrl={foodIcons[item.name]}
                    />
                )}
            />

            <FAB
                icon={{ name: "add", color: "white" }}
                color={theme.colors.primary}
                onPress={() => toggleOverlay()}
                placement="right"
                title=""
                style={{ marginBottom: 10, marginRight: 8 }}
            />

            <AddFoodModal
                isVisible={isOverlayVisible}
                toggleOverlay={toggleOverlay}
                newFood={newFood}
                editFood={editFood}
                errors={errors}
                handleInputChange={handleInputChange}
                handleCreateFood={handleCreateFood}
                handleUpdateFood={handleUpdateFood}
                validateFood={validateFood}
                setErrors={setErrors}
            />
        </SafeAreaView>
    );
};

const useStyles = makeStyles((theme) => ({
    container: {
        flex: 1,
        backgroundColor: theme.colors.background,
    },
    searchBarContainer: {
        backgroundColor: "transparent",
        borderBottomColor: "transparent",
        borderTopColor: "transparent",
        marginBottom: 10,
        padding: 0,
    },
    searchBarInputContainer: {
        borderRadius: 10,
    },
      foodIcon: {
      width: 30,
      height: 30,
      marginRight: 10,
      borderRadius: 15,
      resizeMode: "stretch", // Or 'cover', or 'stretch', see below
    },
}));

export default FoodListScreen;
---------- END FoodListScreen.tsx ----------


---------- SettingsScreen.tsx ----------
// SettingsScreen.tsx
import React, { useState, useEffect, useCallback } from "react";
import { View, ScrollView, Alert } from "react-native";
import { Text, makeStyles } from "@rneui/themed";
import DailyGoalsInput from "../components/DailyGoalsInput";
import DataManagementButtons from "../components/DataManagementButtons";
import ThemeSwitch from "../components/ThemeSwitch";
import StatisticsChart from "../components/StatisticsChart";
import { loadSettings, saveSettings, loadDailyEntries } from "../services/storageService";
import { Settings, Statistics, MacroType, MacroData } from "../types/settings";
import { parseISO, isBefore, formatISO } from "date-fns";
import { formatDate, formatDateReadable } from "../utils/dateUtils"; // Use custom formatDate
import { useTheme } from "@rneui/themed";
import { DailyEntry } from "../types/dailyEntry";
import { useFocusEffect } from "@react-navigation/native";

interface SettingsScreenProps {
  onThemeChange: (theme: "light" | "dark" | "system") => void;
  onDataOperation: () => void;
}

const SettingsScreen: React.FC<SettingsScreenProps> = ({ onThemeChange, onDataOperation }) => {
  const [settings, setSettings] = useState<Settings>({
    theme: "system",
    dailyGoals: {
      calories: 2000,
      protein: 50,
      carbs: 200,
      fat: 70,
    },
  });

  const [statistics, setStatistics] = useState<Statistics>({
    calories: [],
    protein: [],
    carbs: [],
    fat: [],
  });
  // Removed settingsHistory
  const [chartUpdateKey, setChartUpdateKey] = useState(0);
  const [dataChangeCounter, setDataChangeCounter] = useState(0);

  const { theme } = useTheme();
  const styles = useStyles();

  const loadInitialSettings = useCallback(async () => {
    const loadedSettings = await loadSettings();

    setSettings((prevSettings) => ({
      ...prevSettings,
      ...loadedSettings,
      dailyGoals: {
        ...prevSettings.dailyGoals,
        ...(loadedSettings?.dailyGoals || {}),
      },
    }));
  }, []);

  useEffect(() => {
    loadInitialSettings();
  }, [loadInitialSettings]);


  const handleGoalChange = useCallback(async (goalType: MacroType, value: string) => {
    const numericValue = parseFloat(value) || 0;

    setSettings((prevSettings) => {
      const updatedGoals = { ...prevSettings.dailyGoals, [goalType]: numericValue };
      const updatedSettings: Settings = {
        ...prevSettings,
        dailyGoals: updatedGoals,
      };

      // Removed settings history update

      (async () => {
        await saveSettings(updatedSettings); // Simplified save
        setChartUpdateKey((prevKey) => prevKey + 1);
      })();

      return updatedSettings;
    });
    }, []); // Removed settingsHistory dependency


    const getStatisticsData = useCallback(
      (
        dailyEntries: DailyEntry[],
        macro: MacroType,
      ): MacroData[][] => { // Return type annotation
        const intakeData: MacroData[] = [];
        const goalData: MacroData[] = []; // For calories goal

          dailyEntries.forEach((entry) => {
              const entryDate = parseISO(entry.date);
            // Use current settings for all entries
            const relevantGoals = settings.dailyGoals;

            const intakeValue = entry.items.reduce(
              (total, item) => total + (item.food[macro] / 100) * item.grams,
              0
            );
            const goalValue = relevantGoals[macro] ?? 0;

            // Add to intake data (for all macros)
            intakeData.push({ x: entryDate.getTime(), y: intakeValue });

            // Add to goal data (only for calories)
            if (macro === "calories") {
              goalData.push({ x: entryDate.getTime(), y: goalValue });
            }
          });

          // Sort both arrays by date
        intakeData.sort((a, b) => a.x - b.x);
          if (macro === "calories") {
              goalData.sort((a,b) => a.x - b.x);
          }

        // Return as an array of arrays
        if (macro === "calories") {
          return [intakeData, goalData]; // Two series: intake and goal
        } else {
          return [intakeData]; // One series: intake only
        }
      },
      [settings.dailyGoals] // Only settings.dailyGoals as dependency
    );


  const updateStatistics = useCallback(async () => {
    const loadedEntries = await loadDailyEntries();

    // Calculate statistics for each macro
    const updatedStats: Statistics = {
      calories: getStatisticsData(loadedEntries, "calories"),
      protein: getStatisticsData(loadedEntries, "protein"),
      carbs: getStatisticsData(loadedEntries, "carbs"),
      fat: getStatisticsData(loadedEntries, "fat"),
    };

    setStatistics(updatedStats);
  }, [getStatisticsData]);

   useFocusEffect(
    useCallback(() => {
      (async () => {
        await loadInitialSettings();
        await updateStatistics();
      })();
    }, [loadInitialSettings, updateStatistics])
  );

  useEffect(() => {
    (async () => {
      if (dataChangeCounter > 0) {
        await updateStatistics();
        setChartUpdateKey((prevKey) => prevKey + 1);
      }
    })();
  }, [dataChangeCounter, updateStatistics]);

  const handleDataOperation = useCallback(() => {
    setDataChangeCounter((prevCounter) => prevCounter + 1);
  }, []);

  return (
    <ScrollView style={styles.container}>
      <Text h3 style={[styles.sectionTitle, { color: theme.colors.text }]}>General</Text>
      <ThemeSwitch currentTheme={settings.theme} onToggle={onThemeChange} />

      <Text h3 style={[styles.sectionTitle, { color: theme.colors.text }]}>Daily Goals</Text>
      <DailyGoalsInput dailyGoals={settings.dailyGoals} onGoalChange={handleGoalChange} />

      <Text h3 style={[styles.sectionTitle, { color: theme.colors.text }]}>Statistics</Text>
      <StatisticsChart statistics={statistics} key={chartUpdateKey} />

      <Text h3 style={[styles.sectionTitle, { color: theme.colors.text }]}>Data Management</Text>
      <DataManagementButtons onDataOperation={handleDataOperation} />
    </ScrollView>
  );
};
const useStyles = makeStyles((theme) => ({
  container: {
    flex: 1,
    padding: 10,
    backgroundColor: theme.colors.background,
  },
  sectionTitle: {
    marginTop: 20,
    marginBottom: 10,
  },
  button: {
    marginBottom: 10,
  },
}));

export default SettingsScreen;

// components/StatisticsChart.tsx (No changes needed here)
// Remains the same as in the previous, corrected version.  The key changes were in SettingsScreen.
---------- END SettingsScreen.tsx ----------


---------- foodService.ts ----------
// services/foodService.ts
import { Food } from '../types/food';
import { saveFoods, loadFoods } from './storageService';
import 'react-native-get-random-values';
import { v4 as uuidv4 } from 'uuid';

export const createFood = async (foodData: Omit<Food, 'id'>): Promise<Food> => {
  const newFood: Food = {
    id: uuidv4(),
    ...foodData,
  };
  const foods = await loadFoods();
  foods.push(newFood);
  await saveFoods(foods);
  return newFood;
};

export const getFoods = async (): Promise<Food[]> => {
  return loadFoods();
};

export const updateFood = async (updatedFood: Food): Promise<Food> => {
  const foods = await loadFoods();
  const index = foods.findIndex((f) => f.id === updatedFood.id);
  if (index === -1) {
    throw new Error('Food not found'); // Throw an error if not found
  }
  foods[index] = updatedFood;
  await saveFoods(foods);
  return updatedFood;
};

export const deleteFood = async (foodId: string): Promise<void> => {
  const foods = await loadFoods();
  const filteredFoods = foods.filter((f) => f.id !== foodId);
  await saveFoods(filteredFoods);
};
---------- END foodService.ts ----------


---------- storageService.ts ----------
// services/storageService.ts (Modified for Timestamps)
import AsyncStorage from '@react-native-async-storage/async-storage';
import { DailyEntry } from '../types/dailyEntry';
import { Food } from '../types/food';
import { Settings } from '../types/settings';
import { formatISO, parseISO } from 'date-fns';


const DAILY_ENTRIES_KEY = 'dailyEntries';
const FOODS_KEY = 'foods';
const SETTINGS_KEY = 'settings';
const RECENT_FOODS = 'recentFoods';


export const saveDailyEntries = async (entries: DailyEntry[]): Promise<void> => {
  try {
    await AsyncStorage.setItem(DAILY_ENTRIES_KEY, JSON.stringify(entries));
  } catch (error) {
    console.error('Error saving daily entries:', error);
    throw error;
  }
};

export const loadDailyEntries = async (): Promise<DailyEntry[]> => {
  try {
    const entriesJson = await AsyncStorage.getItem(DAILY_ENTRIES_KEY);
    return entriesJson ? JSON.parse(entriesJson) : [];
  } catch (error) {
    console.error('Error loading daily entries:', error);
    return [];
  }
};

export const saveFoods = async (foods: Food[]): Promise<void> => {
  try {
    await AsyncStorage.setItem(FOODS_KEY, JSON.stringify(foods));
  } catch (error) {
    console.error('Error saving foods:', error);
    throw error; // Re-throw the error
  }
};

export const loadFoods = async (): Promise<Food[]> => {
  try {
    const foodsJson = await AsyncStorage.getItem(FOODS_KEY);
    return foodsJson ? JSON.parse(foodsJson) : [];
  } catch (error) {
    console.error('Error loading foods:', error);
    return []; // Return an empty array on error
  }
};



export const saveSettings = async (settings: Settings): Promise<void> => {
  try {
    await AsyncStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
  } catch (error) {
    console.error('Error saving settings:', error);
    throw error;
  }
};

export const loadSettings = async (): Promise<Settings> => {
  try {
    const settingsJson = await AsyncStorage.getItem(SETTINGS_KEY);
    const loadedSettings = settingsJson ? JSON.parse(settingsJson) : {};

    // Apply defaults and ensure structure
    const defaultSettings: Settings = {
      theme: 'system',
      dailyGoals: { calories: 2000, protein: 50, carbs: 200, fat: 70 },
      settingsHistory: [] // Ensure settingsHistory exists
    };


    return {
      ...defaultSettings, // Start with defaults
        ...loadedSettings, // Override with loaded values
        dailyGoals: {
          ...defaultSettings.dailyGoals,  //ensure no fields missing from daily goals
            ...(loadedSettings.dailyGoals || {}) // And override *those* with any loaded dailyGoals
        }
    }

  } catch (error: any) {
    console.error('Error loading settings:', error);

    // *** KEY CHANGE: Handle "Row too big" error ***
    if (error.message.includes('Row too big')) {
      console.warn('Detected oversized settings data. Clearing settings.');
      try {
        await AsyncStorage.removeItem(SETTINGS_KEY); // Clear the oversized data
      } catch (clearError) {
        console.error('Error clearing oversized settings:', clearError);
        // You might want to handle this more gracefully, e.g., by showing an error to the user.
      }
    }

    // Return defaults if loading fails (or after clearing)
    return {
      theme: 'system',
      dailyGoals: { calories: 2000, protein: 50, carbs: 200, fat: 70 },
      settingsHistory: [] // Ensure settingsHistory exists in default
    };
  }
};

export const clearAllData = async (): Promise<void> => {
  try {
    await AsyncStorage.clear();
  } catch (error) {
    console.error('Error clearing data:', error);
    throw error;
  }
};

// Function to save recent foods
export const saveRecentFoods = async (foods: Food[]) => {
    try {
        await AsyncStorage.setItem(RECENT_FOODS, JSON.stringify(foods));
    } catch (error) {
        console.error('Error saving recent foods:', error);
        throw error; // Important: Re-throw the error so calling code knows it failed
    }
};

// Function to load recent foods
export const loadRecentFoods = async (): Promise<Food[]> => {
    try {
        const foods = await AsyncStorage.getItem(RECENT_FOODS);
        return foods ? JSON.parse(foods) : [];
    } catch (error) {
        console.error('Error loading recent foods:', error);
        return []; // Return empty array on error, don't throw
    }
};
---------- END storageService.ts ----------


---------- dailyEntry.ts ----------
// types/dailyEntry.ts (Modified)
import { Food } from "./food";

export interface DailyEntryItem {
  food: Food;
  grams: number;
}

export interface DailyEntry {
  date: string; // YYYY-MM-DD format
  items: DailyEntryItem[];
  goals?: {  // Optional goals
    calories?: number;
    protein?: number;
    carbs?: number;
    fat?: number;
  };
}

export interface FoodItem { //No changes here.
    id: string;
    name: string;
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
  }
---------- END dailyEntry.ts ----------


---------- food.ts ----------
// types/food.ts
export interface Food {
  id: string;
  name: string;
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
  // category: string;  // REMOVED
}
---------- END food.ts ----------


---------- openRouterTypes.ts ----------
// src/utils/types.ts

// =====================================
// Consolidated OpenRouter Type Definitions
// =====================================

// --- Content Parts (for multi-modal input like images) ---
export type OpenRouterContentPart =
  | { type: "text"; text: string }
  | { type: "image_url"; image_url: { url: string; detail?: "low" | "high" | "auto" } };

// --- Message Structure ---
// Allows content to be a simple string OR an array of content parts for vision models
export interface OpenRouterMessage {
  role: "user" | "assistant" | "system";
  content: string | OpenRouterContentPart[]; // Consolidated definition
  name?: string; // Optional name field
}

// --- Choice Structure (within the response) ---
// This structure aligns with standard Chat Completion APIs (like OpenAI/OpenRouter)
export interface OpenRouterChatChoice {
  index: number;
  message: OpenRouterMessage; // Contains the actual message content and role
  logprobs?: any | null; // Optional log probabilities (use a specific type if known)
  finish_reason: string | null; // Can be null sometimes
  // text?: string; // Usually the content is inside message.content, keep optional if some models return it differently
}

// --- API Usage Information ---
export interface OpenRouterUsage {
  prompt_tokens: number;
  completion_tokens: number;
  total_tokens: number;
}

// --- Main Chat Completion Response Structure ---
// Consolidates the fields from both previous declarations
export interface OpenRouterChatCompletionResponse {
  id: string;
  object: string; // Typically "chat.completion"
  created: number; // Timestamp
  model: string; // Model used
  choices: OpenRouterChatChoice[]; // Array of choices using the defined structure
  usage?: OpenRouterUsage; // Usage information is often optional
  // Add any other relevant fields you might encounter from OpenRouter
  // system_fingerprint?: string; // Example optional field
}


// =====================================
// Removed Redundant/Conflicting Declarations:
// =====================================

/*
// REMOVED - Duplicate/Outdated OpenRouterMessage
export interface OpenRouterMessage {
  role: "user" | "assistant" | "system"; // Add system role
  content: string;
}

// REMOVED - Less standard choice structure (often message.content is used instead of top-level text)
export interface OpenRouterChoice {
  text: any; // 'any' is vague, content is usually in message
  message: OpenRouterMessage; // This duplicates content info if 'text' is also present
  finish_reason?: string;
  index?: number;
}

// REMOVED - Duplicate/Simpler OpenRouterChatCompletionResponse
export interface OpenRouterChatCompletionResponse {
  choices: OpenRouterChoice[]; // Used the less standard choice type
  id?: string;
  created?: number;
  model?: string;
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}
*/
---------- END openRouterTypes.ts ----------


---------- settings.ts ----------
// types/settings.ts (Modified)
export const macros = ["calories", "protein", "carbs", "fat"] as const;
export type MacroType = (typeof macros)[number];

export interface MacroData {
  x: number; // Timestamp
  y: number; // Macro value
}

export interface Statistics {
  calories: MacroData[][];
  protein: MacroData[][];
  carbs: MacroData[][];
  fat: MacroData[][];
}

export interface Settings {
  theme: "light" | "dark" | "system";
  dailyGoals: {
    [key in MacroType]: number;
  };
  settingsHistory?: { date: number; dailyGoals: { [key in MacroType]: number } }[]; // CHANGED: Store timestamp
}

export interface SettingsScreenProps {
  onThemeChange: (theme: "light" | "dark" | "system") => void;
}
---------- END settings.ts ----------


---------- ai.ts ----------
// src/utils/ai.ts
import {
  OpenRouterChatCompletionResponse,
  OpenRouterMessage,
} from "../types/openRouterTypes";

const OPENROUTER_API_URL = "https://openrouter.ai/api/v1/chat/completions";

// No API_KEY constant here anymore

export async function getChatCompletion(
  model: string,
  messages: OpenRouterMessage[],
  responseFormat: "json_object" | "text" = "text",
  apiKey?: string // apiKey is now optional, for easier testing
): Promise<OpenRouterChatCompletionResponse> {
  // Get the API key from the environment variable.
  const effectiveApiKey = apiKey || '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';

  const response = await fetch(OPENROUTER_API_URL, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${effectiveApiKey}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      model,
      messages,
      response_format:
        responseFormat === "json_object" ? { type: "json_object" } : undefined,
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(
      `API request failed with status code ${response.status}: ${errorText}`
    );
  }

  const data: OpenRouterChatCompletionResponse = await response.json();

  if (
    !data.choices ||
    data.choices.length === 0 ||
    !data.choices[0].message ||
    !data.choices[0].message.content
  ) {
    throw new Error("Could not find the expected content in the response.");
  }

  return data;
}

---------- END ai.ts ----------


---------- dateUtils.ts ----------
// utils/dateUtils.ts (Modified)
import { format, parseISO, formatISO } from 'date-fns';

// Format a timestamp as YYYY-MM-DD (for display and storage)
export const formatDate = (timestamp: number): string => {
    return formatISO(timestamp, { representation: 'date' });
};

// Format a timestamp as a readable date (for display)
export const formatDateReadable = (timestamp: number | string): string => {
    if (typeof timestamp === 'string') {
        return timestamp; // if it is a string, do nothing.
    }
  return format(timestamp, 'MMMM dd, yyyy');
};

// Get today's date as a timestamp
export const getTodayDateString = (): string => {
  return formatISO(new Date(), { representation: 'date' });
};
---------- END dateUtils.ts ----------


---------- iconUtils.ts ----------
// utils/iconUtils.ts

import AsyncStorage from '@react-native-async-storage/async-storage';

const API_KEY = '25170800-59d7530d1a73abe661796e093';
const API_ENDPOINT = "https://pixabay.com/api/";

// Define the cache entry type
type CacheEntry = {
  url: string | null;
  expiry: number;
};

// In-memory cache for fast access
const memoryCache = new Map<string, CacheEntry>();

// Cache TTL: 3 days in milliseconds
const CACHE_TTL = 3 * 24 * 60 * 60 * 1000;

// Prefix for AsyncStorage keys
const STORAGE_KEY_PREFIX = 'foodIconCache_';

export const getFoodIconUrl = async (foodName: string): Promise<string | null> => {
  const cacheKey = foodName.toLowerCase();
  const now = Date.now();

  // 1. Check the in-memory cache first.
  const memoryEntry = memoryCache.get(cacheKey);
  if (memoryEntry && memoryEntry.expiry > now) {
    return memoryEntry.url;
  }

  // 2. Check persistent AsyncStorage.
  try {
    const storedValue = await AsyncStorage.getItem(STORAGE_KEY_PREFIX + cacheKey);
    if (storedValue) {
      const parsed: CacheEntry = JSON.parse(storedValue);
      if (parsed.expiry > now) {
        // Update in-memory cache with the persistent value.
        memoryCache.set(cacheKey, parsed);
        return parsed.url;
      } else {
        // Remove expired entry.
        await AsyncStorage.removeItem(STORAGE_KEY_PREFIX + cacheKey);
      }
    }
  } catch (error) {
    console.error('Error accessing AsyncStorage:', error);
  }
  

  // 3. No valid cached result, fetch from the API.
  try {
    const query = encodeURIComponent(`${foodName} minimal icon transparent`);
    const url = `${API_ENDPOINT}?key=${API_KEY}&q=${query}&image_type=vector&category=food&safesearch=true`;
    
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    const data = await response.json();
    let iconUrl: string | null = null;
    
    if (data.hits && data.hits.length > 0) {
      const filtered = data.hits.filter((hit: any) => {
        const hitUrl: string = hit.webformatURL.toLowerCase();
        return (hitUrl.endsWith('.png') || hitUrl.includes('svg')) &&
               hit.tags?.toLowerCase().includes(foodName.toLowerCase());
      });
      
      if (filtered.length > 0) {
        iconUrl = filtered[0].webformatURL;
      }
    }
    
    // Create a new cache entry with expiry.
    const newCacheEntry: CacheEntry = { url: iconUrl, expiry: now + CACHE_TTL };
    
    // Update both in-memory and persistent caches.
    memoryCache.set(cacheKey, newCacheEntry);
    try {
      await AsyncStorage.setItem(STORAGE_KEY_PREFIX + cacheKey, JSON.stringify(newCacheEntry));
    } catch (error) {
      console.error('Error saving to AsyncStorage:', error);
    }
    
    return iconUrl;
  } catch (error) {
    console.error("Error fetching food icon:", error);
    return null;
  }
};

---------- END iconUtils.ts ----------


---------- macros.ts ----------
// utils/macros.ts
import * as FileSystem from "expo-file-system";
// Use the React Native compatible library
import MimeTypes from 'react-native-mime-types';
import {
  OpenRouterChatCompletionResponse,
  OpenRouterMessage,
  // Make sure these types are correctly defined in your types file
} from "../types/openRouterTypes"; // Adjust path if needed (e.g., "../types")

// Interfaces
export interface Macros {
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
}

export interface MacrosWithFoodName extends Macros {
  foodName: string;
}

/**
 * Represents a single food item estimated from an image,
 * including its name, estimated weight, and macros per 100g.
 */
export interface EstimatedFoodItem {
  foodName: string;
  estimatedWeightGrams: number;
  calories_per_100g: number;
  protein_per_100g: number;
  carbs_per_100g: number;
  fat_per_100g: number;
}


// --- MOCK/Placeholder getChatCompletion ---
// Replace this with your actual implementation if it lives elsewhere
async function getChatCompletion(model: string, messages: OpenRouterMessage[], response_format?: string): Promise<OpenRouterChatCompletionResponse> {
    console.log("Mock getChatCompletion called for model:", model);
    const effectiveApiKey = "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"; // Use your key securely

    const body: any = {
        model: model,
        messages: messages,
    };
    if (response_format) {
        body.response_format = { type: response_format };
    }

    const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
        method: "POST",
        headers: {
            "Authorization": `Bearer ${effectiveApiKey}`,
            "Content-Type": "application/json",
        },
        body: JSON.stringify(body),
    });
    if (!response.ok) {
        const errorText = await response.text();
        console.error("Mock API Error:", errorText);
        throw new Error(`Mock API request failed: ${response.status} ${errorText}`);
    }
    const data = await response.json();

    /* START MOCK RESPONSE FOR MULTIPLE FOODS */
    // ONLY FOR TESTING getMultipleFoodsFromImage - REMOVE LATER
    if (messages[0]?.content && Array.isArray(messages[0].content) && messages[0].content.some(c => c.type === 'image_url')) {
        const textContent = messages[0].content.find(c => c.type === 'text')?.text || '';
         if (textContent.includes("Identify all distinct food items")) { // Check if it's the multi-food prompt
            console.log("--- RETURNING MOCK MULTI-FOOD RESPONSE ---");
             const mockResponseContent = JSON.stringify([
                { "foodName": "Grilled Chicken Breast", "estimatedWeightGrams": 150, "calories_per_100g": 165, "protein_per_100g": 31, "carbs_per_100g": 0, "fat_per_100g": 3.6 },
                { "foodName": "Steamed Broccoli", "estimatedWeightGrams": 80, "calories_per_100g": 55, "protein_per_100g": 3.7, "carbs_per_100g": 11.2, "fat_per_100g": 0.6 },
                { "foodName": "Quinoa", "estimatedWeightGrams": 120, "calories_per_100g": 120, "protein_per_100g": 4.1, "carbs_per_100g": 21.3, "fat_per_100g": 1.9 }
            ]);
             data.choices = [{
                message: {
                    role: 'assistant',
                    content: mockResponseContent
                },
                finish_reason: 'stop'
             }];
             return data;
         }
    }
    /* END MOCK RESPONSE */

    console.log("Mock API Response:", JSON.stringify(data, null, 2));
    return data as OpenRouterChatCompletionResponse;
}
// --- END MOCK ---


// Function to get macros from text description
export async function getMacrosForRecipe(
    foodName: string,
    Ingredients: string
): Promise<Macros> {
    const prompt = `
      Calculate the macros per 100g for the following food. Output ONLY a JSON object with the keys "calories", "protein", "carbs", and "fat". Do NOT include any other text, explanations, or calculations.

      Food: ${foodName}
      Ingredients:
      ${Ingredients}
      `;

    // Content here is definitely a string
    const messages: OpenRouterMessage[] = [{ role: "user", content: prompt }];
    try {
        const response = await getChatCompletion(
            "google/gemini-2.0-flash-thinking-exp-1219:free", // Model for text
            messages,
            "json_object" // Request JSON output
        );

        if (!response.choices || response.choices.length === 0 || !response.choices[0].message) {
            throw new Error("Invalid response structure from AI.");
        }

        const messageContent = response.choices[0].message.content;
    if (typeof messageContent === 'string') {
            const cleanedContent = messageContent.trim().replace(/^```json\s*|\s*```$/g, "");
    try {
                 const macroInfo: Macros = JSON.parse(cleanedContent);
                 if (typeof macroInfo.calories !== 'number' || typeof macroInfo.protein !== 'number' || typeof macroInfo.carbs !== 'number' || typeof macroInfo.fat !== 'number') {
                    console.error("Parsed JSON has incorrect structure (recipe):", macroInfo);
            throw new Error("AI returned data in an unexpected format.");
        }
        return macroInfo;
    } catch (parseError) {
        if (parseError instanceof SyntaxError) {
                    console.error("Error: The recipe response content was not valid JSON.", parseError);
            console.error("Cleaned content:", cleanedContent);
            throw new Error("Invalid JSON response from AI.");
        }
                 throw parseError;
    }
        } else {
            console.error("Error: AI recipe response content was not a string:", messageContent);
            throw new Error("Unexpected AI response format: content is not a string.");
        }

  } catch (error) {
        console.error("Error fetching/processing macros for recipe:", error);
        if (error instanceof Error && (error.message.startsWith("Invalid JSON") || error.message.startsWith("Unexpected AI response"))) {
             throw error; // Re-throw specific errors
    }
        throw new Error(`Failed to get macros for recipe: ${error instanceof Error ? error.message : String(error)}`);
  }
}

// Utility function to convert a file URI to base64
export async function getBase64FromUri(uri: string): Promise<string> {
  try {
    const base64 = await FileSystem.readAsStringAsync(uri, {
      encoding: FileSystem.EncodingType.Base64,
    });
    return base64;
  } catch (error) {
    console.error(`Failed to convert file to base64: ${uri}`, error);
    throw new Error(`Failed to convert file to base64: ${error}`);
  }
}

// Function to get macros for a single food item from an image file
export async function getMacrosForImageFile(asset: {
  uri: string;
  fileName?: string; // Optional filename from ImagePicker
  type?: string; // Optional MIME type from ImagePicker
}): Promise<MacrosWithFoodName> {
  const prompt = `
    Analyze the food in the image provided and guess the food name, ingredients, and their approximate proportions based on visual estimation or nutrients table if it exists in the image.
    Some nutrients tables might have nutrients per portion in addition to 100g one, be careful to take only the 100g one.
    Then, calculate the estimated macros per 100g (calories, protein, carbs, fat) for the food.
    Output ONLY a JSON object with the keys "foodName", "calories", "protein", "carbs", and "fat".
    Do NOT include any extra text, explanations, calculations, or markdown formatting like \`\`\`json.
    Just the raw JSON object.
  `;

  // 1. Get Base64 Data
  let base64File: string;
  try {
      base64File = await getBase64FromUri(asset.uri);
  } catch (err) {
      console.error("Error getting base64 from URI:", err);
      throw new Error("Failed to read image file.");
  }

  // 2. Determine MIME Type using react-native-mime-types
  let mimeType = asset.type; // Prioritize type from ImagePicker asset

  if (!mimeType && asset.fileName) {
      console.warn(`mimeType missing from ImagePicker asset (fileName: ${asset.fileName}). Attempting lookup.`);
      // Use the compatible library's lookup function
      mimeType = MimeTypes.lookup(asset.fileName) || undefined; // Returns false if not found, convert to undefined
  }

  // Default to jpeg if still undetermined (last resort)
  if (!mimeType) {
      console.warn(`Could not determine mimeType for ${asset.fileName}. Defaulting to image/jpeg.`);
      mimeType = 'image/jpeg';
  }

  console.log(`Using mimeType: ${mimeType} for image processing.`);
  const imageUrl = `data:${mimeType};base64,${base64File}`;

  // 3. Construct Messages for Vision Model
  const messages: OpenRouterMessage[] = [
    {
      role: "user",
      content: [ // Content is an array for multi-modal
        { type: "text", text: prompt },
        {
          type: "image_url",
          image_url: {
            url: imageUrl,
          },
        },
      ],
    },
  ];

  // 4. Prepare API Request Body
  const bodyData = {
    model: "google/gemini-2.0-flash-thinking-exp-1219:free", // DO NOT CHANGE MODEL per user request
    messages: messages,
    response_format: { type: "json_object" },
    // max_tokens: 512, // Optional: Consider adding if responses get cut off
  };

  // 5. API Key (Use secure storage in production!)
  const effectiveApiKey =
    "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";
  if (!effectiveApiKey) {
    throw new Error("API key is missing");
  }

  // 6. Make API Call and Process Response
  try {
    console.log("Sending request to OpenRouter vision model (single food)...");
    const response = await fetch(
      "https://openrouter.ai/api/v1/chat/completions",
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${effectiveApiKey}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify(bodyData),
      }
    );

    const responseBodyText = await response.text();

    if (!response.ok) {
      console.error(
        `API Error (${response.status}): ${responseBodyText}`
      );
      throw new Error(
        `API request failed with status ${response.status}: ${responseBodyText}`
      );
    }

    // Log the raw response text for debugging
    // console.log("Raw API Response Text:", responseBodyText);

    // Attempt to parse the JSON response
    let data: OpenRouterChatCompletionResponse;
    try {
      data = JSON.parse(responseBodyText);
    } catch (parseError) {
      console.error("Error parsing JSON response:", parseError);
      console.error("Response body that failed to parse:", responseBodyText);
      throw new Error("Failed to parse API response as JSON.");
    }

    // 7. Validate and Extract Information
    if (!data.choices || data.choices.length === 0 || !data.choices[0].message) {
      console.error("Invalid response structure from AI:", data);
      throw new Error("Invalid response structure from AI.");
    }

    const messageContent = data.choices[0].message.content;
    if (typeof messageContent !== 'string') {
        console.error("Error: AI vision response content was not a string:", messageContent);
        throw new Error("Unexpected AI response format: content is not a string.");
    }

    // Clean the string content (remove potential markdown formatting)
    const cleanedContent = messageContent.trim().replace(/^```json\s*|\s*```$/g, "");

     // Log cleaned content before parsing
    // console.log("Cleaned JSON content from vision AI:", cleanedContent);

    try {
        const macroInfo: MacrosWithFoodName = JSON.parse(cleanedContent);

        // Validate the structure and types
        if (
            typeof macroInfo.foodName !== 'string' ||
            typeof macroInfo.calories !== 'number' ||
            typeof macroInfo.protein !== 'number' ||
            typeof macroInfo.carbs !== 'number' ||
            typeof macroInfo.fat !== 'number'
        ) {
            console.error("Parsed JSON has incorrect structure (image):", macroInfo);
            throw new Error("AI returned data in an unexpected format.");
        }

        console.log("Successfully extracted macros from image:", macroInfo);
        return macroInfo;

    } catch (parseError) {
        if (parseError instanceof SyntaxError) {
            console.error("Error: The vision response content was not valid JSON.", parseError);
            console.error("Cleaned content that failed parsing:", cleanedContent);
            throw new Error("Invalid JSON response from AI vision model.");
        }
         // Re-throw other potential errors during parsing/validation
                 throw parseError;
    }

  } catch (error) {
    console.error("Error fetching/processing macros for image file:", error);
     // Re-throw specific errors from within the try block
     if (error instanceof Error && (error.message.startsWith("Failed to parse API response") || error.message.startsWith("Invalid JSON response") || error.message.startsWith("AI returned data in an unexpected format") || error.message.startsWith("Invalid response structure"))) {
        throw error;
    }
     // Throw a more generic error for other issues
    throw new Error(
      `Failed to get macros from image: ${
        error instanceof Error ? error.message : String(error)
      }`
    );
    }
  }


/**
 * Get estimations for potentially multiple distinct food items from an image.
 * @param asset - The image asset containing the food(s).
 * @returns A promise resolving to an array of EstimatedFoodItem.
 */
export async function getMultipleFoodsFromImage(asset: {
  uri: string;
  fileName?: string;
  type?: string;
}): Promise<EstimatedFoodItem[]> {
  const prompt = `
    Identify all distinct food items visible in the image. For each item, provide:
    1. A descriptive 'foodName' (e.g., "Grilled Salmon", "Steamed Asparagus", "Mashed Potatoes").
    2. An 'estimatedWeightGrams' based on visual approximation (be reasonable).
    3. The estimated nutritional content per 100 grams: 'calories_per_100g', 'protein_per_100g', 'carbs_per_100g', 'fat_per_100g'. If the image clearly shows a nutrition label with per 100g values, prioritize using those values. Otherwise, provide your best estimate based on the identified food type.

    Output ONLY a valid JSON array where each element is an object containing these keys: "foodName", "estimatedWeightGrams", "calories_per_100g", "protein_per_100g", "carbs_per_100g", "fat_per_100g".
    Do NOT include any extra text, explanations, notes, warnings, or markdown formatting like \`\`\`json.
    Just the raw JSON array. If no food is identifiable, return an empty array [].
  `;

  // 1. Get Base64 Data (reusing the utility function)
  let base64File: string;
  try {
      base64File = await getBase64FromUri(asset.uri);
  } catch (err) {
      console.error("Error getting base64 from URI:", err);
      throw new Error("Failed to read image file.");
}

  // 2. Determine MIME Type (reusing the same logic)
  let mimeType = asset.type;
  if (!mimeType && asset.fileName) {
      mimeType = MimeTypes.lookup(asset.fileName) || undefined;
  }
  if (!mimeType) {
      console.warn(`Could not determine mimeType for ${asset.fileName}. Defaulting to image/jpeg.`);
      mimeType = 'image/jpeg';
  }
  const imageUrl = `data:${mimeType};base64,${base64File}`;

  // 3. Construct Messages for Vision Model
  const messages: OpenRouterMessage[] = [
    {
      role: "user",
      content: [ // Content is an array for multi-modal
        { type: "text", text: prompt },
        {
          type: "image_url",
          image_url: {
            url: imageUrl,
          },
        },
      ],
    },
  ];

   // 4. Prepare API Request Body
   const bodyData = {
        model: "google/gemini-2.0-flash-thinking-exp-1219:free", // Use the same capable model <- DO NOT CHANGE MODEL per user request
        messages: messages,
        response_format: { type: "json_object" }, // Request JSON output, even if it's an array []
        // max_tokens: 1024, // Consider increasing tokens if many items are expected
   };

   // 5. API Key (ensure secure handling)
   const effectiveApiKey = "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";
   if (!effectiveApiKey) {
       throw new Error("API key is missing");
   }

   // 6. Make API Call and Process Response
   try {
       console.log("Sending request to OpenRouter vision model (multiple foods)...");
       // USING THE MOCK FUNCTION FOR TESTING - REPLACE WITH ACTUAL FETCH LATER
        const data = await getChatCompletion(
          bodyData.model, // Pass the model name
          bodyData.messages, // Pass the messages array
          "json_object" // Pass the response format
        );
       // console.log("Raw Multi-Food API Response:", JSON.stringify(data, null, 2)); // Log raw response for debugging


       // --- THIS SECTION USES fetch() WHEN NOT MOCKING ---
       /*
       const response = await fetch(
           "https://openrouter.ai/api/v1/chat/completions",
           {
               method: "POST",
               headers: {
                   Authorization: `Bearer ${effectiveApiKey}`,
                   "Content-Type": "application/json",
               },
               body: JSON.stringify(bodyData),
           }
       );

       const responseBodyText = await response.text(); // Read body once
        if (!response.ok) {
           console.error(
               `API Error (${response.status}): ${responseBodyText}`
           );
           throw new Error(
               `API request failed with status ${response.status}: ${responseBodyText}`
           );
       }

       // Attempt to parse the JSON response
       let data: OpenRouterChatCompletionResponse;
       try {
           data = JSON.parse(responseBodyText);
       } catch (parseError) {
           console.error("Error parsing JSON response (multi-food):", parseError);
           console.error("Response body that failed to parse:", responseBodyText);
           throw new Error("Failed to parse API response as JSON.");
       }
        */
       // --- END OF fetch() SECTION ---


       // 7. Validate and Extract Information (common logic for both mock and real fetch)
       if (!data.choices || data.choices.length === 0 || !data.choices[0].message) {
           console.error("Invalid response structure from multi-food AI:", data);
           throw new Error("Invalid response structure from AI.");
       }

       const messageContent = data.choices[0].message.content;
       if (typeof messageContent !== 'string') {
           console.error("Error: AI multi-food response content was not a string:", messageContent);
           throw new Error("Unexpected AI response format: content is not a string.");
       }

       // Clean the string content
       const cleanedContent = messageContent.trim().replace(/^```json\s*|\s*```$/g, "");

    //    console.log("Cleaned JSON content from multi-food AI:", cleanedContent); // Log cleaned content

       try {
            const estimatedItems: any[] = JSON.parse(cleanedContent); // Expecting an array

            if (!Array.isArray(estimatedItems)) {
                 console.error("Parsed JSON is not an array (multi-food):", estimatedItems);
                 throw new Error("AI returned data that is not a JSON array.");
            }

            // Validate each item in the array
            const validatedItems: EstimatedFoodItem[] = estimatedItems.map((item, index) => {
                if (
                    typeof item !== 'object' || item === null ||
                    typeof item.foodName !== 'string' ||
                    typeof item.estimatedWeightGrams !== 'number' ||
                    typeof item.calories_per_100g !== 'number' ||
                    typeof item.protein_per_100g !== 'number' ||
                    typeof item.carbs_per_100g !== 'number' ||
                    typeof item.fat_per_100g !== 'number'
                ) {
                    console.error(`Parsed JSON array item at index ${index} has incorrect structure:`, item);
                    throw new Error(`AI returned an array item with unexpected format at index ${index}.`);
                }
                 // Ensure numbers are non-negative
                 if (item.estimatedWeightGrams < 0 || item.calories_per_100g < 0 || item.protein_per_100g < 0 || item.carbs_per_100g < 0 || item.fat_per_100g < 0) {
                    console.warn(`Item "${item.foodName}" has negative values, correcting to 0.`);
                    item.estimatedWeightGrams = Math.max(0, item.estimatedWeightGrams);
                    item.calories_per_100g = Math.max(0, item.calories_per_100g);
                    item.protein_per_100g = Math.max(0, item.protein_per_100g);
                    item.carbs_per_100g = Math.max(0, item.carbs_per_100g);
                    item.fat_per_100g = Math.max(0, item.fat_per_100g);
                 }

                return item as EstimatedFoodItem;
            });

            console.log("Successfully extracted multiple food items from image:", validatedItems);
            return validatedItems;

       } catch (parseError) {
            if (parseError instanceof SyntaxError) {
               console.error("Error: The multi-food response content was not valid JSON.", parseError);
               console.error("Cleaned content that failed parsing:", cleanedContent);
               throw new Error("Invalid JSON response from AI vision model (multi-food).");
            }
            // Re-throw other potential errors during parsing/validation
            throw parseError;
       }

   } catch (error) {
       console.error("Error fetching/processing multiple foods for image file:", error);
        // Re-throw specific errors
        if (error instanceof Error && (error.message.includes("Failed to parse") || error.message.includes("Invalid JSON") || error.message.includes("unexpected format") || error.message.includes("not a JSON array") || error.message.includes("Invalid response structure"))) {
           throw error;
        }
       // Throw a more generic error
       throw new Error(
           `Failed to get multiple foods from image: ${
               error instanceof Error ? error.message : String(error)
           }`
       );
   }
}


---------- END macros.ts ----------


---------- units.ts ----------
// --- NEW FUNCTION ---

import { OpenRouterMessage } from "../types/openRouterTypes";
import { getChatCompletion } from "./ai";

/**
 * Estimates the weight in grams based on a natural language description and food item.
 * @param foodName The name of the food item (e.g., "Apple").
 * @param quantityDescription The natural language description (e.g., "2 small", "1 cup chopped").
 * @returns A promise that resolves with the estimated weight in grams (number).
 */
export async function getGramsFromNaturalLanguage(
    foodName: string,
    quantityDescription: string
): Promise<number> {
    const prompt = `
    Estimate the approximate weight in grams for the following quantity of food.
    Food: "${foodName}"
    Quantity: "${quantityDescription}"

    Respond with ONLY the estimated numeric value in grams. Do not include units (like 'g' or 'grams'), explanations, or any other text. Just the number.
    Example response: 150
    `;

    const messages: OpenRouterMessage[] = [{ role: "user", content: prompt }];

    try {
        // Using a capable but potentially free/cheap model
        const response = await getChatCompletion(
            "google/gemini-2.0-flash-thinking-exp-1219:free", // Or try "mistralai/mistral-7b-instruct:free", "nousresearch/nous-hermes-2-mixtral-8x7b-dpo:free"
            messages,
            "text" // Expecting plain text number
        );

        const content = response.choices[0].message.content.trim();

        // Try to parse the response as a number
        const estimatedGrams = parseFloat(content);

        if (isNaN(estimatedGrams)) {
            console.error(`AI response was not a valid number: "${content}"`);
            throw new Error("AI did not return a valid number for grams.");
        }

        return Math.round(estimatedGrams); // Return rounded integer grams

    } catch (error) {
        console.error("Error getting grams estimation from AI:", error);
        // Re-throw the error so the calling component can handle it
        throw error;
    }
}
---------- END units.ts ----------


---------- validationUtils.ts ----------
// utils/validationUtils.ts

export const isValidNumberInput = (value: string): boolean => {
    return /^[0-9]*(\.[0-9]*)?$/.test(value) && !isNaN(parseFloat(value));
  };
  
  export const isNotEmpty = (value: string): boolean => {
    return value.trim() !== '';
  };
---------- END validationUtils.ts ----------


---------- tsconfig.json ----------
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true

  }
}
---------- END tsconfig.json ----------

