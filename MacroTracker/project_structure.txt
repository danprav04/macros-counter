.gitignore
app.json
App.tsx
assets/
  adaptive-icon.png
  favicon.png
  icon.png
  splash.png
eas.json
index.ts
package.json
projectToFile.js
src/
  components/
    AddEntryModal.tsx
    AddFoodModal.tsx
    ConfirmationModal.tsx
    DailyGoalsInput.tsx
    DailyProgress.tsx
    DataManagementButtons.tsx
    FoodItem.tsx
    QuickAddList.tsx
    StatisticsChart.tsx
    ThemeSwitch.tsx
  hooks/
  navigation/
    AppNavigator.tsx
  screens/
    DailyEntryScreen.tsx
    FoodListScreen.tsx
    SettingsScreen.tsx
  services/
    backendService.ts
    clientIDService.ts
    foodService.ts
    storageService.ts
  types/
    dailyEntry.ts
    food.ts
    macros.ts
    openRouterTypes.ts
    settings.ts
  utils/
    dateUtils.ts
    iconUtils.ts
    macros.ts
    units.ts
    validationUtils.ts
tsconfig.json

---------- .gitignore ----------
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

---------- END .gitignore ----------


---------- app.json ----------
{
  "expo": {
    "name": "MacroTracker",
    "slug": "MacroTracker",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "automatic",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#000000"
    },
    "androidStatusBar": {
      "backgroundColor": "#000000",
      "translucent": false,
      "barStyle": "light-content"
    },
    "assetBundlePatterns": [
      "**/*"
    ],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.yourcompany.macrotracker",
      "infoPlist": {
        "UIStatusBarStyle": "UIStatusBarStyleAutomatic"
      }
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "package": "com.yourcompany.macrotracker",
      "userInterfaceStyle": "automatic",
      "statusBar": {
        "backgroundColor": "#00000000",
        "translucent": true,
        "barStyle": "auto"
      }
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      [
        "expo-document-picker",
        {
          "appleTeamId": "YOUR_TEAM_ID"
        }
      ]
    ],
    "extra": {
      "eas": {
        "projectId": "25ac2bcf-78a3-4f2c-a635-4fcaae7b93f1"
      },
      "env": {
         "BACKEND_URL": "http://192.168.1.15:8000"
      }
    }
  }
}
---------- END app.json ----------


---------- App.tsx ----------
// App.tsx
// App.tsx (Initialize Client ID)
import "react-native-get-random-values"; // MUST BE FIRST
import Toast from "react-native-toast-message";
import React, { useState, useEffect } from "react";
import AppNavigator from "./src/navigation/AppNavigator";
import { SafeAreaProvider, SafeAreaView } from "react-native-safe-area-context";
import { ThemeProvider, createTheme } from "@rneui/themed";
import { loadSettings, saveSettings } from "./src/services/storageService";
import {
  useColorScheme,
  AppState,
  AppStateStatus,
  Platform,
} from "react-native";
import {
  NavigationContainer,
  DefaultTheme,
  DarkTheme,
} from "@react-navigation/native";
import { Colors } from "@rneui/base";
import { Settings } from "./src/types/settings";
import { LogBox, View, Text } from "react-native"; //Import view for debug
import { StatusBar } from "expo-status-bar"; // changed import
import { getClientId } from "./src/services/clientIDService"; // Import client ID service

LogBox.ignoreLogs(["Function components cannot be given refs"]);

declare module "@rneui/themed" {
  export interface Colors {
    text: string;
    card: string; // Added for better card styling
    successLight: string; // Lighter success color
  }
}

interface MyTheme {
  mode: "light" | "dark";
  colors: Colors;
}

const lightTheme: MyTheme = {
  mode: "light",
  colors: {
    primary: "#2e86de",
    secondary: "#6c757d",
    background: "#f8f9fa",
    grey5: "#e9ecef",
    white: "#ffffff",
    grey4: "#ced4da",
    success: "#28a745",
    successLight: "#d4edda",
    black: "#000000",
    text: "#212529",
    card: "#ffffff",
    error: "#dc3545",
    warning: "#ffc107",
    disabled: "#6c757d",
    divider: "#ced4da",
    platform: {
      ios: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      android: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      web: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      default: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
    },
    grey0: "#f8f9fa",
    grey1: "#e9ecef",
    grey2: "#dee2e6",
    grey3: "#ced4da",
    greyOutline: "#adb5bd",
    searchBg: "#ffffff",
  },
};

const darkTheme: MyTheme = {
  mode: "dark",
  colors: {
    primary: "#2e86de",
    secondary: "#adb5bd",
    background: "#121212",
    grey5: "#2c2c2c",
    white: "#ffffff",
    grey4: "#343a40",
    success: "#28a745",
    successLight: "#1f5139",
    black: "#000000",
    text: "#f8f9fa",
    card: "#1e1e1e",
    error: "#dc3545",
    warning: "#ffc107",
    disabled: "#6c757d",
    divider: "#343a40",
    platform: {
      ios: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      android: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      web: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      default: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
    },
    grey0: "#212529",
    grey1: "#2c2c2c",
    grey2: "#343a40",
    grey3: "#495057",
    greyOutline: "#6c757d",
    searchBg: "#1e1e1e",
  },
};

const App = () => {
  const [themeMode, setThemeMode] = useState<"light" | "dark" | "system">(
    "system"
  );
  const [loadedSettings, setLoadedSettings] = useState<Settings | null>(null);
  const colorScheme = useColorScheme();
  const [appState, setAppState] = useState(AppState.currentState);
  const [themeCheck, setThemeCheck] = useState(0);
  const [isClientIdReady, setIsClientIdReady] = useState(false); // Track client ID readiness

  // Initialize Client ID and Load initial settings
  useEffect(() => {
    const initializeApp = async () => {
      try {
          // Ensure Client ID is ready before loading other data
          await getClientId(); // This generates/retrieves and caches the ID
          setIsClientIdReady(true);
          console.log('Client ID is ready.');

          // Load settings after client ID is confirmed
          const settings = await loadSettings();
          setThemeMode(settings.theme);
          setLoadedSettings(settings);
          console.log('Settings loaded.');
      } catch (error) {
            console.error("Initialization Error:", error);
            // Handle error, maybe show an error screen
      }
    };
    initializeApp();
  }, []); // Run only once on mount

  // AppState Listener
  useEffect(() => {
    const handleAppStateChange = (nextAppState: AppStateStatus) => {
      setAppState(nextAppState);
    };

    const subscription = AppState.addEventListener(
      "change",
      handleAppStateChange
    );

    return () => {
      subscription.remove();
    };
  }, []); // No appState dependency needed here

  const updateTheme = (newThemeMode: "light" | "dark" | "system") => {
    const isDark =
      newThemeMode === "system"
        ? colorScheme === "dark"
        : newThemeMode === "dark";
    return isDark ? darkTheme : lightTheme;
  };

  const handleThemeChange = async (newTheme: "light" | "dark" | "system") => {
    setThemeMode(newTheme);
    if (loadedSettings) {
      const updatedSettings: Settings = {
        ...loadedSettings,
        theme: newTheme,
      };
      await saveSettings(updatedSettings);
      setLoadedSettings(updatedSettings);
    }
    setThemeCheck((t) => t + 1);
  };

  const currentTheme = updateTheme(themeMode);

  const navigationTheme = {
    dark: {
      ...DarkTheme,
      colors: {
        ...DarkTheme.colors,
        primary: currentTheme.colors.primary,
        background: currentTheme.colors.background,
        card: currentTheme.colors.card,
        text: currentTheme.colors.text,
        border: currentTheme.colors.divider,
        notification: currentTheme.colors.successLight,
      },
    },
    light: {
      ...DefaultTheme,
      colors: {
        ...DefaultTheme.colors,
        primary: currentTheme.colors.primary,
        background: currentTheme.colors.background,
        card: currentTheme.colors.card,
        text: currentTheme.colors.text,
        border: currentTheme.colors.divider,
        notification: currentTheme.colors.success,
      },
    },
  };

  const statusBarTheme = themeMode === "system" ? colorScheme : themeMode;
  const backgroundColor = currentTheme.colors.background;

  // Show loading or placeholder until client ID is ready
  if (!isClientIdReady) {
      return (
          <SafeAreaView style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: backgroundColor }}>
              <Text style={{ color: currentTheme.colors.text }}>Initializing...</Text>
              {/* Optionally add an ActivityIndicator */}
          </SafeAreaView>
      );
  }

  return (
    <ThemeProvider theme={createTheme(currentTheme)}>
      <SafeAreaView style={{ flex: 1, backgroundColor: backgroundColor }}>
        <StatusBar
          style={statusBarTheme === "dark" ? "light" : "dark"}
          backgroundColor={backgroundColor}
          translucent={false}
        />
        <NavigationContainer
          theme={
            currentTheme.mode === "dark"
              ? navigationTheme.dark
              : navigationTheme.light
          }
        >
          <AppNavigator onThemeChange={handleThemeChange} />
        </NavigationContainer>
        <Toast />
      </SafeAreaView>
    </ThemeProvider>
  );
};

export default App;
---------- END App.tsx ----------


---------- adaptive-icon.png ----------
(Image file - content not included)
---------- END adaptive-icon.png ----------


---------- favicon.png ----------
(Image file - content not included)
---------- END favicon.png ----------


---------- icon.png ----------
(Image file - content not included)
---------- END icon.png ----------


---------- splash.png ----------
(Image file - content not included)
---------- END splash.png ----------


---------- eas.json ----------
{
  "cli": {
    "version": ">= 13.4.1",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal"
    },
    "preview": {
      "android": {
        "buildType": "apk"
      }
    },
    "production": {
      "autoIncrement": true
    }
  },
  "submit": {
    "production": {}
  }
}

---------- END eas.json ----------


---------- index.ts ----------
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);

---------- END index.ts ----------


---------- package.json ----------
{
  "name": "macrotracker",
  "license": "0BSD",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@react-native-async-storage/async-storage": "^2.1.2",
    "@react-native-community/datetimepicker": "8.2.0",
    "@react-navigation/bottom-tabs": "^7.3.1",
    "@react-navigation/native": "^7.0.17",
    "@rneui/base": "^4.0.0-rc.7",
    "@rneui/themed": "^4.0.0-rc.8",
    "@types/d3-scale": "^4.0.9",
    "d3-scale": "^4.0.2",
    "date-fns": "^4.1.0",
    "expo": "~52.0.40",
    "expo-document-picker": "^13.0.3",
    "expo-file-system": "^18.0.12",
    "expo-image-picker": "^16.0.6",
    "expo-sharing": "~13.0.1",
    "expo-status-bar": "~2.0.1",
    "react": "18.3.1",
    "react-native": "0.76.7",
    "react-native-config": "^1.5.5",
    "react-native-get-random-values": "^1.11.0",
    "react-native-mime-types": "^2.5.0",
    "react-native-reanimated": "~3.16.1",
    "react-native-safe-area-context": "^4.14.1",
    "react-native-screens": "^4.9.2",
    "react-native-svg": "^15.11.2",
    "react-native-toast-message": "^2.2.1",
    "react-native-uuid": "^2.0.3",
    "react-native-webview": "^13.13.4",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/react": "~18.3.12",
    "@types/react-native": "^0.73.0",
    "@types/react-native-svg-charts": "^5.0.16",
    "@types/uuid": "^10.0.0",
    "typescript": "^5.3.3",
    "victory": "^37.3.6"
  },
  "private": true
}

---------- END package.json ----------


---------- projectToFile.js ----------
const fs = require('fs');
const path = require('path');

async function generateProjectStructureAndContent(projectRoot, outputFile) {
    const excludedDirs = ['node_modules', '.git', '.expo', 'android', 'ios', '__tests__', 'dist', 'build', '.vscode'];
    const excludedFiles = ['.DS_Store', 'package-lock.json', 'yarn.lock', 'bun.lockb', 'metro.config.js', 'babel.config.js'];
    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.webp', '.ico']; // Add more if needed

    let fileStructureTree = '';  // For the initial tree structure
    let fileContents = '';      // For the file contents

    async function traverseDirectory(dir, indent = '') {
        const entries = await fs.promises.readdir(dir, { withFileTypes: true });

        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);

            if (excludedDirs.includes(entry.name)) {
                continue;
            }

            if (entry.isDirectory()) {
                fileStructureTree += `${indent}${entry.name}/\n`;
                await traverseDirectory(fullPath, indent + '  ');
            } else if (entry.isFile()) {
                if (excludedFiles.includes(entry.name)) {
                    continue;
                }
                fileStructureTree += `${indent}${entry.name}\n`;
                const fileExtension = path.extname(entry.name).toLowerCase();

                if (!imageExtensions.includes(fileExtension)) {
                    fileContents += `\n---------- ${entry.name} ----------\n`;
                    try {
                        const fileContent = await fs.promises.readFile(fullPath, 'utf-8');
                        fileContents += `${fileContent}\n`;
                    } catch (readError) {
                        fileContents += `ERROR READING FILE: ${readError.message}\n`;
                    }
                    fileContents += `---------- END ${entry.name} ----------\n\n`;
                } else {
                     fileContents += `\n---------- ${entry.name} ----------\n`;
                     fileContents += `(Image file - content not included)\n`;
                     fileContents += `---------- END ${entry.name} ----------\n\n`;
                }
            }
        }
    }

    try {
        await traverseDirectory(projectRoot);
        const fullOutput = fileStructureTree + fileContents;

        await fs.promises.writeFile(outputFile, fullOutput);
        console.log(`Project structure and content written to ${outputFile}`);

    } catch (error) {
        console.error('An error occurred:', error);
        process.exit(1);
    }
}

// --- Main execution ---

const projectRoot = process.cwd(); // Use the current working directory
const outputFile = 'project_structure.txt';

// Check if the projectRoot exists.
fs.stat(projectRoot, (err, stats) => {
    if (err) {
        console.error(`Error: Project root directory "${projectRoot}" not found or not accessible.`);
        process.exit(1);
    }

    if (!stats.isDirectory()) {
        console.error(`Error: "${projectRoot}" is not a directory.`);
        process.exit(1);
    }

    generateProjectStructureAndContent(projectRoot, outputFile);
});
---------- END projectToFile.js ----------


---------- AddEntryModal.tsx ----------
// src/components/AddEntryModal.tsx
// ---------- AddEntryModal.tsx (Refactored to use single FlatList, Final Version) ----------
import React, {
  useEffect,
  useState,
  useMemo,
  useCallback,
  useRef,
} from "react";
import {
  View,
  FlatList,
  KeyboardAvoidingView,
  Platform,
  TouchableOpacity,
  ScrollView,
  Dimensions,
  Image,
  StyleSheet,
  ActivityIndicator,
  Alert,
  Keyboard,
} from "react-native";
import {
  Button,
  Input,
  Text,
  ListItem,
  Overlay,
  SearchBar,
  makeStyles,
  useTheme,
  Icon,
  ButtonGroup,
} from "@rneui/themed";
import { Food } from "../types/food";
import { isValidNumberInput } from "../utils/validationUtils";
import { loadRecentFoods, saveRecentFoods } from "../services/storageService";
import { getFoodIconUrl } from "../utils/iconUtils";
import { getGramsFromNaturalLanguage } from "../utils/units";
import Toast from "react-native-toast-message";
import * as ImagePicker from "expo-image-picker";
import { EstimatedFoodItem, getMultipleFoodsFromImage } from "../utils/macros";
import { v4 as uuidv4 } from "uuid";

interface AddEntryModalProps {
  isVisible: boolean;
  toggleOverlay: () => void;
  selectedFood: Food | null;
  grams: string;
  setGrams: (grams: string) => void;
  handleAddEntry: () => void;
  handleAddMultipleEntries: (entries: { food: Food; grams: number }[]) => void;
  foods: Food[];
  handleSelectFood: (item: Food | null) => void;
  updateSearch: (search: string) => void;
  search: string;
  isEditMode: boolean;
  initialGrams?: string; // This is the grams value passed IN for editing
}

const KEYBOARD_VERTICAL_OFFSET = Platform.OS === "ios" ? 80 : 0;

type UnitMode = "grams" | "auto";
type ModalMode = "normal" | "quickAddSelect";

// Define types for the items in our main FlatList data structure
type ListItemType =
  | { type: "searchBar"; key: string }
  | { type: "recentFoods"; key: string }
  | { type: "searchResults"; key: string; data: Food } // Individual search result
  | { type: "noResults"; key: string }
  | { type: "amountInput"; key: string }
  | { type: "quickAddHeader"; key: string }
  | { type: "quickAddItem"; key: string; data: EstimatedFoodItem; index: number } // Individual quick add item
  | { type: "quickAddLoading"; key: string }
  | { type: "quickAddEditForm"; key: string; index: number} // Edit form for quick add
  | { type: "spacer"; key: string; height: number };

const AddEntryModal: React.FC<AddEntryModalProps> = ({
  isVisible,
  toggleOverlay,
  selectedFood,
  grams,
  setGrams,
  handleAddEntry,
  handleAddMultipleEntries,
  foods,
  handleSelectFood,
  updateSearch,
  search,
  isEditMode,
  initialGrams,
}) => {
  const { theme } = useTheme();
  const styles = useStyles();
  const [recentFoods, setRecentFoods] = useState<Food[]>([]);
  const MAX_RECENT_FOODS = 5;
  const [foodIcons, setFoodIcons] = useState<{
      [foodName: string]: string | null | undefined;
  }>({});

  const [unitMode, setUnitMode] = useState<UnitMode>("grams");
  const [autoInput, setAutoInput] = useState("");
  const [isAiLoading, setIsAiLoading] = useState(false);

  // --- Quick Add State ---
  const [modalMode, setModalMode] = useState<ModalMode>("normal");
  const [quickAddLoading, setQuickAddLoading] = useState(false);
  const [quickAddItems, setQuickAddItems] = useState<EstimatedFoodItem[]>([]);
  const [selectedQuickAddIndices, setSelectedQuickAddIndices] = useState<
      Set<number>
  >(new Set());
  const [editingQuickAddItemIndex, setEditingQuickAddItemIndex] = useState<
      number | null
  >(null);
  const [editedFoodName, setEditedFoodName] = useState<string>("");
  const [editedGrams, setEditedGrams] = useState<string>("");
  // --- End Quick Add State ---

  const screenWidth = Dimensions.get("window").width;
  const isModalOpening = useRef(false);

  const filteredFoods = useMemo(() => {
      if (!search) return [];
      return foods.filter((food) =>
          food.name.toLowerCase().includes(search.toLowerCase())
      );
  }, [foods, search]);

  // --- Effects ---
  useEffect(() => {
      if (!isVisible) {
          // Reset general states when modal actually closes
          handleSelectFood(null);
          updateSearch("");
          setModalMode("normal");
          setQuickAddItems([]);
          setSelectedQuickAddIndices(new Set());
          setEditingQuickAddItemIndex(null);
          setGrams("");
          setUnitMode("grams");
          setAutoInput("");
          setIsAiLoading(false);
           setQuickAddLoading(false); // Ensure loading state is reset
      }
  }, [isVisible, handleSelectFood, updateSearch, setGrams]);


  useEffect(() => {
      if (isVisible && modalMode === 'normal') {
          isModalOpening.current = true;

          if (isEditMode && selectedFood && initialGrams !== undefined) {
              setGrams(initialGrams);
              setUnitMode('grams');
              setAutoInput('');
          } else if (!isEditMode) { // Only reset if not in edit mode opening
              setGrams('');
              setUnitMode('grams');
              setAutoInput('');
          }

          const loadRecents = async () => {
              const loadedRecentFoods = await loadRecentFoods();
              setRecentFoods(loadedRecentFoods);
          };
          loadRecents();

          const timer = setTimeout(() => {
              isModalOpening.current = false;
          }, 100); // Short delay to prevent effect races

          return () => clearTimeout(timer);
      } else if (isVisible && modalMode === 'quickAddSelect') {
           // Reset normal mode stuff if switching to quick add
          handleSelectFood(null);
          updateSearch('');
          setGrams('');
          setUnitMode("grams");
          setAutoInput("");
      }
  }, [isVisible, modalMode, isEditMode, selectedFood, initialGrams, setGrams]); // Dependencies remain


  // Effect 3: Reset grams/mode if selectedFood changes while modal is open in ADD mode
  useEffect(() => {
      if (isVisible && modalMode === 'normal' && !isEditMode && !isModalOpening.current) {
          setGrams("");
          setUnitMode("grams");
          setAutoInput("");
      }
  }, [selectedFood, isVisible, modalMode, isEditMode]);

  // Load icons
  useEffect(() => {
      if (!isVisible || modalMode !== 'normal') return;

      const loadIcons = async () => {
          const relevantFoods = search ? filteredFoods : recentFoods;
          const uniqueFoodsMap = new Map(relevantFoods.map(food => [food.id ?? food.name, food]));

          for (const food of uniqueFoodsMap.values()) {
              const foodName = food.name;
              if (foodIcons[foodName] === undefined) {
                  getFoodIconUrl(foodName)
                      .then(iconUrl => {
                          setFoodIcons(prevIcons => ({ ...prevIcons, [foodName]: iconUrl }));
                      })
                      .catch(error => {
                          console.warn(`Icon fetch failed for ${foodName}:`, error);
                          setFoodIcons(prevIcons => ({ ...prevIcons, [foodName]: null }));
                      });
              }
          }
      };
      loadIcons();
  }, [isVisible, modalMode, search, filteredFoods, recentFoods, foodIcons]);


  // --- Utility Functions ---
  const addToRecentFoods = useCallback(async (food: Food) => {
      if (!food || !food.id) return;
      if (recentFoods.length > 0 && recentFoods[0].id === food.id) return;

      setRecentFoods((prevRecent) => {
          const updated = prevRecent.filter((rf) => rf.id !== food.id);
          updated.unshift(food);
          const trimmed = updated.slice(0, MAX_RECENT_FOODS);
          saveRecentFoods(trimmed).catch(err => console.error("Failed to save recent foods:", err));
          return trimmed;
      });
  }, [recentFoods]);

  const servingSizeSuggestions = useMemo(() => {
      if (!selectedFood) return [];
      return [
          { label: "50g", value: "50" },
          { label: "100g", value: "100" },
          { label: "150g", value: "150" },
          { label: "200g", value: "200" },
      ];
  }, [selectedFood]);

  // --- Action Handlers ---
  const handleEstimateGrams = useCallback(async () => {
      Keyboard.dismiss();
      if (!selectedFood || !autoInput.trim()) {
          Alert.alert("Input Missing", "Please select a food and enter a quantity description.");
          return;
      }
      if (isAiLoading) return;
      setIsAiLoading(true);
      try {
          const estimatedGrams = await getGramsFromNaturalLanguage(selectedFood.name, autoInput);
          const roundedGrams = String(Math.round(estimatedGrams));
          setGrams(roundedGrams);
          setUnitMode("grams"); // Switch back to grams view
          setAutoInput("");
          Toast.show({ type: "success", text1: "Grams Estimated", text2: `Estimated ${roundedGrams}g for ${selectedFood.name}`, position: "bottom" });
      } catch (error: any) {
          console.error("AI Gram Estimation Error:", error);
          Toast.show({ type: "error", text1: "Estimation Failed", text2: error.message || "Could not estimate grams.", position: "bottom" });
      } finally {
          setIsAiLoading(false);
      }
  }, [selectedFood, autoInput, isAiLoading, setGrams]);

  const handleAddOrUpdateSingleEntry = useCallback(async () => {
      Keyboard.dismiss();
      if (!selectedFood) {
          Alert.alert("Food Not Selected", "Please select a food item."); return;
      }
      const numericGrams = parseFloat(grams);
      if (!isValidNumberInput(grams) || numericGrams <= 0) {
          Alert.alert("Invalid Amount", "Please enter a valid positive number for grams."); return;
      }
      if (isAiLoading || quickAddLoading) return;

      handleAddEntry();
      if (!isEditMode) { // Only add to recents on ADD, not UPDATE
           addToRecentFoods(selectedFood);
      }

  }, [selectedFood, grams, isAiLoading, quickAddLoading, handleAddEntry, addToRecentFoods, isEditMode]);

  const handleInternalSelectFood = useCallback((item: Food | null) => {
      handleSelectFood(item);
      updateSearch(""); // Clear search when a food is selected from results/recent
      Keyboard.dismiss();
  }, [handleSelectFood, updateSearch]);


  // --- Quick Add Functions (Declare dependent functions first) ---

  const pickImageAndAnalyze = useCallback(async (source: "camera" | "gallery") => {
      if (isEditMode) return;

      let permissionResult;
      let pickerResult: ImagePicker.ImagePickerResult;

      setQuickAddLoading(true);
      setQuickAddItems([]);
      setSelectedQuickAddIndices(new Set());
      setEditingQuickAddItemIndex(null);
      setModalMode("quickAddSelect"); // Switch view mode
      // Clear normal mode state when entering quick add
      handleSelectFood(null);
      updateSearch("");
      setGrams("");

      try {
          if (source === "camera") {
              permissionResult = await ImagePicker.requestCameraPermissionsAsync();
              if (!permissionResult.granted) { Alert.alert("Permission Required", "Camera access needed."); setModalMode("normal"); setQuickAddLoading(false); return; }
              pickerResult = await ImagePicker.launchCameraAsync({ quality: 0.6 });
          } else {
              permissionResult = await ImagePicker.requestMediaLibraryPermissionsAsync();
              if (!permissionResult.granted) { Alert.alert("Permission Required", "Gallery access needed."); setModalMode("normal"); setQuickAddLoading(false); return; }
              pickerResult = await ImagePicker.launchImageLibraryAsync({ mediaTypes: ImagePicker.MediaTypeOptions.Images, quality: 0.6 });
          }

          if (pickerResult.canceled) { setModalMode("normal"); setQuickAddLoading(false); return; }

          if (pickerResult.assets && pickerResult.assets.length > 0) {
              const asset = pickerResult.assets[0];
              const results = await getMultipleFoodsFromImage(asset);
              if (results.length === 0) {
                  Alert.alert("No Foods Found", "Couldn't identify food items. Try again or add manually.");
                  setModalMode("normal"); // Go back if nothing found
              } else {
                  setQuickAddItems(results);
                  setSelectedQuickAddIndices(new Set(results.map((_, i) => i))); // Select all initially
              }
          } else {
              Alert.alert("Error", "Could not select image."); setModalMode("normal");
          }
      } catch (error: any) {
          console.error("Error during Quick Add image process:", error);
          Alert.alert("Analysis Failed", error.message || "An error occurred during image analysis.");
          setModalMode("normal"); setQuickAddItems([]); setSelectedQuickAddIndices(new Set());
      } finally {
          setTimeout(() => setQuickAddLoading(false), 150);
      }
  }, [isEditMode, handleSelectFood, updateSearch, setGrams]); // Dependencies for pickImageAndAnalyze

  const handleQuickAddImage = useCallback(async () => {
      Keyboard.dismiss();
      if (isEditMode) return;
      if (editingQuickAddItemIndex !== null) {
          Alert.alert("Finish Editing", "Please save or cancel the current edit first."); return;
      }
      Alert.alert("Quick Add from Image", "Identify multiple foods from an image.",
          [ { text: "Cancel", style: "cancel" },
            { text: "Camera", onPress: () => pickImageAndAnalyze("camera") },
            { text: "Gallery", onPress: () => pickImageAndAnalyze("gallery") }, ]
      );
  }, [isEditMode, editingQuickAddItemIndex, pickImageAndAnalyze]); // Now pickImageAndAnalyze is declared above

  const handleToggleQuickAddItem = useCallback((index: number) => {
      if (editingQuickAddItemIndex !== null) return;
      setSelectedQuickAddIndices((prev) => {
          const newSet = new Set(prev);
          if (newSet.has(index)) newSet.delete(index);
          else newSet.add(index);
          return newSet;
      });
  }, [editingQuickAddItemIndex]);

  const handleEditQuickAddItem = useCallback((index: number) => {
      if (editingQuickAddItemIndex !== null) {
          Alert.alert("Finish Editing", "Please save or cancel the current edit first."); return;
      }
      const item = quickAddItems[index];
      setEditingQuickAddItemIndex(index);
      setEditedFoodName(item.foodName);
      setEditedGrams(String(Math.round(item.estimatedWeightGrams)));
  }, [editingQuickAddItemIndex, quickAddItems]);

  const handleSaveQuickAddItemEdit = useCallback(() => {
      if (editingQuickAddItemIndex === null) return;

      const trimmedName = editedFoodName.trim();
      if (!trimmedName) { Alert.alert("Invalid Name", "Food name cannot be empty."); return; }
      const numericGrams = parseFloat(editedGrams);
      if (!isValidNumberInput(editedGrams) || numericGrams <= 0) { Alert.alert("Invalid Grams", "Please enter a valid positive number."); return; }
      const roundedGrams = Math.round(numericGrams);

      setQuickAddItems((prevItems) =>
          prevItems.map((item, index) =>
              index === editingQuickAddItemIndex
                  ? { ...item, foodName: trimmedName, estimatedWeightGrams: roundedGrams }
                  : item
          )
      );

      setEditingQuickAddItemIndex(null);
      setEditedFoodName("");
      setEditedGrams("");
      Keyboard.dismiss();
  }, [editingQuickAddItemIndex, editedFoodName, editedGrams]);

  const handleCancelQuickAddItemEdit = useCallback(() => {
      setEditingQuickAddItemIndex(null);
      setEditedFoodName("");
      setEditedGrams("");
      Keyboard.dismiss();
  }, []);

  const handleConfirmQuickAdd = useCallback(() => {
      Keyboard.dismiss();
      if (isEditMode || editingQuickAddItemIndex !== null || selectedQuickAddIndices.size === 0) {
         if(editingQuickAddItemIndex !== null) Alert.alert("Finish Editing", "Save or cancel your edit before adding.");
         else if(selectedQuickAddIndices.size === 0) Alert.alert("No Items Selected", "Select items to add.");
        return;
      }

      try {
          const entriesToAdd: { food: Food; grams: number }[] = [];
          Array.from(selectedQuickAddIndices).forEach((index) => {
               if (index >= 0 && index < quickAddItems.length) { // Bounds check
                  const item = quickAddItems[index];
                  const quickFood: Food = {
                      id: uuidv4(), name: item.foodName,
                      calories: Math.round(Number(item.calories_per_100g) || 0),
                      protein: Math.round(Number(item.protein_per_100g) || 0),
                      carbs: Math.round(Number(item.carbs_per_100g) || 0),
                      fat: Math.round(Number(item.fat_per_100g) || 0),
                  };
                  const entryGrams = Math.max(1, Math.round(Number(item.estimatedWeightGrams) || 1));
                  entriesToAdd.push({ food: quickFood, grams: entryGrams });
               } else {
                   console.warn(`Skipping invalid index ${index} during quick add confirm.`);
               }
          });

          if (entriesToAdd.length > 0) {
               handleAddMultipleEntries(entriesToAdd);
               // toggleOverlay(); // Decide if you want to close the modal automatically
          } else {
               Alert.alert("Nothing to Add", "No valid items were selected.");
          }

      } catch (error) {
          console.error("Error confirming Quick Add:", error);
          Alert.alert("Error", "Could not prepare items to add.");
      }
  }, [quickAddItems, selectedQuickAddIndices, editingQuickAddItemIndex, handleAddMultipleEntries, isEditMode]);


  const handleQuickAddGramsChange = useCallback((text: string) => {
      const cleanedText = text.replace(/[^0-9.]/g, "").replace(/(\..*)\./g, "$1");
      setEditedGrams(cleanedText);
  }, []);

  // --- Computed States ---
  const isActionDisabled = isAiLoading || (quickAddLoading && modalMode === 'quickAddSelect');
  const isAddButtonDisabled = modalMode !== "normal" || !selectedFood || !isValidNumberInput(grams) || parseFloat(grams) <= 0 || isAiLoading;
  const isAiButtonDisabled = modalMode !== "normal" || !selectedFood || !autoInput.trim() || isAiLoading;
  const isQuickAddConfirmDisabled = isEditMode || modalMode !== "quickAddSelect" || selectedQuickAddIndices.size === 0 || editingQuickAddItemIndex !== null || quickAddLoading;
  const isQuickAddImageButtonDisabled = isEditMode || isAiLoading || quickAddLoading;

  // --- Build list data for the main FlatList ---
  const listData = useMemo((): ListItemType[] => {
      const items: ListItemType[] = [];

      // --- NORMAL MODE ---
      if (modalMode === "normal") {
          items.push({ type: "searchBar", key: "searchBar" });

          if (!search && recentFoods.length > 0) {
              items.push({ type: "recentFoods", key: "recentFoods" });
          }

          if (search) {
              if (filteredFoods.length > 0) {
                  filteredFoods.forEach((food) =>
                      items.push({ type: "searchResults", key: `search-${food.id}`, data: food })
                  );
              } else {
                  items.push({ type: "noResults", key: "noResults" });
              }
          }

          if (selectedFood) {
              items.push({ type: "amountInput", key: "amountInput" });
          }
      }
      // --- QUICK ADD MODE ---
      else if (modalMode === "quickAddSelect") {
           items.push({ type: "quickAddHeader", key: "quickAddHeader" });

           if (quickAddLoading) {
               items.push({ type: "quickAddLoading", key: "quickAddLoading"});
           } else if (quickAddItems.length > 0) {
               quickAddItems.forEach((item, index) => {
                   if (editingQuickAddItemIndex === index) {
                       items.push({ type: "quickAddEditForm", key: `qa-edit-${index}`, index });
                   } else {
                       items.push({ type: "quickAddItem", key: `qa-${index}`, data: item, index });
                   }
               });
           } else {
               // Optionally show a "No items found" message here if needed after loading
           }
      }

      items.push({ type: "spacer", key: "bottom-spacer", height: 60 });

      return items;
  }, [
      modalMode, search, recentFoods, filteredFoods, selectedFood,
      quickAddLoading, quickAddItems, editingQuickAddItemIndex,
  ]);

  // --- Render individual item types for the main FlatList ---
  const renderListItem = useCallback(({ item }: { item: ListItemType }): React.ReactElement | null => {
      switch (item.type) {
          case "searchBar":
              return (
                  <SearchBar
                      placeholder="Search Foods..."
                      onChangeText={updateSearch}
                      value={search}
                      platform={Platform.OS === "ios" ? "ios" : "android"}
                      containerStyle={styles.searchBarContainer}
                      inputContainerStyle={styles.searchBarInputContainer}
                      inputStyle={styles.searchInputStyle}
                      onCancel={() => updateSearch("")}
                      showCancel={Platform.OS === 'ios'}
                      onClear={() => updateSearch("")}
                      disabled={isActionDisabled || modalMode !== 'normal'}
                  />
              );

          case "recentFoods":
              if (!recentFoods || recentFoods.length === 0) {
                   return null;
               }
              return (
                   <View style={styles.recentFoodsSection}>
                       <Text style={styles.sectionTitle}>Recent</Text>
                       <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={styles.recentFoodsContainer}>
                           {recentFoods.map((food) => (
                               <TouchableOpacity
                                   key={`recent-${food.id}`}
                                   style={[styles.recentFoodItem, screenWidth < 350 && styles.smallRecentFoodItem, selectedFood?.id === food.id && styles.selectedRecentFoodItem]}
                                   onPress={() => handleInternalSelectFood(food)}
                                   disabled={isActionDisabled}
                                   >
                                   {foodIcons[food.name] !== undefined ? (
                                       foodIcons[food.name] ? (
                                           <Image source={{ uri: foodIcons[food.name] as string }} style={styles.foodIconSmall} onError={() => setFoodIcons((prev) => ({ ...prev, [food.name]: null }))}/>
                                       ) : (
                                           <View style={[styles.foodIconSmall, styles.iconPlaceholderSmall]}><Icon name="fastfood" type="material" size={12} color={theme.colors.grey2} /></View>
                                       )
                                   ) : (
                                       <ActivityIndicator size="small" color={theme.colors.grey3} style={styles.foodIconSmall} />
                                   )}
                                   <Text style={[styles.recentFoodText, screenWidth < 350 && styles.smallRecentFoodText]} numberOfLines={1} ellipsizeMode="tail">
                                       {food.name}
                                   </Text>
                               </TouchableOpacity>
                           ))}
                       </ScrollView>
                   </View>
               );

          case "searchResults": {
              const food = item.data;
              return (
                  <TouchableOpacity onPress={() => handleInternalSelectFood(food)} disabled={isActionDisabled}>
                      <ListItem bottomDivider containerStyle={[styles.listItemContainer, selectedFood?.id === food.id && styles.selectedListItem]}>
                           {foodIcons[food.name] !== undefined ? (
                              foodIcons[food.name] ? (
                                  <Image source={{ uri: foodIcons[food.name] as string }} style={styles.foodIcon} onError={() => setFoodIcons((prev) => ({ ...prev, [food.name]: null }))} />
                              ) : (
                                  <View style={styles.defaultIconContainer}><Icon name="restaurant" type="material" size={18} color={theme.colors.grey3} /></View>
                              )
                          ) : (
                              <ActivityIndicator size="small" color={theme.colors.grey3} style={styles.foodIcon} />
                          )}
                          <ListItem.Content>
                              <ListItem.Title style={styles.listItemTitle}>{food.name}</ListItem.Title>
                          </ListItem.Content>
                          {selectedFood?.id === food.id && (
                              <Icon name="checkmark-circle" type="ionicon" color={theme.colors.primary} size={24} />
                          )}
                      </ListItem>
                  </TouchableOpacity>
              );
          }

          case "noResults":
               return <Text style={styles.noFoodsText}> No foods found matching "{search}". </Text>;

          case "amountInput":
              if (!selectedFood) {
                  return null;
              }
              return (
                  <View style={styles.amountSection}>
                      <View style={styles.unitSelectorContainer}>
                          <Text style={styles.inputLabel}>Amount</Text>
                          <ButtonGroup
                              buttons={["Grams", "Auto (AI)"]}
                              selectedIndex={unitMode === "grams" ? 0 : 1}
                              onPress={(index) => !isActionDisabled && setUnitMode(index === 0 ? "grams" : "auto")}
                              containerStyle={styles.buttonGroupContainer}
                              selectedButtonStyle={{ backgroundColor: theme.colors.primary }}
                              textStyle={styles.buttonGroupText}
                              selectedTextStyle={{ color: theme.colors.white }}
                              disabled={isEditMode ? [1] : (isActionDisabled ? [0, 1] : [])}
                              disabledStyle={{ backgroundColor: theme.colors.grey5 }}
                              disabledTextStyle={{ color: theme.colors.grey3 }}
                          />
                      </View>

                      {unitMode === "grams" && (
                          <>
                              {!isEditMode && servingSizeSuggestions.length > 0 && (
                                  <View style={styles.servingSizeRow}>
                                      <Text style={styles.servingSizeLabel}>Quick Add:</Text>
                                      <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={styles.servingSizeContainer}>
                                          {servingSizeSuggestions.map((suggestion) => (
                                              <TouchableOpacity key={suggestion.label} style={styles.servingSizeButton} onPress={() => !isActionDisabled && setGrams(suggestion.value)} disabled={isActionDisabled}>
                                                  <Text style={styles.servingSizeButtonTitle}>{suggestion.label}</Text>
                                              </TouchableOpacity>
                                          ))}
                                      </ScrollView>
                                  </View>
                              )}
                              <Input
                                  placeholder={isEditMode ? "Update grams" : "Enter grams (e.g., 150)"}
                                  keyboardType="numeric" value={grams}
                                  onChangeText={(text) => {
                                      const cleanedText = text.replace(/[^0-9.]/g, "").replace(/(\..*)\./g, "$1");
                                      setGrams(cleanedText);
                                  }}
                                  inputStyle={styles.gramInputStyle}
                                  inputContainerStyle={styles.gramInputContainerStyle}
                                  errorMessage={!isValidNumberInput(grams) && grams !== "" && grams !== "." ? "Enter a valid number" : ""}
                                  errorStyle={{ color: theme.colors.error }}
                                  rightIcon={<Text style={styles.unitText}>g</Text>}
                                  containerStyle={{ paddingHorizontal: 0 }}
                                  key={`grams-input-${selectedFood.id}`}
                                  disabled={isActionDisabled}
                              />
                          </>
                      )}

                      {unitMode === "auto" && !isEditMode && (
                          <View style={styles.autoInputRow}>
                              <Input
                                  placeholder="Describe quantity (e.g., 1 cup cooked)"
                                  value={autoInput} onChangeText={setAutoInput}
                                  inputStyle={[styles.gramInputStyle, styles.autoInputField]}
                                  inputContainerStyle={styles.gramInputContainerStyle}
                                  containerStyle={styles.autoInputContainer}
                                  multiline={false}
                                  onSubmitEditing={handleEstimateGrams}
                                  key={`auto-input-${selectedFood.id}`}
                                  disabled={isActionDisabled}
                              />
                              <Button
                                  onPress={handleEstimateGrams}
                                  disabled={isAiButtonDisabled || isActionDisabled}
                                  loading={isAiLoading}
                                  buttonStyle={styles.aiButton}
                                  icon={isAiLoading ? undefined : (<Icon name="calculator-variant" type="material-community" size={20} color={theme.colors.white} />)}
                                  title={isAiLoading ? '' : ''}
                              />
                          </View>
                      )}
                  </View>
              );

          case "quickAddHeader":
              return (
                   <View style={styles.quickAddHeader}>
                      <Text style={styles.sectionTitle}>
                          {editingQuickAddItemIndex !== null ? "Editing Item Details" : "Select Items from Image"}
                      </Text>
                      {editingQuickAddItemIndex === null && (
                          <Button type="clear" title="Back"
                              onPress={() => {
                                  setModalMode("normal");
                                  setQuickAddItems([]);
                                  setSelectedQuickAddIndices(new Set());
                                  setEditingQuickAddItemIndex(null);
                              }}
                              titleStyle={{ color: theme.colors.primary, fontSize: 14 }}
                              icon={<Icon name="arrow-back" type="ionicon" size={18} color={theme.colors.primary} />}
                              disabled={quickAddLoading}
                          />
                      )}
                  </View>
              );

          case "quickAddLoading":
              return (
                   <View style={styles.centeredContent}>
                      <ActivityIndicator size="large" color={theme.colors.primary} />
                      <Text style={styles.loadingText}>Analyzing Image...</Text>
                  </View>
              );

          case "quickAddItem": {
              const { data: itemData, index } = item;
              const isSelected = selectedQuickAddIndices.has(index);
              return (
                  <ListItem
                       bottomDivider
                       containerStyle={[
                          styles.quickAddItemContainer,
                          isSelected && styles.quickAddItemSelected,
                       ]}
                       onPress={() => handleToggleQuickAddItem(index)}
                       disabled={editingQuickAddItemIndex !== null || isActionDisabled}
                       >
                       <ListItem.Content style={styles.quickAddItemContent}>
                          <ListItem.Title style={styles.quickAddItemTitle} numberOfLines={1}>
                              {itemData.foodName}
                          </ListItem.Title>
                          <ListItem.Subtitle style={styles.quickAddItemSubtitle}>
                              {`~${Math.round(itemData.estimatedWeightGrams)}g`}
                              {itemData.calories_per_100g ? ` (${Math.round(itemData.calories_per_100g * itemData.estimatedWeightGrams / 100)} kcal)` : ''}
                          </ListItem.Subtitle>
                      </ListItem.Content>
                      <View style={styles.quickAddItemActions}>
                         <TouchableOpacity onPress={() => handleEditQuickAddItem(index)} disabled={editingQuickAddItemIndex !== null || isActionDisabled} style={styles.quickAddActionButton}>
                              <Icon name="pencil" type="material-community" size={20} color={theme.colors.primary} />
                         </TouchableOpacity>
                          <Icon
                              name={isSelected ? "checkbox-marked" : "checkbox-blank-outline"}
                              type="material-community"
                              color={isSelected ? theme.colors.success : theme.colors.grey3}
                              size={24}
                              containerStyle={styles.quickAddCheckbox}
                              />
                      </View>
                  </ListItem>
              );
          }

          case "quickAddEditForm": {
               const { index } = item;
               return (
                  <View style={styles.quickAddEditContainer}>
                      <Input
                          label="Food Name"
                          placeholder="Enter food name"
                          value={editedFoodName}
                          onChangeText={setEditedFoodName}
                          inputContainerStyle={styles.quickAddEditInput}
                          inputStyle={{fontSize: 15}}
                          labelStyle={{fontSize: 13, fontWeight:'normal', color: theme.colors.grey2}}
                          disabled={isActionDisabled}
                      />
                      <Input
                          label="Estimated Grams"
                          placeholder="Enter grams"
                          value={editedGrams}
                          onChangeText={handleQuickAddGramsChange}
                          keyboardType="numeric"
                          inputContainerStyle={styles.quickAddEditInput}
                           inputStyle={{fontSize: 15}}
                          labelStyle={{fontSize: 13, fontWeight:'normal', color: theme.colors.grey2}}
                          rightIcon={<Text style={styles.unitText}>g</Text>}
                          disabled={isActionDisabled}
                      />
                      <View style={styles.quickAddEditButtons}>
                          <Button title="Cancel" type="outline" onPress={handleCancelQuickAddItemEdit} buttonStyle={styles.quickAddEditButton} titleStyle={styles.quickAddEditButtonTitle} disabled={isActionDisabled} />
                          <Button title="Save" onPress={handleSaveQuickAddItemEdit} buttonStyle={[styles.quickAddEditButton, {backgroundColor: theme.colors.primary}]} titleStyle={[styles.quickAddEditButtonTitle, {color: theme.colors.white}]} disabled={isActionDisabled}/>
                      </View>
                  </View>
               );
          }

          case "spacer":
              return <View style={{ height: item.height }} />;

          default:
              return null;
      }
  }, [
      // IMPORTANT: Keep ALL dependencies used inside the switch cases here
      search, updateSearch, isActionDisabled, modalMode, recentFoods, screenWidth, selectedFood, foodIcons, setFoodIcons,
      handleInternalSelectFood, filteredFoods, unitMode, setUnitMode, isEditMode, servingSizeSuggestions, setGrams, grams,
      autoInput, setAutoInput, handleEstimateGrams, isAiLoading, isAiButtonDisabled, theme, styles,
      quickAddLoading, quickAddItems, editingQuickAddItemIndex, selectedQuickAddIndices, handleToggleQuickAddItem, handleEditQuickAddItem,
      editedFoodName, setEditedFoodName, editedGrams, handleQuickAddGramsChange, handleCancelQuickAddItemEdit, handleSaveQuickAddItemEdit,
      handleAddMultipleEntries, pickImageAndAnalyze, addToRecentFoods, handleAddEntry, // Added missing function dependencies
  ]);

  // --- Render ---
  const combinedOverlayStyle = StyleSheet.flatten([
      styles.overlayStyle,
      { backgroundColor: theme.colors.background },
  ]);

  return (
      <Overlay
          isVisible={isVisible}
          onBackdropPress={!isActionDisabled ? toggleOverlay : undefined}
          animationType="slide"
          overlayStyle={styles.overlayContainer}
      >
          <KeyboardAvoidingView
              behavior={Platform.OS === "ios" ? "padding" : "height"}
              style={styles.keyboardAvoidingView}
              keyboardVerticalOffset={KEYBOARD_VERTICAL_OFFSET}
          >
              <View style={combinedOverlayStyle}>
                  {/* Header (Stays Fixed) */}
                  <View style={styles.header}>
                      <TouchableOpacity onPress={!isActionDisabled ? toggleOverlay : undefined} style={styles.closeIconTouchable} disabled={isActionDisabled}>
                          <Icon name="close" type="material" size={28} color={isActionDisabled ? theme.colors.grey3 : theme.colors.text} />
                      </TouchableOpacity>

                      <Text h4 h4Style={[styles.overlayTitle, isEditMode && modalMode === "normal" && styles.editModeTitle]} numberOfLines={1} ellipsizeMode="tail">
                          {modalMode === "quickAddSelect"
                              ? editingQuickAddItemIndex !== null ? "Edit Item" : "Select Items to Add"
                              : isEditMode ? "Edit Entry" : "Add Entry"
                          }
                      </Text>

                      {modalMode === "normal" && (
                          <>
                              {!isEditMode && (
                                  <TouchableOpacity onPress={handleQuickAddImage} disabled={isQuickAddImageButtonDisabled} style={styles.headerIcon}>
                                      {(quickAddLoading && modalMode === 'normal') ? (
                                          <ActivityIndicator size="small" color={theme.colors.primary} />
                                      ) : (
                                          <Icon name="camera-burst" type="material-community" size={26} color={isQuickAddImageButtonDisabled ? theme.colors.grey3 : theme.colors.primary} />
                                      )}
                                  </TouchableOpacity>
                              )}
                              <Button
                                  title={isEditMode ? "Update" : "Add"}
                                  onPress={handleAddOrUpdateSingleEntry}
                                  disabled={isAddButtonDisabled}
                                  buttonStyle={[styles.addButton, isEditMode && styles.updateButton]}
                                  titleStyle={styles.buttonTitle}
                                  loading={isAiLoading && unitMode === 'auto'}
                              />
                          </>
                      )}
                      {modalMode === "quickAddSelect" && !isEditMode && (
                          editingQuickAddItemIndex === null ? (
                              <Button
                                  title={`Add ${selectedQuickAddIndices.size}`}
                                  onPress={handleConfirmQuickAdd}
                                  disabled={isQuickAddConfirmDisabled}
                                  buttonStyle={[styles.addButton, { backgroundColor: theme.colors.success }]}
                                  titleStyle={styles.buttonTitle}
                                  loading={quickAddLoading}
                              />
                          ) : (
                              <View style={{ width: 70, marginLeft: 5}} /> // Placeholder to balance header
                          )
                      )}
                  </View>

                  {/* --- Content Area (Now a FlatList) --- */}
                  <FlatList
                      data={listData}
                      renderItem={renderListItem}
                      keyExtractor={(item) => item.key}
                      extraData={{ // All state that renderListItem depends on indirectly
                          selectedFood,
                          grams,
                          unitMode,
                          autoInput,
                          isAiLoading,
                          search,
                          foodIcons,
                          modalMode,
                          quickAddItems,
                          selectedQuickAddIndices,
                          editingQuickAddItemIndex,
                          editedFoodName,
                          editedGrams,
                          isActionDisabled,
                          quickAddLoading,
                      }}
                      style={styles.flatListContainer}
                      contentContainerStyle={styles.flatListContentContainer}
                      keyboardShouldPersistTaps="handled"
                      initialNumToRender={10}
                      maxToRenderPerBatch={10}
                      windowSize={5}
                  />
              </View>
          </KeyboardAvoidingView>
          <Toast />
      </Overlay>
  );
};

// --- Styles ---
const useStyles = makeStyles((theme) => ({
  overlayContainer: {
      backgroundColor: "transparent", width: "90%", maxWidth: 500, padding: 0,
      borderRadius: 15, shadowColor: "#000", shadowOffset: { width: 0, height: 3 },
      shadowOpacity: 0.2, shadowRadius: 5, elevation: 6, overflow: "hidden",
      maxHeight: Dimensions.get("window").height * 0.85,
  },
  overlayStyle: {
      width: "100%", height: "100%", borderRadius: 15, padding: 15, paddingBottom: 0,
      backgroundColor: theme.colors.background, flex: 1,
  },
  keyboardAvoidingView: { width: "100%", height: "100%" },
  header: {
      flexDirection: "row", justifyContent: "space-between", alignItems: "center",
      marginBottom: 15, paddingHorizontal: 0,
  },
  closeIconTouchable: { padding: 5, zIndex: 1 },
  overlayTitle: {
      color: theme.colors.text, fontWeight: "bold", fontSize: 20, textAlign: "center",
      flex: 1, marginHorizontal: 5,
  },
  editModeTitle: { color: theme.colors.warning },
  headerIcon: { padding: 5, marginHorizontal: 5, zIndex: 1 },
  addButton: {
      borderRadius: 20, paddingHorizontal: 15, paddingVertical: 8, minWidth: 70,
      marginLeft: 5, backgroundColor: theme.colors.primary, zIndex: 1,
  },
  updateButton: { backgroundColor: theme.colors.warning },
  buttonTitle: { color: theme.colors.white, fontWeight: "600", fontSize: 15 },
  flatListContainer: { flex: 1, width: '100%' },
  flatListContentContainer: { paddingBottom: 30 },
  searchBarContainer: {
      backgroundColor: "transparent", borderBottomColor: "transparent", borderTopColor: "transparent",
      paddingHorizontal: 0, marginBottom: 10,
  },
  searchBarInputContainer: {
      borderRadius: 25, backgroundColor: theme.colors.searchBg || theme.colors.grey5, height: 40,
  },
  searchInputStyle: { color: theme.colors.text, fontSize: 15 },
  recentFoodsSection: { marginBottom: 15 },
  sectionTitle: {
      fontWeight: "600", marginBottom: 8, color: theme.colors.text, fontSize: 14,
      marginLeft: 5, textTransform: "uppercase",
  },
  recentFoodsContainer: { paddingHorizontal: 5, paddingVertical: 2 },
  recentFoodItem: {
      paddingHorizontal: 10, paddingVertical: 6, borderRadius: 16,
      backgroundColor: theme.colors.grey5, marginRight: 8, flexDirection: "row",
      alignItems: "center", borderWidth: 1.5, borderColor: "transparent",
  },
  selectedRecentFoodItem: { borderColor: theme.colors.primary },
  smallRecentFoodItem: { paddingHorizontal: 8, paddingVertical: 5 },
  foodIconSmall: {
      width: 20, height: 20, marginRight: 6, borderRadius: 10, resizeMode: "contain",
      alignItems: "center", justifyContent: "center", backgroundColor: theme.colors.grey4,
  },
  iconPlaceholderSmall: {
      backgroundColor: theme.colors.grey4, alignItems: "center", justifyContent: "center",
  },
  recentFoodText: { color: theme.colors.text, fontSize: 13, maxWidth: 80 },
  smallRecentFoodText: { fontSize: 12, maxWidth: 70 },
  listItemContainer: {
      backgroundColor: "transparent", paddingVertical: 8, paddingHorizontal: 5,
      borderBottomColor: theme.colors.divider,
  },
  selectedListItem: { backgroundColor: theme.colors.grey5, borderRadius: 8 },
  defaultIconContainer: {
      width: 35, height: 35, marginRight: 12, borderRadius: 17.5,
      backgroundColor: theme.colors.grey5, alignItems: "center", justifyContent: "center",
  },
  foodIcon: {
      width: 35, height: 35, marginRight: 12, borderRadius: 17.5, resizeMode: "contain",
      backgroundColor: theme.colors.grey5, alignItems: "center", justifyContent: "center",
  },
  listItemTitle: { color: theme.colors.text, fontSize: 16, fontWeight: "500" },
  noFoodsText: {
      color: theme.colors.grey2, fontStyle: "italic", textAlign: "center",
      marginTop: 20, marginBottom: 10, paddingHorizontal: 10,
  },
  amountSection: {
      marginTop: 10, borderTopWidth: 1, borderTopColor: theme.colors.divider,
      paddingTop: 15, paddingHorizontal: 0,
  },
  unitSelectorContainer: {
      flexDirection: "row", alignItems: "center", justifyContent: "space-between",
      marginBottom: 15, paddingHorizontal: 5,
  },
  inputLabel: {
      fontWeight: "600", color: theme.colors.grey1, fontSize: 14, marginRight: 10,
      textTransform: "uppercase",
  },
  buttonGroupContainer: {
      flex: 0.7, maxWidth: 220, height: 35, borderRadius: 8,
      borderColor: theme.colors.primary, borderWidth: 1,
      backgroundColor: theme.colors.background,
  },
  buttonGroupText: { fontSize: 14, color: theme.colors.text },
  servingSizeRow: {
      flexDirection: "row", alignItems: "center", marginBottom: 12, paddingHorizontal: 5,
  },
  servingSizeLabel: { color: theme.colors.grey2, fontSize: 13, marginRight: 8 },
  servingSizeContainer: { flexGrow: 0 },
  servingSizeButton: {
      backgroundColor: theme.colors.grey4, borderRadius: 15, marginRight: 8,
      paddingHorizontal: 12, paddingVertical: 5, justifyContent: "center",
      alignItems: "center", height: 30,
  },
  servingSizeButtonTitle: { color: theme.colors.text, fontSize: 13 },
  gramInputStyle: { color: theme.colors.text, fontSize: 16, paddingVertical: 8, height: 40, },
  gramInputContainerStyle: { borderBottomColor: theme.colors.grey3, paddingHorizontal: 5, },
  unitText: { color: theme.colors.grey2, fontSize: 15, fontWeight: "500", paddingRight: 5, },
  autoInputRow: { flexDirection: "row", alignItems: "center", paddingHorizontal: 0 },
  autoInputContainer: { flex: 1, paddingHorizontal: 0, marginRight: 10 },
  autoInputField: { height: 40 },
  aiButton: {
      backgroundColor: theme.colors.secondary, borderRadius: 20, width: 40, height: 40,
      padding: 0, justifyContent: "center", alignItems: "center", minWidth: 40,
  },
  quickAddHeader: {
      flexDirection: "row", justifyContent: "space-between", alignItems: "center",
      marginBottom: 10, paddingHorizontal: 5, borderBottomWidth: 1,
      borderBottomColor: theme.colors.divider, paddingBottom: 8,
  },
  centeredContent: {
      alignItems: 'center', justifyContent: 'center', padding: 20, minHeight: 150,
  },
  loadingText: { marginTop: 10, color: theme.colors.text, fontSize: 16, fontWeight: "500" },
  quickAddItemContainer: {
      paddingVertical: 10, paddingHorizontal: 5,
      backgroundColor: theme.colors.background,
  },
   quickAddItemSelected: {
      backgroundColor: theme.colors.grey5, borderRadius: 8,
  },
  quickAddItemContent: { flex: 1, marginRight: 10 },
   quickAddItemTitle: { color: theme.colors.text, fontWeight: '500', fontSize: 15 },
  quickAddItemSubtitle: { color: theme.colors.grey1, fontSize: 13, marginTop: 2 },
  quickAddItemActions: { flexDirection: 'row', alignItems: 'center' },
  quickAddActionButton: { padding: 5, marginRight: 10 },
  quickAddCheckbox: {},
   quickAddEditContainer: {
      padding: 10, marginVertical: 5, backgroundColor: theme.colors.grey5,
      borderRadius: 8, borderWidth: 1, borderColor: theme.colors.primary,
  },
  quickAddEditInput: {
      borderBottomWidth: 1, borderColor: theme.colors.grey3,
      paddingHorizontal: 0, marginBottom: 5,
  },
   quickAddEditButtons: {
      flexDirection: 'row', justifyContent: 'flex-end', marginTop: 10,
  },
  quickAddEditButton: {
      marginLeft: 10, paddingHorizontal: 15, minWidth: 80, borderRadius: 15,
  },
  quickAddEditButtonTitle: { fontSize: 14, fontWeight: '600' }
}));

export default AddEntryModal;
---------- END AddEntryModal.tsx ----------


---------- AddFoodModal.tsx ----------
// src/components/AddFoodModal.tsx
// components/AddFoodModal.tsx (Integrate Backend, Handle Errors)
import React, { useState, useEffect } from "react";
import {
  View,
  KeyboardAvoidingView,
  Platform,
  ActivityIndicator,
  Alert,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
} from "react-native";
import {
  Button,
  Input,
  Text,
  Overlay,
  makeStyles,
  useTheme,
  Icon,
} from "@rneui/themed";
import { Food } from "../types/food";
import { MaterialCommunityIcons } from "@expo/vector-icons";
import Toast from "react-native-toast-message";
// Import backend service functions and error type
import {
    getMacrosFromText, // Renamed utility function using backend
    getMacrosForImageFile, // Utility function using backend
    getBase64FromUri, // Keep utility
    BackendError
} from "../utils/macros";
import * as ImagePicker from "expo-image-picker";
import { ImagePickerAsset, ImagePickerResult } from 'expo-image-picker';
import { isValidNumberInput, isNotEmpty } from "../utils/validationUtils";

interface AddFoodModalProps {
  isVisible: boolean;
  toggleOverlay: () => void;
  newFood: Omit<Food, "id">;
  editFood: Food | null;
  errors: { [key: string]: string };
  handleInputChange: (
    key: keyof Omit<Food, "id">,
    value: string,
    isEdit: boolean
  ) => void;
  handleCreateFood: () => void; // Still used to update local list state
  handleUpdateFood: () => void; // Still used to update local list state
  validateFood: (food: Omit<Food, "id">) => { [key: string]: string } | null;
  setErrors: React.Dispatch<React.SetStateAction<{ [key: string]: string }>>;
}

const KEYBOARD_VERTICAL_OFFSET = Platform.OS === "ios" ? 60 : 0;

const AddFoodModal: React.FC<AddFoodModalProps> = ({
  isVisible,
  toggleOverlay,
  newFood,
  editFood,
  errors,
  handleInputChange,
  handleCreateFood,
  handleUpdateFood,
  validateFood,
  setErrors,
}) => {
  const { theme } = useTheme();
  const styles = useStyles();
  const [loading, setLoading] = useState(false); // For save/update button
  const [apiLoading, setApiLoading] = useState(false); // General API loading (may not be needed)
  const [mode, setMode] = useState<"normal" | "ingredients">("normal");
  const [ingredients, setIngredients] = useState("");
  const [aiButtonLoading, setAiButtonLoading] = useState(false); // For ingredient text AI
  const [imageLoading, setImageLoading] = useState(false); // For image analysis AI

  useEffect(() => {
    if (isVisible) {
      setErrors({});
      setMode("normal");
      setIngredients("");
      setAiButtonLoading(false);
      setImageLoading(false);
      setLoading(false);
    }
  }, [isVisible, setErrors]);

  const getValue = (key: keyof Omit<Food, "id">) => {
    const value = (editFood && editFood[key]) ?? newFood[key] ?? "";
    if (!editFood && typeof value === 'number' && value === 0 && key !== 'name') {
        return "";
    }
    if (editFood && typeof value === 'number' && value === 0 && key !== 'name') {
        return "0";
    }
    return String(value);
  };

  // Handles local state update and triggers parent save/update
  const handleCreateOrUpdate = async (isUpdate: boolean) => {
    setLoading(true);
    const foodData = isUpdate ? editFood : newFood;
    if (!foodData) {
        setLoading(false);
        return;
    }

     const dataToValidate: Omit<Food, "id"> = {
        ...foodData,
        name: String(foodData.name).trim(),
        calories: parseFloat(getValue("calories")) || 0,
        protein: parseFloat(getValue("protein")) || 0,
        carbs: parseFloat(getValue("carbs")) || 0,
        fat: parseFloat(getValue("fat")) || 0,
    };

    const validationErrors = validateFood(dataToValidate);

    if (validationErrors) {
      setErrors(validationErrors);
      setLoading(false);
      Toast.show({
        type: "error", text1: "Please fix the errors", position: 'bottom',
      });
      return;
    }
    setErrors({});

    try {
      // Call the parent function which handles storage/state update
      if (isUpdate) {
          await handleUpdateFood();
      } else {
          await handleCreateFood();
      }

      Toast.show({
        type: "success",
        text1: `Food ${isUpdate ? "Updated" : "Created"} Successfully!`,
        position: 'bottom',
      });
      toggleOverlay(); // Close modal on success
    } catch (error: any) {
        // Errors during storage save (handled by parent) might show alerts
        // This catch block is more for unexpected issues during the call
      console.error(`Error during ${isUpdate ? 'update' : 'create'} food handler:`, error);
      Alert.alert(
        "Error",
        error.message || `Failed to ${isUpdate ? "update" : "create"} food.`
      );
    } finally {
      setLoading(false);
    }
  };

  // Uses backend service for recipe text analysis
  const handleAiButtonClick = async () => {
    const foodName = getValue("name");
    if (!foodName && mode === 'ingredients') {
      Alert.alert("Missing Name", "Please enter a food name first.");
      return;
    }

    if (mode === "normal") {
      setMode("ingredients");
      handleInputChange("calories", "", !!editFood);
      handleInputChange("protein", "", !!editFood);
      handleInputChange("carbs", "", !!editFood);
      handleInputChange("fat", "", !!editFood);
    } else if (mode === "ingredients") {
      const currentFoodName = getValue("name");
      if (!currentFoodName) {
        Alert.alert("Missing Name", "Please enter a food name before calculating macros.");
        return;
      }

      setAiButtonLoading(true);
      try {
        // Call the refactored utility function (uses backend)
        const macros = await getMacrosFromText(currentFoodName, ingredients);

        handleInputChange("calories", String(Math.round(macros.calories)), !!editFood);
        handleInputChange("protein", String(Math.round(macros.protein)), !!editFood);
        handleInputChange("carbs", String(Math.round(macros.carbs)), !!editFood);
        handleInputChange("fat", String(Math.round(macros.fat)), !!editFood);

        setMode("normal");
        Toast.show({ type: 'info', text1: 'Macros estimated from text.', position: 'bottom' });
      } catch (error) {
         // Alert is handled within getMacrosFromText utility now
         console.error("AI Macro fetch error (recipe - modal):", error);
         // Optional: Additional handling specific to this modal if needed
      } finally {
        setAiButtonLoading(false);
      }
    }
  };

  // Uses backend service for image analysis
  const handleGetImageAndAnalyze = async () => {

    const processImage = async (pickerResult: ImagePickerResult) => {
        if (pickerResult.canceled) {
            console.log("Image selection/capture cancelled");
            setImageLoading(false); // Stop loading if cancelled
            return;
        }

        if (pickerResult.assets && pickerResult.assets.length > 0) {
            const asset = pickerResult.assets[0];
            console.log("Image acquired:", asset.uri);
            setImageLoading(true); // Loading starts before backend call

            try {
                 // Call the refactored utility function (uses backend)
                 const result = await getMacrosForImageFile(asset); // Pass asset directly

                // Update form fields with results
                handleInputChange("name", result.foodName, !!editFood);
                handleInputChange("calories", String(Math.round(result.calories)), !!editFood);
                handleInputChange("protein", String(Math.round(result.protein)), !!editFood);
                handleInputChange("carbs", String(Math.round(result.carbs)), !!editFood);
                handleInputChange("fat", String(Math.round(result.fat)), !!editFood);

                setMode("normal");
                setIngredients("");

                Toast.show({
                    type: 'success',
                    text1: 'Food Identified!',
                    text2: `Identified as ${result.foodName}. Macros estimated.`,
                    position: 'bottom',
                });

            } catch (analysisError) {
                // Alert is handled within getMacrosForImageFile utility now
                console.error("Error during image analysis (modal):", analysisError);
                 // Optional: Specific modal handling if needed
            } finally {
                 setTimeout(() => setImageLoading(false), 100); // Stop loading
            }
        } else {
            console.log("No assets selected or returned.");
            setImageLoading(false); // Stop loading if no assets
        }
    };

    Alert.alert(
      "Get Image",
      "Choose a source for the food image:",
      [
        { text: "Cancel", style: "cancel", onPress: () => setImageLoading(false) }, // Ensure loading stops
        {
          text: "Camera",
          onPress: async () => {
            setImageLoading(true); // Indicate loading
            try {
                const permissionResult = await ImagePicker.requestCameraPermissionsAsync();
                if (!permissionResult.granted) {
                    Alert.alert("Permission Required", "Camera access is needed.");
                    setImageLoading(false); return;
                }
                const cameraResult = await ImagePicker.launchCameraAsync({ quality: 0.6 });
                await processImage(cameraResult);
            } catch (error) {
                console.error("Error launching camera:", error);
                Alert.alert("Camera Error", "Could not open the camera.");
                setImageLoading(false); // Stop loading on error
            }
          },
        },
        {
          text: "Gallery",
          onPress: async () => {
            setImageLoading(true); // Indicate loading
            try {
                const permissionResult = await ImagePicker.requestMediaLibraryPermissionsAsync();
                if (!permissionResult.granted) {
                    Alert.alert("Permission Required", "Gallery access needed.");
                    setImageLoading(false); return;
                }
                const libraryResult = await ImagePicker.launchImageLibraryAsync({
                    mediaTypes: ImagePicker.MediaTypeOptions.Images, quality: 0.6,
                });
                await processImage(libraryResult);
            } catch (error) {
                console.error("Error launching image library:", error);
                Alert.alert("Gallery Error", "Could not open the image library.");
                 setImageLoading(false); // Stop loading on error
            }
          },
        },
      ],
      { cancelable: true, onDismiss: () => setImageLoading(false) } // Stop loading if dismissed
    );
  };

    const combinedOverlayStyle = StyleSheet.flatten([
        styles.overlayStyle,
        { backgroundColor: theme.colors.background }
    ]);

    const isAnyLoading = loading || aiButtonLoading || imageLoading; // Combined loading state

  return (
    <Overlay
      isVisible={isVisible}
      onBackdropPress={!isAnyLoading ? toggleOverlay : undefined} // Prevent closing while loading
      animationType="fade"
      overlayStyle={styles.overlayContainer}
    >
      <KeyboardAvoidingView
        behavior={Platform.OS === "ios" ? "padding" : "height"}
        style={styles.keyboardAvoidingView}
        keyboardVerticalOffset={KEYBOARD_VERTICAL_OFFSET}
      >
        <View style={combinedOverlayStyle}>
          <View style={styles.header}>
            <Text h4 style={styles.overlayTitle}>
              {editFood ? "Edit Food" : "Add New Food"}
            </Text>
            <Button
              title={editFood ? "Update" : "Add"}
              onPress={() => handleCreateOrUpdate(!!editFood)}
              buttonStyle={[
                styles.button,
                { backgroundColor: editFood ? theme.colors.warning : theme.colors.primary },
              ]}
              titleStyle={{ color: theme.colors.white, fontWeight: "600" }}
              loading={loading} // Only show loading for the save/update action itself
              disabled={isAnyLoading} // Disable if any operation is running
              containerStyle={styles.buttonContainer}
            />
            <Icon
              name="close"
              type="material"
              size={28}
              color={theme.colors.text}
              onPress={!isAnyLoading ? toggleOverlay : undefined} // Disable close when loading
              containerStyle={styles.closeIcon}
              disabled={isAnyLoading}
              disabledStyle={{ backgroundColor: 'transparent' }}
            />
          </View>

          <ScrollView keyboardShouldPersistTaps="handled">
             {/* Food Name Input with Image Icon */}
            <View style={styles.inputRow}>
                <Input
                    label="Food Name"
                    labelStyle={{ color: theme.colors.text }}
                    value={getValue("name")}
                    onChangeText={(text) => handleInputChange("name", text, !!editFood)}
                    errorMessage={errors.name}
                    inputContainerStyle={[styles.inputContainerStyle, styles.inputContainerFlex]}
                    inputStyle={styles.inputStyle}
                    containerStyle={{ flex: 1 }}
                    leftIcon={
                        <MaterialCommunityIcons
                        name="food-apple" size={24}
                        color={errors.name ? theme.colors.error : theme.colors.grey1}
                        />
                    }
                    disabled={isAnyLoading} // Disable input while loading
                />
                {/* Image Picker/Camera Icon Button */}
                <TouchableOpacity
                    onPress={handleGetImageAndAnalyze}
                    disabled={isAnyLoading} // Disable while loading
                    style={styles.iconButtonContainer}
                 >
                    {imageLoading ? ( // Use specific loading state for this button
                        <ActivityIndicator size="small" color={theme.colors.primary} />
                    ) : (
                        <Icon
                            name="camera-enhance-outline"
                            type="material-community" size={28}
                            color={isAnyLoading ? theme.colors.grey3 : theme.colors.primary} // Dim icon when disabled
                        />
                    )}
                </TouchableOpacity>
            </View>

            {/* Macro Inputs or Ingredient Input */}
            {mode === "normal" && (
              <>
                <Input
                  label="Calories (per 100g)" labelStyle={{ color: theme.colors.text }}
                  keyboardType="numeric" value={getValue("calories")}
                  onChangeText={(text) => handleInputChange("calories", text.replace(/[^0-9.]/g, "").replace(/(\..*)\./g, "$1"), !!editFood)}
                  errorMessage={errors.calories} inputContainerStyle={styles.inputContainerStyle}
                  inputStyle={styles.inputStyle}
                  leftIcon={<MaterialCommunityIcons name="fire" size={24} color={errors.calories ? theme.colors.error : theme.colors.grey1}/>}
                  disabled={isAnyLoading}
                />
                <Input
                  label="Protein (per 100g)" labelStyle={{ color: theme.colors.text }}
                  keyboardType="numeric" value={getValue("protein")}
                  onChangeText={(text) => handleInputChange("protein", text.replace(/[^0-9.]/g, "").replace(/(\..*)\./g, "$1"), !!editFood)}
                  errorMessage={errors.protein} inputContainerStyle={styles.inputContainerStyle}
                  inputStyle={styles.inputStyle}
                  leftIcon={<MaterialCommunityIcons name="food-drumstick" size={24} color={errors.protein ? theme.colors.error : theme.colors.grey1}/>}
                   disabled={isAnyLoading}
               />
                <Input
                  label="Carbs (per 100g)" labelStyle={{ color: theme.colors.text }}
                  keyboardType="numeric" value={getValue("carbs")}
                  onChangeText={(text) => handleInputChange("carbs", text.replace(/[^0-9.]/g, "").replace(/(\..*)\./g, "$1"), !!editFood)}
                  errorMessage={errors.carbs} inputContainerStyle={styles.inputContainerStyle}
                  inputStyle={styles.inputStyle}
                  leftIcon={<MaterialCommunityIcons name="bread-slice" size={24} color={errors.carbs ? theme.colors.error : theme.colors.grey1}/>}
                   disabled={isAnyLoading}
               />
                <Input
                  label="Fat (per 100g)" labelStyle={{ color: theme.colors.text }}
                  keyboardType="numeric" value={getValue("fat")}
                  onChangeText={(text) => handleInputChange("fat", text.replace(/[^0-9.]/g, "").replace(/(\..*)\./g, "$1"), !!editFood)}
                  errorMessage={errors.fat} inputContainerStyle={styles.inputContainerStyle}
                  inputStyle={styles.inputStyle}
                  leftIcon={<MaterialCommunityIcons name="oil" size={24} color={errors.fat ? theme.colors.error : theme.colors.grey1}/>}
                   disabled={isAnyLoading}
               />
              </>
            )}

            {mode === "ingredients" && (
              <>
                <View style={styles.backButtonContainer}>
                  <Icon name="arrow-left" type="material-community" size={24} color={theme.colors.primary}
                    onPress={() => !isAnyLoading && setMode("normal")} // Prevent switching during AI call
                    disabled={isAnyLoading} containerStyle={styles.backIcon}
                  />
                  <Text style={[styles.backButtonText, isAnyLoading && styles.disabledText]} onPress={() => !isAnyLoading && setMode("normal")}>
                      Back to Manual Input
                  </Text>
                </View>
                <Input
                  label="Ingredients (Optional)" labelStyle={{ color: theme.colors.text }}
                  value={ingredients} onChangeText={setIngredients} multiline={true}
                  numberOfLines={4} inputContainerStyle={[styles.inputContainerStyle, styles.multilineInputContainer]}
                  inputStyle={[styles.inputStyle, styles.multilineInput]}
                  placeholder="e.g.\n100g Chicken Breast\n50g Rice\n1 tbsp Olive Oil"
                  placeholderTextColor={theme.colors.grey3}
                  leftIcon={<MaterialCommunityIcons name="format-list-bulleted" size={24} color={theme.colors.grey1} style={styles.multilineIcon}/>}
                  disabled={isAnyLoading}
                />
              </>
            )}

            {/* AI (Text) Button */}
            <Button
              title={mode === "normal" ? "Calculate with AI (Recipe/Text)" : ingredients ? "Get Macros from Ingredients" : "Get Macros from Name Only"}
              onPress={handleAiButtonClick}
              buttonStyle={[styles.button, styles.aiButton, { backgroundColor: theme.colors.secondary }]}
              titleStyle={[styles.aiButtonTitle, { color: theme.colors.white }]}
              loading={aiButtonLoading} // Use specific loading state
              disabled={isAnyLoading} // Disable while any op runs
              icon={mode === "normal" ? <MaterialCommunityIcons name="text-box-search-outline" size={18} color={theme.colors.white} style={{ marginRight: 8 }}/> : undefined}
              containerStyle={[styles.buttonContainer, { marginTop: 15 }]}
            />

            {/* Barcode Placeholder */}
            <View style={styles.futureInputContainer}>
              <Text style={styles.futureInputLabel}>
                Barcode Input (Coming Soon)
              </Text>
            </View>
          </ScrollView>
        </View>
      </KeyboardAvoidingView>
      {/* General API Loading Overlay (Optional) */}
      {/* {apiLoading && (
        <View style={styles.loadingOverlay}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
        </View>
      )} */}
    </Overlay>
  );
};

// --- Styles (Keep existing styles) ---
const useStyles = makeStyles((theme) => ({
    overlayContainer: {
        backgroundColor: 'transparent', width: '90%', maxWidth: 500, padding: 0, borderRadius: 15,
        shadowColor: "#000", shadowOffset: { width: 0, height: 2, }, shadowOpacity: 0.25,
        shadowRadius: 3.84, elevation: 5, overflow: 'hidden',
    },
    overlayStyle: {
        width: '100%', borderRadius: 15, padding: 20, paddingBottom: 30, maxHeight: '90%',
    },
    keyboardAvoidingView: { width: "100%", },
    header: {
        flexDirection: "row", justifyContent: "space-between", alignItems: "center",
        marginBottom: 20, paddingBottom: 10, borderBottomWidth: 1, borderBottomColor: theme.colors.divider,
    },
    overlayTitle: { color: theme.colors.text, fontWeight: "bold", fontSize: 20, flexShrink: 1, marginRight: 10, },
    closeIcon: { padding: 5, marginLeft: 10, },
    inputRow: { flexDirection: 'row', alignItems: 'flex-end', marginBottom: 5, },
    inputContainerFlex: { flex: 1, marginRight: 10, marginBottom: 0, },
    iconButtonContainer: {
        height: 40, width: 40, justifyContent: 'center', alignItems: 'center', marginBottom: 10,
    },
    inputContainerStyle: { borderBottomWidth: 1, borderBottomColor: theme.colors.grey4, marginBottom: 5, paddingBottom: 2, },
    inputStyle: { color: theme.colors.text, marginLeft: 10, fontSize: 16, },
    multilineInputContainer: {
        borderWidth: 1, borderColor: theme.colors.grey4, borderRadius: 8, paddingVertical: 8,
        paddingHorizontal: 5, marginBottom: 10, borderBottomWidth: 1, borderBottomColor: theme.colors.grey4,
    },
    multilineInput: { marginLeft: 5, textAlignVertical: 'top', minHeight: 80, fontSize: 16, color: theme.colors.text, },
    multilineIcon: { marginTop: 8, marginRight: 5, },
    futureInputContainer: {
        backgroundColor: theme.colors.grey5, padding: 15, borderRadius: 10,
        marginTop: 20, marginBottom: 10, alignItems: "center",
    },
    futureInputLabel: { color: theme.colors.grey2, fontStyle: "italic", },
    buttonContainer: { },
    button: { borderRadius: 8, paddingHorizontal: 15, paddingVertical: 10, },
    aiButton: { paddingVertical: 12, },
    aiButtonTitle: { fontWeight: "600", fontSize: 15, textAlign: 'center', },
    loadingOverlay: {
        position: "absolute", top: 0, left: 0, right: 0, bottom: 0, backgroundColor: "rgba(0, 0, 0, 0.5)",
        justifyContent: "center", alignItems: "center", zIndex: 10, borderRadius: 15,
    },
    backButtonContainer: { flexDirection: "row", alignItems: "center", marginBottom: 15, marginTop: 5, },
    backIcon: { marginRight: 5, padding: 5, },
    backButtonText: { color: theme.colors.primary, fontSize: 16, fontWeight: '500', },
    disabledText: { color: theme.colors.grey3, }
}));


export default AddFoodModal;
---------- END AddFoodModal.tsx ----------


---------- ConfirmationModal.tsx ----------
// components/ConfirmationModal.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Overlay, Button, Input, Text, useTheme } from '@rneui/themed';

interface ConfirmationModalProps {
  isVisible: boolean;
  onCancel: () => void;
  onConfirm: () => void;
  confirmationText: string;
  setConfirmationText: (text: string) => void;
  title?: string; // Optional title
  message?: string;  //Optional message
}

const ConfirmationModal: React.FC<ConfirmationModalProps> = ({
  isVisible,
  onCancel,
  onConfirm,
  confirmationText,
  setConfirmationText,
  title = "Confirm Action", //default title
  message = "Are you sure you want to perform this action?"
}) => {
  const { theme } = useTheme();

  return (
    <Overlay
      isVisible={isVisible}
      onBackdropPress={onCancel}
      overlayStyle={styles.overlay}
      backdropStyle={styles.backdrop} // Add the backdropStyle
    >
      <View style={[styles.container, {backgroundColor: theme.colors.background}]}>
        <Text style={[styles.title, {color: theme.colors.text}]}>{title}</Text>
        <Text style={[styles.message, {color: theme.colors.text}]}>{message}</Text>
        <Input
          placeholder="Enter confirmation text"
          placeholderTextColor={theme.colors.text}
          value={confirmationText}
          onChangeText={setConfirmationText}
          containerStyle={styles.inputContainer}
          inputStyle={{ color: theme.colors.text }}
          inputContainerStyle={{borderBottomColor: theme.colors.text}}
        />
        <View style={styles.buttonContainer}>
          <Button title="Cancel" onPress={onCancel} type="outline" buttonStyle={styles.button} />
          <Button
            title="Confirm"
            onPress={onConfirm}
            color="error"
            buttonStyle={styles.button}
            disabled={confirmationText === ""}  //Disable when empty
          />
        </View>
      </View>
    </Overlay>
  );
};

const styles = StyleSheet.create({
    overlay: {
        borderRadius: 10,
        width: '80%', // Responsive width
        padding: 6,
        backgroundColor: 'rgba(200, 200, 200, 0.5)'
    },
  container: {
    padding: 20,
    borderRadius: 7,
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 10,
    textAlign: 'center', //center align
  },
  message: {
    marginBottom: 15,
    textAlign: 'center'
  },
  inputContainer: {
    marginBottom: 20,
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
  },
  button: {
    width: 100,
    padding: 10,
  },
  backdrop: {  // Add styles for the backdrop
    backgroundColor: 'rgba(0, 0, 0, 0.5)', // Semi-transparent black
  },
});

export default ConfirmationModal;
---------- END ConfirmationModal.tsx ----------


---------- DailyGoalsInput.tsx ----------
// components/DailyGoalsInput.tsx
import React from "react";
import { Input, Text } from "@rneui/themed";
import { MacroType } from "../types/settings";
import { useTheme } from "@rneui/themed";


interface DailyGoalsInputProps {
    dailyGoals: { [key in MacroType]: number };
    onGoalChange: (goalType: MacroType, value: string) => void;
}

const DailyGoalsInput: React.FC<DailyGoalsInputProps> = ({
  dailyGoals,
  onGoalChange,
}) => {

    const { theme } = useTheme();

  return (
    <>
      {["calories", "protein", "carbs", "fat"].map((macro) => (
        <Input
          key={macro}
          label={<Text style={{ color: theme.colors.text }}>{`${macro.charAt(0).toUpperCase() + macro.slice(1)} Goal`}</Text>} // Wrap label in <Text>
          keyboardType="numeric"
          value={dailyGoals?.[macro as MacroType]?.toString() || ""}
          onChangeText={(value) => onGoalChange(macro as MacroType, value)}
          style={{ color: theme.colors.text }}
          inputContainerStyle={{ borderBottomColor: theme.colors.text }}
          labelStyle={{ color: theme.colors.text }}
        />
      ))}
    </>
  );
};

export default DailyGoalsInput;
---------- END DailyGoalsInput.tsx ----------


---------- DailyProgress.tsx ----------
// components/DailyProgress.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, useTheme } from '@rneui/themed';

interface DailyProgressProps {
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
  goals: {
    calories?: number;
    protein?: number;
    carbs?: number;
    fat?: number;
  };
}

const DailyProgress: React.FC<DailyProgressProps> = ({
  calories,
  protein,
  carbs,
  fat,
  goals,
}) => {
  const { theme } = useTheme();

  const calculateProgress = (current: number, goal?: number) => {
    if (!goal || goal <= 0) return 0; // Avoid division by zero and handle undefined goals
    return Math.min(current / goal, 1); // Cap at 100%
  };

  const renderProgressBar = (label: string, current: number, goal: number | undefined, color: string) => {
      const progress = calculateProgress(current, goal);
      return (
          <View style={styles.macroContainer} key={label}>
              <View style={styles.labelContainer}>
                    <Text style={[styles.macroLabel, {color: theme.colors.text}]}>{label}:</Text>
                    <Text style={[styles.macroValue, {color: theme.colors.text}]}>
                        {`${Math.round(current)} / ${goal || 0}`}
                    </Text>
              </View>
              <View style={styles.progressBarContainer}>
                  <View style={[styles.progressBar, { width: `${progress * 100}%`, backgroundColor: color }]} />
              </View>
          </View>
      )
  }


  return (
    <View style={styles.container}>
        {renderProgressBar('Calories', calories, goals.calories, theme.colors.primary)}
        {renderProgressBar('Protein', protein, goals.protein, 'green')}
        {renderProgressBar('Carbs', carbs, goals.carbs, 'orange')}
        {renderProgressBar('Fat', fat, goals.fat, 'blue')}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: 20,
    padding: 10,
    borderRadius: 8, // Rounded corners for the container
    //backgroundColor: '#f0f0f0', // Light background for contrast Removed for theme consistency
  },
  macroContainer: {
    marginBottom: 10,
  },
  labelContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 5,
  },
  macroLabel: {
    fontWeight: 'bold',
  },
  macroValue: {},
  progressBarContainer: {
      backgroundColor: '#e0e0e0', //Light grey for track
      borderRadius: 5,
      height: 10
  },
  progressBar: {
    height: 10,
    borderRadius: 5,
  },
});

export default DailyProgress;
---------- END DailyProgress.tsx ----------


---------- DataManagementButtons.tsx ----------
// components/DataManagementButtons.tsx (Modified callback)

import React, { useState } from "react";
import { Alert, Platform } from "react-native"; // Import Platform
import { Button } from "@rneui/themed";
import * as DocumentPicker from "expo-document-picker";
import * as FileSystem from "expo-file-system";
import * as Sharing from 'expo-sharing'; // Import Sharing
import { formatDate } from "../utils/dateUtils";
import {
  clearAllData,
  loadDailyEntries,
  saveDailyEntries,
  loadFoods,
  saveFoods,
  loadSettings,
  saveSettings
} from "../services/storageService";
import ConfirmationModal from "./ConfirmationModal";
import { DailyEntry } from "../types/dailyEntry";
import { Food } from "../types/food";
import { Settings } from "../types/settings";
import { useTheme } from "@rneui/themed";


interface DataManagementButtonsProps {
  onDataOperation: () => void; // Changed prop name
}

const DataManagementButtons: React.FC<DataManagementButtonsProps> = ({
    onDataOperation
}) => {
  const [isConfirmationVisible, setIsConfirmationVisible] = useState(false);
  const [confirmationText, setConfirmationText] = useState("");
  const { theme } = useTheme();

  const handleExportData = async () => {
    try {
      const dailyEntries = await loadDailyEntries();
      const foods = await loadFoods();
      const settings = await loadSettings();

      const exportData = {
        dailyEntries,
        foods,
        settings
      };

      const exportDataString = JSON.stringify(exportData);
      const formattedDate = formatDate(new Date()).replace(/\//g, '-'); // Replace slashes
      const fileName = `macro_data_${formattedDate}.json`;
      const fileUri = FileSystem.documentDirectory + fileName;

      await FileSystem.writeAsStringAsync(fileUri, exportDataString, {
        encoding: FileSystem.EncodingType.UTF8,
      });

      // Use expo-sharing to share the file
      if (!(await Sharing.isAvailableAsync())) {
        Alert.alert('Sharing is not available on your platform');
        return;
      }

      await Sharing.shareAsync(fileUri);
      onDataOperation(); // Trigger reload after export

    } catch (error: any) {
      console.error(error);
      Alert.alert(
        "Export Failed",
        error.message || "An error occurred while exporting data."
      );
    }
  };

  const handleImportData = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: ["application/json"], // Only accept JSON files
      });

      if (result.assets && result.assets.length > 0) {
        const file = result.assets[0];

        // Check file extension
        if (!file.name?.toLowerCase().endsWith(".json")) {
          Alert.alert("Invalid File", "Please select a JSON file.");
          return;
        }

        const fileContent = await FileSystem.readAsStringAsync(file.uri, {
          encoding: FileSystem.EncodingType.UTF8,
        });


        try {
          const importedData = JSON.parse(fileContent);

          // Basic structure validation:
          if (
            !importedData.hasOwnProperty("dailyEntries") ||
            !importedData.hasOwnProperty("foods") ||
            !importedData.hasOwnProperty("settings")
          ) {
            Alert.alert(
              "Import Failed",
              "The imported file is missing required data (dailyEntries, foods, or settings)."
            );
            return;
          }


          await saveDailyEntries(importedData.dailyEntries);
          await saveFoods(importedData.foods);
          await saveSettings(importedData.settings)
          Alert.alert("Import Successful", "Data imported and saved.");
          onDataOperation(); //trigger reload

        } catch (parseError) {
          Alert.alert(
            "Import Failed",
            "The imported file is not valid JSON."
          );
          return;
        }


      } else {
        // Explicitly check for cancelled
        if (result.canceled) {
          // User cancelled, do nothing
        } else {
          Alert.alert("Import Failed", "Invalid file selected.");
        }
      }
    } catch (error: any) {
      console.error("Import Error:", error);
      Alert.alert(
        "Import Failed",
        error.message || "An unknown error occurred."
      );
    }
  };

  const handleClearData = () => setIsConfirmationVisible(true);

  const confirmClearData = async () => {
    if (confirmationText === "CLEAR DATA") {
      try {
        await clearAllData();
        Alert.alert("Data Cleared", "All data has been cleared.");
        onDataOperation(); // Trigger reload after clearing
      } catch (error) {
        Alert.alert("Error", "Failed to clear data.");
      } finally {
        setConfirmationText("");
        setIsConfirmationVisible(false);
      }
    } else {
      Alert.alert("Error", "Incorrect confirmation text.");
    }
  };

  return (
    <>
      <Button
        title="Export Data"
        onPress={handleExportData}
        buttonStyle={{ marginBottom: 10, backgroundColor: theme.colors.primary }}
      />
      <Button
        title="Import Data"
        onPress={handleImportData}
        buttonStyle={{ marginBottom: 10, backgroundColor: theme.colors.primary }}
      />
      <Button
        title="Clear All Data"
        onPress={handleClearData}
        color="error"
        buttonStyle={{ marginBottom: 10 }}
      />

      <ConfirmationModal
        isVisible={isConfirmationVisible}
        onCancel={() => setIsConfirmationVisible(false)}
        onConfirm={confirmClearData}
        confirmationText={confirmationText}
        setConfirmationText={setConfirmationText}
        title="Clear All Data?"
        message="This action cannot be undone. Confirmation Text: CLEAR DATA"
      />
    </>
  );
};

export default DataManagementButtons;
---------- END DataManagementButtons.tsx ----------


---------- FoodItem.tsx ----------
// FoodItem.tsx (Corrected with forwardRef and Enhanced Icon Handling)
import React, { forwardRef, useState, useCallback, memo } from "react"; // Import forwardRef, useState, useCallback, memo
import { StyleSheet, View, Image } from "react-native"; // Import View and Image
import { ListItem, Icon, useTheme, Button, makeStyles, Text } from "@rneui/themed"; // Added makeStyles, Text
import { Food } from "../types/food";
import Toast from "react-native-toast-message";

interface FoodItemProps {
  food: Food;
  onEdit: (food: Food) => void;
  onDelete: (foodId: string) => void;
  onUndoDelete: (food: Food) => void;
  foodIconUrl: string | null | undefined; // Accept undefined for loading state
}

// Use forwardRef to receive the ref from the parent
// Use memo to prevent unnecessary re-renders if props haven't changed
const FoodItem = memo(forwardRef<any, FoodItemProps>(
  ({ food, onEdit, onDelete, onUndoDelete, foodIconUrl }, ref) => {
    const { theme } = useTheme();
    const styles = useStyles(); // Use makeStyles hook
    const [iconLoadError, setIconLoadError] = useState(false); // State to track image load errors

    const handleDelete = useCallback(() => {
      // The parent (FoodListScreen) handles the actual deletion and Toast
      onDelete(food.id);
      // Toast is shown in the parent component after delete confirmation/logic
    }, [food.id, onDelete]); // Depend only on what's needed for the callback itself

    const handleUndo = useCallback(() => {
         // The parent handles the undo logic and Toast confirmation
         onUndoDelete(food);
    }, [food, onUndoDelete]);


    const handleImageError = useCallback(() => {
        console.warn(`Failed to load image for ${food.name} from URL: ${foodIconUrl}`);
        setIconLoadError(true);
    }, [food.name, foodIconUrl]);

    // Reset error state if the URL changes (e.g., during refresh)
    React.useEffect(() => {
        setIconLoadError(false);
    }, [foodIconUrl]);

    const renderIcon = () => {
        // Explicitly handle undefined (loading), null (no icon), or error state
        if (foodIconUrl === undefined) {
            // Still loading the URL itself
             return (
                <View style={[styles.foodIcon, styles.iconPlaceholder]}>
                    <Icon name="hourglass-outline" type="ionicon" size={18} color={theme.colors.grey3} />
                </View>
             );
        } else if (foodIconUrl && !iconLoadError) {
            // URL exists and no loading error occurred yet
             return (
                <Image
                    source={{ uri: foodIconUrl }}
                    style={styles.foodIconImage} // Use specific style for image
                    onError={handleImageError} // Use callback for error
                    resizeMode="contain" // Ensure image fits well
                />
            );
        } else {
             // URL is null, empty, or an error occurred loading the image
            return (
                <View style={[styles.foodIcon, styles.iconPlaceholder]}>
                    <Icon
                        name="fast-food-outline" // Default placeholder icon
                        type="ionicon"
                        size={20} // Slightly larger placeholder icon
                        color={theme.colors.grey3}
                    />
                </View>
            );
        }
    };

    return (
      // Attach the received ref to ListItem.Swipeable
      <ListItem.Swipeable
        ref={ref} // Pass the forwarded ref here!
        bottomDivider
        leftContent={(reset) => (
          <Button
            title="Edit"
            onPress={() => {
              onEdit(food);
              reset();
            }}
            icon={{ name: "edit", color: theme.colors.white }}
            buttonStyle={styles.swipeButtonEdit}
            titleStyle={styles.swipeButtonTitle}
          />
        )}
        rightContent={(reset) => (
          <Button
            title="Delete"
            onPress={() => { // Wrap handleDelete in another function to call reset
                handleDelete(); // Call the memoized delete handler
                reset();
            }}
            icon={{ name: "delete", color: theme.colors.white }}
            buttonStyle={styles.swipeButtonDelete}
            titleStyle={styles.swipeButtonTitle}
          />
        )}
        containerStyle={[
          styles.listItemContainer,
          { backgroundColor: theme.colors.background },
        ]}
      >
        {/* Render the icon based on state */}
        {renderIcon()}

        <ListItem.Content>
          <ListItem.Title style={[styles.title, { color: theme.colors.text }]}>
            {food.name}
          </ListItem.Title>
          <ListItem.Subtitle style={{ color: theme.colors.grey1, fontSize: 13, marginTop: 3 }}>
            {`Cal: ${Math.round(food.calories)} P: ${Math.round(food.protein)}g C: ${Math.round(food.carbs)}g F: ${Math.round(food.fat)}g (per 100g)`}
          </ListItem.Subtitle>
        </ListItem.Content>
        {/* Optional: Chevron can indicate drill-down, but swipe provides actions */}
        {/* <ListItem.Chevron color={theme.colors.grey2}/> */}
      </ListItem.Swipeable>
    );
  }
)); // Close memo wrapper

const useStyles = makeStyles((theme) => ({ // Define styles using makeStyles
  listItemContainer: {
    paddingVertical: 12,
    paddingHorizontal: 15,
    borderRadius: 0,
    marginVertical: 0,
    borderBottomColor: theme.colors.divider, // Ensure bottom divider color matches theme
  },
  title: {
    fontWeight: "600",
    fontSize: 16,
    marginBottom: 2,
  },
  swipeButtonEdit: {
    minHeight: "100%",
    backgroundColor: theme.colors.warning,
    justifyContent: 'center',
    alignItems: 'flex-start',
    paddingLeft: 20,
  },
  swipeButtonDelete: {
    minHeight: "100%",
    backgroundColor: theme.colors.error,
    justifyContent: 'center',
    alignItems: 'flex-end',
    paddingRight: 20,
  },
  swipeButtonTitle: {
    color: theme.colors.white,
    fontWeight: 'bold',
    fontSize: 15,
  },
   foodIcon: { // Container style for placeholder/loading icon
       width: 40,
       height: 40,
       marginRight: 12,
       borderRadius: 8,
       alignItems: 'center',
       justifyContent: 'center',
   },
   foodIconImage: { // Specific style for the Image component itself
       width: 40,
       height: 40,
       marginRight: 12,
       borderRadius: 8,
   },
   iconPlaceholder: {
      backgroundColor: theme.colors.grey5, // Background for placeholder/loading
   }
})); // Close useStyles definition

export default FoodItem;
---------- END FoodItem.tsx ----------


---------- QuickAddList.tsx ----------
// src/components/QuickAddList.tsx
// ---------- NEW FILE ----------
import React from 'react';
import {
    View,
    FlatList,
    StyleSheet,
    TouchableOpacity,
    Pressable,
    Dimensions,
    ActivityIndicator,
} from 'react-native';
import {
    ListItem,
    CheckBox,
    Input,
    Icon,
    Text,
    useTheme,
    makeStyles,
} from '@rneui/themed';
import { EstimatedFoodItem } from '../types/macros';
import { isValidNumberInput } from '../utils/validationUtils';

interface QuickAddListProps {
    items: EstimatedFoodItem[];
    selectedIndices: Set<number>;
    editingIndex: number | null;
    editedName: string;
    editedGrams: string;
    onToggleItem: (index: number) => void;
    onEditItem: (index: number) => void;
    onSaveEdit: () => void;
    onCancelEdit: () => void;
    onNameChange: (name: string) => void;
    onGramsChange: (grams: string) => void;
    style?: object; // Optional style prop for the FlatList container
    isLoading?: boolean; // Optional loading state for the list itself
}

const QuickAddList: React.FC<QuickAddListProps> = ({
    items,
    selectedIndices,
    editingIndex,
    editedName,
    editedGrams,
    onToggleItem,
    onEditItem,
    onSaveEdit,
    onCancelEdit,
    onNameChange,
    onGramsChange,
    style,
    isLoading,
}) => {
    const { theme } = useTheme();
    const styles = useStyles();

    const renderItem = ({ item, index }: { item: EstimatedFoodItem; index: number }) => {
        const isSelected = selectedIndices.has(index);
        const isEditingThisItem = editingIndex === index;
        const isAnyItemEditing = editingIndex !== null;
        const estimatedCalories = Math.round(
            (item.calories_per_100g / 100) * item.estimatedWeightGrams
        );

        return (
            <Pressable
                onPress={() => !isEditingThisItem && onToggleItem(index)}
                disabled={(isAnyItemEditing && !isEditingThisItem)}
            >
                <ListItem
                    bottomDivider
                    containerStyle={[
                        styles.quickAddItemContainer,
                        isEditingThisItem && styles.quickAddItemEditing,
                        isSelected && styles.quickAddItemSelected,
                        isAnyItemEditing && !isEditingThisItem && { opacity: 0.6 },
                    ]}
                >
                    {isEditingThisItem ? (
                        // --- EDIT VIEW for Quick Add Item ---
                        <View style={styles.quickAddEditView}>
                            <Input
                                value={editedName}
                                onChangeText={onNameChange}
                                placeholder="Food Name"
                                inputContainerStyle={styles.quickEditInputContainer}
                                inputStyle={styles.quickEditInput}
                                containerStyle={styles.quickEditNameContainer}
                                autoFocus
                                selectTextOnFocus
                            />
                            <View style={styles.quickEditGramsRow}>
                                <Input
                                    value={editedGrams}
                                    onChangeText={onGramsChange} // Use the specific handler for cleaning
                                    placeholder="Grams"
                                    keyboardType="numeric"
                                    inputContainerStyle={styles.quickEditInputContainer}
                                    inputStyle={styles.quickEditInput}
                                    containerStyle={styles.quickEditGramsContainer}
                                    rightIcon={<Text style={styles.quickEditUnitText}> g </Text>}
                                    errorMessage={ !isValidNumberInput(editedGrams) && editedGrams !== "" ? "Invalid" : "" }
                                    errorStyle={styles.inputError}
                                />
                                {/* Save/Cancel Edit Buttons */}
                                <TouchableOpacity onPress={onSaveEdit} style={styles.quickEditButton}>
                                    <Icon name="checkmark" type="ionicon" color={theme.colors.success} size={26} />
                                </TouchableOpacity>
                                <TouchableOpacity onPress={onCancelEdit} style={styles.quickEditButton}>
                                    <Icon name="close-circle-outline" type="ionicon" color={theme.colors.error} size={26} />
                                </TouchableOpacity>
                            </View>
                        </View>
                    ) : (
                        // --- DISPLAY VIEW for Quick Add Item ---
                        <>
                            <CheckBox
                                checked={isSelected}
                                onPress={() => onToggleItem(index)}
                                containerStyle={styles.quickAddCheckbox}
                                checkedColor={theme.colors.primary}
                                disabled={isAnyItemEditing}
                            />
                            <ListItem.Content>
                                <ListItem.Title style={styles.quickAddItemTitle}>
                                    {item.foodName}
                                </ListItem.Title>
                                <ListItem.Subtitle style={styles.quickAddItemSubtitle}>
                                    {`Est: ${Math.round(item.estimatedWeightGrams)}g  ~${estimatedCalories} kcal`}
                                </ListItem.Subtitle>
                            </ListItem.Content>
                            {/* Edit Icon */}
                            {!isAnyItemEditing && (
                                <TouchableOpacity onPress={() => onEditItem(index)} style={styles.quickEditIconButton}>
                                    <Icon name="pencil" type="material-community" size={20} color={theme.colors.grey1} />
                                </TouchableOpacity>
                            )}
                        </>
                    )}
                </ListItem>
            </Pressable>
        );
    };

    if (isLoading) {
         return (
             <View style={styles.centeredContent}>
                 <ActivityIndicator size="large" color={theme.colors.primary} />
                 <Text style={styles.loadingText}>Analyzing...</Text>
             </View>
         );
    }

    return (
        <FlatList
            data={items}
            keyExtractor={(item, index) => `quickadd-${index}-${item.foodName}`}
            renderItem={renderItem}
            ListEmptyComponent={ // Show if API returned no items initially
                <View style={styles.emptyListContainer}>
                    <Icon name="image-off-outline" type="material-community" size={40} color={theme.colors.grey3} />
                    <Text style={styles.emptyListText}> No identifiable foods found in the image. </Text>
                    <Text style={styles.emptyListSubText}> Try a different image or add manually. </Text>
                </View>
            }
            style={[styles.listDefaults, style]} // Combine default styles with passed styles
            extraData={{ selectedIndices, editingIndex }} // Ensure re-render on state change
            keyboardShouldPersistTaps="handled"
            contentContainerStyle={items.length === 0 ? styles.listContentContainerEmpty : {}}
        />
    );
};

const useStyles = makeStyles((theme) => ({
    listDefaults: { // Default styles for the FlatList itself
        // maxHeight: Dimensions.get("window").height * 0.55, // Moved to parent or style prop
        // flexGrow: 0, // Moved to parent or style prop
        // marginBottom: 10, // Moved to parent or style prop
    },
    listContentContainerEmpty: {
        flexGrow: 1,
        justifyContent: 'center',
    },
    quickAddItemContainer: {
        paddingVertical: 6, paddingHorizontal: 5, backgroundColor: theme.colors.background,
        borderBottomColor: theme.colors.divider, flexDirection: "row", alignItems: "center",
        minHeight: 60, // Ensure consistent item height
    },
    quickAddItemSelected: { backgroundColor: theme.colors.successLight || '#d4edda' },
    quickAddItemEditing: { backgroundColor: theme.colors.grey5, paddingVertical: 8, },
    quickAddCheckbox: { padding: 0, margin: 0, marginRight: 10, backgroundColor: "transparent", borderWidth: 0, },
    quickAddItemTitle: { fontWeight: "bold", color: theme.colors.text, fontSize: 16, },
    quickAddItemSubtitle: { color: theme.colors.grey1, fontSize: 13, marginTop: 2, },
    quickEditIconButton: { padding: 8, marginLeft: 8, },
    quickAddEditView: { flex: 1, paddingLeft: 10, },
    quickEditInputContainer: {
        borderBottomWidth: 1, borderBottomColor: theme.colors.primary, height: 35, paddingHorizontal: 0,
        // paddingBottom: 0, // Reduce bottom padding to avoid height issues
        // marginBottom: 0, // Reduce margin
    },
    quickEditInput: {
        fontSize: 15, color: theme.colors.text, paddingVertical: 0, // Remove vertical padding
        // lineHeight: 18, // Control line height if needed
        // height: 'auto', // Auto height? Test this carefully
    },
    quickEditNameContainer: { paddingHorizontal: 0, marginBottom: 5, },
    quickEditGramsRow: { flexDirection: "row", alignItems: "center", },
    quickEditGramsContainer: { flex: 1, paddingHorizontal: 0, },
    quickEditUnitText: { color: theme.colors.grey2, fontSize: 14, fontWeight: "500", },
    quickEditButton: { paddingLeft: 10, paddingVertical: 5, },
    emptyListContainer: {
        alignItems: "center", paddingVertical: 30, paddingHorizontal: 15,
    },
    emptyListText: { color: theme.colors.grey2, fontSize: 16, textAlign: "center", marginTop: 10 },
    emptyListSubText: { fontSize: 14, color: theme.colors.grey3, textAlign: "center", marginTop: 5, },
    inputError: { color: theme.colors.error, fontSize: 10, marginVertical: 0, height: 12 }, // Compact error message
     centeredContent: { // Centered loading/empty states within main area
      flex: 1,
      alignItems: 'center',
      justifyContent: 'center',
      padding: 20,
      minHeight: 150, // Ensure it takes some space
   },
    loadingText: { marginTop: 10, color: theme.colors.text, fontSize: 16, fontWeight: "500", },
}));

export default QuickAddList;
---------- END QuickAddList.tsx ----------


---------- StatisticsChart.tsx ----------
// components/StatisticsChart.tsx (Modified)
import React from "react";
import { View, StyleSheet } from "react-native";
import { WebView } from "react-native-webview";
import { Statistics, MacroType, macros } from "../types/settings"; // Import types
import { useTheme } from "@rneui/themed";


interface StatisticsChartProps {
  statistics: Statistics;
}

const StatisticsChart: React.FC<StatisticsChartProps> = ({ statistics }) => {

  const { theme } = useTheme();

  const generateChartHTML = () => {
    const chartData = macros.reduce((acc, macro) => {
      // Prepare data for each macro, including goal if applicable
      acc[macro] = statistics[macro].map((series) =>
        series.map((item) => [item.x / 1000, item.y])
      );
      return acc;
    }, {} as { [key in MacroType]: number[][][] });

    const textColor = theme.colors.text;
    const gridColor = theme.colors.grey5; // Lighter grid
    const axisColor = theme.colors.grey3; // Slightly darker axis
    const fontFamily = "Helvetica, Arial, sans-serif";

    // Define color palette for the lines, using theme colors if possible
    const lineColors = {
      calories: theme.colors.primary,
      protein: theme.colors.success,
      carbs: theme.colors.warning,
      fat: theme.colors.error,
    };


    // Re-enabled caching, but *only* cache the HTML itself, not the data.  The data is now dynamic.
    return `
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>Macro Charts</title>
            <style>
            body { font-family: ${fontFamily}; margin: 0; padding: 0; background-color: ${theme.colors.background}; color: ${textColor};}
                .chart-container { width: 95%; height: 250px; margin: 10px auto; }
            </style>
            <link rel="stylesheet" href="https://unpkg.com/uplot@1.6.27/dist/uPlot.min.css">
            <script src="https://unpkg.com/uplot@1.6.27/dist/uPlot.iife.min.js"></script>
        </head>
        <body>
            ${macros
      .map((macro) => {
        const isCalories = macro === "calories";
        const seriesCount = isCalories ? 2 : 1; // Two series for calories (intake, goal)

        const seriesConfig = isCalories
          ? `[
                      {},
                      {
                        stroke: "${lineColors[macro] || theme.colors.primary}",
                        width: 2,
                        label: "Intake",
                        points: { show: false }
                      },
                      {
                        stroke: "red",
                        width: 1,
                        dash: [5, 5],
                        label: "Goal",
                        points: { show: false }
                      }
                    ]`
          : `[
                      {},
                      {
                        stroke: "${lineColors[macro] || theme.colors.primary}",
                        width: 2,
                        label: "${macro.charAt(0).toUpperCase() + macro.slice(1)}",
                        points: { show: false }
                      }
                    ]`;


        const uPlotData =
          seriesCount === 2
            ? `[data[0].map(d => d[0]), data[0].map(d => d[1]), data[1].map(d => d[1])]`
            : `[data[0].map(d => d[0]), data[0].map(d => d[1])]`;



        return `
                <div id="${macro}-chart" class="chart-container"></div>
                <script>
                    const data = ${JSON.stringify(chartData[macro])};
                    const opts = {
                        title: "${macro.charAt(0).toUpperCase() + macro.slice(1)}",
                        width: window.innerWidth * 0.95,
                        height: 250,
                        scales: {
                            x: { time: true },
                            y: { },
                        },
                        axes: [
                            {
                                stroke: "${textColor}",
                                font: "14px ${fontFamily}",
                            grid: {
                                    stroke: "${gridColor}",
                                    width: 1
                                },
                                ticks: {
                                    stroke: "${gridColor}",
                                    width: 1
                                }
                            },
                            {
                                stroke: "${textColor}",
                                font: "14px ${fontFamily}",
                                grid: {
                                    stroke: "${gridColor}",
                                    width: 1
                                },
                                ticks: {
                                    stroke: "${gridColor}",
                                    width: 1
                                }
                            }
                        ],
                        series: ${seriesConfig},
                        cursor: {
                            drag: { setScale: false },
                            points: {
                                size: 6,
                                fill: (self, i) => self.series[i]._stroke,
                                stroke: (self, i) => self.series[i]._stroke,
                            }
                        },
                        ${isCalories ? `
                        hooks: {
                            draw: [
                                (u) => {
                                   const ctx = u.ctx;
                                    u.series.forEach((series, seriesIdx) => {
                                      if (seriesIdx === 1) {
                                        const intakeData = data[0];
                                        const goalData = data[1];

                                        ctx.beginPath();
                                        ctx.fillStyle = "rgba(255, 0, 0, 0.3)"; // Semi-transparent red

                                        for (let i = 0; i < intakeData.length; i++) {
                                          const intakeY = intakeData[i][1];
                                          const goalY = goalData[i][1];
                                          const x = u.valToPos(intakeData[i][0], "x", true);
                                          
                                           // Check if intake exceeds the goal
                                            if(intakeY > goalY){
                                                const intakeYPos = u.valToPos(intakeY, 'y', true);
                                                const goalYPos = u.valToPos(goalY, 'y', true);
                                               
                                                //if this is the first point or last point, move to x, other wise line to x
                                                if(i === 0){
                                                   ctx.moveTo(x, intakeYPos);
                                                }else{
                                                  ctx.lineTo(x, intakeYPos);
                                                }
                                            }
                                        }
                                        //go back along the goal data
                                         for (let i = intakeData.length-1; i >= 0; i--) {
                                            const intakeY = intakeData[i][1];
                                            const goalY = goalData[i][1];
                                             const x = u.valToPos(intakeData[i][0], "x", true);
                                               // Check if intake exceeds the goal
                                            if(intakeY > goalY){
                                                 const goalYPos = u.valToPos(goalY, 'y', true);
                                                ctx.lineTo(x, goalYPos);
                                            }
                                         }

                                        ctx.closePath();
                                        ctx.fill();
                                        }

                                    });

                                }
                            ]
                        }
                        ` : ''}
                    };
                    new uPlot(opts, ${uPlotData}, document.getElementById('${macro}-chart'));
                </script>
            `;
      })
      .join("")}
        </body>
        </html>
        `;

  };

  return (
    <View style={styles.webViewContainer}>
      <WebView
        originWhitelist={["*"]}
        source={{ html: generateChartHTML() }}
        style={styles.webView}
        scalesPageToFit={false}
        scrollEnabled={false}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  webViewContainer: {
    height: 'auto',
    width: "100%",
    marginTop: 10,
  },
  webView: {
    height: 340, // Explicit height, adjust as needed.
  },
});

export default StatisticsChart;
---------- END StatisticsChart.tsx ----------


---------- ThemeSwitch.tsx ----------
// components/ThemeSwitch.tsx (Corrected)
import React from "react";
import { ListItem, Switch } from "@rneui/themed";
import { useTheme } from "@rneui/themed";

interface ThemeSwitchProps {
  currentTheme: 'light' | 'dark' | 'system'; // Use theme string
  onToggle: (theme: 'light' | 'dark' | 'system') => void; // Pass the theme string
}

const ThemeSwitch: React.FC<ThemeSwitchProps> = ({ currentTheme, onToggle }) => {
  const { theme } = useTheme();

  return (
    <ListItem
      bottomDivider
      containerStyle={{ backgroundColor: theme.colors.background }}
    >
      <ListItem.Content>
        <ListItem.Title style={{ color: theme.colors.text }}>
          Dark Mode
        </ListItem.Title>
      </ListItem.Content>
      <Switch
        value={currentTheme === 'dark'} // Correctly reflect theme
        onValueChange={(newValue) => {
          onToggle(newValue ? 'dark' : 'light'); // Toggle between 'light' and 'dark'
        }}
      />
    </ListItem>
  );
};

export default ThemeSwitch;
---------- END ThemeSwitch.tsx ----------


---------- AppNavigator.tsx ----------
// navigation/AppNavigator.tsx
import React, { useState, useCallback } from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { Icon, useTheme } from '@rneui/themed';
import DailyEntryScreen from '../screens/DailyEntryScreen';
import FoodListScreen from '../screens/FoodListScreen';
import SettingsScreen from '../screens/SettingsScreen';

const Tab = createBottomTabNavigator();

interface AppNavigatorProps {
  onThemeChange: (theme: 'light' | 'dark' | 'system') => void;
}

const AppNavigator: React.FC<AppNavigatorProps> = ({ onThemeChange }) => {
  const { theme } = useTheme();
  const [foodListRefresh, setFoodListRefresh] = useState(false);

  const handleFoodChange = useCallback(() => {
    setFoodListRefresh(prev => !prev); // Toggle the state to trigger refresh
  }, []);

  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        tabBarIcon: ({ focused, color, size }) => {
          let iconName: string = '';
          let type: string = '';

          if (route.name === 'Daily Entry') {
            iconName = focused ? 'calendar' : 'calendar-outline';
            type = 'ionicon';
          } else if (route.name === 'Foods') {
            iconName = focused ? 'fast-food' : 'fast-food-outline';
            type = 'ionicon'; // Consistent icon set
          } else if (route.name === 'Settings') {
            iconName = focused ? 'settings' : 'settings-outline';
            type = 'ionicon';
          }

          return <Icon name={iconName} type={type} size={size} color={color} />;
        },
        tabBarActiveTintColor: theme.colors.primary,
        tabBarInactiveTintColor: theme.colors.secondary, // Use secondary color
        headerShown: false,
        tabBarStyle: {
          backgroundColor: theme.colors.background,
          borderTopColor: theme.colors.divider, // Add a subtle border
        },
        tabBarLabelStyle: {
          fontWeight: 'bold', // Make labels more prominent
        }
      })}
    >
      <Tab.Screen name="Daily Entry">
        {() => <DailyEntryScreen key={foodListRefresh ? 'refresh' : 'normal'} />}
      </Tab.Screen>
      <Tab.Screen name="Foods">
        {() => <FoodListScreen onFoodChange={handleFoodChange} />}
      </Tab.Screen>
      <Tab.Screen name="Settings">
        {() => <SettingsScreen onThemeChange={onThemeChange} onDataOperation={function (): void {
          throw new Error('Function not implemented.');
        } } />}
      </Tab.Screen>
    </Tab.Navigator>
  );
};

export default AppNavigator;
---------- END AppNavigator.tsx ----------


---------- DailyEntryScreen.tsx ----------
// src/screens/DailyEntryScreen.tsx
// This version aims to restore the visual appearance and interaction patterns
// of the provided "before" code, while retaining the underlying functional
// improvements (like improved state management, backend integration hooks,
// multi-add support) from the "current" code.

import React, { useState, useEffect, useCallback, useMemo } from "react";
import {
  View,
  FlatList,
  Alert,
  Platform,
  Image,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
  Keyboard, // Import Keyboard
} from "react-native";
import { DailyEntry, DailyEntryItem } from "../types/dailyEntry";
import { Food } from "../types/food";
import { getFoods } from "../services/foodService"; // Still use foodService
import {
  saveDailyEntries,
  loadDailyEntries,
  loadSettings,
} from "../services/storageService";
import {
  formatDateReadable,
  getTodayDateString,
  formatDateISO, // Use ISO format internally
} from "../utils/dateUtils";
import { isValidNumberInput } from "../utils/validationUtils";
import DailyProgress from "../components/DailyProgress";
import {
  Button,
  Text,
  ListItem,
  FAB,
  makeStyles,
  useTheme,
  Divider,
  Input,
} from "@rneui/themed";
import DateTimePicker, { DateTimePickerEvent } from "@react-native-community/datetimepicker"; // Import event type
import { addDays, subDays, parseISO, formatISO, isValid } from "date-fns"; // Import isValid
import { Icon } from "@rneui/base";
import { SafeAreaView } from "react-native-safe-area-context";
import AddEntryModal from "../components/AddEntryModal";
import "react-native-get-random-values"; // Ensure this is imported before uuid
import Toast from "react-native-toast-message";
import { useFocusEffect } from "@react-navigation/native";
import { getFoodIconUrl } from "../utils/iconUtils"; // Use the refactored icon util

// Interface for daily goals structure (remains the same)
interface DailyGoals {
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
}

const DailyEntryScreen: React.FC = () => {
  // State variables - Combining states from both versions where necessary
  const [dailyEntries, setDailyEntries] = useState<DailyEntry[]>([]);
  const [selectedDate, setSelectedDate] = useState<string>(getTodayDateString()); // YYYY-MM-DD format
  const [foods, setFoods] = useState<Food[]>([]); // All available foods
  const [selectedFood, setSelectedFood] = useState<Food | null>(null); // For modal
  const [grams, setGrams] = useState(""); // For modal input
  const [isOverlayVisible, setIsOverlayVisible] = useState(false);
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [dailyGoals, setDailyGoals] = useState<DailyGoals>({
    calories: 2000, protein: 150, carbs: 200, fat: 70, // Example goals
  });
  const [editingIndex, setEditingIndex] = useState<number | null>(null); // *Inline* edit ORIGINAL index
  const [tempGrams, setTempGrams] = useState(""); // *Inline* edit temporary grams
  const [search, setSearch] = useState(""); // Modal search term
  // *** Reverted State Variable: Use 'editIndex' for MODAL edit index as per "before" code ***
  const [editIndex, setEditIndex] = useState<number | null>(null); // *Modal* edit REVERSED index
  const [foodIcons, setFoodIcons] = useState<{ [foodName: string]: string | null | undefined }>({}); // Cache: name -> url | null | undefined
  const [isLoadingData, setIsLoadingData] = useState(true); // Initial data load state
  const [isSaving, setIsSaving] = useState(false); // Saving state

  const { theme } = useTheme();
  const styles = useStyles(); // Use the styles from the "before" code (pasted below)

  // --- Data Loading and Icon Fetching (Uses improved logic) ---
  const loadData = useCallback(async () => {
    console.log(`DailyEntryScreen: Loading data for date: ${selectedDate}`);
    setIsLoadingData(true);
    try {
      const [loadedFoods, loadedEntries, loadedSettings] = await Promise.all([
        getFoods(),
        loadDailyEntries(),
        loadSettings(),
      ]);

      const currentGoals = loadedSettings?.dailyGoals ?? { calories: 2000, protein: 150, carbs: 200, fat: 70 };
      setDailyGoals(currentGoals);

      loadedFoods.sort((a, b) => a.name.localeCompare(b.name));
      setFoods(loadedFoods);

      setDailyEntries(loadedEntries);
      console.log(`DailyEntryScreen: Loaded ${loadedFoods.length} foods, ${loadedEntries.length} entry days.`);

      triggerIconFetches(loadedFoods, loadedEntries, selectedDate);
    } catch (error) {
      console.error("DailyEntryScreen: Error loading data:", error);
      Alert.alert("Load Error", "Failed to load necessary data.");
      setFoods([]);
      setDailyEntries([]);
      setDailyGoals({ calories: 0, protein: 0, carbs: 0, fat: 0 });
    } finally {
      setIsLoadingData(false);
    }
  }, [selectedDate]);

  const triggerIconFetches = useCallback((allFoods: Food[], allEntries: DailyEntry[], currentDate: string) => {
    const relevantFoodNames = new Set<string>();
    allFoods.forEach((f) => relevantFoodNames.add(f.name));
    const currentOriginalEntry = allEntries.find((entry) => entry.date === currentDate);
    if (currentOriginalEntry) {
      currentOriginalEntry.items.forEach((item) => {
        if (item.food?.name) {
          relevantFoodNames.add(item.food.name);
        }
      });
    }
    console.log(`DailyEntryScreen: Triggering icon fetches for ${relevantFoodNames.size} unique food names.`);
    relevantFoodNames.forEach((foodName) => {
      if (foodIcons[foodName] === undefined) {
        getFoodIconUrl(foodName)
          .then((iconUrl) => {
            setFoodIcons((prevIcons) => ({ ...prevIcons, [foodName]: iconUrl }));
          })
          .catch((error) => {
            console.warn(`Icon fetch failed for ${foodName} in background:`, error);
            setFoodIcons((prevIcons) => ({ ...prevIcons, [foodName]: null }));
          });
      }
    });
  }, [foodIcons]);

  useFocusEffect(
    useCallback(() => {
      loadData();
      return () => {
        console.log("DailyEntryScreen: Unfocused.");
        setSearch("");
        setIsOverlayVisible(false);
        setEditingIndex(null); // Clear inline edit
        setTempGrams("");
        setEditIndex(null); // Clear modal edit
      };
    }, [loadData])
  );

  // --- List and Index Management (Uses improved logic) ---
  const currentEntryItems = useMemo(() => {
    const entry = dailyEntries.find((e) => e.date === selectedDate);
    return entry ? [...entry.items].reverse() : [];
  }, [dailyEntries, selectedDate]);

  const getOriginalIndex = useCallback((reversedIndex: number): number => {
    const entry = dailyEntries.find((e) => e.date === selectedDate);
    if (!entry || reversedIndex < 0 || reversedIndex >= entry.items.length) {
      console.error(`getOriginalIndex: Invalid reversedIndex ${reversedIndex} for entry length ${entry?.items?.length}`);
      return -1;
    }
    return entry.items.length - 1 - reversedIndex;
  }, [dailyEntries, selectedDate]);

  // --- State Update Helper (Uses improved logic) ---
  const updateAndSaveEntries = useCallback(async (updatedEntries: DailyEntry[]) => {
    setIsSaving(true);
    const entryForSelectedDate = updatedEntries.find((e) => e.date === selectedDate);
    console.log(`DailyEntryScreen: updateAndSaveEntries called. Saving ${updatedEntries.length} total entries.`);
    console.log(`Entry for ${selectedDate} contains ${entryForSelectedDate?.items?.length ?? 0} items.`);
    setDailyEntries(updatedEntries);
    try {
      await saveDailyEntries(updatedEntries);
      console.log("DailyEntryScreen: Successfully saved updated entries to storage.");
    } catch (error) {
      console.error("DailyEntryScreen: Failed to save updated entries to storage:", error);
      Alert.alert("Save Error", "Could not save changes. Please try again.");
    } finally {
      setIsSaving(false);
    }
  }, [selectedDate]);

  // --- Inline Editing Handlers (Logic from 'before', adapted for state) ---
  const handleStartEditing = (reversedIndex: number) => {
     if (isSaving) return;
    const originalIndex = getOriginalIndex(reversedIndex);
    if (originalIndex === -1) return;

    const currentEntry = dailyEntries.find((e) => e.date === selectedDate);
    if (!currentEntry || !currentEntry.items[originalIndex]) return;

    console.log(`Starting inline edit for item at original index: ${originalIndex}`);
    setEditingIndex(originalIndex); // Store ORIGINAL index for inline
    setTempGrams(String(currentEntry.items[originalIndex].grams));
    setEditIndex(null); // Ensure modal edit state is cleared
    Keyboard.dismiss(); // Dismiss if opening edit overlay
  };

  const handleSaveInlineEdit = useCallback(async () => {
    if (editingIndex === null || isSaving) return;
    Keyboard.dismiss();

    const trimmedGrams = tempGrams.trim();
    if (!isValidNumberInput(trimmedGrams) || parseFloat(trimmedGrams) <= 0) {
      Alert.alert("Invalid Input", "Please enter a valid, positive number for grams.");
      return;
    }
    const newGramsValue = parseFloat(trimmedGrams);
    console.log(`Saving inline edit for index ${editingIndex} with grams: ${newGramsValue}`);

    const updatedEntries = dailyEntries.map((entry) => {
      if (entry.date === selectedDate) {
        const items = entry.items ?? [];
        const updatedItems = items.map((item, index) => {
          if (index === editingIndex) {
            return { ...item, grams: newGramsValue };
          }
          return item;
        });
        return { ...entry, items: updatedItems };
      }
      return entry;
    });

    await updateAndSaveEntries(updatedEntries);
    setEditingIndex(null);
    setTempGrams("");

  }, [editingIndex, tempGrams, dailyEntries, selectedDate, updateAndSaveEntries, isSaving]);

  const handleCancelInlineEdit = () => {
    console.log(`Canceling inline edit for index ${editingIndex}`);
    setEditingIndex(null);
    setTempGrams("");
    Keyboard.dismiss();
  };

  // --- Add/Update/Remove Entry Handlers (Using combined logic) ---
  // Handles single add/update from MODAL
  const handleSingleEntryAction = useCallback(async () => {
    if (isSaving) return;
    if (!selectedFood || !selectedFood.id) {
      Alert.alert("Food Not Selected", "Please select a valid food item.");
      return;
    }
    const trimmedGrams = grams.trim();
    if (!isValidNumberInput(trimmedGrams) || parseFloat(trimmedGrams) <= 0) {
      Alert.alert("Invalid Amount", "Please enter a valid positive number for grams.");
      return;
    }

    const numericGrams = parseFloat(trimmedGrams);
    const entryItem: DailyEntryItem = {
      food: selectedFood,
      grams: numericGrams,
    };

    // *** Use 'editIndex' for modal edit mode check (reverted variable name) ***
    const isEditMode = editIndex !== null;
    console.log(`handleSingleEntryAction: Mode=${isEditMode ? 'Edit' : 'Add'}, Food=${selectedFood.name}, Grams=${numericGrams}, ReversedIndex=${editIndex}`);

    const existingEntryIndex = dailyEntries.findIndex((entry) => entry.date === selectedDate);
    let updatedEntries: DailyEntry[];

    if (existingEntryIndex > -1) {
      const existingEntry = dailyEntries[existingEntryIndex];
      let updatedItems;
      if (isEditMode) {
        // --- Modal Edit Mode ---
        // *** Use 'editIndex' (reverted variable name) ***
        const originalEditIndex = getOriginalIndex(editIndex!);
        if (originalEditIndex === -1) {
          console.error("DailyEntryScreen: Error updating entry via modal - Could not find original index.");
          Alert.alert("Update Error", "An internal error occurred while trying to update the entry.");
          setIsOverlayVisible(false);
          setIsSaving(false);
          return;
        }
        console.log(`Updating item at original index ${originalEditIndex}`);
        updatedItems = existingEntry.items.map((item, index) =>
          index === originalEditIndex ? entryItem : item
        );
      } else {
        console.log("Adding new single item to existing date entry.");
        updatedItems = [...existingEntry.items, entryItem];
      }
      const updatedEntry = { ...existingEntry, items: updatedItems };
      updatedEntries = dailyEntries.map((entry, index) =>
        index === existingEntryIndex ? updatedEntry : entry
      );
    } else {
      if (isEditMode) {
        console.error("DailyEntryScreen: Error - Trying to edit an entry for a date that doesn't exist.");
        Alert.alert("Update Error", "Cannot edit an entry for a day with no previous entries.");
         setIsOverlayVisible(false);
         setIsSaving(false);
         return;
      }
      console.log("Creating new date entry with the first item.");
      const newDailyEntry: DailyEntry = { date: selectedDate, items: [entryItem] };
      updatedEntries = [...dailyEntries, newDailyEntry];
      updatedEntries.sort((a, b) => a.date.localeCompare(b.date));
    }

    await updateAndSaveEntries(updatedEntries);

    if (foodIcons[selectedFood.name] === undefined) {
      triggerIconFetches([selectedFood], [], selectedDate);
    }

    setSelectedFood(null);
    setGrams("");
    // *** Use 'editIndex' (reverted variable name) ***
    setEditIndex(null); // Reset modal edit index
    setIsOverlayVisible(false);
    setSearch("");

  }, [
    selectedFood, grams, editIndex, dailyEntries, selectedDate, isSaving,
    getOriginalIndex, updateAndSaveEntries, foodIcons, triggerIconFetches
  ]);

  // Handles multi-add from MODAL (using improved logic)
  const handleAddMultipleEntries = useCallback(
    async (entriesToAdd: { food: Food; grams: number }[]) => {
      if (isSaving) return;
      console.log(`DailyEntryScreen: handleAddMultipleEntries START - Received ${entriesToAdd.length} items for ${selectedDate}`);
      try {
        if (!entriesToAdd || entriesToAdd.length === 0) {
             console.warn("handleAddMultipleEntries called with no items.");
             return;
        }
        const newItems: DailyEntryItem[] = entriesToAdd.map((entry) => ({
          food: entry.food,
          grams: entry.grams,
        }));
        console.log(`DailyEntryScreen: Mapped to ${newItems.length} DailyEntryItems.`);

        const existingEntryIndex = dailyEntries.findIndex((entry) => entry.date === selectedDate);
        let updatedEntries: DailyEntry[];

        if (existingEntryIndex > -1) {
          console.log(`DailyEntryScreen: Appending ${newItems.length} items to existing entry for ${selectedDate}.`);
          const existingEntry = dailyEntries[existingEntryIndex];
          const updatedItems = [...(existingEntry.items ?? []), ...newItems];
          const updatedEntry = { ...existingEntry, items: updatedItems };
          updatedEntries = dailyEntries.map((entry, index) =>
            index === existingEntryIndex ? updatedEntry : entry
          );
        } else {
          console.log(`DailyEntryScreen: Creating new entry for ${selectedDate} with ${newItems.length} items.`);
          const newDailyEntry: DailyEntry = { date: selectedDate, items: newItems };
          updatedEntries = [...dailyEntries, newDailyEntry];
          updatedEntries.sort((a, b) => a.date.localeCompare(b.date));
        }

        await updateAndSaveEntries(updatedEntries);
        console.log("DailyEntryScreen: updateAndSaveEntries completed for multiple items.");

        const foodsToFetchIconsFor = newItems.map((item) => item.food);
        triggerIconFetches(foodsToFetchIconsFor, [], selectedDate);

        Toast.show({
          type: "success",
          text1: `${entriesToAdd.length} item(s) added`,
          // *** Use readable date format from 'before' logic ***
          text2: `to ${formatDateReadable(parseISO(selectedDate))}`,
          position: "bottom",
          visibilityTime: 3000,
        });

        setIsOverlayVisible(false);
        setSelectedFood(null);
        setGrams("");
        // *** Use 'editIndex' (reverted variable name) ***
        setEditIndex(null);
        setSearch("");

      } catch (error) {
        console.error("DailyEntryScreen: Error in handleAddMultipleEntries:", error);
        Alert.alert(
          "Quick Add Error",
          `Failed to add items. ${error instanceof Error ? error.message : "Please try again."}`
        );
        setIsOverlayVisible(false);
      }
    },
    [dailyEntries, selectedDate, isSaving, updateAndSaveEntries, triggerIconFetches]
  );

  const handleSelectFood = (item: Food | null) => {
     console.log("Modal selecting food:", item?.name ?? 'null');
    setSelectedFood(item);
     // If selecting a food for *adding* (not editing), maybe clear grams?
     // *** Use 'editIndex' (reverted variable name) ***
     if (item && editIndex === null) {
          setGrams(''); // Clear grams when selecting a new food for adding
     }
  };

  // Handles remove from swipe (using combined logic)
  const handleRemoveEntry = useCallback(async (reversedIndex: number) => {
    if (isSaving) return;
    const originalIndex = getOriginalIndex(reversedIndex);
    if (originalIndex === -1) {
         console.error(`handleRemoveEntry: Invalid reversedIndex ${reversedIndex}`);
         return;
    }

    const currentEntry = dailyEntries.find((e) => e.date === selectedDate);
    if (!currentEntry || originalIndex >= currentEntry.items.length) {
        console.error(`handleRemoveEntry: Cannot find entry or item at original index ${originalIndex}`);
        return;
    }

    const itemToRemove = currentEntry.items[originalIndex];
    console.log(`Attempting to remove item at original index ${originalIndex}: ${itemToRemove.food.name}`);

    const updatedItems = currentEntry.items.filter((_, i) => i !== originalIndex);
    let finalEntries: DailyEntry[];
    if (updatedItems.length === 0) {
         console.log(`Removing last item for date ${selectedDate}, entry will be removed.`);
         finalEntries = dailyEntries.filter((entry) => entry.date !== selectedDate);
    } else {
         const updatedEntry = { ...currentEntry, items: updatedItems };
         finalEntries = dailyEntries.map((entry) =>
            entry.date === selectedDate ? updatedEntry : entry
         );
    }

    await updateAndSaveEntries(finalEntries);

    Toast.show({
      type: "info",
      text1: `${itemToRemove.food.name} removed`,
      text2: "Tap here to undo",
      position: "bottom",
      bottomOffset: 80,
      visibilityTime: 4000,
      onPress: () => handleUndoRemoveEntry(itemToRemove, selectedDate, originalIndex),
    });

  }, [dailyEntries, selectedDate, isSaving, getOriginalIndex, updateAndSaveEntries]);

  // Handles undo remove from toast (using combined logic)
  const handleUndoRemoveEntry = useCallback(async (
    itemToRestore: DailyEntryItem,
    entryDate: string,
    originalIndex: number
  ) => {
    if (isSaving) return;
    console.log(`Undoing removal of ${itemToRestore.food.name} at original index ${originalIndex} on ${entryDate}`);

    const existingEntryIndex = dailyEntries.findIndex((e) => e.date === entryDate);
    let updatedEntries;

    if (existingEntryIndex > -1) {
        const entryToUpdate = dailyEntries[existingEntryIndex];
        const updatedItems = [...entryToUpdate.items];
        updatedItems.splice(originalIndex, 0, itemToRestore);
        const restoredEntry = { ...entryToUpdate, items: updatedItems };
        updatedEntries = dailyEntries.map((entry, index) =>
            index === existingEntryIndex ? restoredEntry : entry
        );
        console.log(`Item inserted back into existing entry at index ${originalIndex}.`);
    } else {
        console.log(`Creating new entry for date ${entryDate} as it was removed.`);
        const newEntry: DailyEntry = { date: entryDate, items: [itemToRestore] };
        updatedEntries = [...dailyEntries, newEntry];
        updatedEntries.sort((a, b) => a.date.localeCompare(b.date));
    }

    await updateAndSaveEntries(updatedEntries);
    Toast.hide();
    Toast.show({
      type: "success",
      text1: "Entry restored!",
      visibilityTime: 1500,
      position: "bottom",
    });
  }, [dailyEntries, isSaving, updateAndSaveEntries]);

  const updateSearch = (search: string) => setSearch(search);

  // --- Modal Toggle Logic (Adapted from 'before' to use 'editIndex') ---
  const toggleOverlay = useCallback((
    itemToEdit: DailyEntryItem | null = null,
    reversedIndex: number | null = null
  ) => {
    if (isSaving) {
        console.warn("Attempted to toggle modal while saving.");
        return;
    }

    // *** Reset state based on 'before' logic ***
    setSelectedFood(null);
    setGrams("");
    setEditIndex(null); // Clear modal edit index by default
    setSearch("");
    setEditingIndex(null); // Clear inline edit state
    setTempGrams("");

    if (itemToEdit && reversedIndex !== null) {
      // --- Setup for MODAL EDIT ---
      console.log(`Opening modal to edit item '${itemToEdit.food.name}' at reversed index ${reversedIndex}`);
      setSelectedFood(itemToEdit.food);
      setGrams(String(itemToEdit.grams)); // Set initial grams for edit
      // *** Use 'editIndex' (reverted variable name) ***
      setEditIndex(reversedIndex); // Store REVERSED index for modal context
      setIsOverlayVisible(true); // Show modal
    } else {
      // --- Setup for ADD or Closing ---
      if (isOverlayVisible) {
         console.log("Closing modal.");
      } else {
           console.log("Opening modal for Add.");
      }
      setIsOverlayVisible((current) => !current); // Toggle visibility
    }
  }, [isSaving, isOverlayVisible]); // Added isOverlayVisible dependency

  const handleEditEntryViaModal = (item: DailyEntryItem, reversedIndex: number) => {
    toggleOverlay(item, reversedIndex); // Call toggleOverlay with edit context
  };

  // --- Date Navigation Handlers (Using combined logic) ---
  const handleDateChange = useCallback((event: DateTimePickerEvent, selectedDateValue?: Date) => {
    const isAndroidDismiss = Platform.OS === "android" && event.type === "dismissed";
    setShowDatePicker(Platform.OS === "ios");

    if (!isAndroidDismiss && event.type === "set" && selectedDateValue) {
        if (isValid(selectedDateValue)) {
             const formattedDate = formatISO(selectedDateValue, { representation: "date" });
            if (formattedDate !== selectedDate) {
                 console.log(`Date changed via picker to: ${formattedDate}`);
                 setSelectedDate(formattedDate);
                 setEditingIndex(null); // Cancel inline edit
                 setTempGrams("");
                 setEditIndex(null); // Cancel modal edit
            }
        } else {
            console.warn("Date picker returned invalid date:", selectedDateValue);
            Alert.alert("Invalid Date", "The selected date is not valid.");
        }
    } else if (Platform.OS === "android") {
         setShowDatePicker(false);
    }
  }, [selectedDate]);

  const handlePreviousDay = useCallback(() => {
    try {
        const currentDateObj = parseISO(selectedDate);
        if (!isValid(currentDateObj)) {
             console.error("Error parsing current selected date:", selectedDate);
             return;
        }
        const newDate = subDays(currentDateObj, 1);
        const newDateString = formatISO(newDate, { representation: "date" });
        console.log(`Navigating to previous day: ${newDateString}`);
        setSelectedDate(newDateString);
        setEditingIndex(null); // Cancel inline edit
        setTempGrams("");
        setEditIndex(null); // Cancel modal edit
    } catch (e) {
      console.error("Error calculating previous day:", selectedDate, e);
    }
  }, [selectedDate]);

  const handleNextDay = useCallback(() => {
    try {
       const currentDateObj = parseISO(selectedDate);
        if (!isValid(currentDateObj)) {
             console.error("Error parsing current selected date:", selectedDate);
             return;
        }
        const newDate = addDays(currentDateObj, 1);
         const newDateString = formatISO(newDate, { representation: "date" });
        console.log(`Navigating to next day: ${newDateString}`);
        setSelectedDate(newDateString);
        setEditingIndex(null); // Cancel inline edit
        setTempGrams("");
        setEditIndex(null); // Cancel modal edit
    } catch (e) {
      console.error("Error calculating next day:", selectedDate, e);
    }
  }, [selectedDate]);

  // --- Totals Calculation (Using improved logic) ---
  const calculateTotals = useMemo(() => {
    const currentOriginalEntry = dailyEntries.find((entry) => entry.date === selectedDate);
    let totals = { totalCalories: 0, totalProtein: 0, totalCarbs: 0, totalFat: 0 };

    if (currentOriginalEntry) {
      currentOriginalEntry.items.forEach((item) => {
        if (item.food && typeof item.food.calories === 'number' &&
            typeof item.food.protein === 'number' &&
            typeof item.food.carbs === 'number' &&
            typeof item.food.fat === 'number' &&
            typeof item.grams === 'number' && item.grams > 0) {
                const factor = item.grams / 100;
                totals.totalCalories += item.food.calories * factor;
                totals.totalProtein += item.food.protein * factor;
                totals.totalCarbs += item.food.carbs * factor;
                totals.totalFat += item.food.fat * factor;
        } else {
            console.warn("Skipping item in total calculation due to missing/invalid data:", item);
        }
      });
    }
    return {
      totalCalories: Math.round(totals.totalCalories),
      totalProtein: Math.round(totals.totalProtein),
      totalCarbs: Math.round(totals.totalCarbs),
      totalFat: Math.round(totals.totalFat),
    };
  }, [dailyEntries, selectedDate]);

   // --- Render Item Component (Memoized, adapted to 'before' look) ---
   const RenderItem = React.memo(({ item, reversedIndex }: { item: DailyEntryItem, reversedIndex: number }) => {
        const [iconLoadError, setIconLoadError] = useState(false); // Local state for image errors
        const originalIndex = getOriginalIndex(reversedIndex);
        const isInlineEditing = editingIndex === originalIndex;
        const iconStatus = foodIcons[item.food.name];
        const isLoadingIcon = iconStatus === undefined;

        const handleImageError = useCallback(() => {
            console.warn(`Image component failed to load icon for ${item.food.name}: ${iconStatus}`);
            setIconLoadError(true);
            // *** Explicitly update state in cache to null if Image fails ***
            if (foodIcons[item.food.name] !== null) {
                setFoodIcons(prev => ({ ...prev, [item.food.name]: null }));
            }
        }, [item.food.name, iconStatus]);

        useEffect(() => {
            setIconLoadError(false); // Reset error if icon URL changes
        }, [iconStatus]);

        const renderListItemIcon = () => {
             // Uses styles from 'before' code
             if (isLoadingIcon) {
                return <ActivityIndicator size="small" color={theme.colors.grey3} style={styles.foodIcon} />;
             } else if (iconStatus && !iconLoadError) {
                 return <Image source={{ uri: iconStatus }} style={styles.foodIcon} onError={handleImageError} />;
             } else {
                 // Use placeholder from 'before' code
                 return (
                     <Icon
                         name="restaurant-outline"
                         type="ionicon"
                         color={theme.colors.grey3}
                         containerStyle={styles.defaultIconContainer} // Use container style
                     />
                 );
             }
        };

        return (
            <ListItem.Swipeable
                bottomDivider
                leftContent={(reset) => (
                    // Style from 'before' code
                    <Button
                        title="Edit"
                        onPress={() => {
                            if (!isSaving) {
                                handleEditEntryViaModal(item, reversedIndex);
                                reset();
                            }
                        }}
                        icon={{ name: "edit", color: "white" }}
                        buttonStyle={{ minHeight: "100%", backgroundColor: theme.colors.warning }}
                        disabled={isSaving}
                    />
                )}
                rightContent={(reset) => (
                     // Style from 'before' code
                    <Button
                        title="Delete"
                        onPress={() => {
                            if (!isSaving) {
                                handleRemoveEntry(reversedIndex);
                                reset();
                            }
                        }}
                        icon={{ name: "delete", color: "white" }}
                        buttonStyle={{ minHeight: "100%", backgroundColor: theme.colors.error }}
                        disabled={isSaving}
                    />
                )}
                containerStyle={{ backgroundColor: theme.colors.background }}
            >
                {/* Icon Rendering Logic */}
                {renderListItemIcon()}

                {/* Content: Title and Subtitle/Inline Edit (structure from 'before') */}
                <ListItem.Content>
                    <ListItem.Title style={styles.listItemTitle}>
                        {item.food.name}
                    </ListItem.Title>
                    {isInlineEditing ? (
                        // --- Inline Edit View (structure/styles from 'before') ---
                        <View style={styles.inlineEditContainer}>
                            <Input
                                value={tempGrams}
                                onChangeText={setTempGrams}
                                keyboardType="numeric"
                                containerStyle={styles.inlineInputContainer}
                                inputContainerStyle={styles.inlineInputInnerContainer}
                                inputStyle={styles.inlineInput}
                                autoFocus
                                selectTextOnFocus
                                maxLength={6}
                                onSubmitEditing={handleSaveInlineEdit} // Save on submit
                                onBlur={handleSaveInlineEdit} // Also save on blur
                                disabled={isSaving}
                            />
                            <Text style={styles.inlineInputSuffix}>g</Text>
                            <Button
                                type="clear"
                                onPress={handleSaveInlineEdit}
                                icon={<Icon name="checkmark-circle" type="ionicon" color={theme.colors.success} size={24} />}
                                containerStyle={styles.inlineButtonContainer}
                                disabled={isSaving}
                            />
                            <Button
                                type="clear"
                                onPress={handleCancelInlineEdit}
                                icon={<Icon name="close-circle" type="ionicon" color={theme.colors.error} size={24} />}
                                containerStyle={styles.inlineButtonContainer}
                                disabled={isSaving}
                            />
                        </View>
                    ) : (
                         // --- Display View (structure from 'before') ---
                        <ListItem.Subtitle
                            style={styles.listItemSubtitle}
                            onPress={() => !isSaving && handleStartEditing(reversedIndex)} // Subtitle press triggers inline edit
                            disabled={isSaving}
                        >
                            {`${item.grams}g  ${Math.round((item.food.calories / 100) * item.grams)} kcal`}
                        </ListItem.Subtitle>
                    )}
                </ListItem.Content>
                 {/* Show Chevron only when NOT editing (as per 'before' code) */}
                 {!isInlineEditing && <ListItem.Chevron color={theme.colors.grey3} />}
            </ListItem.Swipeable>
        );
   });

  // --- Main Render (Structure from 'before') ---
  return (
    <SafeAreaView style={styles.container} edges={["top", "left", "right"]}>
      {/* Date Navigation Header (styles/icons from 'before') */}
      <View style={styles.dateNavigation}>
        <Button
          type="clear"
          onPress={handlePreviousDay}
           // *** Use theme.colors.text for icon color as per 'before' ***
          icon={<Icon name="chevron-back-outline" type="ionicon" color={theme.colors.text} size={28} />}
          buttonStyle={styles.navButton}
          disabled={isSaving || isLoadingData}
        />
        {/* TouchableOpacity around Text for date */}
        <TouchableOpacity onPress={() => !isSaving && !isLoadingData && setShowDatePicker(true)} disabled={isSaving || isLoadingData}>
          <Text h4 style={styles.dateText}>
             {formatDateReadable(parseISO(selectedDate))}
          </Text>
        </TouchableOpacity>
        <Button
          type="clear"
          onPress={handleNextDay}
          // *** Use theme.colors.text for icon color as per 'before' ***
          icon={<Icon name="chevron-forward-outline" type="ionicon" color={theme.colors.text} size={28} />}
          buttonStyle={styles.navButton}
          disabled={isSaving || isLoadingData}
        />
      </View>

      {/* Date Picker */}
      {showDatePicker && (
        <DateTimePicker
          value={parseISO(selectedDate)}
          mode="date"
          display={Platform.OS === "ios" ? "spinner" : "default"}
          onChange={handleDateChange}
          // maximumDate={new Date()}
        />
      )}

      {/* Progress Bars */}
      <DailyProgress
        calories={calculateTotals.totalCalories}
        protein={calculateTotals.totalProtein}
        carbs={calculateTotals.totalCarbs}
        fat={calculateTotals.totalFat}
        goals={dailyGoals}
      />
      <Divider style={styles.divider} />

       {/* Saving Indicator (subtle) */}
      {isSaving && (
          <View style={styles.savingIndicator}>
              <ActivityIndicator size="small" color={theme.colors.primary} />
              <Text style={styles.savingText}>Saving...</Text>
          </View>
      )}

      {/* Section Title (style from 'before') */}
      <Text h4 style={[styles.sectionTitle, { color: theme.colors.text }]}>
        Today's Entries
      </Text>

      {/* Entries List */}
      {isLoadingData ? (
         <View style={styles.centeredLoader}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text style={styles.loadingText}>Loading Entries...</Text>
          </View>
      ) : (
        <FlatList
            data={currentEntryItems}
            // Key needs stability - use food ID, index, and grams
             keyExtractor={(item, index) => `entry-${item?.food?.id ?? 'unknown'}-${getOriginalIndex(index)}-${item?.grams ?? index}`}
            renderItem={({ item, index }) => <RenderItem item={item} reversedIndex={index} />}
             // Empty Component (structure/icon/styles from 'before')
            ListEmptyComponent={
            <View style={styles.emptyListContainer}>
                <Icon name="leaf-outline" type="ionicon" size={40} color={theme.colors.grey3} />
                <Text style={styles.emptyListText}>No entries for this day yet.</Text>
                <Text style={styles.emptyListSubText}>Tap the '+' button to add food.</Text>
            </View>
            }
            // Optimization props from 'before'
            initialNumToRender={10}
            maxToRenderPerBatch={5}
            windowSize={11}
            contentContainerStyle={styles.listContentContainer}
            keyboardShouldPersistTaps="handled"
        />
      )}

      {/* FAB (style from 'before') */}
      <FAB
        icon={<Icon name="add" color="white" />}
        color={theme.colors.primary}
        onPress={() => !isSaving && toggleOverlay()}
        placement="right"
        size="large"
        style={styles.fab} // Use style from 'before' for positioning
        disabled={isSaving || isLoadingData}
      />

      {/* Add/Edit Modal */}
      <AddEntryModal
        isVisible={isOverlayVisible}
        toggleOverlay={toggleOverlay}
        selectedFood={selectedFood}
        grams={grams}
        setGrams={setGrams}
        foods={foods}
        handleAddEntry={handleSingleEntryAction} // For single add/update
        handleAddMultipleEntries={handleAddMultipleEntries} // For multi-add
        handleSelectFood={handleSelectFood}
        search={search}
        updateSearch={updateSearch}
        // *** Pass isEditMode based on 'editIndex' (reverted variable name) ***
        isEditMode={editIndex !== null}
        // *** Pass initialGrams based on 'editIndex' for modal edit ***
        initialGrams={editIndex !== null ? grams : undefined}
      />
    </SafeAreaView>
  );
};

// Styles definition using makeStyles - **PASTED FROM 'BEFORE' CODE**
const useStyles = makeStyles((theme) => ({
    container: {
        flex: 1,
        backgroundColor: theme.colors.background,
    },
    dateNavigation: {
        flexDirection: "row",
        alignItems: "center",
        justifyContent: "space-between",
        paddingVertical: 8,
        paddingHorizontal: 5, // Reduced horizontal padding for buttons
        borderBottomWidth: 1,
        borderBottomColor: theme.colors.divider,
    },
    navButton: { // Style for the arrow buttons
        paddingHorizontal: 8, // Give arrows some horizontal tap space
    },
    dateText: {
        fontSize: 18,
        fontWeight: "bold",
        color: theme.colors.text,
        textAlign: 'center', // Center the date text
        paddingVertical: 5, // Add vertical padding for touchability
    },
    foodIcon: { // Consistent style for list item icons
        width: 40,
        height: 40,
        marginRight: 15,
        borderRadius: 20, // Circular
        resizeMode: "contain", // Ensure icon fits well
        backgroundColor: theme.colors.grey5, // Background shown while loading/if error
        alignItems: 'center', // Center activity indicator if shown
        justifyContent: 'center', // Center activity indicator if shown
        overflow: 'hidden', // Hide overflow for clean look
    },
    defaultIconContainer: { // Container used when icon fetch fails or returns null
        width: 40,
        height: 40,
        marginRight: 15,
        borderRadius: 20,
        backgroundColor: theme.colors.grey5,
        alignItems: 'center',
        justifyContent: 'center',
    },
    listItemTitle: {
        color: theme.colors.text,
        fontWeight: 'bold',
        fontSize: 16, // Slightly larger title
    },
    listItemSubtitle: {
        color: theme.colors.grey1, // Subtitle color
        fontSize: 14,
        marginTop: 3, // Space below title
        // *** Added padding for better touch target for inline edit ***
        paddingVertical: 2,
        paddingHorizontal: 5, // Some horizontal padding too
    },
    divider: {
        marginVertical: 10,
    },
    sectionTitle: {
        marginTop: 15, // Increased top margin
        marginBottom: 8,
        paddingHorizontal: 15,
        fontWeight: '600', // Slightly less bold than h3 default
        fontSize: 18, // Adjust font size
        // *** Color changed back to grey1 as per 'before' ***
        color: theme.colors.grey1,
    },
    fab: { // Style for the FAB component itself
        position: 'absolute', // Keep absolute positioning
        margin: 16, // Standard margin
        right: 10, // Adjust position slightly
        bottom: 10, // Adjust position slightly
    },
     emptyListContainer: { // Styling for the empty list message
        flex: 1, // Allow it to take space if needed
        alignItems: 'center',
        justifyContent: 'center',
        marginTop: 50,
        paddingHorizontal: 30, // More padding
    },
    emptyListText: {
        fontSize: 17, // Slightly larger text
        color: theme.colors.grey2,
        textAlign: 'center',
        marginTop: 10, // Space below icon
    },
     emptyListSubText: {
        fontSize: 14,
        color: theme.colors.grey3,
        textAlign: 'center',
        marginTop: 8,
    },
    // --- Inline Editing Styles (from 'before' code) ---
    inlineEditContainer: { // Container for the input and buttons during inline edit
        flexDirection: "row",
        alignItems: "center",
        marginTop: 5, // Space below the title
        width: '100%', // Take full width of content area
    },
    inlineInputContainer: { // RNE Input component's outer container
        width: 80, // Fixed width for the input area
        height: 38, // Match button height approximately
        paddingHorizontal: 0, // Remove default padding
        // *** Added marginRight to space from suffix ***
        marginRight: 4,
    },
    inlineInputInnerContainer: { // RNE Input component's inner container (handles underline)
        borderBottomWidth: 1,
        borderColor: theme.colors.primary,
        paddingHorizontal: 6,
        height: '100%',
        paddingVertical: 0, // Remove vertical padding if any
        justifyContent: 'center', // Center text vertically
        // *** Added background to match theme, prevents potential transparency issues ***
        backgroundColor: theme.colors.background,
    },
    inlineInput: { // Style for the text *inside* the inline input
        fontSize: 14, // Match subtitle size
        color: theme.colors.text, // Use theme text color
        textAlign: 'right', // Align number to the right
        paddingVertical: 0, // No extra vertical padding
    },
    inlineInputSuffix: { // Style for the "g" text next to the input
         fontSize: 14,
         color: theme.colors.grey1,
         // *** Adjusted margins as per 'before' ***
         marginLeft: 0,
         marginRight: 8, // Space before buttons
    },
     inlineButtonContainer: { // Container for the checkmark/cross buttons
        padding: 0, // Remove padding
        // *** Adjusted margins as per 'before' ***
        marginHorizontal: 0, // No horizontal margin between buttons
        minWidth: 30, // Ensure decent tap area
        justifyContent: 'center',
        alignItems: 'center',
    },
    // --- Loader and Saving Styles ---
    centeredLoader: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
    },
    loadingText: {
        marginTop: 10,
        color: theme.colors.grey2,
        fontSize: 16,
    },
    savingIndicator: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      paddingVertical: 4,
      // backgroundColor: theme.colors.grey5, // Optional subtle background
    },
    savingText: {
        marginLeft: 8,
        color: theme.colors.primary,
        fontSize: 14,
        fontStyle: 'italic',
    },
    // --- List Content Container Style ---
    listContentContainer: {
        paddingBottom: 80, // Ensure space for FAB
    }
}));

export default DailyEntryScreen;
---------- END DailyEntryScreen.tsx ----------


---------- FoodListScreen.tsx ----------
// FoodListScreen.tsx (Corrected State Key and Prop Passing)
import React, { useState, useEffect, useCallback, useMemo, useRef } from "react";
import { View, FlatList, Alert, Platform, ActivityIndicator, StyleSheet } from "react-native";
import {
    createFood,
    getFoods,
    updateFood,
    deleteFood,
} from "../services/foodService";
import { Food } from "../types/food";
import { isValidNumberInput, isNotEmpty } from "../utils/validationUtils";
import FoodItem from "../components/FoodItem";
import { Button, SearchBar, useTheme, makeStyles, Text, Icon as RNEIcon } from "@rneui/themed";
import { FAB } from "@rneui/base";
import { SafeAreaView } from "react-native-safe-area-context";
import AddFoodModal from "../components/AddFoodModal";
import Toast from "react-native-toast-message";
import { useFocusEffect } from "@react-navigation/native";
import { getFoodIconUrl } from "../utils/iconUtils";

interface FoodListScreenProps {
    onFoodChange?: () => void; // Optional callback when food data changes
}

const FoodListScreen: React.FC<FoodListScreenProps> = ({ onFoodChange }) => {
    const [foods, setFoods] = useState<Food[]>([]);
    // State: key=food.name, value=undefined(loading), null(failed/no_icon), string(url)
    const [foodIcons, setFoodIcons] = useState<{ [foodName: string]: string | null | undefined }>({});
    const [isLoading, setIsLoading] = useState(true); // Loading state for initial fetch
    const [isOverlayVisible, setIsOverlayVisible] = useState(false);
    const [search, setSearch] = useState("");
    const [newFood, setNewFood] = useState<Omit<Food, "id">>({
        name: "", calories: 0, protein: 0, carbs: 0, fat: 0,
    });
    const [editFood, setEditFood] = useState<Food | null>(null);
    const [errors, setErrors] = useState<{ [key: string]: string }>({});
    const [isSaving, setIsSaving] = useState(false); // State to disable buttons during save

    const { theme } = useTheme();
    const styles = useStyles();
    const flatListRef = useRef<FlatList>(null); // Ref for FlatList

    // --- Data Loading and Icon Fetching ---
    const loadFoodData = useCallback(async () => {
        console.log("FoodListScreen: Loading food data...");
        setIsLoading(true);
        setFoodIcons({}); // Clear icons on reload
        try {
            const loadedFoods = await getFoods();
            loadedFoods.sort((a, b) => a.name.localeCompare(b.name));
            setFoods(loadedFoods);
            console.log(`FoodListScreen: Loaded ${loadedFoods.length} foods.`);
            // Trigger icon fetches after foods are loaded
            fetchIconsForFoods(loadedFoods); // Pass loaded foods directly
        } catch (error) {
            console.error("FoodListScreen: Error loading food data:", error);
            Alert.alert("Error", "Failed to load food list.");
            setFoods([]);
        } finally {
            setIsLoading(false);
        }
    }, []); // No dependencies, should run once or on focus

    const fetchIconsForFoods = useCallback(async (foodsToFetch: Food[]) => {
        if (!foodsToFetch || foodsToFetch.length === 0) return;
        console.log(`FoodListScreen: Fetching icons for ${foodsToFetch.length} foods.`);

        // Use food.name as the key
        const iconPromises = foodsToFetch.map(async (food) => {
            // Check if icon status is unknown (undefined) using food.name
            if (foodIcons[food.name] === undefined) {
                try {
                    const iconUrl = await getFoodIconUrl(food.name);
                    return { name: food.name, url: iconUrl }; // Return name and URL
                } catch (error) {
                    console.warn(`Icon fetch failed for ${food.name}:`, error);
                    return { name: food.name, url: null }; // Ensure null on error
                }
            }
            return null; // Skip fetch if already checked/cached in state
        });

        const results = await Promise.all(iconPromises);
        // Use functional update for reliability
        setFoodIcons(prevIcons => {
             const newIcons = { ...prevIcons }; // Copy previous state
             results.forEach(result => {
                 if (result) {
                     newIcons[result.name] = result.url; // Use food.name as key
                 }
             });
             // Log only if there were actual updates
             const updatedKeys = results.filter(r => r !== null).length;
             if (updatedKeys > 0) {
                  console.log(`FoodListScreen: Updated icons state for ${updatedKeys} food names.`);
             }
             return newIcons;
        });

    }, []); // Remove foodIcons dependency to allow re-fetching if needed, managed by undefined check

    // Load data when the screen comes into focus
    useFocusEffect(
        useCallback(() => {
            loadFoodData();
            return () => {
                 console.log("FoodListScreen: Unfocused.");
            };
        }, [loadFoodData])
    );

    // --- Validation ---
    const validateFood = (food: Omit<Food, "id">): { [key: string]: string } | null => {
        const newErrors: { [key: string]: string } = {};
        if (!isNotEmpty(food.name)) newErrors.name = "Name is required";
        if (isNaN(food.calories) || food.calories < 0) newErrors.calories = "Invalid number (>= 0)";
        if (isNaN(food.protein) || food.protein < 0) newErrors.protein = "Invalid number (>= 0)";
        if (isNaN(food.carbs) || food.carbs < 0) newErrors.carbs = "Invalid number (>= 0)";
        if (isNaN(food.fat) || food.fat < 0) newErrors.fat = "Invalid number (>= 0)";
        return Object.keys(newErrors).length === 0 ? null : newErrors;
    };

    // --- CRUD Operations ---
    const handleCreateFood = async () => {
        const validationErrors = validateFood(newFood);
        if (validationErrors) {
            setErrors(validationErrors);
            Toast.show({ type: 'error', text1: 'Please fix errors', position: 'bottom' });
            return;
        }
        setErrors({});
        setIsSaving(true);
        try {
            const foodToCreate = { ...newFood, name: newFood.name.trim() }; // Trim name before saving
            console.log("FoodListScreen: Creating food:", foodToCreate);
            const createdFood = await createFood(foodToCreate);
            console.log("FoodListScreen: Food created successfully:", createdFood);

            const updatedFoods = [...foods, createdFood].sort((a, b) => a.name.localeCompare(b.name));
            setFoods(updatedFoods);

             // Fetch icon for the newly created food using its name
             const iconUrl = await getFoodIconUrl(createdFood.name);
             setFoodIcons(prev => ({ ...prev, [createdFood.name]: iconUrl })); // Use name as key

            setNewFood({ name: "", calories: 0, protein: 0, carbs: 0, fat: 0 });
            setIsOverlayVisible(false);
            onFoodChange?.();
            Toast.show({ type: 'success', text1: `${createdFood.name} added`, position: 'bottom' });

        } catch (error: any) {
            console.error("FoodListScreen: Error creating food:", error);
            Alert.alert("Error", error.message || "Failed to create food.");
        } finally {
            setIsSaving(false);
        }
    };

    const handleUpdateFood = async () => {
        if (!editFood) return;
        const foodToUpdate = { ...editFood, name: editFood.name.trim() }; // Trim name
        const validationErrors = validateFood(foodToUpdate);
        if (validationErrors) {
            setErrors(validationErrors);
            Toast.show({ type: 'error', text1: 'Please fix errors', position: 'bottom' });
            return;
        }
        setErrors({});
        setIsSaving(true);
        try {
            console.log("FoodListScreen: Updating food:", foodToUpdate);
            const updated = await updateFood(foodToUpdate); // Use trimmed version
            console.log("FoodListScreen: Food updated successfully:", updated);

            const originalFood = foods.find(f => f.id === updated.id); // Find original for comparison
            const updatedFoods = foods.map((f) => (f.id === updated.id ? updated : f))
                                      .sort((a, b) => a.name.localeCompare(b.name));
            setFoods(updatedFoods);

             // Check if the name changed and if the icon needs refetching
            if (originalFood && originalFood.name.toLowerCase() !== updated.name.toLowerCase()) {
                 console.log(`Food name changed from "${originalFood.name}" to "${updated.name}", refetching icon.`);
                 const iconUrl = await getFoodIconUrl(updated.name);
                 setFoodIcons(prev => ({ ...prev, [updated.name]: iconUrl }));
                 // Optionally remove old icon state if name was key: delete newIcons[originalFood.name];
            }

            setEditFood(null);
            setIsOverlayVisible(false);
            onFoodChange?.();
            Toast.show({ type: 'success', text1: `${updated.name} updated`, position: 'bottom' });
        } catch (error: any) {
            console.error("FoodListScreen: Error updating food:", error);
            Alert.alert("Error", error.message || "Failed to update food.");
        } finally {
            setIsSaving(false);
        }
    };

     const handleDeleteFood = async (foodId: string) => {
        const foodToDelete = foods.find((f) => f.id === foodId);
        if (!foodToDelete) return;

        setFoods(foods.filter((f) => f.id !== foodId)); // Optimistic UI update

        try {
            console.log("FoodListScreen: Deleting food:", foodToDelete.name, foodId);
            await deleteFood(foodId);
            console.log("FoodListScreen: Food deleted successfully from storage.");
            // Toast is handled by FoodItem callback
            onFoodChange?.();
        } catch (error) {
            console.error("FoodListScreen: Error deleting food:", error);
            // Revert UI change on error
            setFoods((prevFoods) => [...prevFoods, foodToDelete].sort((a,b) => a.name.localeCompare(b.name)));
            Alert.alert("Delete Error", "Failed to delete food from storage. Restored item.");
        }
    };

    const handleUndoDeleteFood = async (food: Food) => {
         console.log("FoodListScreen: Undoing delete for:", food.name, food.id);
        const restoredFoods = [...foods, food].sort((a, b) => a.name.localeCompare(b.name));
        setFoods(restoredFoods);
        Toast.hide();

        // --- Important Note on Undo ---
        // This UNDO is primarily client-side for the UI.
        // A robust backend implementation would ideally require an "undelete" endpoint
        // or use soft deletes. Re-creating the food via `createFood` would generate
        // a NEW ID, which is usually not the desired behavior for an undo.
        // We are skipping backend interaction here, assuming the user wants the UI restored.
        console.log("FoodListScreen: Food restored in UI state. Backend state not modified by undo.");
        onFoodChange?.();
        Toast.show({ type: 'success', text1: `${food.name} restored`, position: 'bottom', visibilityTime: 2000 });
    };

    // --- Modal and Input Handling ---
    const toggleOverlay = (foodToEdit?: Food) => {
        if (isSaving) return; // Prevent toggle while saving
        if (foodToEdit) {
            console.log("FoodListScreen: Opening modal to edit:", foodToEdit.name);
            setEditFood(foodToEdit);
            setNewFood({ name: "", calories: 0, protein: 0, carbs: 0, fat: 0 });
        } else {
             console.log("FoodListScreen: Opening modal to add new food.");
            setEditFood(null);
            setNewFood({ name: "", calories: 0, protein: 0, carbs: 0, fat: 0 });
        }
        setErrors({});
        setIsOverlayVisible(!isOverlayVisible);
    };

    const updateSearch = (search: string) => setSearch(search);

    const filteredFoods = useMemo(() => {
        return foods.filter((food) =>
            food.name.toLowerCase().includes(search.toLowerCase())
        );
    }, [foods, search]);

    // Using useCallback for stability if passed down, though AddFoodModal might not need it
    const handleInputChange = useCallback((
        key: keyof Omit<Food, "id">,
        value: string,
        isEdit: boolean
    ) => {
        const numericKeys: (keyof Omit<Food, "id">)[] = ['calories', 'protein', 'carbs', 'fat'];
        let processedValue: string | number = value;

        if (numericKeys.includes(key)) {
            if (value === "" || value === ".") {
                 processedValue = value;
            } else {
                const cleaned = value.replace(/[^0-9.]/g, "").replace(/(\..*)\./g, "$1");
                // Allow empty string result from cleaning, treat as 0 later
                if (cleaned === "" || !isNaN(parseFloat(cleaned))) {
                     processedValue = cleaned;
                } else {
                    return; // Prevent update if cleaning results in invalid state like ".."
                }
            }
        }

        const updateState = (prevState: any) => {
             let finalValue: string | number;
             if (numericKeys.includes(key)) {
                  // Store 0 in state if input is empty or just "."
                  if (processedValue === "" || processedValue === ".") {
                      finalValue = 0;
                  } else {
                      finalValue = parseFloat(processedValue as string); // Convert valid string to number
                  }
             } else {
                finalValue = processedValue; // Use the string value for name
             }
             return { ...prevState, [key]: finalValue };
        };

        if (isEdit) {
            // Update the editFood state which holds the actual numeric values
            setEditFood(updateState);
        } else {
            // Update the newFood state similarly
            setNewFood(updateState);
        }
    }, []); // No dependencies needed as it operates on arguments

    // --- Render ---
    if (isLoading) {
        return (
            <SafeAreaView style={styles.centered}>
                <ActivityIndicator size="large" color={theme.colors.primary} />
                <Text style={styles.loadingText}>Loading Foods...</Text>
            </SafeAreaView>
        );
    }

    return (
        <SafeAreaView style={styles.container} edges={['top', 'left', 'right']}>
            <SearchBar
                placeholder="Search Foods..."
                onChangeText={updateSearch}
                value={search}
                platform={Platform.OS === "ios" ? "ios" : "android"}
                containerStyle={styles.searchBarContainer}
                inputContainerStyle={styles.searchBarInputContainer}
                inputStyle={styles.searchInputStyle}
                onClear={() => setSearch('')}
                showCancel={Platform.OS === 'ios'}
            />
            <FlatList
                ref={flatListRef}
                data={filteredFoods}
                keyExtractor={(item) => item.id} // Key remains the food ID
                renderItem={({ item }) => (
                    <FoodItem
                        food={item}
                        onEdit={toggleOverlay}
                        onDelete={handleDeleteFood}
                        onUndoDelete={handleUndoDeleteFood}
                        foodIconUrl={foodIcons[item.name]} // Pass icon state using food NAME
                    />
                )}
                ListEmptyComponent={
                    <View style={styles.centered}>
                        <RNEIcon name="fast-food-outline" type="ionicon" size={50} color={theme.colors.grey3} />
                        <Text style={styles.emptyText}>
                            {search ? `No foods found matching "${search}"` : "No foods added yet."}
                        </Text>
                        {!search && <Text style={styles.emptySubText}>Tap '+' to add your first food!</Text>}
                    </View>
                }
                contentContainerStyle={filteredFoods.length === 0 ? styles.listContainerEmpty : styles.listContainer}
                initialNumToRender={15} // Increased initial render
                maxToRenderPerBatch={10}
                windowSize={21}
                keyboardShouldPersistTaps="handled"
            />

            <FAB
                icon={{ name: "add", color: "white" }}
                color={theme.colors.primary}
                onPress={() => !isSaving && toggleOverlay()}
                placement="right"
                size="large"
                style={styles.fab}
                disabled={isSaving}
            />

            <AddFoodModal
                isVisible={isOverlayVisible}
                toggleOverlay={() => !isSaving && setIsOverlayVisible(false)}
                newFood={newFood}
                editFood={editFood}
                errors={errors}
                handleInputChange={handleInputChange}
                handleCreateFood={handleCreateFood}
                handleUpdateFood={handleUpdateFood}
                validateFood={validateFood}
                setErrors={setErrors}
                // Consider passing isSaving to disable modal inputs/buttons
            />
        </SafeAreaView>
    );
};

// Use makeStyles for theme-aware styles (keep existing styles from previous correction)
const useStyles = makeStyles((theme) => ({
    container: {
        flex: 1,
        backgroundColor: theme.colors.background,
    },
    centered: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        padding: 20,
        marginTop: 50, // Add some top margin
    },
    loadingText: {
        marginTop: 10,
        color: theme.colors.grey1,
        fontSize: 16,
    },
    emptyText: {
        marginTop: 15,
        fontSize: 18,
        color: theme.colors.grey2,
        textAlign: 'center',
    },
     emptySubText: {
        marginTop: 8,
        fontSize: 14,
        color: theme.colors.grey3,
        textAlign: 'center',
    },
    searchBarContainer: {
        backgroundColor: theme.colors.background,
        borderBottomColor: theme.colors.divider,
        borderTopColor: theme.colors.background, // Match background
        borderBottomWidth: StyleSheet.hairlineWidth,
        borderTopWidth: 0,
        paddingHorizontal: 8,
        paddingVertical: 4,
        marginBottom: 0,
    },
    searchBarInputContainer: {
        backgroundColor: theme.colors.searchBg || theme.colors.grey5,
        borderRadius: 10,
        height: 40,
    },
    searchInputStyle: {
        color: theme.colors.text,
        fontSize: 15,
    },
    listContainer: {
        paddingBottom: 80, // Ensure space for FAB
    },
    listContainerEmpty: {
        flexGrow: 1, // Ensure empty component takes full height if needed
    },
    fab: {
        position: 'absolute',
        margin: 16,
        right: 5, // Adjusted position slightly
        bottom: 5, // Adjusted position slightly
    },
}));

export default FoodListScreen;
---------- END FoodListScreen.tsx ----------


---------- SettingsScreen.tsx ----------
// src/screens/SettingsScreen.tsx
import React, { useState, useEffect, useCallback } from "react";
import { View, ScrollView, Alert, StyleSheet, ActivityIndicator } from "react-native";
import { Text, makeStyles, Button, Icon, ListItem, useTheme } from "@rneui/themed"; // Import ListItem
import DailyGoalsInput from "../components/DailyGoalsInput";
import DataManagementButtons from "../components/DataManagementButtons";
import ThemeSwitch from "../components/ThemeSwitch";
import StatisticsChart from "../components/StatisticsChart";
import { loadSettings, saveSettings, loadDailyEntries } from "../services/storageService";
import { Settings, Statistics, MacroType, MacroData } from "../types/settings";
import { parseISO, isValid } from "date-fns";
import { DailyEntry } from "../types/dailyEntry";
import { useFocusEffect } from "@react-navigation/native";
import { clearIconCache } from "../utils/iconUtils";
import Toast from "react-native-toast-message";
// Import backend service functions
import { getUserStatus, addCoinsToUser, UserStatus, BackendError } from "../services/backendService";

interface SettingsScreenProps {
  onThemeChange: (theme: "light" | "dark" | "system") => void;
}

const SettingsScreen: React.FC<SettingsScreenProps> = ({ onThemeChange }) => {
  // Initial default state - will be overwritten by loadSettings
  const [settings, setSettings] = useState<Settings>({
    theme: "system",
    dailyGoals: { calories: 0, protein: 0, carbs: 0, fat: 0 },
    settingsHistory: [],
  });

  const [statistics, setStatistics] = useState<Statistics>({
    calories: [], protein: [], carbs: [], fat: [],
  });
  const [chartUpdateKey, setChartUpdateKey] = useState(0);
  const [isClearingCache, setIsClearingCache] = useState(false);
  // State for user coins
  const [userCoins, setUserCoins] = useState<number | null>(null);
  const [isLoadingCoins, setIsLoadingCoins] = useState(false);
  const [isAddingCoins, setIsAddingCoins] = useState(false);

  const { theme } = useTheme();
  const styles = useStyles();

  // --- Statistics Calculation (No change needed here) ---
  const getStatisticsData = useCallback((
    dailyEntries: DailyEntry[],
    macro: MacroType,
    currentGoals: { [key in MacroType]: number }
   ): MacroData[][] => {
    const intakeData: MacroData[] = [];
    const goalData: MacroData[] = [];

    dailyEntries.forEach((entry) => {
       try {
            const entryDate = parseISO(entry.date);
            if (!isValid(entryDate)) {
                console.warn(`Skipping entry with invalid date: ${entry.date}`);
                return;
            }

            const entryTimestamp = entryDate.getTime();
            let intakeValue = 0;

            if (entry.items && Array.isArray(entry.items)) {
                intakeValue = entry.items.reduce((total, item) => {
                    if (item.food && typeof item.food[macro] === 'number' && typeof item.grams === 'number' && item.grams > 0) {
                        return total + (item.food[macro] / 100) * item.grams;
                    }
                    return total;
                }, 0);
            }

            const goalValue = currentGoals[macro] ?? 0;

            intakeData.push({ x: entryTimestamp, y: Math.round(intakeValue) });

            if (macro === "calories") {
                goalData.push({ x: entryTimestamp, y: Math.round(goalValue) });
            }
        } catch (parseError) {
             console.error(`Error processing entry for date ${entry.date}:`, parseError);
        }
    });

    intakeData.sort((a, b) => a.x - b.x);
    if (macro === "calories") {
        goalData.sort((a, b) => a.x - b.x);
        return [intakeData, goalData];
    } else {
        return [intakeData];
    }
  }, []);

  // --- Update Statistics State ---
  // Modified: Accepts goals as argument, removed settings.dailyGoals dependency
  const updateStatistics = useCallback(async (currentGoals: { [key in MacroType]: number }) => {
    console.log("SettingsScreen: Updating statistics...");
    try {
        const loadedEntries = await loadDailyEntries();
        // Use the passed currentGoals
        const updatedStats: Statistics = {
            calories: getStatisticsData(loadedEntries, "calories", currentGoals),
            protein: getStatisticsData(loadedEntries, "protein", currentGoals),
            carbs: getStatisticsData(loadedEntries, "carbs", currentGoals),
            fat: getStatisticsData(loadedEntries, "fat", currentGoals),
        };

        setStatistics(updatedStats);
        setChartUpdateKey((prevKey) => prevKey + 1); // Trigger chart re-render
        console.log("SettingsScreen: Statistics updated.");
    } catch (error) {
         console.error("SettingsScreen: Failed to update statistics:", error);
    }
    // Dependency only on the calculation function now
  }, [getStatisticsData]);

  // --- Fetch User Status ---
  const fetchUserStatus = useCallback(async () => {
    setIsLoadingCoins(true);
    try {
        console.log("SettingsScreen: Fetching user status...");
        const status = await getUserStatus();
        setUserCoins(status.coins);
        console.log(`SettingsScreen: User status fetched. Coins: ${status.coins}`);
    } catch (error) {
        console.error("SettingsScreen: Failed to fetch user status:", error);
        setUserCoins(null); // Indicate error state
        // Optionally show a toast or alert
         Toast.show({
           type: 'error',
           text1: 'Could not load coin balance',
           text2: error instanceof BackendError ? error.message : 'Please check connection.',
           position: 'bottom',
         });
    } finally {
        setIsLoadingCoins(false);
    }
  }, []);


  // --- Load Data on Focus ---
  // Modified: Loads settings, sets state, then calls updateStatistics and fetchUserStatus
  useFocusEffect(
    useCallback(() => {
      let isActive = true; // Prevent state updates if component is unmounted quickly
      console.log("SettingsScreen: Focused. Loading settings, user status, and statistics.");

      const loadAndProcessData = async () => {
        try {
          // Load settings first
          const loadedSettings = await loadSettings();
          if (!isActive) return; // Check flag before state update
          setSettings(loadedSettings); // Update settings state

          // Fetch user status (coins)
          await fetchUserStatus(); // Fetch coins

          // Now update statistics using the just-loaded goals
          // Pass the goals directly to avoid dependency loop
          updateStatistics(loadedSettings.dailyGoals);

        } catch (error) {
           if (isActive) {
                console.error("SettingsScreen: Error during focus effect data load:", error);
                // Handle error appropriately, e.g., show an alert
                 Alert.alert("Load Error", "Failed to load settings or statistics data.");
           }
        }
      };

      loadAndProcessData();

      return () => {
        isActive = false; // Set flag on unmount/blur
        console.log("SettingsScreen: Unfocused.");
      };
      // Dependencies are now only on the stable updateStatistics and fetchUserStatus callbacks
    }, [updateStatistics, fetchUserStatus])
  );


  // --- Handle Goal Changes ---
  // Modified: Uses functional state update and passes new goals directly to updateStatistics
  const handleGoalChange = useCallback(async (goalType: MacroType, value: string) => {
    const numericValue = parseFloat(value) || 0;

    // Use functional update for settings to get the latest state reliably
    let latestSettings: Settings | null = null;
    setSettings((prevSettings) => {
      const updatedGoals = { ...prevSettings.dailyGoals, [goalType]: numericValue };
      const updatedSettings: Settings = { ...prevSettings, dailyGoals: updatedGoals };
      latestSettings = updatedSettings; // Store the updated object

      // Trigger save and stats update in the background
      (async () => {
          if (!latestSettings) return; // Should always be set, but good practice
        try {
          await saveSettings(latestSettings);
          console.log("Settings saved successfully after goal change.");
          // Update statistics immediately with the new goals
          updateStatistics(latestSettings.dailyGoals);
        } catch (error) {
          console.error("Failed to save settings or update stats after goal change:", error);
          Alert.alert("Save Error", "Could not save goal changes.");
          // Optional: Revert UI state if save/update fails critically?
          // E.g., reload settings: setSettings(await loadSettings());
        }
      })();

      return updatedSettings; // Return updated state immediately for UI responsiveness
    });
  }, [updateStatistics]); // Dependency is only on the stable updateStatistics callback


  // --- Handle Data Management Button Trigger ---
  // Modified: Reloads settings AND passes the new goals to updateStatistics, AND refetches user status
  const handleDataOperation = useCallback(async () => {
    console.log("SettingsScreen: Data operation triggered. Reloading settings, user status, and statistics.");
    try {
        const reloadedSettings = await loadSettings();
        setSettings(reloadedSettings); // Update settings state
        updateStatistics(reloadedSettings.dailyGoals); // Update stats with new goals
        fetchUserStatus(); // Refetch user status
        // Trigger theme change if it was altered by import
        onThemeChange(reloadedSettings.theme);
        Toast.show({ type: 'info', text1: 'Data reloaded.', position: 'bottom'});
    } catch (error) {
        console.error("Error reloading data after operation:", error);
        Alert.alert("Reload Error", "Failed to reload data after operation.");
    }
  }, [updateStatistics, onThemeChange, fetchUserStatus]);

  // --- Handle Icon Cache Clearing (No change needed) ---
   const handleClearIconCache = useCallback(async () => {
      console.log("SettingsScreen: Clearing icon cache...");
      setIsClearingCache(true);
      try {
          await clearIconCache();
          Toast.show({
              type: 'success',
              text1: 'Food Icon Cache Cleared',
              text2: 'Icons will refresh when viewed.',
              position: 'bottom'
          });
          console.log("SettingsScreen: Icon cache cleared successfully.");
      } catch (error) {
           console.error("SettingsScreen: Failed to clear icon cache:", error);
           Toast.show({
              type: 'error',
              text1: 'Failed to Clear Cache',
              text2: error instanceof Error ? error.message : 'An unknown error occurred.',
              position: 'bottom'
           });
      } finally {
          setIsClearingCache(false);
      }
   }, []);

    // --- Handle Add Coins Button ---
    const handleAddTestCoins = useCallback(async () => {
        setIsAddingCoins(true);
        try {
            const amountToAdd = 10;
            console.log(`SettingsScreen: Attempting to add ${amountToAdd} coins...`);
            const updatedStatus = await addCoinsToUser(amountToAdd);
            setUserCoins(updatedStatus.coins); // Update displayed coins
            console.log(`SettingsScreen: Coins added successfully. New balance: ${updatedStatus.coins}`);
            Toast.show({
                type: 'success',
                text1: `${amountToAdd} Coins Added!`,
                text2: `New balance: ${updatedStatus.coins}`,
                position: 'bottom'
            });
        } catch (error) {
            console.error("SettingsScreen: Failed to add coins:", error);
             Toast.show({
                type: 'error',
                text1: 'Failed to Add Coins',
                text2: error instanceof BackendError ? error.message : 'Please try again.',
                position: 'bottom'
             });
        } finally {
            setIsAddingCoins(false);
        }
    }, []);

  // --- Render ---
  return (
    <ScrollView style={styles.container} contentContainerStyle={styles.scrollContentContainer}>
      <Text h3 style={styles.sectionTitle}>Account</Text>
        <ListItem bottomDivider containerStyle={styles.listItem}>
            {/* Changed Icon */}
            <Icon name="database" type="material-community" color={theme.colors.warning} />
            <ListItem.Content>
                <ListItem.Title style={styles.listItemTitle}>Coin Balance</ListItem.Title>
            </ListItem.Content>
            {isLoadingCoins ? (
                 <ActivityIndicator size="small" color={theme.colors.primary} />
             ) : (
                 <Text style={styles.coinValue}>{userCoins !== null ? userCoins : 'N/A'}</Text>
             )}
        </ListItem>
        {/* REMOVE OR PROTECT THIS BUTTON IN PRODUCTION */}
        <Button
            title="Add 10 Coins (Test)"
            onPress={handleAddTestCoins}
            buttonStyle={[styles.button, { backgroundColor: theme.colors.success, marginTop: 10 }]}
            icon={<Icon name="plus-circle-outline" type="material-community" color="white" size={20} style={{ marginRight: 8 }} />}
            loading={isAddingCoins}
            disabled={isAddingCoins || isLoadingCoins}
        />
        <Text style={styles.testButtonWarning}>
             Note: The "Add Coins" button is for testing/development only and should be removed or secured for production releases.
        </Text>


      <Text h3 style={styles.sectionTitle}>General</Text>
      {/* Pass settings.theme which is updated by useFocusEffect */}
      <ThemeSwitch currentTheme={settings.theme} onToggle={onThemeChange} />

      <Text h3 style={styles.sectionTitle}>Daily Goals</Text>
      <View style={styles.inputGroup}>
        {/* Pass settings.dailyGoals which is updated by useFocusEffect & handleGoalChange */}
        <DailyGoalsInput dailyGoals={settings.dailyGoals} onGoalChange={handleGoalChange} />
      </View>

       <Text h3 style={styles.sectionTitle}>Cache Management</Text>
       <View style={styles.buttonGroup}>
            <Button
                title="Refresh Food Icons"
                onPress={handleClearIconCache}
                buttonStyle={[styles.button, { backgroundColor: theme.colors.secondary }]}
                icon={<Icon name="refresh-outline" type="ionicon" color="white" size={20} style={{ marginRight: 8 }} />}
                loading={isClearingCache}
                disabled={isClearingCache}
            />
       </View>


      <Text h3 style={styles.sectionTitle}>Statistics</Text>
      <View style={styles.chartContainer}>
        {/* Statistics and key are updated by updateStatistics */}
        <StatisticsChart statistics={statistics} key={chartUpdateKey} />
      </View>


      <Text h3 style={styles.sectionTitle}>Data Management</Text>
      <View style={styles.buttonGroup}>
        <DataManagementButtons onDataOperation={handleDataOperation} />
      </View>
    </ScrollView>
  );
};

// Styles (adjusted from original)
const useStyles = makeStyles((theme) => ({
  container: {
    flex: 1,
    backgroundColor: theme.colors.background,
  },
  scrollContentContainer: {
     padding: 15,
     paddingBottom: 40,
  },
  sectionTitle: {
    color: theme.colors.text,
    marginTop: 25,
    marginBottom: 15,
    paddingLeft: 5,
    borderLeftWidth: 3,
    borderLeftColor: theme.colors.primary,
  },
  inputGroup: {
     marginBottom: 10,
     paddingHorizontal: 5,
  },
   buttonGroup: {
      marginBottom: 10,
      paddingHorizontal: 5,
   },
  button: {
    marginBottom: 10,
    borderRadius: 8,
  },
  chartContainer: {
    minHeight: 300,
    height: 'auto',
    marginBottom: 20,
  },
  // Styles for Coin Display
  listItem: {
    backgroundColor: theme.colors.background,
    paddingVertical: 15, // Add some padding
  },
  listItemTitle: {
    color: theme.colors.text,
    fontWeight: '500',
  },
  coinValue: {
    color: theme.colors.primary,
    fontWeight: 'bold',
    fontSize: 16,
  },
  testButtonWarning: {
    fontSize: 12,
    color: theme.colors.grey3,
    fontStyle: 'italic',
    textAlign: 'center',
    marginTop: 0,
    marginBottom: 15,
    marginHorizontal: 10,
  },
}));

export default SettingsScreen;
---------- END SettingsScreen.tsx ----------


---------- backendService.ts ----------
// src/services/backendService.ts
// ---------- backendService.ts ----------
// src/services/backendService.ts
import Constants from 'expo-constants';
import { getClientId } from './clientIDService';
// Correctly import types from their new location
import { EstimatedFoodItem, Macros, MacrosWithFoodName } from '../types/macros';

// --- Configuration ---
// Use environment variable from Expo config (extra.env.BACKEND_URL) or fallback
// Ensure you set this in app.json or app.config.js/ts
const getBackendUrl = (): string => {
    // Access environment variables defined in app.json extra field
    const backendUrl = Constants.expoConfig?.extra?.env?.BACKEND_URL;
    if (!backendUrl) {
        console.warn("BACKEND_URL not found in app.json extra.env, using default development URL.");
        // Fallback to a default development URL if needed
        // IMPORTANT: Replace this with your actual development backend IP/hostname
        // Make sure the path includes the /api/v1 prefix if your backend expects it
        return 'http://192.168.1.15:8000/api/v1';
    }
    console.log("Using Backend URL:", backendUrl);
    // Ensure the URL ends with /api/v1 if the backend is structured that way
    // Check if backendUrl already includes the prefix
    const apiPrefix = "/api/v1";
    if (backendUrl.endsWith(apiPrefix)) {
        return backendUrl;
    } else {
        // Append the prefix, removing trailing slashes if they exist
        return `${backendUrl.replace(/\/$/, '')}${apiPrefix}`;
    }
};

const BASE_URL = getBackendUrl();


// --- Interfaces ---
interface GramsResponse {
    grams: number;
}

interface IconResponse {
    icon_url: string | null;
}

// Interface representing the user status response from the backend
export interface UserStatus {
    client_id: string;
    coins: number;
}

interface BackendErrorDetail {
    detail?: string | any;
}

// --- Custom Error Class ---
export class BackendError extends Error {
    status: number;
    detail?: string | any;

    constructor(message: string, status: number, detail?: string | any) {
        super(message);
        this.name = 'BackendError';
        this.status = status;
        this.detail = detail;
    }
}

// --- API Call Helper ---
async function fetchBackend<T>(
    endpoint: string,
    options: RequestInit = {}
): Promise<T> {
    // Ensure endpoint starts with a '/' for clean joining
    const cleanEndpoint = endpoint.startsWith('/') ? endpoint : `/${endpoint}`;
    const url = `${BASE_URL}${cleanEndpoint}`;
    console.log(`Calling Backend: ${options.method || 'GET'} ${url}`);

    const defaultHeaders: HeadersInit = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
    };

    // Add Client ID header to every request automatically
    const clientId = await getClientId();
    const authHeaders: HeadersInit = {
        'X-Client-ID': clientId, // Backend expects this header
    };


    const config: RequestInit = {
        ...options,
        headers: {
            ...defaultHeaders,
            ...authHeaders, // Add client ID header
            ...options.headers,
        },
    };

    try {
        const response = await fetch(url, config);

        // Attempt to parse JSON regardless of status code for error details
        let responseBody: any;
        const contentType = response.headers.get("content-type");
        try {
            if (contentType && contentType.indexOf("application/json") !== -1) {
                responseBody = await response.json();
            } else {
                 // Handle non-JSON responses (e.g., plain text errors from proxies/servers)
                 responseBody = await response.text();
                 // If response was not OK, throw using the text body
                 if (!response.ok) {
                    console.error(`Backend Error (${response.status}) on ${url}: Received non-JSON response: ${responseBody}`);
                    throw new BackendError(`Backend request failed with status ${response.status}. Non-JSON response: ${responseBody}`, response.status, responseBody);
                 }
                 // If response was OK but non-JSON, it might be unexpected. Log or handle.
                 console.warn(`Backend Success (${response.status}) on ${url}: Received non-JSON response: ${responseBody}`);
                 // Depending on expected T, you might return null or throw.
                 // If T is expected to be always JSON, this should be an error.
                 // If T could be string, return responseBody. For now, assume JSON is expected.
                  if (typeof responseBody === 'string' && responseBody === '') {
                     // Handle empty successful responses (e.g., 204 No Content)
                     return null as T;
                 }
                 throw new BackendError(`Received unexpected non-JSON response from backend. Status: ${response.status}`, response.status, responseBody);
            }
        } catch (e) {
            // JSON parsing failed specifically
            console.error(`Backend response for ${url} was not valid JSON. Status: ${response.status}`, e);
            // Throw a specific error if response wasn't OK, otherwise might be empty 204 etc.
            if (!response.ok) {
                 const errorText = await response.text(); // Try to get raw text
                throw new BackendError(`Backend request failed with status ${response.status}. Response was not valid JSON.`, response.status, errorText);
            }
            // If response was OK but no JSON body (or failed parsing), return null or handle as appropriate for T
            return null as T; // Adjust based on expected return types
        }


        if (!response.ok) {
            console.error(`Backend Error (${response.status}) on ${url}:`, responseBody);
            const detail = (responseBody as BackendErrorDetail)?.detail || 'Unknown backend error';
            let message = `Backend request failed with status ${response.status}`;
            if (response.status === 402) {
                message = 'Insufficient coins.';
            } else if (typeof detail === 'string') {
                message = detail; // Use detail message from backend if available and string
            } else if (detail && typeof detail === 'object') {
                // Try to extract a meaningful message from object detail, e.g., validation errors
                 try {
                     message = JSON.stringify(detail); // Show the structure if it's an object
                 } catch { /* ignore stringify error */ }
            }
            throw new BackendError(message, response.status, detail);
        }

        console.log(`Backend Success (${response.status}) on ${url}`);
        return responseBody as T;

    } catch (error) {
        if (error instanceof BackendError) {
            throw error; // Re-throw known backend errors
        }
        // Handle network errors (e.g., server unreachable)
        console.error(`Network or other error calling ${url}:`, error);
        let errorMessage = `Failed to communicate with the backend.`;
         // Check for common fetch error messages
         if (error instanceof Error) {
             if (error.message.includes('Network request failed')) {
                 errorMessage += ' Please check your network connection and ensure the backend server is running.';
             } else if (error.message.includes('fetch')) { // Generic fetch error
                 errorMessage += ' A network error occurred during the request.';
             } else {
                 errorMessage += ` Details: ${error.message}`;
             }
         } else {
             errorMessage += ' An unknown network error occurred.';
         }
        // Throw a generic error for network issues or unexpected problems
        // Use status 0 or a custom code to indicate client-side network error
        throw new BackendError(errorMessage, 0, errorMessage);
    }
}

// --- Service Functions ---

export const getUserStatus = async (): Promise<UserStatus> => {
    const clientId = await getClientId();
    return fetchBackend<UserStatus>(`/users/status/${clientId}`);
};

export const getMacrosForRecipe = async (foodName: string, ingredients: string): Promise<Macros> => {
    const body = { food_name: foodName, ingredients };
    return fetchBackend<Macros>('/ai/macros_recipe', {
        method: 'POST',
        body: JSON.stringify(body),
    });
};

export const getMacrosForImageSingle = async (image_base64: string, mime_type: string): Promise<MacrosWithFoodName> => {
    const body = { image_base64, mime_type };
    return fetchBackend<MacrosWithFoodName>('/ai/macros_image_single', {
        method: 'POST',
        body: JSON.stringify(body),
    });
};

export const getMacrosForImageMultiple = async (image_base64: string, mime_type: string): Promise<EstimatedFoodItem[]> => {
    const body = { image_base64, mime_type };
    return fetchBackend<EstimatedFoodItem[]>('/ai/macros_image_multiple', {
        method: 'POST',
        body: JSON.stringify(body),
    });
};

export const estimateGramsNaturalLanguage = async (foodName: string, quantityDescription: string): Promise<number> => {
    const body = { food_name: foodName, quantity_description: quantityDescription };
    const response = await fetchBackend<GramsResponse>('/ai/grams_natural_language', {
        method: 'POST',
        body: JSON.stringify(body),
    });
    if (!response) {
        throw new Error("Received unexpected null response while estimating grams.");
    }
    return response.grams;
};

export const getFoodIcon = async (foodName: string, locale: string = 'en'): Promise<string | null> => {
    const encodedFoodName = encodeURIComponent(foodName);
    const encodedLocale = encodeURIComponent(locale);
    try {
        const response = await fetchBackend<IconResponse>(`/icons/food?food_name=${encodedFoodName}&locale=${encodedLocale}`);
         if (!response) {
            console.warn(`Received null response when fetching icon for ${foodName}. Treating as no icon found.`);
            return null;
         }
        return response.icon_url;
    } catch (error) {
         console.error(`Failed to get icon for ${foodName} via backend service:`, error);
         return null;
    }
};

/**
 * Adds a specified amount of coins to the current user via the backend.
 * @param amount The number of coins to add.
 * @returns A promise resolving to the updated UserStatus (client_id, coins).
 */
export const addCoinsToUser = async (amount: number): Promise<UserStatus> => {
    const clientId = await getClientId(); // Client ID is needed for the endpoint URL
    const body = { amount }; // Amount goes into the body as per updated backend endpoint
    return fetchBackend<UserStatus>(`/users/add_coins/${clientId}`, {
        method: 'POST',
        body: JSON.stringify(body),
    });
};

// ---------- END backendService.ts ----------
---------- END backendService.ts ----------


---------- clientIDService.ts ----------
// src/services/clientIDService.ts
import AsyncStorage from '@react-native-async-storage/async-storage';
import uuid from 'react-native-uuid';

const CLIENT_ID_KEY = '@MacroTracker:clientId';
let currentClientId: string | null = null; // In-memory cache

export const getClientId = async (): Promise<string> => {
  if (currentClientId) {
    return currentClientId;
  }

  try {
    let clientId = await AsyncStorage.getItem(CLIENT_ID_KEY);
    if (!clientId) {
      clientId = uuid.v4() as string;
      console.log('Generated new client ID:', clientId);
      await AsyncStorage.setItem(CLIENT_ID_KEY, clientId);
    } else {
      console.log('Retrieved existing client ID:', clientId);
    }
    currentClientId = clientId;
    return clientId;
  } catch (error) {
    console.error('Error handling client ID:', error);
    // Fallback or throw error depending on desired behavior
    // For now, generating a temporary one if storage fails
    return uuid.v4() as string;
  }
};

// Optional: Function to clear ID for testing
export const clearClientId = async (): Promise<void> => {
    currentClientId = null;
    try {
        await AsyncStorage.removeItem(CLIENT_ID_KEY);
        console.log('Client ID cleared.');
    } catch (error) {
        console.error('Error clearing client ID:', error);
    }
};
---------- END clientIDService.ts ----------


---------- foodService.ts ----------
// services/foodService.ts
import { Food } from '../types/food';
import { saveFoods, loadFoods } from './storageService';
import 'react-native-get-random-values';
import { v4 as uuidv4 } from 'uuid';

export const createFood = async (foodData: Omit<Food, 'id'>): Promise<Food> => {
  const newFood: Food = {
    id: uuidv4(),
    ...foodData,
  };
  const foods = await loadFoods();
  foods.push(newFood);
  await saveFoods(foods);
  return newFood;
};

export const getFoods = async (): Promise<Food[]> => {
  return loadFoods();
};

export const updateFood = async (updatedFood: Food): Promise<Food> => {
  const foods = await loadFoods();
  const index = foods.findIndex((f) => f.id === updatedFood.id);
  if (index === -1) {
    throw new Error('Food not found'); // Throw an error if not found
  }
  foods[index] = updatedFood;
  await saveFoods(foods);
  return updatedFood;
};

export const deleteFood = async (foodId: string): Promise<void> => {
  const foods = await loadFoods();
  const filteredFoods = foods.filter((f) => f.id !== foodId);
  await saveFoods(filteredFoods);
};
---------- END foodService.ts ----------


---------- storageService.ts ----------
// services/storageService.ts (Modified for Timestamps)
import AsyncStorage from '@react-native-async-storage/async-storage';
import { DailyEntry } from '../types/dailyEntry';
import { Food } from '../types/food';
import { Settings } from '../types/settings';
import { formatISO, parseISO } from 'date-fns';


const DAILY_ENTRIES_KEY = 'dailyEntries';
const FOODS_KEY = 'foods';
const SETTINGS_KEY = 'settings';
const RECENT_FOODS = 'recentFoods';


export const saveDailyEntries = async (entries: DailyEntry[]): Promise<void> => {
  try {
    await AsyncStorage.setItem(DAILY_ENTRIES_KEY, JSON.stringify(entries));
  } catch (error) {
    console.error('Error saving daily entries:', error);
    throw error;
  }
};

export const loadDailyEntries = async (): Promise<DailyEntry[]> => {
  try {
    const entriesJson = await AsyncStorage.getItem(DAILY_ENTRIES_KEY);
    return entriesJson ? JSON.parse(entriesJson) : [];
  } catch (error) {
    console.error('Error loading daily entries:', error);
    return [];
  }
};

export const saveFoods = async (foods: Food[]): Promise<void> => {
  try {
    await AsyncStorage.setItem(FOODS_KEY, JSON.stringify(foods));
  } catch (error) {
    console.error('Error saving foods:', error);
    throw error; // Re-throw the error
  }
};

export const loadFoods = async (): Promise<Food[]> => {
  try {
    const foodsJson = await AsyncStorage.getItem(FOODS_KEY);
    return foodsJson ? JSON.parse(foodsJson) : [];
  } catch (error) {
    console.error('Error loading foods:', error);
    return []; // Return an empty array on error
  }
};



export const saveSettings = async (settings: Settings): Promise<void> => {
  try {
    await AsyncStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
  } catch (error) {
    console.error('Error saving settings:', error);
    throw error;
  }
};

export const loadSettings = async (): Promise<Settings> => {
  try {
    const settingsJson = await AsyncStorage.getItem(SETTINGS_KEY);
    const loadedSettings = settingsJson ? JSON.parse(settingsJson) : {};

    // Apply defaults and ensure structure
    const defaultSettings: Settings = {
      theme: 'system',
      dailyGoals: { calories: 2000, protein: 50, carbs: 200, fat: 70 },
      settingsHistory: [] // Ensure settingsHistory exists
    };


    return {
      ...defaultSettings, // Start with defaults
        ...loadedSettings, // Override with loaded values
        dailyGoals: {
          ...defaultSettings.dailyGoals,  //ensure no fields missing from daily goals
            ...(loadedSettings.dailyGoals || {}) // And override *those* with any loaded dailyGoals
        }
    }

  } catch (error: any) {
    console.error('Error loading settings:', error);

    // *** KEY CHANGE: Handle "Row too big" error ***
    if (error.message.includes('Row too big')) {
      console.warn('Detected oversized settings data. Clearing settings.');
      try {
        await AsyncStorage.removeItem(SETTINGS_KEY); // Clear the oversized data
      } catch (clearError) {
        console.error('Error clearing oversized settings:', clearError);
        // You might want to handle this more gracefully, e.g., by showing an error to the user.
      }
    }

    // Return defaults if loading fails (or after clearing)
    return {
      theme: 'system',
      dailyGoals: { calories: 2000, protein: 50, carbs: 200, fat: 70 },
      settingsHistory: [] // Ensure settingsHistory exists in default
    };
  }
};

export const clearAllData = async (): Promise<void> => {
  try {
    await AsyncStorage.clear();
  } catch (error) {
    console.error('Error clearing data:', error);
    throw error;
  }
};

// Function to save recent foods
export const saveRecentFoods = async (foods: Food[]) => {
    try {
        await AsyncStorage.setItem(RECENT_FOODS, JSON.stringify(foods));
    } catch (error) {
        console.error('Error saving recent foods:', error);
        throw error; // Important: Re-throw the error so calling code knows it failed
    }
};

// Function to load recent foods
export const loadRecentFoods = async (): Promise<Food[]> => {
    try {
        const foods = await AsyncStorage.getItem(RECENT_FOODS);
        return foods ? JSON.parse(foods) : [];
    } catch (error) {
        console.error('Error loading recent foods:', error);
        return []; // Return empty array on error, don't throw
    }
};
---------- END storageService.ts ----------


---------- dailyEntry.ts ----------
// types/dailyEntry.ts (Modified)
import { Food } from "./food";

export interface DailyEntryItem {
  food: Food;
  grams: number;
}

export interface DailyEntry {
  date: string; // YYYY-MM-DD format
  items: DailyEntryItem[];
  goals?: {  // Optional goals
    calories?: number;
    protein?: number;
    carbs?: number;
    fat?: number;
  };
}

export interface FoodItem { //No changes here.
    id: string;
    name: string;
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
  }
---------- END dailyEntry.ts ----------


---------- food.ts ----------
// types/food.ts
export interface Food {
  id: string;
  name: string;
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
  // category: string;  // REMOVED
}
---------- END food.ts ----------


---------- macros.ts ----------
// src/types/macros.ts

// Basic macro structure
export interface Macros {
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
  }
  
  // Macros structure including the identified food name
  export interface MacrosWithFoodName extends Macros {
    foodName: string;
  }
  
  /**
   * Represents a single food item estimated from an image,
   * including its name, estimated weight, and macros per 100g.
   * Matches the structure expected/returned by the backend service.
   */
  export interface EstimatedFoodItem {
    foodName: string;
    estimatedWeightGrams: number;
    calories_per_100g: number;
    protein_per_100g: number;
    carbs_per_100g: number;
    fat_per_100g: number;
  }
---------- END macros.ts ----------


---------- openRouterTypes.ts ----------
// src/utils/types.ts

// =====================================
// Consolidated OpenRouter Type Definitions
// =====================================

// --- Content Parts (for multi-modal input like images) ---
export type OpenRouterContentPart =
  | { type: "text"; text: string }
  | { type: "image_url"; image_url: { url: string; detail?: "low" | "high" | "auto" } };

// --- Message Structure ---
// Allows content to be a simple string OR an array of content parts for vision models
export interface OpenRouterMessage {
  role: "user" | "assistant" | "system";
  content: string | OpenRouterContentPart[]; // Consolidated definition
  name?: string; // Optional name field
}

// --- Choice Structure (within the response) ---
// This structure aligns with standard Chat Completion APIs (like OpenAI/OpenRouter)
export interface OpenRouterChatChoice {
  index: number;
  message: OpenRouterMessage; // Contains the actual message content and role
  logprobs?: any | null; // Optional log probabilities (use a specific type if known)
  finish_reason: string | null; // Can be null sometimes
  // text?: string; // Usually the content is inside message.content, keep optional if some models return it differently
}

// --- API Usage Information ---
export interface OpenRouterUsage {
  prompt_tokens: number;
  completion_tokens: number;
  total_tokens: number;
}

// --- Main Chat Completion Response Structure ---
// Consolidates the fields from both previous declarations
export interface OpenRouterChatCompletionResponse {
  id: string;
  object: string; // Typically "chat.completion"
  created: number; // Timestamp
  model: string; // Model used
  choices: OpenRouterChatChoice[]; // Array of choices using the defined structure
  usage?: OpenRouterUsage; // Usage information is often optional
  // Add any other relevant fields you might encounter from OpenRouter
  // system_fingerprint?: string; // Example optional field
}


// =====================================
// Removed Redundant/Conflicting Declarations:
// =====================================

/*
// REMOVED - Duplicate/Outdated OpenRouterMessage
export interface OpenRouterMessage {
  role: "user" | "assistant" | "system"; // Add system role
  content: string;
}

// REMOVED - Less standard choice structure (often message.content is used instead of top-level text)
export interface OpenRouterChoice {
  text: any; // 'any' is vague, content is usually in message
  message: OpenRouterMessage; // This duplicates content info if 'text' is also present
  finish_reason?: string;
  index?: number;
}

// REMOVED - Duplicate/Simpler OpenRouterChatCompletionResponse
export interface OpenRouterChatCompletionResponse {
  choices: OpenRouterChoice[]; // Used the less standard choice type
  id?: string;
  created?: number;
  model?: string;
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}
*/
---------- END openRouterTypes.ts ----------


---------- settings.ts ----------
// types/settings.ts (Modified)
export const macros = ["calories", "protein", "carbs", "fat"] as const;
export type MacroType = (typeof macros)[number];

export interface MacroData {
  x: number; // Timestamp
  y: number; // Macro value
}

export interface Statistics {
  calories: MacroData[][];
  protein: MacroData[][];
  carbs: MacroData[][];
  fat: MacroData[][];
}

export interface Settings {
  theme: "light" | "dark" | "system";
  dailyGoals: {
    [key in MacroType]: number;
  };
  settingsHistory?: { date: number; dailyGoals: { [key in MacroType]: number } }[]; // CHANGED: Store timestamp
}

export interface SettingsScreenProps {
  onThemeChange: (theme: "light" | "dark" | "system") => void;
}
---------- END settings.ts ----------


---------- dateUtils.ts ----------
// utils/dateUtils.ts (Corrected type for formatDateReadable)
import { format, parseISO, formatISO, isValid } from 'date-fns';

/**
 * Formats a Date object, timestamp (number), or ISO date string (YYYY-MM-DD)
 * into a standard YYYY-MM-DD string representation.
 * Returns an empty string if the input is invalid.
 * @param dateInput - The date to format (Date object, timestamp number, or 'YYYY-MM-DD' string).
 * @returns The formatted date string 'YYYY-MM-DD' or empty string on error.
 */
export const formatDateISO = (dateInput: number | string | Date): string => {
    try {
        let dateObj: Date;
        if (dateInput instanceof Date) {
            dateObj = dateInput;
        } else if (typeof dateInput === 'string') {
            // Assume 'YYYY-MM-DD' format if string
            dateObj = parseISO(dateInput);
        } else if (typeof dateInput === 'number') {
            // Assume timestamp if number
            dateObj = new Date(dateInput);
        } else {
            throw new Error("Invalid input type");
        }

        if (!isValid(dateObj)) {
             throw new Error("Invalid date value");
        }
        return formatISO(dateObj, { representation: 'date' });
    } catch (error) {
        console.error("Error in formatDateISO:", error, "Input:", dateInput);
        return ""; // Return empty string on error
    }
};


/**
 * Formats a Date object, timestamp (number), or ISO date string (YYYY-MM-DD)
 * into a human-readable format (e.g., "MMMM dd, yyyy").
 * Returns 'Invalid Date' if the input is invalid.
 * @param dateInput - The date to format (Date object, timestamp number, or 'YYYY-MM-DD' string).
 * @returns The formatted readable date string or 'Invalid Date' on error.
 */
export const formatDateReadable = (dateInput: number | string | Date): string => {
    try {
        let dateObj: Date;
        if (dateInput instanceof Date) {
            dateObj = dateInput;
        } else if (typeof dateInput === 'string') {
            // Assume 'YYYY-MM-DD' format if string
            dateObj = parseISO(dateInput);
        } else if (typeof dateInput === 'number') {
             // Assume timestamp if number
            dateObj = new Date(dateInput);
        } else {
             throw new Error("Invalid input type");
        }

        if (!isValid(dateObj)) {
            throw new Error("Invalid date value");
        }
        return format(dateObj, 'MMMM dd, yyyy'); // Example format
    } catch (error) {
         console.error("Error in formatDateReadable:", error, "Input:", dateInput);
         return 'Invalid Date'; // Return indicator string on error
    }
};

/**
 * Gets today's date as a standard YYYY-MM-DD string.
 * @returns Today's date in 'YYYY-MM-DD' format.
 */
export const getTodayDateString = (): string => {
  // formatISO handles Date object correctly
  return formatISO(new Date(), { representation: 'date' });
};
---------- END dateUtils.ts ----------


---------- iconUtils.ts ----------
// src/utils/iconUtils.ts
// Import necessary modules
import AsyncStorage from '@react-native-async-storage/async-storage';
import { getFoodIcon } from '../services/backendService'; // Import backend service

// Define the cache entry type (URL only, no expiry handled here)
type CacheEntry = {
  url: string | null;
};

// In-memory cache for fast access
const memoryCache = new Map<string, CacheEntry>();

// Prefix for AsyncStorage keys (keeping versioning)
const STORAGE_KEY_PREFIX = 'foodIconCacheBE_v1_'; // BE = Backend

// --- Main Exported Function ---

/**
 * Gets the icon URL for a food item.
 * Checks memory cache, then AsyncStorage, then calls the backend service.
 * Caches the result (including null for failures/not found).
 *
 * @param foodName The name of the food item.
 * @param locale The desired locale for the icon search (defaults to 'en').
 * @returns A Promise resolving to the icon URL (string) or null if not found or an error occurred.
 */
export const getFoodIconUrl = async (foodName: string, locale: string = 'en'): Promise<string | null> => {
  if (!foodName || foodName.trim() === '') {
      console.warn("getFoodIconUrl called with empty foodName.");
      return null;
  }

  const cacheKey = `${locale}_${foodName.toLowerCase().trim()}`;

  // 1. Check Memory Cache
  const memoryEntry = memoryCache.get(cacheKey);
  if (memoryEntry !== undefined) { // Check existence, not just truthiness (null is valid cached value)
    // console.log(`Icon Cache HIT (Memory): ${cacheKey} -> ${memoryEntry.url}`);
    return memoryEntry.url;
  }

  // 2. Check AsyncStorage
  const storageKey = STORAGE_KEY_PREFIX + cacheKey;
  try {
    const storedValue = await AsyncStorage.getItem(storageKey);
    if (storedValue !== null) {
      const parsed: CacheEntry = JSON.parse(storedValue);
      // console.log(`Icon Cache HIT (Storage): ${cacheKey} -> ${parsed.url}`);
      memoryCache.set(cacheKey, parsed); // Update memory cache
      return parsed.url;
    }
  } catch (error) {
    console.error(`Error reading icon cache from AsyncStorage for key ${storageKey}:`, error);
    // Continue to fetch if storage read fails
  }

  // 3. Fetch from Backend API
  // console.log(`Icon Cache MISS / Fetching Backend API: ${cacheKey}`);
  let iconUrl: string | null = null;
  try {
      // Call the backend service function - it handles its own errors and returns null on failure
      iconUrl = await getFoodIcon(foodName, locale);
      // console.log(`Backend returned icon URL for ${foodName}: ${iconUrl}`);

  } catch (error) {
      // This catch block might be redundant if getFoodIcon handles all errors,
      // but kept as a safeguard against unexpected issues in the service call itself.
      console.error(`Unexpected error calling getFoodIcon service for ${foodName}:`, error);
      iconUrl = null; // Ensure null is cached on unexpected error during service call
  }

  // 4. Cache the final result (even nulls) from backend
  const newCacheEntry: CacheEntry = { url: iconUrl };
  memoryCache.set(cacheKey, newCacheEntry); // Cache in memory
  try {
    // Cache in AsyncStorage
    await AsyncStorage.setItem(storageKey, JSON.stringify(newCacheEntry));
  } catch (error) {
    console.error(`Error saving icon cache to AsyncStorage for key ${storageKey}:`, error);
  }

  return iconUrl;
};

// --- Cache Management (Optional but recommended) ---

export const clearIconCache = async () => {
    memoryCache.clear();
    try {
        const keys = await AsyncStorage.getAllKeys();
        const cacheKeys = keys.filter(key => key.startsWith(STORAGE_KEY_PREFIX));
        if (cacheKeys.length > 0) {
             await AsyncStorage.multiRemove(cacheKeys);
             console.log(`Cleared ${cacheKeys.length} items from AsyncStorage icon cache (Backend Version).`);
        }
    } catch (error) {
        console.error("Error clearing backend icon cache from AsyncStorage:", error);
    }
};

export const logMemoryCacheSize = () => {
    console.log(`In-memory icon cache size: ${memoryCache.size}`);
};
---------- END iconUtils.ts ----------


---------- macros.ts ----------
// src/utils/macros.ts
import * as FileSystem from 'expo-file-system';
// Import MimeTypes library if you have it, otherwise use extension mapping
// import MimeTypes from 'react-native-mime-types'; // Uncomment if using react-native-mime-types
import {
    getMacrosForRecipe,
    getMacrosForImageSingle,
    getMacrosForImageMultiple,
    BackendError
} from '../services/backendService'; // Import backend service functions
import { Alert } from 'react-native';
// Import types from the new location
import { Macros, MacrosWithFoodName, EstimatedFoodItem } from '../types/macros';
import { ImagePickerAsset } from 'expo-image-picker'; // Import the specific type

// --- Helper function to determine MIME type ---
function determineMimeType(asset: {
    uri: string;
    mimeType?: string | null; // Explicitly use mimeType if provided
    fileName?: string | null; // Use fileName for fallback
    type?: string; // Keep existing 'type' for potential backward compatibility? (Less reliable)
}): string {
    // 1. Prioritize asset.mimeType if available (most reliable)
    if (asset.mimeType) {
        console.log(`Using provided MIME type: ${asset.mimeType}`);
        return asset.mimeType;
    }

    // 2. Fallback using react-native-mime-types library (if installed)
    // const validFileNameForLookup = asset.fileName ?? undefined;
    // if (validFileNameForLookup) {
    //     const lookedUpMime = MimeTypes.lookup(validFileNameForLookup);
    //     if (lookedUpMime) {
    //         console.log(`Looked up MIME type using filename: ${lookedUpMime}`);
    //         return lookedUpMime;
    //     }
    // }

    // 3. Fallback: Infer from URI extension (less reliable but better than 'image')
    const uriParts = asset.uri.split('.');
    const extension = uriParts.pop()?.toLowerCase();
    console.log(`Inferring MIME type from extension: .${extension}`);
    switch (extension) {
        case 'jpg':
        case 'jpeg':
            return 'image/jpeg';
        case 'png':
            return 'image/png';
        case 'gif':
            return 'image/gif';
        case 'webp':
            return 'image/webp';
        case 'bmp':
            return 'image/bmp';
        default:
            // 4. Use asset.type if available and other methods failed (least reliable)
            if (asset.type && asset.type.includes('/')) {
                 console.warn(`Falling back to asset.type: ${asset.type}`);
                 return asset.type;
            }
             // 5. Final fallback
            console.warn(`Could not determine specific MIME type for URI: ${asset.uri}. Defaulting to image/jpeg.`);
            return 'image/jpeg';
    }
}


// --- Refactored Functions ---

// Function to get macros from text description (using backend)
export async function getMacrosFromText(
    foodName: string,
    ingredients: string // Changed param name for clarity
): Promise<Macros> {
    try {
        // Backend service already returns the correct Macros type
        const macros = await getMacrosForRecipe(foodName, ingredients);
        return macros;
    } catch (error) {
        console.error("Error fetching macros for recipe from backend:", error);
        const message = error instanceof BackendError
            ? error.message // Use message from BackendError (e.g., "Insufficient coins.")
            : `Failed to get macros for recipe: ${error instanceof Error ? error.message : String(error)}`;
        Alert.alert("AI Error", message); // Show alert to user
        throw error; // Re-throw to allow calling component further handling if needed
    }
}

// Utility function to convert a file URI to base64 (remains the same)
export async function getBase64FromUri(uri: string): Promise<string> {
    try {
        const base64 = await FileSystem.readAsStringAsync(uri, {
            encoding: FileSystem.EncodingType.Base64,
        });
        return base64;
    } catch (error) {
        console.error(`Failed to convert file to base64: ${uri}`, error);
        throw new Error(`Failed to convert file to base64: ${error}`);
    }
}

// Function to get macros for a single food item from an image file (using backend)
// Accepts the specific type structure matching ImagePickerAsset properties needed
export async function getMacrosForImageFile(asset: ImagePickerAsset): Promise<MacrosWithFoodName> {
    let base64File: string;
    try {
        base64File = await getBase64FromUri(asset.uri);
    } catch (err) {
        Alert.alert("Error", "Failed to read image file.");
        throw err; // Re-throw
    }

    // --- Determine Correct MIME Type using helper ---
    const mimeType = determineMimeType(asset);
    console.log(`Frontend (single-food): Determined MIME type: ${mimeType}`);

    try {
        // Backend service already returns the correct MacrosWithFoodName type
        const result = await getMacrosForImageSingle(base64File, mimeType);
        return result;
    } catch (error) {
        console.error("Error fetching single food macros from image from backend:", error);
         const message = error instanceof BackendError
            ? error.message
            : `Analysis failed: ${error instanceof Error ? error.message : String(error)}`;
        Alert.alert("Analysis Failed", message);
        throw error; // Re-throw
    }
}


// Function for Multiple Foods (using backend)
// Accepts the specific type structure matching ImagePickerAsset properties needed
export async function getMultipleFoodsFromImage(asset: ImagePickerAsset): Promise<EstimatedFoodItem[]> {
    console.log(`Frontend: Starting getMultipleFoodsFromImage for asset URI: ${asset.uri}`);
    let base64File: string;
    try {
        base64File = await getBase64FromUri(asset.uri);
        console.log("Frontend: Successfully converted multi-food image to base64.");
    } catch (err) {
         Alert.alert("Error", "Failed to read image file.");
         throw err;
    }

    // --- Determine Correct MIME Type using helper ---
    const mimeType = determineMimeType(asset);
    console.log(`Frontend (multi-food): Determined MIME type: ${mimeType}`);

    try {
        console.log("Frontend: Calling backendService.getMacrosForImageMultiple...");
        // Backend service already returns the correct EstimatedFoodItem[] type
        const results = await getMacrosForImageMultiple(base64File, mimeType);
        console.log(`Frontend: Received ${results.length} items from backend.`);
        return results;
    } catch (error) {
        console.error("Frontend: Error calling backend for multiple foods:", error);
         const message = error instanceof BackendError
            ? error.message
            : `Could not analyze image: ${error instanceof Error ? error.message : String(error)}`;
        Alert.alert("Quick Add Failed", message);
        throw error; // Re-throw
    }
}

// Re-export BackendError and types if needed by components directly
export { BackendError, EstimatedFoodItem, Macros, MacrosWithFoodName };
---------- END macros.ts ----------


---------- units.ts ----------
// src/utils/units.ts
import { Alert } from 'react-native';
import { estimateGramsNaturalLanguage, BackendError } from '../services/backendService';

/**
 * Estimates the weight in grams based on a natural language description and food item, using the backend service.
 * @param foodName The name of the food item (e.g., "Apple").
 * @param quantityDescription The natural language description (e.g., "2 small", "1 cup chopped").
 * @returns A promise that resolves with the estimated weight in grams (number).
 */
export async function getGramsFromNaturalLanguage(
    foodName: string,
    quantityDescription: string
): Promise<number> {
    try {
        const grams = await estimateGramsNaturalLanguage(foodName, quantityDescription);
        return grams; // Backend service already rounds
    } catch (error) {
        console.error("Error getting grams estimation from backend:", error);
        const message = error instanceof BackendError
            ? error.message
            : `Could not estimate grams: ${error instanceof Error ? error.message : String(error)}`;
        Alert.alert("AI Estimation Failed", message);
        throw error; // Re-throw error
    }
}
---------- END units.ts ----------


---------- validationUtils.ts ----------
// utils/validationUtils.ts

export const isValidNumberInput = (value: string): boolean => {
    return /^[0-9]*(\.[0-9]*)?$/.test(value) && !isNaN(parseFloat(value));
  };
  
  export const isNotEmpty = (value: string): boolean => {
    return value.trim() !== '';
  };
---------- END validationUtils.ts ----------


---------- tsconfig.json ----------
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true

  }
}
---------- END tsconfig.json ----------

