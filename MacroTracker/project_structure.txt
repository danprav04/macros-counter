.gitignore
app.json
App.tsx
assets/
  adaptive-icon.png
  favicon.png
  icon.png
  splash-icon.png
components/
  AddEntryModal.tsx
  AddFoodModal.tsx
  ConfirmationModal.tsx
  DailyGoalsInput.tsx
  DailyProgress.tsx
  DataManagementButtons.tsx
  FoodItem.tsx
  StatisticsChart.tsx
  ThemeSwitch.tsx
index.ts
navigation/
  AppNavigator.tsx
package.json
projectToFile.js
screens/
  DailyEntryScreen.tsx
  FoodListScreen.tsx
  SettingsScreen.tsx
services/
  foodService.ts
  storageService.ts
tsconfig.json
types/
  dailyEntry.ts
  food.ts
  openRouterTypes.ts
  settings.ts
utils/
  ai.ts
  dateUtils.ts
  iconUtils.ts
  macros.ts
  validationUtils.ts

---------- .gitignore ----------
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

---------- END .gitignore ----------


---------- app.json ----------
{
  "expo": {
    "name": "MacroTracker",
    "slug": "MacroTracker",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "automatic",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "assetBundlePatterns": ["**/*"],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.yourcompany.macrotracker"
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "package": "com.yourcompany.macrotracker"
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      [
        "expo-document-picker",
        {
          "appleTeamId": "YOUR_TEAM_ID"
        }
      ]
    ]
  }
}

---------- END app.json ----------


---------- App.tsx ----------
// App.tsx (Modified for Reload)
import 'react-native-get-random-values'; // MUST BE FIRST
import Toast from 'react-native-toast-message';
import React, { useState, useEffect } from 'react';
import AppNavigator from './navigation/AppNavigator';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { ThemeProvider, createTheme } from '@rneui/themed';
import { loadSettings, saveSettings } from './services/storageService';
import { useColorScheme, AppState, AppStateStatus } from 'react-native'; // Import AppState
import { NavigationContainer, DefaultTheme, DarkTheme } from '@react-navigation/native';
import { Colors } from '@rneui/base';
import { Settings } from './types/settings';
import { LogBox } from 'react-native';

LogBox.ignoreLogs(['Function components cannot be given refs']);

declare module '@rneui/themed' {
  export interface Colors {
    text: string;
    card: string; // Added for better card styling
    successLight: string; // Lighter success color
  }
}

interface MyTheme {
  mode: 'light' | 'dark';
  colors: Colors;
}

const lightTheme: MyTheme = {
  mode: 'light',
  colors: {
    primary: '#2e86de',
    secondary: '#6c757d',
    background: '#f8f9fa',
    grey5: '#e9ecef',
    white: '#ffffff',
    grey4: '#ced4da',
    success: '#28a745',
    successLight: '#d4edda',
    black: '#000000',
    text: '#212529',
    card: '#ffffff',
    error: '#dc3545',
    warning: '#ffc107',
    disabled: '#6c757d',
    divider: '#ced4da',
    platform: {
      ios: {
        primary: '',
        secondary: '',
        grey: '',
        searchBg: '',
        success: '',
        error: '',
        warning: ''
      },
      android: {
        primary: '',
        secondary: '',
        grey: '',
        searchBg: '',
        success: '',
        error: '',
        warning: ''
      },
      web: {
        primary: '',
        secondary: '',
        grey: '',
        searchBg: '',
        success: '',
        error: '',
        warning: ''
      },
      default: {
        primary: '',
        secondary: '',
        grey: '',
        searchBg: '',
        success: '',
        error: '',
        warning: ''
      },
    },
    // Complete the missing grey colors
    grey0: '#f8f9fa', // Very light, almost white
    grey1: '#e9ecef', // Light grey, same as grey5 (can adjust)
    grey2: '#dee2e6', // Medium-light grey
    grey3: '#ced4da', // Medium grey, same as grey4
    greyOutline: '#adb5bd', // Slightly darker for outlines
    searchBg: '#ffffff' // Background for search input, usually white
  },
};

const darkTheme: MyTheme = {
  mode: 'dark',
  colors: {
    primary: '#2e86de',
    secondary: '#adb5bd',
    background: '#121212',
    grey5: '#2c2c2c',
    white: '#ffffff',
    grey4: '#343a40',
    success: '#28a745',
    successLight: '#1f5139',
    black: '#000000',
    text: '#f8f9fa',
    card: '#1e1e1e',
    error: '#dc3545',
    warning: '#ffc107',
    disabled: '#6c757d',
    divider: '#343a40',
    platform: {
      ios: {
        primary: '',
        secondary: '',
        grey: '',
        searchBg: '',
        success: '',
        error: '',
        warning: ''
      },
      android: {
        primary: '',
        secondary: '',
        grey: '',
        searchBg: '',
        success: '',
        error: '',
        warning: ''
      },
      web: {
        primary: '',
        secondary: '',
        grey: '',
        searchBg: '',
        success: '',
        error: '',
        warning: ''
      },
      default: {
        primary: '',
        secondary: '',
        grey: '',
        searchBg: '',
        success: '',
        error: '',
        warning: ''
      },
    },
    // Complete the missing grey colors
    grey0: '#212529', // Very dark, almost black
    grey1: '#2c2c2c', // Dark grey, same as grey5
    grey2: '#343a40', // Medium-dark grey, same as grey4
    grey3: '#495057', // Medium grey
    greyOutline: '#6c757d', // Lighter grey for outlines, same as disabled
    searchBg: '#1e1e1e'  // Background for search, dark to match card
  },
};


const App = () => {
  const [themeMode, setThemeMode] = useState<'light' | 'dark' | 'system'>('system');
  const [loadedSettings, setLoadedSettings] = useState<Settings | null>(null);
  const colorScheme = useColorScheme();
  const [reloadKey, setReloadKey] = useState(0); // Key for forcing remount
  const [appState, setAppState] = useState(AppState.currentState); // AppState


  // Load initial settings
    useEffect(() => {
    const initializeApp = async () => {
      const settings = await loadSettings();
      setThemeMode(settings.theme);
      setLoadedSettings(settings);
    };
    initializeApp();
  }, []);

  // Function to trigger a reload
  const triggerReload = () => {
    setReloadKey((prevKey) => prevKey + 1);
  };

    useEffect(() => {
    const handleAppStateChange = (nextAppState: AppStateStatus) => {
      if (appState.match(/inactive|background/) && nextAppState === 'active') {
        // App has come to the foreground, trigger reload
        triggerReload();
      }
      setAppState(nextAppState);
    };

    const subscription = AppState.addEventListener('change', handleAppStateChange);

    return () => {
      subscription.remove();
    };
  }, [appState]); // Depend on appState


  const updateTheme = (newThemeMode: 'light' | 'dark' | 'system') => {
    const isDark = newThemeMode === 'system' ? colorScheme === 'dark' : newThemeMode === 'dark';
    return isDark ? darkTheme : lightTheme;
  };

  const handleThemeChange = async (newTheme: 'light' | 'dark' | 'system') => {
    setThemeMode(newTheme);
    if (loadedSettings) {
      const updatedSettings: Settings = {
        ...loadedSettings,
        theme: newTheme,
      };
      await saveSettings(updatedSettings);
      setLoadedSettings(updatedSettings);
    }
  };

  const currentTheme = updateTheme(themeMode);

    const navigationTheme = {
    dark: {
        ...DarkTheme,
        colors: {
            ...DarkTheme.colors,
            primary: currentTheme.colors.primary,
            background: currentTheme.colors.background,
            card: currentTheme.colors.card,
            text: currentTheme.colors.text,
            border: currentTheme.colors.divider,
            notification: currentTheme.colors.successLight,
        },
    },
    light: {
        ...DefaultTheme,
        colors: {
            ...DefaultTheme.colors,
            primary: currentTheme.colors.primary,
            background: currentTheme.colors.background,
            card: currentTheme.colors.card,
            text: currentTheme.colors.text,
            border: currentTheme.colors.divider,
            notification: currentTheme.colors.success,
        },
    },
};

  return (
    <ThemeProvider theme={createTheme(currentTheme)} key={themeMode}>
      <SafeAreaProvider>
        <NavigationContainer
          theme={currentTheme.mode === 'dark' ? navigationTheme.dark : navigationTheme.light}
        >
          {/* Pass reloadKey and triggerReload */}
          <AppNavigator onThemeChange={handleThemeChange}  key={reloadKey} />
        </NavigationContainer>
      </SafeAreaProvider>
      <Toast />
    </ThemeProvider>
  );
};

export default App;
---------- END App.tsx ----------


---------- adaptive-icon.png ----------
(Image file - content not included)
---------- END adaptive-icon.png ----------


---------- favicon.png ----------
(Image file - content not included)
---------- END favicon.png ----------


---------- icon.png ----------
(Image file - content not included)
---------- END icon.png ----------


---------- splash-icon.png ----------
(Image file - content not included)
---------- END splash-icon.png ----------


---------- AddEntryModal.tsx ----------
// AddEntryModal.tsx
// AddEntryModal.tsx
import React, { useEffect, useState, useMemo } from "react";
import {
    View,
    FlatList,
    KeyboardAvoidingView,
    Platform,
    TouchableOpacity,
    ScrollView,
    Dimensions, // Import Dimensions
    Image,
} from "react-native";
import {
    Button,
    Input,
    Text,
    ListItem,
    Overlay,
    SearchBar,
    makeStyles,
    useTheme,
    Icon
} from "@rneui/themed";
import { Food } from "../types/food";
import { SafeAreaView } from "react-native-safe-area-context";
import { isValidNumberInput } from "../utils/validationUtils";
import { DailyEntryItem } from "../types/dailyEntry";
import { loadRecentFoods, saveRecentFoods } from "../services/storageService"; // Import storage functions
import { getFoodIconUrl } from "../utils/iconUtils"; // Import the icon helper function

interface AddEntryModalProps {
    isVisible: boolean;
    toggleOverlay: () => void;
    selectedFood: Food | null;
    grams: string;
    setGrams: (grams: string) => void;
    handleAddEntry: () => void;
    foods: Food[];
    handleSelectFood: (item: Food | null) => void;
    updateSearch: (search: string) => void;
    search: string;
    isEditMode: boolean;
    initialGrams?: string;

}

const AddEntryModal: React.FC<AddEntryModalProps> = ({
    isVisible,
    toggleOverlay,
    selectedFood,
    grams,
    setGrams,
    handleAddEntry,
    foods,
    handleSelectFood,
    updateSearch,
    search,
    isEditMode,
    initialGrams
}) => {
    const { theme } = useTheme();
    const styles = useStyles();
    const [recentFoods, setRecentFoods] = useState<Food[]>([]);
    const MAX_RECENT_FOODS = 5;
    const [foodIcons, setFoodIcons] = useState<{ [foodName: string]: string | null }>({});

    // Get screen width for responsive adjustments
    const screenWidth = Dimensions.get('window').width;

    useEffect(() => {
        if (isEditMode && initialGrams) {
            setGrams(initialGrams);
        }
    }, [isEditMode, initialGrams, setGrams]);

    const addToRecentFoods = async (food: Food) => {
        const updatedRecentFoods = recentFoods.filter(recentFood => recentFood.id !== food.id);
        updatedRecentFoods.unshift(food);
        const trimmedRecentFoods = updatedRecentFoods.slice(0, MAX_RECENT_FOODS);
        setRecentFoods(trimmedRecentFoods);
        await saveRecentFoods(trimmedRecentFoods);
    };

    useEffect(() => {
        const loadRecents = async () => {
            const loadedRecentFoods = await loadRecentFoods();
            setRecentFoods(loadedRecentFoods);
        };
        if (isVisible) {
            loadRecents()
        }
    }, [isVisible]);

    useEffect(() => {
        if (!isVisible) {
            handleSelectFood(null);
            setGrams("");
            updateSearch("");
        }
    }, [isVisible, handleSelectFood, setGrams, updateSearch]);

    const filteredFoods = useMemo(() => {
        let result = foods;
        if (search) {
            result = result.filter((food) =>
                food.name.toLowerCase().includes(search.toLowerCase())
            );
        }
        return result;
    }, [foods, search]);
    useEffect(() => {
        const loadIcons = async () => {
            const icons: { [foodName: string]: string | null } = {};
            for (const food of foods) {
                const iconUrl = await getFoodIconUrl(food.name);
                icons[food.name] = iconUrl;
            }
            setFoodIcons(icons);
        };

        loadIcons();
    }, [foods]);

    const servingSizeSuggestions = useMemo(() => {
        if (!selectedFood) return [];
        return [
            { label: "50g", value: "50" },
            { label: "100g", value: "100" },
            { label: "150g", value: "150" },
            { label: "200g", value: "200" },
        ];
    }, [selectedFood]);

    const handleAddOrUpdateEntry = async () => {
        handleAddEntry();
        if (selectedFood) {
            await addToRecentFoods(selectedFood);
        }
    };

    return (
        <Overlay
            isVisible={isVisible}
            onBackdropPress={toggleOverlay}
            animationType="slide"
            transparent={true}
            statusBarTranslucent={Platform.OS === 'android'}
            overlayStyle={styles.overlayStyle}
        >
            <SafeAreaView style={styles.modalSafeArea}>
                <KeyboardAvoidingView
                    behavior={Platform.OS === "ios" ? "padding" : "height"}
                    style={styles.keyboardAvoidingView}
                >
                    <View style={styles.overlayContent}>
                        <View style={styles.header}>
                            <Text style={[styles.overlayTitle, isEditMode && styles.editModeTitle]}>
                                {isEditMode ? "Edit Entry" : "Add Entry"}
                            </Text>

                            <Button
                                title={isEditMode ? "Update" : "Add"}
                                onPress={handleAddOrUpdateEntry}
                                disabled={!selectedFood || !isValidNumberInput(grams) || grams === ""}
                                buttonStyle={[styles.addButton, { backgroundColor: isEditMode ? theme.colors.warning : theme.colors.primary }]}
                                titleStyle={styles.buttonTitle}
                            />
                            <TouchableOpacity onPress={toggleOverlay} style={styles.closeIcon}>
                                <Icon
                                    name="close"
                                    type="material"
                                    size={28}
                                    color={theme.colors.text}
                                />
                            </TouchableOpacity>
                        </View>

                        <SearchBar
                            placeholder="Search Foods..."
                            onChangeText={updateSearch}
                            value={search}
                            platform={Platform.OS === "ios" ? "ios" : "android"}
                            containerStyle={styles.searchBarContainer}
                            inputContainerStyle={styles.searchBarInputContainer}
                            inputStyle={styles.searchInputStyle}
                        />

                        {recentFoods.length > 0 && (
                            <View style={styles.recentFoodsContainer}>
                                <Text style={styles.sectionTitle}>Recent Foods</Text>
                                <FlatList
                                    data={recentFoods}
                                    keyExtractor={(item) => item.id}
                                    horizontal
                                    showsHorizontalScrollIndicator={false}
                                    renderItem={({ item }) => (
                                        <TouchableOpacity
                                            style={[
                                                styles.recentFoodItem,
                                                screenWidth < 350 && styles.smallRecentFoodItem,
                                                selectedFood?.id === item.id && styles.selectedRecentFoodItem, // Apply selected style
                                            ]}
                                            onPress={() => handleSelectFood(item)}>
                                            {foodIcons[item.name] ? (
                                                <Image
                                                    source={{ uri: foodIcons[item.name] as string }}
                                                    style={styles.foodIcon}
                                                />
                                            ) : (
                                                <Icon
                                                    name="fast-food-outline"
                                                    type="ionicon"
                                                    size={16}
                                                />
                                            )}
                                            <Text style={[styles.recentFoodText, screenWidth < 350 && styles.smallRecentFoodText]}>{item.name}</Text>
                                        </TouchableOpacity>
                                    )}
                                />
                            </View>
                        )}

                        {filteredFoods.length > 0 ? (
                            <FlatList
                                data={filteredFoods}
                                keyExtractor={(item) => item.id}
                                renderItem={({ item }) => (
                                    <TouchableOpacity onPress={() => handleSelectFood(item)}>
                                        <ListItem
                                            bottomDivider
                                            containerStyle={[
                                                styles.listItemContainer,
                                                selectedFood?.id === item.id && styles.selectedListItem, // Apply selected style
                                            ]}
                                        >
                                            {foodIcons[item.name] ? (
                                                <Image
                                                    source={{ uri: foodIcons[item.name] as string }}
                                                    style={styles.foodIcon}
                                                />
                                            ) : (
                                                <Icon
                                                    name="fast-food-outline"
                                                    type="ionicon"
                                                    size={16}
                                                />
                                            )}
                                            <ListItem.Content>
                                                <ListItem.Title style={styles.listItemTitle}>{item.name}</ListItem.Title>
                                            </ListItem.Content>
                                        </ListItem>
                                    </TouchableOpacity>
                                )}
                                style={styles.foodList}
                            />
                        ) : (
                            <Text style={styles.noFoodsText}>No foods found.</Text>
                        )}

                        {selectedFood && (
                            <View>
                                <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.servingSizeContainer}>
                                    {servingSizeSuggestions.map((suggestion) => (
                                        <TouchableOpacity
                                            key={suggestion.label}
                                            style={styles.servingSizeButton}
                                            onPress={() => setGrams(suggestion.value)}
                                        >
                                            <Text style={styles.servingSizeButtonTitle}>{suggestion.label}</Text>
                                        </TouchableOpacity>
                                    ))}
                                </ScrollView>
                                <Input
                                    placeholder="Grams (e.g. 150)"
                                    keyboardType="numeric"
                                    value={grams}
                                    onChangeText={(text) => setGrams(text.replace(/[^0-9]/g, ""))}
                                    style={styles.gramInputStyle}
                                    inputContainerStyle={styles.gramInputContainerStyle}
                                    errorMessage={!isValidNumberInput(grams) && grams !== "" ? "Enter a valid number" : ""}
                                />
                            </View>
                        )}
                    </View>
                </KeyboardAvoidingView>
            </SafeAreaView>
        </Overlay>
    );
};
const useStyles = makeStyles((theme) => ({
    overlayStyle: {
        backgroundColor: 'rgba(255, 255, 255, 00)', // Semi-transparent white
        padding: 20,
        marginVertical: 50,
        width: '90%',
        borderRadius: 20, // More rounded
        height: '100%', //MODIFIED.  Use auto
        shadowColor: "#000", // Add shadow
        shadowOffset: {
            width: 0,
            height: 2,
        },
        shadowOpacity: 0.25,
        shadowRadius: 3.84,
        elevation: 5,
    },
    modalSafeArea: {
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
    },
    keyboardAvoidingView: {
        width: "100%",
        flex: 1,
    },
    overlayContent: {
        backgroundColor: theme.colors.background,
        width: "100%",
        borderRadius: 20, // More rounded
        padding: 20,
        flexGrow: 1, //MODIFIED
    },
    header: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: 20,
    },
    overlayTitle: {
        color: theme.colors.text,
        fontWeight: 'bold',
        fontSize: 24, // Larger title
    },
    editModeTitle: {
        color: theme.colors.warning,
    },
    searchBarContainer: {
        backgroundColor: "transparent",
        borderBottomColor: "transparent",
        borderTopColor: "transparent",
        marginBottom: 10,
        padding: 0,
    },
    searchBarInputContainer: {
        borderRadius: 25, // More rounded
        backgroundColor: theme.colors.grey5,
        height: 40, // Consistent height
    },
    searchInputStyle: {
        color: theme.colors.text,
        marginLeft: 10,
        fontSize: 16, // Slightly larger font
    },
    recentFoodsContainer: {
        marginBottom: 15,
    },
    sectionTitle: {
        fontWeight: 'bold',
        marginBottom: 8,
        color: theme.colors.text,
        fontSize: 18, // Larger section title
    },
    recentFoodItem: {
        paddingHorizontal: 15,
        paddingVertical: 10,
        borderRadius: 20, // More rounded
        backgroundColor: theme.colors.grey5,
        marginRight: 10,
        justifyContent: 'center', // Center text
        alignItems: 'center',
        flexDirection: 'row', // Added for icon and text alignment
    },
    selectedRecentFoodItem: {
        backgroundColor: theme.colors.grey3, // Slightly darker background
        borderColor: theme.colors.primary,
        borderWidth: 2,
    },
    smallRecentFoodItem: {
        paddingHorizontal: 10, // Reduce padding on small screens
    },
    recentFoodText: {
        color: theme.colors.text,
        fontSize: 14,
        marginLeft: 5, // Added to separate the icon and text
    },
    smallRecentFoodText: {
        fontSize: 12, // Smaller font on small screens
    },
    foodIcon: {
        width: 30,
        height: 30,
        marginRight: 10,
        borderRadius: 15,
        resizeMode: "stretch", // Or 'cover', or 'stretch', see below
      },
    foodList: {
        maxHeight: '48%',
        marginBottom: 8
    },
    listItemContainer: {
        backgroundColor: 'transparent',
        paddingVertical: 12, // More vertical padding
        flexDirection: 'row', // Added for icon and text alignment
    },
    selectedListItem: {
        backgroundColor: theme.colors.grey5, // Highlight selected item
    },
    listItemTitle: {
        color: theme.colors.text,
        fontSize: 16,
    },
    noFoodsText: {
        color: theme.colors.grey2,
        fontStyle: 'italic',
        textAlign: 'center',
        marginTop: 20,
    },
    servingSizeContainer: {
        marginTop: 15,
        marginBottom: 10,
    },
    servingSizeButton: {
      backgroundColor: theme.colors.grey4,
      borderRadius: 20,
      marginRight: 8,
      paddingHorizontal: 15,
      paddingVertical: 8, // Add vertical padding
      justifyContent: 'center', // Center text
      alignItems: 'center', // Center text
  },
    servingSizeButtonTitle: {
        color: theme.colors.text,
        fontSize: 14,
    },
    gramInputStyle: {
        color: theme.colors.text,
        marginLeft: 10,
        fontSize: 16,
    },
    gramInputContainerStyle: {
        borderBottomWidth: 1,
        borderBottomColor: theme.colors.text,
        paddingBottom: 5,
    },
    addButton: {
        borderRadius: 20, // More rounded
        paddingHorizontal: 25,
        paddingVertical: 10, // Add vertical padding
        minWidth: 100, // Set minimum width
    },
    buttonTitle: {
        color: theme.colors.white,
        fontWeight: '600',
        fontSize: 16, // Larger button text
    },
    closeIcon: {
        padding: 5,
    },
}));

export default AddEntryModal;
---------- END AddEntryModal.tsx ----------


---------- AddFoodModal.tsx ----------
import React, { useState, useEffect } from "react";
import {
  View,
  KeyboardAvoidingView,
  Platform,
  ActivityIndicator,
  Alert,
  ScrollView,
} from "react-native";
import {
  Button,
  Input,
  Text,
  Overlay,
  makeStyles,
  useTheme,
  Icon, // Re-using the Icon component from RNEUI
} from "@rneui/themed";
import { Food } from "../types/food";
import { SafeAreaView } from "react-native-safe-area-context";
import { MaterialCommunityIcons } from "@expo/vector-icons";
import Toast from "react-native-toast-message";
import { getMacrosForRecipe } from "../utils/macros";

interface AddFoodModalProps {
  isVisible: boolean;
  toggleOverlay: () => void;
  newFood: Omit<Food, "id">;
  editFood: Food | null;
  errors: { [key: string]: string };
  handleInputChange: (
    key: keyof Omit<Food, "id">,
    value: string,
    isEdit: boolean
  ) => void;
  handleCreateFood: () => void;
  handleUpdateFood: () => void;
  validateFood: (food: Omit<Food, "id">) => { [key: string]: string } | null;
  setErrors: React.Dispatch<React.SetStateAction<{ [key: string]: string }>>;
}

const AddFoodModal: React.FC<AddFoodModalProps> = ({
  isVisible,
  toggleOverlay,
  newFood,
  editFood,
  errors,
  handleInputChange,
  handleCreateFood,
  handleUpdateFood,
  validateFood,
  setErrors,
}) => {
  const { theme } = useTheme();
  const styles = useStyles();
  const [loading, setLoading] = useState(false);
  const [apiLoading, setApiLoading] = useState(false);
  const [mode, setMode] = useState<"normal" | "ingredients">("normal");
  const [ingredients, setIngredients] = useState("");
  const [aiButtonLoading, setAiButtonLoading] = useState(false);

  useEffect(() => {
    if (isVisible) {
      setErrors({});
      setMode("normal");
      setIngredients("");
    }
  }, [isVisible, setErrors]);

  const getValue = (key: keyof Omit<Food, "id">) => {
    return String((editFood && editFood[key]) ?? newFood[key] ?? "");
  };

  const handleCreateOrUpdate = async (isUpdate: boolean) => {
    setLoading(true);
    const validationErrors = validateFood(
      isUpdate ? (editFood as Omit<Food, "id">) : newFood
    );

    if (validationErrors) {
      setErrors(validationErrors);
      setLoading(false);
      Toast.show({
        type: "error",
        text1: "Please fix the errors",
      });
      return;
    }

    try {
      isUpdate ? await handleUpdateFood() : await handleCreateFood();
      Toast.show({
        type: "success",
        text1: `Food ${isUpdate ? "Updated" : "Created"} Successfully!`,
      });
      toggleOverlay();
    } catch (error: any) {
      Alert.alert(
        "Error",
        error.message || `Failed to ${isUpdate ? "update" : "create"} food.`
      );
    } finally {
      setLoading(false);
    }
  };

  const handleAiButtonClick = async () => {
    const foodName = getValue("name");

    if (mode === "normal") {
      setMode("ingredients");
      handleInputChange("calories", "", !!editFood);
      handleInputChange("protein", "", !!editFood);
      handleInputChange("carbs", "", !!editFood);
      handleInputChange("fat", "", !!editFood);
    } else if (mode === "ingredients") {
      setAiButtonLoading(true);
      try {
        const macros = await getMacrosForRecipe(foodName, ingredients);
        handleInputChange("calories", String(macros.calories), !!editFood);
        handleInputChange("protein", String(macros.protein), !!editFood);
        handleInputChange("carbs", String(macros.carbs), !!editFood);
        handleInputChange("fat", String(macros.fat), !!editFood);
        setMode("normal");
      } catch (error) {
        Alert.alert(
          "AI Error",
          "Could not calculate macros.  Please check your ingredients and try again."
        );
      } finally {
        setAiButtonLoading(false);
      }
    }
  };

  return (
    <Overlay
      isVisible={isVisible}
      onBackdropPress={toggleOverlay}
      animationType="fade"
      transparent={true}
      statusBarTranslucent={Platform.OS === "android"}
      overlayStyle={styles.overlayStyle}
    >
      <SafeAreaView style={styles.modalSafeArea}>
        <KeyboardAvoidingView
          behavior={Platform.OS === "ios" ? "padding" : "height"}
          style={styles.keyboardAvoidingView}
        >
          <View style={styles.overlayContent}>
            <View style={styles.header}>
              <Text h4 style={styles.overlayTitle}>
                {editFood ? "Edit Food" : "Add New Food"}
              </Text>
              <Button
                title={editFood ? "Update" : "Add"}
                onPress={() => handleCreateOrUpdate(!!editFood)}
                buttonStyle={[
                  styles.button,
                  {
                    backgroundColor: editFood
                      ? theme.colors.warning
                      : theme.colors.primary,
                  },
                ]}
                titleStyle={{ color: theme.colors.white, fontWeight: "600" }}
                loading={loading}
                containerStyle={styles.buttonContainer}
              />

              <Icon
                name="close"
                type="material"
                size={28}
                color={theme.colors.text}
                onPress={toggleOverlay}
                containerStyle={styles.closeIcon}
              />
            </View>

            <ScrollView>
              <Input
                label="Food Name"
                labelStyle={{ color: theme.colors.text }}
                value={getValue("name")}
                onChangeText={(text) =>
                  handleInputChange("name", text, !!editFood)
                }
                errorMessage={errors.name}
                inputContainerStyle={styles.inputContainerStyle}
                inputStyle={styles.inputStyle}
                leftIcon={
                  <MaterialCommunityIcons
                    name="food-apple"
                    size={24}
                    color={errors.name ? theme.colors.error : theme.colors.text}
                  />
                }
              />
              {mode === "normal" && (
                <>
                  <Input
                    label="Calories (per 100g)"
                    labelStyle={{ color: theme.colors.text }}
                    keyboardType="numeric"
                    value={getValue("calories")}
                    onChangeText={(text) =>
                      handleInputChange(
                        "calories",
                        text.replace(/[^0-9]/g, ""),
                        !!editFood
                      )
                    }
                    errorMessage={errors.calories}
                    inputContainerStyle={styles.inputContainerStyle}
                    inputStyle={styles.inputStyle}
                    leftIcon={
                      <MaterialCommunityIcons
                        name="fire"
                        size={24}
                        color={
                          errors.calories
                            ? theme.colors.error
                            : theme.colors.text
                        }
                      />
                    }
                  />

                  <Input
                    label="Protein (per 100g)"
                    labelStyle={{ color: theme.colors.text }}
                    keyboardType="numeric"
                    value={getValue("protein")}
                    onChangeText={(text) =>
                      handleInputChange(
                        "protein",
                        text.replace(/[^0-9]/g, ""),
                        !!editFood
                      )
                    }
                    errorMessage={errors.protein}
                    inputContainerStyle={styles.inputContainerStyle}
                    inputStyle={styles.inputStyle}
                    leftIcon={
                      <MaterialCommunityIcons
                        name="food-drumstick"
                        size={24}
                        color={
                          errors.protein
                            ? theme.colors.error
                            : theme.colors.text
                        }
                      />
                    }
                  />

                  <Input
                    label="Carbs (per 100g)"
                    labelStyle={{ color: theme.colors.text }}
                    keyboardType="numeric"
                    value={getValue("carbs")}
                    onChangeText={(text) =>
                      handleInputChange(
                        "carbs",
                        text.replace(/[^0-9]/g, ""),
                        !!editFood
                      )
                    }
                    errorMessage={errors.carbs}
                    inputContainerStyle={styles.inputContainerStyle}
                    inputStyle={styles.inputStyle}
                    leftIcon={
                      <MaterialCommunityIcons
                        name="bread-slice"
                        size={24}
                        color={
                          errors.carbs ? theme.colors.error : theme.colors.text
                        }
                      />
                    }
                  />
                  <Input
                    label="Fat (per 100g)"
                    labelStyle={{ color: theme.colors.text }}
                    keyboardType="numeric"
                    value={getValue("fat")}
                    onChangeText={(text) =>
                      handleInputChange(
                        "fat",
                        text.replace(/[^0-9]/g, ""),
                        !!editFood
                      )
                    }
                    errorMessage={errors.fat}
                    inputContainerStyle={styles.inputContainerStyle}
                    inputStyle={styles.inputStyle}
                    leftIcon={
                      <MaterialCommunityIcons
                        name="bucket"
                        size={24}
                        color={
                          errors.fat ? theme.colors.error : theme.colors.text
                        }
                      />
                    }
                  />
                </>
              )}

              {mode === "ingredients" && (
                <>
                <View style={styles.backButtonContainer}>
                    <Icon
                        name="arrow-left" // Use a clear back arrow icon
                        type="material-community" // From MaterialCommunityIcons
                        size={28}
                        color={theme.colors.primary} // Use a contrasting color
                        onPress={() => setMode("normal")}
                        containerStyle={styles.backIcon} // Added style for positioning
                    />
                    <Text style={styles.backButtonText}>Back to Manual Input</Text>
                </View>

                  <Input
                    label="Ingredients"
                    labelStyle={{ color: theme.colors.text }}
                    value={ingredients}
                    onChangeText={setIngredients}
                    multiline={true}
                    numberOfLines={4}
                    inputContainerStyle={[styles.inputContainerStyle]}
                    inputStyle={styles.inputStyle}
                    leftIcon={
                      <MaterialCommunityIcons
                        name="food-variant"
                        size={24}
                        color={theme.colors.text}
                      />
                    }
                  />
                </>
              )}
                <Button
                    title={mode === "normal" ? "AI Input" : "Get Macros"}
                    onPress={handleAiButtonClick}
                    buttonStyle={[
                    styles.button,
                    { backgroundColor: theme.colors.secondary },
                    ]}
                    titleStyle={{ color: theme.colors.white, fontWeight: "600" }}
                    loading={aiButtonLoading}
                    containerStyle={[styles.buttonContainer, { marginTop: 15 }]}
                />

              <View style={styles.futureInputContainer}>
                <Text style={styles.futureInputLabel}>
                  Barcode Input (Coming Soon)
                </Text>
              </View>
            </ScrollView>
          </View>
        </KeyboardAvoidingView>
        {apiLoading && (
          <View style={styles.loadingOverlay}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
          </View>
        )}
      </SafeAreaView>
    </Overlay>
  );
};

const useStyles = makeStyles((theme) => ({
  overlayStyle: {
    backgroundColor: "rgba(150, 150, 150, 0)",
    padding: 20,
    marginVertical: 50,
    width: "90%",
    borderRadius: 15,
    height: "100%",
  },
  modalSafeArea: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  keyboardAvoidingView: {
    width: "100%",
    flex: 1,
  },
  overlayContent: {
    backgroundColor: theme.colors.background,
    width: "100%",
    borderRadius: 15,
    padding: 20,
    minHeight: "50%",
    flexGrow: 1,
  },
  header: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 20,
  },
  overlayTitle: {
    color: theme.colors.text,
    fontWeight: "bold",
  },
  closeIcon: {
    padding: 5,
  },
  inputContainerStyle: {
    borderBottomWidth: 1,
    borderBottomColor: theme.colors.grey4,
    marginBottom: 10,
  },
  inputStyle: {
    color: theme.colors.text,
    marginLeft: 10,
  },
  futureInputContainer: {
    backgroundColor: theme.colors.grey5,
    padding: 15,
    borderRadius: 10,
    marginTop: 10,
    alignItems: "center",
  },
  futureInputLabel: {
    color: theme.colors.grey2,
    fontStyle: "italic",
  },
  buttonContainer: {},
  button: {
    borderRadius: 8,
    paddingHorizontal: 20,
  },
  loadingOverlay: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    justifyContent: "center",
    alignItems: "center",
    zIndex: 10,
  },
    backButtonContainer: {
        flexDirection: "row", // Arrange icon and text horizontally
        alignItems: "center", // Vertically center
        marginBottom: 10,
        marginTop: 5,
        marginLeft: 5, // Add left margin

    },
    backIcon: {
        marginRight: 8, // Add space between the icon and text
        padding: 5,

    },
    backButtonText: {
        color: theme.colors.grey2,
        fontSize: 16,
    }
}));

export default AddFoodModal;
---------- END AddFoodModal.tsx ----------


---------- ConfirmationModal.tsx ----------
// components/ConfirmationModal.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Overlay, Button, Input, Text, useTheme } from '@rneui/themed';

interface ConfirmationModalProps {
  isVisible: boolean;
  onCancel: () => void;
  onConfirm: () => void;
  confirmationText: string;
  setConfirmationText: (text: string) => void;
  title?: string; // Optional title
  message?: string;  //Optional message
}

const ConfirmationModal: React.FC<ConfirmationModalProps> = ({
  isVisible,
  onCancel,
  onConfirm,
  confirmationText,
  setConfirmationText,
  title = "Confirm Action", //default title
  message = "Are you sure you want to perform this action?"
}) => {
  const { theme } = useTheme();

  return (
    <Overlay
      isVisible={isVisible}
      onBackdropPress={onCancel}
      overlayStyle={styles.overlay}
      backdropStyle={styles.backdrop} // Add the backdropStyle
    >
      <View style={[styles.container, {backgroundColor: theme.colors.background}]}>
        <Text style={[styles.title, {color: theme.colors.text}]}>{title}</Text>
        <Text style={[styles.message, {color: theme.colors.text}]}>{message}</Text>
        <Input
          placeholder="Enter confirmation text"
          placeholderTextColor={theme.colors.text}
          value={confirmationText}
          onChangeText={setConfirmationText}
          containerStyle={styles.inputContainer}
          inputStyle={{ color: theme.colors.text }}
          inputContainerStyle={{borderBottomColor: theme.colors.text}}
        />
        <View style={styles.buttonContainer}>
          <Button title="Cancel" onPress={onCancel} type="outline" buttonStyle={styles.button} />
          <Button
            title="Confirm"
            onPress={onConfirm}
            color="error"
            buttonStyle={styles.button}
            disabled={confirmationText === ""}  //Disable when empty
          />
        </View>
      </View>
    </Overlay>
  );
};

const styles = StyleSheet.create({
    overlay: {
        borderRadius: 10,
        width: '80%', // Responsive width
        padding: 6,
        backgroundColor: 'rgba(200, 200, 200, 0.5)'
    },
  container: {
    padding: 20,
    borderRadius: 7,
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 10,
    textAlign: 'center', //center align
  },
  message: {
    marginBottom: 15,
    textAlign: 'center'
  },
  inputContainer: {
    marginBottom: 20,
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
  },
  button: {
    width: 100,
    padding: 10,
  },
  backdrop: {  // Add styles for the backdrop
    backgroundColor: 'rgba(0, 0, 0, 0.5)', // Semi-transparent black
  },
});

export default ConfirmationModal;
---------- END ConfirmationModal.tsx ----------


---------- DailyGoalsInput.tsx ----------
// components/DailyGoalsInput.tsx
import React from "react";
import { Input } from "@rneui/themed";
import { MacroType } from "../types/settings";
import { useTheme } from "@rneui/themed";


interface DailyGoalsInputProps {
  dailyGoals: { [key in MacroType]: number };
  onGoalChange: (goalType: MacroType, value: string) => void;
}

const DailyGoalsInput: React.FC<DailyGoalsInputProps> = ({
  dailyGoals,
  onGoalChange,
}) => {

    const { theme } = useTheme();

  return (
    <>
      {["calories", "protein", "carbs", "fat"].map((macro) => (
        <Input
          key={macro}
          label={`${macro.charAt(0).toUpperCase() + macro.slice(1)} Goal`}
          keyboardType="numeric"
          value={dailyGoals?.[macro as MacroType]?.toString() || ""}
          onChangeText={(value) => onGoalChange(macro as MacroType, value)}
          style={{ color: theme.colors.text }}
          inputContainerStyle={{ borderBottomColor: theme.colors.text }}
          labelStyle={{ color: theme.colors.text }}
        />
      ))}
    </>
  );
};

export default DailyGoalsInput;
---------- END DailyGoalsInput.tsx ----------


---------- DailyProgress.tsx ----------
// components/DailyProgress.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, useTheme } from '@rneui/themed';

interface DailyProgressProps {
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
  goals: {
    calories?: number;
    protein?: number;
    carbs?: number;
    fat?: number;
  };
}

const DailyProgress: React.FC<DailyProgressProps> = ({
  calories,
  protein,
  carbs,
  fat,
  goals,
}) => {
  const { theme } = useTheme();

  const calculateProgress = (current: number, goal?: number) => {
    if (!goal || goal <= 0) return 0; // Avoid division by zero and handle undefined goals
    return Math.min(current / goal, 1); // Cap at 100%
  };

  const renderProgressBar = (label: string, current: number, goal: number | undefined, color: string) => {
      const progress = calculateProgress(current, goal);
      return (
          <View style={styles.macroContainer} key={label}>
              <View style={styles.labelContainer}>
                    <Text style={[styles.macroLabel, {color: theme.colors.text}]}>{label}:</Text>
                    <Text style={[styles.macroValue, {color: theme.colors.text}]}>
                        {`${Math.round(current)} / ${goal || 0}`}
                    </Text>
              </View>
              <View style={styles.progressBarContainer}>
                  <View style={[styles.progressBar, { width: `${progress * 100}%`, backgroundColor: color }]} />
              </View>
          </View>
      )
  }


  return (
    <View style={styles.container}>
        {renderProgressBar('Calories', calories, goals.calories, theme.colors.primary)}
        {renderProgressBar('Protein', protein, goals.protein, 'green')}
        {renderProgressBar('Carbs', carbs, goals.carbs, 'orange')}
        {renderProgressBar('Fat', fat, goals.fat, 'blue')}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: 20,
    padding: 10,
    borderRadius: 8, // Rounded corners for the container
    //backgroundColor: '#f0f0f0', // Light background for contrast Removed for theme consistency
  },
  macroContainer: {
    marginBottom: 10,
  },
  labelContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 5,
  },
  macroLabel: {
    fontWeight: 'bold',
  },
  macroValue: {},
  progressBarContainer: {
      backgroundColor: '#e0e0e0', //Light grey for track
      borderRadius: 5,
      height: 10
  },
  progressBar: {
    height: 10,
    borderRadius: 5,
  },
});

export default DailyProgress;
---------- END DailyProgress.tsx ----------


---------- DataManagementButtons.tsx ----------
// components/DataManagementButtons.tsx (Modified callback)

import React, { useState } from "react";
import { Alert, Platform } from "react-native"; // Import Platform
import { Button } from "@rneui/themed";
import * as DocumentPicker from "expo-document-picker";
import * as FileSystem from "expo-file-system";
import * as Sharing from 'expo-sharing'; // Import Sharing
import { formatDate } from "../utils/dateUtils";
import {
  clearAllData,
  loadDailyEntries,
  saveDailyEntries,
  loadFoods,
  saveFoods,
  loadSettings,
  saveSettings
} from "../services/storageService";
import ConfirmationModal from "./ConfirmationModal";
import { DailyEntry } from "../types/dailyEntry";
import { Food } from "../types/food";
import { Settings } from "../types/settings";
import { useTheme } from "@rneui/themed";


interface DataManagementButtonsProps {
  onDataOperation: () => void; // Changed prop name
}

const DataManagementButtons: React.FC<DataManagementButtonsProps> = ({
    onDataOperation
}) => {
  const [isConfirmationVisible, setIsConfirmationVisible] = useState(false);
  const [confirmationText, setConfirmationText] = useState("");
  const { theme } = useTheme();

  const handleExportData = async () => {
    try {
      const dailyEntries = await loadDailyEntries();
      const foods = await loadFoods();
      const settings = await loadSettings();

      const exportData = {
        dailyEntries,
        foods,
        settings
      };

      const exportDataString = JSON.stringify(exportData);
      const formattedDate = formatDate(new Date()).replace(/\//g, '-'); // Replace slashes
      const fileName = `macro_data_${formattedDate}.json`;
      const fileUri = FileSystem.documentDirectory + fileName;

      await FileSystem.writeAsStringAsync(fileUri, exportDataString, {
        encoding: FileSystem.EncodingType.UTF8,
      });

      // Use expo-sharing to share the file
      if (!(await Sharing.isAvailableAsync())) {
        Alert.alert('Sharing is not available on your platform');
        return;
      }

      await Sharing.shareAsync(fileUri);
      onDataOperation(); // Trigger reload after export

    } catch (error: any) {
      console.error(error);
      Alert.alert(
        "Export Failed",
        error.message || "An error occurred while exporting data."
      );
    }
  };

  const handleImportData = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: ["application/json"], // Only accept JSON files
      });

      if (result.assets && result.assets.length > 0) {
        const file = result.assets[0];

        // Check file extension
        if (!file.name?.toLowerCase().endsWith(".json")) {
          Alert.alert("Invalid File", "Please select a JSON file.");
          return;
        }

        const fileContent = await FileSystem.readAsStringAsync(file.uri, {
          encoding: FileSystem.EncodingType.UTF8,
        });


        try {
          const importedData = JSON.parse(fileContent);

          // Basic structure validation:
          if (
            !importedData.hasOwnProperty("dailyEntries") ||
            !importedData.hasOwnProperty("foods") ||
            !importedData.hasOwnProperty("settings")
          ) {
            Alert.alert(
              "Import Failed",
              "The imported file is missing required data (dailyEntries, foods, or settings)."
            );
            return;
          }


          await saveDailyEntries(importedData.dailyEntries);
          await saveFoods(importedData.foods);
          await saveSettings(importedData.settings)
          Alert.alert("Import Successful", "Data imported and saved.");
          onDataOperation(); //trigger reload

        } catch (parseError) {
          Alert.alert(
            "Import Failed",
            "The imported file is not valid JSON."
          );
          return;
        }


      } else {
        // Explicitly check for cancelled
        if (result.canceled) {
          // User cancelled, do nothing
        } else {
          Alert.alert("Import Failed", "Invalid file selected.");
        }
      }
    } catch (error: any) {
      console.error("Import Error:", error);
      Alert.alert(
        "Import Failed",
        error.message || "An unknown error occurred."
      );
    }
  };

  const handleClearData = () => setIsConfirmationVisible(true);

  const confirmClearData = async () => {
    if (confirmationText === "CLEAR DATA") {
      try {
        await clearAllData();
        Alert.alert("Data Cleared", "All data has been cleared.");
        onDataOperation(); // Trigger reload after clearing
      } catch (error) {
        Alert.alert("Error", "Failed to clear data.");
      } finally {
        setConfirmationText("");
        setIsConfirmationVisible(false);
      }
    } else {
      Alert.alert("Error", "Incorrect confirmation text.");
    }
  };

  return (
    <>
      <Button
        title="Export Data"
        onPress={handleExportData}
        buttonStyle={{ marginBottom: 10, backgroundColor: theme.colors.primary }}
      />
      <Button
        title="Import Data"
        onPress={handleImportData}
        buttonStyle={{ marginBottom: 10, backgroundColor: theme.colors.primary }}
      />
      <Button
        title="Clear All Data"
        onPress={handleClearData}
        color="error"
        buttonStyle={{ marginBottom: 10 }}
      />

      <ConfirmationModal
        isVisible={isConfirmationVisible}
        onCancel={() => setIsConfirmationVisible(false)}
        onConfirm={confirmClearData}
        confirmationText={confirmationText}
        setConfirmationText={setConfirmationText}
        title="Clear All Data?"
        message="This action cannot be undone. Confirmation Text: CLEAR DATA"
      />
    </>
  );
};

export default DataManagementButtons;
---------- END DataManagementButtons.tsx ----------


---------- FoodItem.tsx ----------
// FoodItem.tsx (Corrected with forwardRef and Icon Handling)
import React, { forwardRef } from "react"; // Import forwardRef
import { StyleSheet, View, Image } from "react-native"; // Import View and Image
import { ListItem, Icon, useTheme, Button } from "@rneui/themed";
import { Food } from "../types/food";
import Toast from "react-native-toast-message";

interface FoodItemProps {
  food: Food;
  onEdit: (food: Food) => void;
  onDelete: (foodId: string) => void;
  onUndoDelete: (food: Food) => void;
  foodIconUrl: string | null; // Add foodIconUrl prop
}

// Use forwardRef to receive the ref from the parent
const FoodItem = forwardRef<any, FoodItemProps>(
  ({ food, onEdit, onDelete, onUndoDelete, foodIconUrl }, ref) => {
    const { theme } = useTheme();

    const handleDelete = () => {
      onDelete(food.id);
      Toast.show({
        type: "success",
        text1: `${food.name} deleted`,
        text2: "Tap to undo",
        position: "bottom",
        bottomOffset: 80,
        onPress: () => onUndoDelete(food), // Call undo function
        visibilityTime: 3000, // Show for 3 seconds
      });
    };

    return (
      // Attach the received ref to ListItem.Swipeable
      <ListItem.Swipeable
        ref={ref} // Pass the forwarded ref here!
        bottomDivider
        leftContent={(reset) => (
          <Button
            title="Edit"
            onPress={() => {
              onEdit(food);
              reset();
            }}
            icon={{ name: "edit", color: "white" }}
            buttonStyle={styles.swipeButtonEdit}
          />
        )}
        rightContent={(reset) => (
          <Button
            title="Delete"
            onPress={handleDelete} // Call handleDelete
            icon={{ name: "delete", color: "white" }}
            buttonStyle={styles.swipeButtonDelete}
          />
        )}
        containerStyle={[
          styles.listItemContainer,
          { backgroundColor: theme.colors.background },
        ]}
      >
        {/* Use Image component if foodIconUrl exists, otherwise use default Icon */}
        {foodIconUrl ? (
          <Image source={{ uri: foodIconUrl }} style={styles.foodIcon} />
        ) : (
          <Icon
            name="fast-food-outline"
            type="ionicon"
            color={theme.colors.text}
          />
        )}
        <ListItem.Content>
          <ListItem.Title style={[styles.title, { color: theme.colors.text }]}>
            {food.name}
          </ListItem.Title>
          <ListItem.Subtitle style={{ color: theme.colors.text }}>
            {`Cal: ${food.calories}, P: ${food.protein}g, C: ${food.carbs}g, F: ${food.fat}g`}
          </ListItem.Subtitle>
        </ListItem.Content>
        <ListItem.Chevron />
      </ListItem.Swipeable>
    );
  }
);

const styles = StyleSheet.create({
  listItemContainer: {
    paddingVertical: 15,
    borderRadius: 0,
    marginVertical: 0,
  },
  title: {
    fontWeight: "bold",
    fontSize: 16,
  },
  swipeButtonEdit: {
    minHeight: "100%",
    backgroundColor: "orange",
  },
  swipeButtonDelete: {
    minHeight: "100%",
    backgroundColor: "red",
  },
  foodIcon: {
    width: 30,
    height: 30,
    marginRight: 10,
    borderRadius: 15,
    resizeMode: "stretch", // Or 'cover', or 'stretch', see below
  },
});

export default FoodItem;

---------- END FoodItem.tsx ----------


---------- StatisticsChart.tsx ----------
// components/StatisticsChart.tsx (Modified)
import React from "react";
import { View, StyleSheet } from "react-native";
import { WebView } from "react-native-webview";
import { Statistics, MacroType, macros } from "../types/settings"; // Import types
import { useTheme } from "@rneui/themed";


interface StatisticsChartProps {
  statistics: Statistics;
}

const StatisticsChart: React.FC<StatisticsChartProps> = ({ statistics }) => {

  const { theme } = useTheme();

  const generateChartHTML = () => {
    const chartData = macros.reduce((acc, macro) => {
      // Prepare data for each macro, including goal if applicable
      acc[macro] = statistics[macro].map((series) =>
        series.map((item) => [item.x / 1000, item.y])
      );
      return acc;
    }, {} as { [key in MacroType]: number[][][] });

    const textColor = theme.colors.text;
    const gridColor = theme.colors.grey5; // Lighter grid
    const axisColor = theme.colors.grey3; // Slightly darker axis
    const fontFamily = "Helvetica, Arial, sans-serif";

    // Define color palette for the lines, using theme colors if possible
    const lineColors = {
      calories: theme.colors.primary,
      protein: theme.colors.success,
      carbs: theme.colors.warning,
      fat: theme.colors.error,
    };


    // Re-enabled caching, but *only* cache the HTML itself, not the data.  The data is now dynamic.
    return `
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>Macro Charts</title>
            <style>
            body { font-family: ${fontFamily}; margin: 0; padding: 0; background-color: ${theme.colors.background}; color: ${textColor};}
                .chart-container { width: 95%; height: 250px; margin: 10px auto; }
            </style>
            <link rel="stylesheet" href="https://unpkg.com/uplot@1.6.27/dist/uPlot.min.css">
            <script src="https://unpkg.com/uplot@1.6.27/dist/uPlot.iife.min.js"></script>
        </head>
        <body>
            ${macros
      .map((macro) => {
        const isCalories = macro === "calories";
        const seriesCount = isCalories ? 2 : 1; // Two series for calories (intake, goal)

        const seriesConfig = isCalories
          ? `[
                      {},
                      {
                        stroke: "${lineColors[macro] || theme.colors.primary}",
                        width: 2,
                        label: "Intake",
                        points: { show: false }
                      },
                      {
                        stroke: "red",
                        width: 1,
                        dash: [5, 5],
                        label: "Goal",
                        points: { show: false }
                      }
                    ]`
          : `[
                      {},
                      {
                        stroke: "${lineColors[macro] || theme.colors.primary}",
                        width: 2,
                        label: "${macro.charAt(0).toUpperCase() + macro.slice(1)}",
                        points: { show: false }
                      }
                    ]`;


        const uPlotData =
          seriesCount === 2
            ? `[data[0].map(d => d[0]), data[0].map(d => d[1]), data[1].map(d => d[1])]`
            : `[data[0].map(d => d[0]), data[0].map(d => d[1])]`;



        return `
                <div id="${macro}-chart" class="chart-container"></div>
                <script>
                    const data = ${JSON.stringify(chartData[macro])};
                    const opts = {
                        title: "${macro.charAt(0).toUpperCase() + macro.slice(1)}",
                        width: window.innerWidth * 0.95,
                        height: 250,
                        scales: {
                            x: { time: true },
                            y: { },
                        },
                        axes: [
                            {
                                stroke: "${textColor}",
                                font: "14px ${fontFamily}",
                            grid: {
                                    stroke: "${gridColor}",
                                    width: 1
                                },
                                ticks: {
                                    stroke: "${gridColor}",
                                    width: 1
                                }
                            },
                            {
                                stroke: "${textColor}",
                                font: "14px ${fontFamily}",
                                grid: {
                                    stroke: "${gridColor}",
                                    width: 1
                                },
                                ticks: {
                                    stroke: "${gridColor}",
                                    width: 1
                                }
                            }
                        ],
                        series: ${seriesConfig},
                        cursor: {
                            drag: { setScale: false },
                            points: {
                                size: 6,
                                fill: (self, i) => self.series[i]._stroke,
                                stroke: (self, i) => self.series[i]._stroke,
                            }
                        },
                        ${isCalories ? `
                        hooks: {
                            draw: [
                                (u) => {
                                   const ctx = u.ctx;
                                    u.series.forEach((series, seriesIdx) => {
                                      if (seriesIdx === 1) {
                                        const intakeData = data[0];
                                        const goalData = data[1];

                                        ctx.beginPath();
                                        ctx.fillStyle = "rgba(255, 0, 0, 0.3)"; // Semi-transparent red

                                        for (let i = 0; i < intakeData.length; i++) {
                                          const intakeY = intakeData[i][1];
                                          const goalY = goalData[i][1];
                                          const x = u.valToPos(intakeData[i][0], "x", true);
                                          
                                           // Check if intake exceeds the goal
                                            if(intakeY > goalY){
                                                const intakeYPos = u.valToPos(intakeY, 'y', true);
                                                const goalYPos = u.valToPos(goalY, 'y', true);
                                               
                                                //if this is the first point or last point, move to x, other wise line to x
                                                if(i === 0){
                                                   ctx.moveTo(x, intakeYPos);
                                                }else{
                                                  ctx.lineTo(x, intakeYPos);
                                                }
                                            }
                                        }
                                        //go back along the goal data
                                         for (let i = intakeData.length-1; i >= 0; i--) {
                                            const intakeY = intakeData[i][1];
                                            const goalY = goalData[i][1];
                                             const x = u.valToPos(intakeData[i][0], "x", true);
                                               // Check if intake exceeds the goal
                                            if(intakeY > goalY){
                                                 const goalYPos = u.valToPos(goalY, 'y', true);
                                                ctx.lineTo(x, goalYPos);
                                            }
                                         }

                                        ctx.closePath();
                                        ctx.fill();
                                        }

                                    });

                                }
                            ]
                        }
                        ` : ''}
                    };
                    new uPlot(opts, ${uPlotData}, document.getElementById('${macro}-chart'));
                </script>
            `;
      })
      .join("")}
        </body>
        </html>
        `;

  };

  return (
    <View style={styles.webViewContainer}>
      <WebView
        originWhitelist={["*"]}
        source={{ html: generateChartHTML() }}
        style={styles.webView}
        scalesPageToFit={false}
        scrollEnabled={false}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  webViewContainer: {
    height: 'auto',
    width: "100%",
    marginTop: 10,
  },
  webView: {
    height: 340, // Explicit height, adjust as needed.
  },
});

export default StatisticsChart;
---------- END StatisticsChart.tsx ----------


---------- ThemeSwitch.tsx ----------
// components/ThemeSwitch.tsx (Corrected)
import React from "react";
import { ListItem, Switch } from "@rneui/themed";
import { useTheme } from "@rneui/themed";

interface ThemeSwitchProps {
  currentTheme: 'light' | 'dark' | 'system'; // Use theme string
  onToggle: (theme: 'light' | 'dark' | 'system') => void; // Pass the theme string
}

const ThemeSwitch: React.FC<ThemeSwitchProps> = ({ currentTheme, onToggle }) => {
  const { theme } = useTheme();

  return (
    <ListItem
      bottomDivider
      containerStyle={{ backgroundColor: theme.colors.background }}
    >
      <ListItem.Content>
        <ListItem.Title style={{ color: theme.colors.text }}>
          Dark Mode
        </ListItem.Title>
      </ListItem.Content>
      <Switch
        value={currentTheme === 'dark'} // Correctly reflect theme
        onValueChange={(newValue) => {
          onToggle(newValue ? 'dark' : 'light'); // Toggle between 'light' and 'dark'
        }}
      />
    </ListItem>
  );
};

export default ThemeSwitch;
---------- END ThemeSwitch.tsx ----------


---------- index.ts ----------
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);

---------- END index.ts ----------


---------- AppNavigator.tsx ----------
// navigation/AppNavigator.tsx
import React, { useState, useCallback } from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { Icon, useTheme } from '@rneui/themed';
import DailyEntryScreen from '../screens/DailyEntryScreen';
import FoodListScreen from '../screens/FoodListScreen';
import SettingsScreen from '../screens/SettingsScreen';

const Tab = createBottomTabNavigator();

interface AppNavigatorProps {
  onThemeChange: (theme: 'light' | 'dark' | 'system') => void;
}

const AppNavigator: React.FC<AppNavigatorProps> = ({ onThemeChange }) => {
  const { theme } = useTheme();
  const [foodListRefresh, setFoodListRefresh] = useState(false);

  const handleFoodChange = useCallback(() => {
    setFoodListRefresh(prev => !prev); // Toggle the state to trigger refresh
  }, []);

  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        tabBarIcon: ({ focused, color, size }) => {
          let iconName: string = '';
          let type: string = '';

          if (route.name === 'Daily Entry') {
            iconName = focused ? 'calendar' : 'calendar-outline';
            type = 'ionicon';
          } else if (route.name === 'Foods') {
            iconName = focused ? 'fast-food' : 'fast-food-outline';
            type = 'ionicon'; // Consistent icon set
          } else if (route.name === 'Settings') {
            iconName = focused ? 'settings' : 'settings-outline';
            type = 'ionicon';
          }

          return <Icon name={iconName} type={type} size={size} color={color} />;
        },
        tabBarActiveTintColor: theme.colors.primary,
        tabBarInactiveTintColor: theme.colors.secondary, // Use secondary color
        headerShown: false,
        tabBarStyle: {
          backgroundColor: theme.colors.background,
          borderTopColor: theme.colors.divider, // Add a subtle border
        },
        tabBarLabelStyle: {
          fontWeight: 'bold', // Make labels more prominent
        }
      })}
    >
      <Tab.Screen name="Daily Entry">
        {() => <DailyEntryScreen key={foodListRefresh ? 'refresh' : 'normal'} />}
      </Tab.Screen>
      <Tab.Screen name="Foods">
        {() => <FoodListScreen onFoodChange={handleFoodChange} />}
      </Tab.Screen>
      <Tab.Screen name="Settings">
        {() => <SettingsScreen onThemeChange={onThemeChange} onDataOperation={function (): void {
          throw new Error('Function not implemented.');
        } } />}
      </Tab.Screen>
    </Tab.Navigator>
  );
};

export default AppNavigator;
---------- END AppNavigator.tsx ----------


---------- package.json ----------
{
  "name": "macrotracker",
  "license": "0BSD",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@react-native-async-storage/async-storage": "^2.1.2",
    "@react-native-community/datetimepicker": "8.2.0",
    "@react-navigation/bottom-tabs": "^7.3.1",
    "@react-navigation/native": "^7.0.17",
    "@rneui/base": "^4.0.0-rc.7",
    "@rneui/themed": "^4.0.0-rc.8",
    "@types/d3-scale": "^4.0.9",
    "d3-scale": "^4.0.2",
    "date-fns": "^4.1.0",
    "expo": "~52.0.40",
    "expo-document-picker": "^13.0.3",
    "expo-file-system": "^18.0.12",
    "expo-sharing": "~13.0.1",
    "expo-status-bar": "~2.0.1",
    "react": "18.3.1",
    "react-native": "0.76.7",
    "react-native-config": "^1.5.5",
    "react-native-get-random-values": "^1.11.0",
    "react-native-reanimated": "~3.16.1",
    "react-native-safe-area-context": "^4.14.1",
    "react-native-screens": "^4.9.2",
    "react-native-svg": "^15.11.2",
    "react-native-toast-message": "^2.2.1",
    "react-native-webview": "^13.13.4",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/react": "~18.3.12",
    "@types/react-native": "^0.73.0",
    "@types/react-native-svg-charts": "^5.0.16",
    "@types/uuid": "^10.0.0",
    "typescript": "^5.3.3",
    "victory": "^37.3.6"
  },
  "private": true
}

---------- END package.json ----------


---------- projectToFile.js ----------
const fs = require('fs');
const path = require('path');

async function generateProjectStructureAndContent(projectRoot, outputFile) {
    const excludedDirs = ['node_modules', '.git', '.expo', 'android', 'ios', '__tests__', 'dist', 'build', '.vscode'];
    const excludedFiles = ['.DS_Store', 'package-lock.json', 'yarn.lock', 'bun.lockb', 'metro.config.js', 'babel.config.js'];
    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.webp', '.ico']; // Add more if needed

    let fileStructureTree = '';  // For the initial tree structure
    let fileContents = '';      // For the file contents

    async function traverseDirectory(dir, indent = '') {
        const entries = await fs.promises.readdir(dir, { withFileTypes: true });

        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);

            if (excludedDirs.includes(entry.name)) {
                continue;
            }

            if (entry.isDirectory()) {
                fileStructureTree += `${indent}${entry.name}/\n`;
                await traverseDirectory(fullPath, indent + '  ');
            } else if (entry.isFile()) {
                if (excludedFiles.includes(entry.name)) {
                    continue;
                }
                fileStructureTree += `${indent}${entry.name}\n`;
                const fileExtension = path.extname(entry.name).toLowerCase();

                if (!imageExtensions.includes(fileExtension)) {
                    fileContents += `\n---------- ${entry.name} ----------\n`;
                    try {
                        const fileContent = await fs.promises.readFile(fullPath, 'utf-8');
                        fileContents += `${fileContent}\n`;
                    } catch (readError) {
                        fileContents += `ERROR READING FILE: ${readError.message}\n`;
                    }
                    fileContents += `---------- END ${entry.name} ----------\n\n`;
                } else {
                     fileContents += `\n---------- ${entry.name} ----------\n`;
                     fileContents += `(Image file - content not included)\n`;
                     fileContents += `---------- END ${entry.name} ----------\n\n`;
                }
            }
        }
    }

    try {
        await traverseDirectory(projectRoot);
        const fullOutput = fileStructureTree + fileContents;

        await fs.promises.writeFile(outputFile, fullOutput);
        console.log(`Project structure and content written to ${outputFile}`);

    } catch (error) {
        console.error('An error occurred:', error);
        process.exit(1);
    }
}

// --- Main execution ---

const projectRoot = process.cwd(); // Use the current working directory
const outputFile = 'project_structure.txt';

// Check if the projectRoot exists.
fs.stat(projectRoot, (err, stats) => {
    if (err) {
        console.error(`Error: Project root directory "${projectRoot}" not found or not accessible.`);
        process.exit(1);
    }

    if (!stats.isDirectory()) {
        console.error(`Error: "${projectRoot}" is not a directory.`);
        process.exit(1);
    }

    generateProjectStructureAndContent(projectRoot, outputFile);
});
---------- END projectToFile.js ----------


---------- DailyEntryScreen.tsx ----------
// DailyEntryScreen.tsx (Modified for Food Icons)
import React, { useState, useEffect, useCallback, useMemo } from "react";
import { View, FlatList, Alert, Platform, Image, StyleSheet } from "react-native"; // Import Image and StyleSheet
import { DailyEntry, DailyEntryItem } from "../types/dailyEntry";
import { Food } from "../types/food";
import { getFoods } from "../services/foodService";
import {
    saveDailyEntries,
    loadDailyEntries,
    loadSettings,
} from "../services/storageService";
import {
    formatDate,
    formatDateReadable,
    getTodayDateString,
} from "../utils/dateUtils";
import { isValidNumberInput } from "../utils/validationUtils";
import DailyProgress from "../components/DailyProgress";
import {
    Button,
    Text,
    ListItem,
    FAB,
    makeStyles,
    useTheme,
    Divider,
    Input,
} from "@rneui/themed";
import DateTimePicker from "@react-native-community/datetimepicker";
import { addDays, subDays, parseISO, formatISO } from "date-fns";
import { Icon } from "@rneui/base";
import { SafeAreaView } from "react-native-safe-area-context";
import AddEntryModal from "../components/AddEntryModal";
import "react-native-get-random-values";
import Toast from "react-native-toast-message";
import { useFocusEffect } from '@react-navigation/native';
import { getFoodIconUrl } from "./../utils/iconUtils"; // Import the icon helper function

interface DailyGoals {
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
}

const DailyEntryScreen: React.FC = () => {
    const [dailyEntries, setDailyEntries] = useState<DailyEntry[]>([]);
    const [selectedDate, setSelectedDate] = useState<string>(getTodayDateString());
    const [foods, setFoods] = useState<Food[]>([]);
    const [selectedFood, setSelectedFood] = useState<Food | null>(null);
    const [grams, setGrams] = useState("");
    const [isOverlayVisible, setIsOverlayVisible] = useState(false);
    const [showDatePicker, setShowDatePicker] = useState(false);
    const [dailyGoals, setDailyGoals] = useState<DailyGoals>({
        calories: 2000,
        protein: 50,
        carbs: 200,
        fat: 70,
    });
    const [editingIndex, setEditingIndex] = useState<number | null>(null);
    const [tempGrams, setTempGrams] = useState("");
    const [search, setSearch] = useState("");
    const [editIndex, setEditIndex] = useState<number | null>(null);
    const [foodIcons, setFoodIcons] = useState<{ [foodName: string]: string | null }>({});

    const { theme } = useTheme();
    const styles = useStyles();

    const loadData = useCallback(async () => {
        const loadedFoods = await getFoods();
        const loadedEntries = await loadDailyEntries();
        const loadedSettings = await loadSettings();

        if (loadedSettings.dailyGoals) {
            setDailyGoals(loadedSettings.dailyGoals);
        }

        setFoods(loadedFoods);
        setDailyEntries(loadedEntries);
    }, []);

    useFocusEffect(
        useCallback(() => {
            loadData();
            return () => {
                setSearch('');
            };
        }, [loadData])
    );

    // Load food icons when component mounts or foods change
    useEffect(() => {
        const loadIcons = async () => {
            const icons: { [foodName: string]: string | null } = {};
            for (const food of foods) {
                const iconUrl = await getFoodIconUrl(food.name);
                icons[food.name] = iconUrl;
            }
            setFoodIcons(icons);
        };

        loadIcons();
    }, [foods]);


    const getCurrentEntry = (): DailyEntry => {
        return (
            dailyEntries.find((entry) => entry.date === selectedDate) || {
                date: selectedDate,
                items: [],
            }
        );
    };

    const updateAndSaveEntries = async (updatedEntries: DailyEntry[]) => {
        await saveDailyEntries(updatedEntries);
        setDailyEntries(updatedEntries);
    };

    const handleStartEditing = (index: number, currentGrams: number) => {
        setEditingIndex(index);
        setTempGrams(String(currentGrams));
    };

    const handleSaveInlineEdit = async (index: number) => {
        if (!isValidNumberInput(tempGrams) || parseFloat(tempGrams) <= 0) {
            Alert.alert(
                "Invalid Input",
                "Please enter a valid, positive number for grams."
            );
            return;
        }

        const currentEntry = getCurrentEntry();
        const updatedItems = [...currentEntry.items];
        updatedItems[index] = { ...updatedItems[index], grams: parseFloat(tempGrams) };
        const updatedEntry = { ...currentEntry, items: updatedItems };

        const updatedEntries = dailyEntries.filter(
            (entry) => entry.date !== selectedDate
        );
        updatedEntries.push(updatedEntry);

        await updateAndSaveEntries(updatedEntries);
        setEditingIndex(null);
        setTempGrams("");
    };

    const handleCancelInlineEdit = () => {
        setEditingIndex(null);
        setTempGrams("");
    };

    const handleAddEntry = async () => {
        if (!selectedFood || !isValidNumberInput(grams) || parseFloat(grams) <= 0) {
            Alert.alert(
                "Invalid Input",
                "Please select a food and enter a valid, positive number for grams."
            );
            return;
        }

        const newEntryItem: DailyEntryItem = {
            food: selectedFood,
            grams: parseFloat(grams),
        };
        const currentEntry = getCurrentEntry();
        let updatedItems;

        if (editIndex !== null) {
            updatedItems = currentEntry.items.map((item, index) =>
                index === editIndex ? newEntryItem : item
            );
        } else {
            updatedItems = [...currentEntry.items, newEntryItem];
        }

        const updatedEntry = { ...currentEntry, items: updatedItems };

        const updatedEntries = dailyEntries.map((entry) => {
            if (entry.date === currentEntry.date) {
                return updatedEntry;
            }
            return entry;
        });

        await updateAndSaveEntries(updatedEntries);
        setSelectedFood(null);
        setGrams("");
        setEditIndex(null);
        setIsOverlayVisible(false);
    };

    const handleSelectFood = (item: Food | null) => {
        setSelectedFood(item);
    };

    const handleRemoveEntry = async (index: number) => {
        const currentEntry = getCurrentEntry();
        const itemToRemove = currentEntry.items[index];
        const updatedItems = currentEntry.items.filter((_, i) => i !== index);


        const updatedEntry = { ...currentEntry, items: updatedItems };

        //If the entry is empty, remove it completely from the entries.
        if (updatedItems.length === 0) {
            const newEntries = dailyEntries.filter((entry) => entry.date !== currentEntry.date);
            await updateAndSaveEntries(newEntries);
        }
        else {
            const updatedEntries = dailyEntries.map((entry) => {
                if (entry.date === currentEntry.date) {
                    return updatedEntry;
                }
                return entry;
            });
            await updateAndSaveEntries(updatedEntries);
        }

        Toast.show({
            type: 'success',
            text1: `${itemToRemove.food.name} entry deleted`,
            text2: 'Tap to undo',
            position: 'bottom',
            bottomOffset: 80,
            onPress: () => handleUndoRemoveEntry(itemToRemove, currentEntry),
            visibilityTime: 3000,
        });
    };

    const handleUndoRemoveEntry = (
        item: DailyEntryItem,
        originalEntry: DailyEntry
    ) => {
        const updatedEntries = dailyEntries.map((entry) => {
            if (entry.date === originalEntry.date) {
                const existingItemIndex = entry.items.findIndex(
                    (existingItem) => existingItem.food.id === item.food.id
                );

                let updatedItems = [...entry.items];

                if (existingItemIndex === -1) {
                    updatedItems = [...entry.items, item];
                }

                return { ...entry, items: updatedItems };
            }
            return entry;
        });

        updateAndSaveEntries(updatedEntries);
        Toast.hide();
    };

    const updateSearch = (search: string) => setSearch(search);

    const toggleOverlay = (
        item: DailyEntryItem | null = null,
        index: number | null = null
    ) => {
        setIsOverlayVisible(!isOverlayVisible);
        if (item) {
            setSelectedFood(item.food);
            setGrams(String(item.grams));
            setEditIndex(index);
        } else {
            setSelectedFood(null);
            setGrams("");
            setEditIndex(null);
            setSearch("");
        }
    };

    const handleEditEntry = (item: DailyEntryItem, index: number) => {
        toggleOverlay(item, index);
    };

    // Key Change: Update date handling
    const handleDateChange = (event: any, selectedDateVal?: Date) => {
        setShowDatePicker(false);
        if (event.type === "set" && selectedDateVal) {
            // Format the selected date to a string
            const formattedDate = formatISO(selectedDateVal, { representation: 'date' });
            setSelectedDate(formattedDate);
        }
    };

    const handlePreviousDay = () => {
        const currentDate = parseISO(selectedDate);
        const newDate = subDays(currentDate, 1);
        setSelectedDate(formatISO(newDate, { representation: 'date' }));
    }

    const handleNextDay = () => {
        const currentDate = parseISO(selectedDate);
        const newDate = addDays(currentDate, 1);
        setSelectedDate(formatISO(newDate, { representation: 'date' }));
    }

    const calculateTotals = () => {
        const currentEntry = getCurrentEntry();
        let [totalCalories, totalProtein, totalCarbs, totalFat] = [0, 0, 0, 0];

        currentEntry.items.forEach((item) => {
            totalCalories += (item.food.calories / 100) * item.grams;
            totalProtein += (item.food.protein / 100) * item.grams;
            totalCarbs += (item.food.carbs / 100) * item.grams;
            totalFat += (item.food.fat / 100) * item.grams;
        });

        return {
            totalCalories: Math.round(totalCalories),
            totalProtein: Math.round(totalProtein),
            totalCarbs: Math.round(totalCarbs),
            totalFat: Math.round(totalFat),
        };
    };

    const { totalCalories, totalProtein, totalCarbs, totalFat } =
        calculateTotals();

    return (
        <SafeAreaView style={styles.container}>
            <View style={styles.dateNavigation}>
                <Button
                    type="clear"
                    onPress={handlePreviousDay}
                    icon={
                        <Icon name="arrow-back" type="ionicon" color={theme.colors.text} />
                    }
                />
                <Text style={styles.dateText} onPress={() => setShowDatePicker(true)}>
                    {formatDateReadable(selectedDate)}
                </Text>
                <Button
                    type="clear"
                    onPress={handleNextDay}
                    icon={
                        <Icon
                            name="arrow-forward"
                            type="ionicon"
                            color={theme.colors.text}
                        />
                    }
                />
            </View>

            {showDatePicker && (
                <DateTimePicker
                    value={parseISO(selectedDate)}
                    mode="date"
                    display="default"
                    onChange={handleDateChange}
                />
            )}

            <DailyProgress
                calories={totalCalories}
                protein={totalProtein}
                carbs={totalCarbs}
                fat={totalFat}
                goals={dailyGoals}
            />
            <Divider style={styles.divider} />

            <Text h4 style={[styles.sectionTitle, { color: theme.colors.text }]}>
                Entries:
            </Text>

            <FlatList
                data={getCurrentEntry().items}
                keyExtractor={(_, index) => index.toString()}
                renderItem={({ item, index }) => (
                    <ListItem.Swipeable
                        bottomDivider
                        leftContent={(reset) => (
                            <Button
                                title="Edit"
                                onPress={() => {
                                    handleEditEntry(item, index);
                                    reset();
                                }}
                                icon={{ name: "edit", color: "white" }}
                                buttonStyle={{ minHeight: "100%", backgroundColor: "orange" }}
                            />
                        )}
                        rightContent={(reset) => (
                            <Button
                                title="Delete"
                                onPress={() => {
                                    handleRemoveEntry(index);
                                    reset();
                                }}
                                icon={{ name: "delete", color: "white" }}
                                buttonStyle={{ minHeight: "100%", backgroundColor: "red" }}
                            />
                        )}
                        containerStyle={{ backgroundColor: theme.colors.background }}
                    >
                        {/* Use Image if icon URL exists, otherwise use default Icon */}
                        {foodIcons[item.food.name] ? (
                            <Image
                                source={{ uri: foodIcons[item.food.name] as string }}
                                style={styles.foodIcon}
                            />
                        ) : (
                            <Icon
                                name="nutrition-outline"
                                type="ionicon"
                                color={theme.colors.text}
                            />
                        )}
                        <ListItem.Content>
                            <ListItem.Title style={{ color: theme.colors.text }}>
                                {item.food.name}
                            </ListItem.Title>

                            {editingIndex === index ? (
                                <View style={{ flexDirection: "row", alignItems: "center" }}>
                                    <Input
                                        value={tempGrams}
                                        onChangeText={setTempGrams}
                                        keyboardType="numeric"
                                        inputContainerStyle={{ borderBottomWidth: 0 }}
                                        style={{ width: 80, color: theme.colors.text }}
                                    />
                                    <Button
                                        title="Save"
                                        type="clear"
                                        onPress={() => handleSaveInlineEdit(index)}
                                        icon={<Icon name="checkmark" type="ionicon" color="green" />}
                                    />
                                    <Button
                                        title="Cancel"
                                        type="clear"
                                        onPress={handleCancelInlineEdit}
                                        icon={<Icon name="close" type="ionicon" color="red" />}
                                    />
                                </View>
                            ) : (
                                <ListItem.Subtitle style={{ color: theme.colors.text }}>
                                    {`${item.grams}g`}
                                </ListItem.Subtitle>
                            )}
                        </ListItem.Content>
                    </ListItem.Swipeable>
                )}
            />

            <FAB
                icon={<Icon name="add" color="white" />}
                color={theme.colors.primary}
                onPress={() => toggleOverlay()}
                placement="right"
                size="large"
                containerStyle={styles.fabContainer}
            />

            <AddEntryModal
                isVisible={isOverlayVisible}
                toggleOverlay={toggleOverlay}
                selectedFood={selectedFood}
                grams={grams}
                setGrams={setGrams}
                foods={foods} // Pass all foods
                handleAddEntry={handleAddEntry}
                handleSelectFood={handleSelectFood}
                search={search}
                updateSearch={updateSearch}
                isEditMode={editIndex !== null}
                initialGrams={editIndex !== null ? String(getCurrentEntry().items[editIndex]?.grams) : undefined}
            />
        </SafeAreaView>
    );
};

const useStyles = makeStyles((theme) => ({
    container: {
        flex: 1,
        backgroundColor: theme.colors.background,
    },
    dateNavigation: {
        flexDirection: "row",
        alignItems: "center",
        justifyContent: "space-between",
        marginVertical: 10,
        paddingHorizontal: 10,
    },
    dateText: {
        fontSize: 18,
        fontWeight: "bold",
        color: theme.colors.text,
    },
    foodIcon: {
      width: 30,
      height: 30,
      marginRight: 10,
      borderRadius: 15,
      resizeMode: "stretch", // Or 'cover', or 'stretch', see below
    },
    divider: {
        marginVertical: 10,
    },
    sectionTitle: {
        marginBottom: 10,
        paddingHorizontal: 10,
    },
    fabContainer: {
        position: "absolute",
        bottom: -6,
        right: -8,
        elevation: 0,
        zIndex: 10,
    },
}));

export default DailyEntryScreen;
---------- END DailyEntryScreen.tsx ----------


---------- FoodListScreen.tsx ----------
// FoodListScreen.tsx (Corrected)

import React, { useState, useEffect, useCallback } from "react";
import { View, FlatList, Alert, Platform, Image } from "react-native";
import {
    createFood,
    getFoods,
    updateFood,
    deleteFood,
} from "../services/foodService";
import { Food } from "../types/food";
import { isValidNumberInput, isNotEmpty } from "../utils/validationUtils";
import FoodItem from "../components/FoodItem";
import { Button, SearchBar, useTheme, makeStyles } from "@rneui/themed";
import { FAB } from "@rneui/base";
import { SafeAreaView } from "react-native-safe-area-context";
import AddFoodModal from "../components/AddFoodModal";
import Toast from "react-native-toast-message";
import { useFocusEffect } from "@react-navigation/native";
import { Icon } from "@rneui/base";
import { getFoodIconUrl } from "./../utils/iconUtils";

interface FoodListScreenProps {
    onFoodChange?: () => void;
}

const FoodListScreen: React.FC<FoodListScreenProps> = ({ onFoodChange }) => {
    const [foods, setFoods] = useState<Food[]>([]);
    const [foodIcons, setFoodIcons] = useState<{ [foodName: string]: string | null }>({});
    const [isOverlayVisible, setIsOverlayVisible] = useState(false);
    const [search, setSearch] = useState("");
    const [newFood, setNewFood] = useState<Omit<Food, "id">>({
        name: "",
        calories: 0,
        protein: 0,
        carbs: 0,
        fat: 0,
    });
    const [editFood, setEditFood] = useState<Food | null>(null);
    const [errors, setErrors] = useState<{ [key: string]: string }>({});
    const { theme } = useTheme();
    const styles = useStyles();

    const loadFoodData = useCallback(async () => {
        const loadedFoods = await getFoods();
        setFoods(loadedFoods);
    }, []);

    useFocusEffect(
        useCallback(() => {
            loadFoodData();
        }, [loadFoodData])
    );
    useEffect(() => {
        const loadIcons = async () => {
            const icons: { [foodName: string]: string | null } = {};
            for (const food of foods) {
                const iconUrl = await getFoodIconUrl(food.name);
                icons[food.name] = iconUrl;
            }
            setFoodIcons(icons);
        };

        loadIcons();
    }, [foods]);

    const validateFood = (food: Omit<Food, "id">) => {
        const newErrors: { [key: string]: string } = {};
        if (!isNotEmpty(food.name)) newErrors.name = "Name is required";
        if (!isValidNumberInput(String(food.calories)))
            newErrors.calories = "Invalid input";
        if (!isValidNumberInput(String(food.protein)))
            newErrors.protein = "Invalid input";
        if (!isValidNumberInput(String(food.carbs)))
            newErrors.carbs = "Invalid input";
        if (!isValidNumberInput(String(food.fat)))
            newErrors.fat = "Invalid input";

        return Object.keys(newErrors).length === 0 ? null : newErrors;
    };

    const handleCreateFood = async () => {
        const validationErrors = validateFood(newFood);
        if (validationErrors) {
            setErrors(validationErrors);
            return;
        }
        setErrors({});
        try {
            const createdFood = await createFood(newFood);
            setFoods([...foods, createdFood]);
            setNewFood({
                name: "",
                calories: 0,
                protein: 0,
                carbs: 0,
                fat: 0,
            });
            setIsOverlayVisible(false);
            onFoodChange && onFoodChange();
        } catch (error: any) {
            Alert.alert("Error", error.message || "Failed to create food.");
        }
    };

    const handleUpdateFood = async () => {
        if (!editFood) return;
        const validationErrors = validateFood(editFood);
        if (validationErrors) {
            setErrors(validationErrors);
            return;
        }
        setErrors({});
        try {
            const updated = await updateFood(editFood);
            setFoods(foods.map((f) => (f.id === updated.id ? updated : f)));
            setEditFood(null);
            setIsOverlayVisible(false);
            onFoodChange && onFoodChange();
        } catch (error: any) {
            Alert.alert("Error", error.message || "Failed to update food.");
        }
    };

    const handleDeleteFood = async (foodId: string) => {
        const foodToDelete = foods.find((f) => f.id === foodId);
        if (!foodToDelete) return;
        setFoods(foods.filter((f) => f.id !== foodId));

        try {
            await deleteFood(foodId);
            Toast.show({
                type: "success",
                text1: `${foodToDelete.name} deleted`,
                text2: "Tap to undo",
                position: "bottom",
                bottomOffset: 80,
                onPress: () => handleUndoDeleteFood(foodToDelete),
                visibilityTime: 3000,
            });
            onFoodChange && onFoodChange();
        } catch (error) {
            setFoods((prevFoods) => [...prevFoods, foodToDelete]);
            Alert.alert("Error", "Failed to delete food.");
        }
    };

    const handleUndoDeleteFood = (food: Food) => {
        setFoods((prevFoods) => [...prevFoods, food]);
        Toast.hide();
        onFoodChange && onFoodChange();
    };

    const toggleOverlay = (food?: Food) => {
        if (food) {
            setEditFood(food);
        } else {
            setEditFood(null);
            setNewFood({
                name: "",
                calories: 0,
                protein: 0,
                carbs: 0,
                fat: 0,
            });
        }
        setErrors({});
        setIsOverlayVisible(!isOverlayVisible);
    };

    const updateSearch = (search: string) => setSearch(search);

    const filteredFoods = foods.filter((food) =>
        food.name.toLowerCase().includes(search.toLowerCase())
    );

   const handleInputChange = (
        key: keyof Omit<Food, "id">,
        value: string,
        isEdit: boolean
    ) => {
        if (isEdit) {
            setEditFood((prevEditFood) => {
                if (!prevEditFood) return null; // Or some default empty Food object
                return {
                    ...prevEditFood,
                    [key]: key === "name" ? value : value === "" ? 0 : parseFloat(value),
                };
            });
        } else {
            setNewFood((prevNewFood) => ({
                ...prevNewFood,
                [key]: key === "name" ? value : value === "" ? 0 : parseFloat(value),
            }));
        }
    };

    return (
        <SafeAreaView style={styles.container}>
            <SearchBar
                placeholder="Search Foods..."
                onChangeText={updateSearch}
                value={search}
                platform={Platform.OS === "ios" ? "ios" : "android"}
                containerStyle={styles.searchBarContainer}
                inputContainerStyle={[
                    styles.searchBarInputContainer,
                    { backgroundColor: theme.colors.grey5 },
                ]}
                inputStyle={{ color: theme.colors.text }}
            />
            <FlatList
                data={filteredFoods}
                keyExtractor={(item) => item.id}
                renderItem={({ item }) => (
                    <FoodItem
                        food={item}
                        onEdit={toggleOverlay}
                        onDelete={handleDeleteFood}
                        onUndoDelete={handleUndoDeleteFood}
                        foodIconUrl={foodIcons[item.name]}
                    />
                )}
            />

            <FAB
                icon={{ name: "add", color: "white" }}
                color={theme.colors.primary}
                onPress={() => toggleOverlay()}
                placement="right"
                title=""
                style={{ marginBottom: 10, marginRight: 8 }}
            />

            <AddFoodModal
                isVisible={isOverlayVisible}
                toggleOverlay={toggleOverlay}
                newFood={newFood}
                editFood={editFood}
                errors={errors}
                handleInputChange={handleInputChange}
                handleCreateFood={handleCreateFood}
                handleUpdateFood={handleUpdateFood}
                validateFood={validateFood}
                setErrors={setErrors}
            />
        </SafeAreaView>
    );
};

const useStyles = makeStyles((theme) => ({
    container: {
        flex: 1,
        backgroundColor: theme.colors.background,
    },
    searchBarContainer: {
        backgroundColor: "transparent",
        borderBottomColor: "transparent",
        borderTopColor: "transparent",
        marginBottom: 10,
        padding: 0,
    },
    searchBarInputContainer: {
        borderRadius: 10,
    },
      foodIcon: {
      width: 30,
      height: 30,
      marginRight: 10,
      borderRadius: 15,
      resizeMode: "stretch", // Or 'cover', or 'stretch', see below
    },
}));

export default FoodListScreen;
---------- END FoodListScreen.tsx ----------


---------- SettingsScreen.tsx ----------
// SettingsScreen.tsx
import React, { useState, useEffect, useCallback } from "react";
import { View, ScrollView, Alert } from "react-native";
import { Text, makeStyles } from "@rneui/themed";
import DailyGoalsInput from "../components/DailyGoalsInput";
import DataManagementButtons from "../components/DataManagementButtons";
import ThemeSwitch from "../components/ThemeSwitch";
import StatisticsChart from "../components/StatisticsChart";
import { loadSettings, saveSettings, loadDailyEntries } from "../services/storageService";
import { Settings, Statistics, MacroType, MacroData } from "../types/settings";
import { parseISO, isBefore, formatISO } from "date-fns";
import { formatDate, formatDateReadable } from "../utils/dateUtils"; // Use custom formatDate
import { useTheme } from "@rneui/themed";
import { DailyEntry } from "../types/dailyEntry";
import { useFocusEffect } from "@react-navigation/native";

interface SettingsScreenProps {
  onThemeChange: (theme: "light" | "dark" | "system") => void;
  onDataOperation: () => void;
}

const SettingsScreen: React.FC<SettingsScreenProps> = ({ onThemeChange, onDataOperation }) => {
  const [settings, setSettings] = useState<Settings>({
    theme: "system",
    dailyGoals: {
      calories: 2000,
      protein: 50,
      carbs: 200,
      fat: 70,
    },
  });

  const [statistics, setStatistics] = useState<Statistics>({
    calories: [],
    protein: [],
    carbs: [],
    fat: [],
  });
  // Removed settingsHistory
  const [chartUpdateKey, setChartUpdateKey] = useState(0);
  const [dataChangeCounter, setDataChangeCounter] = useState(0);

  const { theme } = useTheme();
  const styles = useStyles();

  const loadInitialSettings = useCallback(async () => {
    const loadedSettings = await loadSettings();

    setSettings((prevSettings) => ({
      ...prevSettings,
      ...loadedSettings,
      dailyGoals: {
        ...prevSettings.dailyGoals,
        ...(loadedSettings?.dailyGoals || {}),
      },
    }));
  }, []);

  useEffect(() => {
    loadInitialSettings();
  }, [loadInitialSettings]);


  const handleGoalChange = useCallback(async (goalType: MacroType, value: string) => {
    const numericValue = parseFloat(value) || 0;

    setSettings((prevSettings) => {
      const updatedGoals = { ...prevSettings.dailyGoals, [goalType]: numericValue };
      const updatedSettings: Settings = {
        ...prevSettings,
        dailyGoals: updatedGoals,
      };

      // Removed settings history update

      (async () => {
        await saveSettings(updatedSettings); // Simplified save
        setChartUpdateKey((prevKey) => prevKey + 1);
      })();

      return updatedSettings;
    });
    }, []); // Removed settingsHistory dependency


    const getStatisticsData = useCallback(
      (
        dailyEntries: DailyEntry[],
        macro: MacroType,
      ): MacroData[][] => { // Return type annotation
        const intakeData: MacroData[] = [];
        const goalData: MacroData[] = []; // For calories goal

          dailyEntries.forEach((entry) => {
              const entryDate = parseISO(entry.date);
            // Use current settings for all entries
            const relevantGoals = settings.dailyGoals;

            const intakeValue = entry.items.reduce(
              (total, item) => total + (item.food[macro] / 100) * item.grams,
              0
            );
            const goalValue = relevantGoals[macro] ?? 0;

            // Add to intake data (for all macros)
            intakeData.push({ x: entryDate.getTime(), y: intakeValue });

            // Add to goal data (only for calories)
            if (macro === "calories") {
              goalData.push({ x: entryDate.getTime(), y: goalValue });
            }
          });

          // Sort both arrays by date
        intakeData.sort((a, b) => a.x - b.x);
          if (macro === "calories") {
              goalData.sort((a,b) => a.x - b.x);
          }

        // Return as an array of arrays
        if (macro === "calories") {
          return [intakeData, goalData]; // Two series: intake and goal
        } else {
          return [intakeData]; // One series: intake only
        }
      },
      [settings.dailyGoals] // Only settings.dailyGoals as dependency
    );


  const updateStatistics = useCallback(async () => {
    const loadedEntries = await loadDailyEntries();

    // Calculate statistics for each macro
    const updatedStats: Statistics = {
      calories: getStatisticsData(loadedEntries, "calories"),
      protein: getStatisticsData(loadedEntries, "protein"),
      carbs: getStatisticsData(loadedEntries, "carbs"),
      fat: getStatisticsData(loadedEntries, "fat"),
    };

    setStatistics(updatedStats);
  }, [getStatisticsData]);

   useFocusEffect(
    useCallback(() => {
      (async () => {
        await loadInitialSettings();
        await updateStatistics();
      })();
    }, [loadInitialSettings, updateStatistics])
  );

  useEffect(() => {
    (async () => {
      if (dataChangeCounter > 0) {
        await updateStatistics();
        setChartUpdateKey((prevKey) => prevKey + 1);
      }
    })();
  }, [dataChangeCounter, updateStatistics]);

  const handleDataOperation = useCallback(() => {
    setDataChangeCounter((prevCounter) => prevCounter + 1);
  }, []);

  return (
    <ScrollView style={styles.container}>
      <Text h3 style={[styles.sectionTitle, { color: theme.colors.text }]}>General</Text>
      <ThemeSwitch currentTheme={settings.theme} onToggle={onThemeChange} />

      <Text h3 style={[styles.sectionTitle, { color: theme.colors.text }]}>Daily Goals</Text>
      <DailyGoalsInput dailyGoals={settings.dailyGoals} onGoalChange={handleGoalChange} />

      <Text h3 style={[styles.sectionTitle, { color: theme.colors.text }]}>Statistics</Text>
      <StatisticsChart statistics={statistics} key={chartUpdateKey} />

      <Text h3 style={[styles.sectionTitle, { color: theme.colors.text }]}>Data Management</Text>
      <DataManagementButtons onDataOperation={handleDataOperation} />
    </ScrollView>
  );
};
const useStyles = makeStyles((theme) => ({
  container: {
    flex: 1,
    padding: 10,
    backgroundColor: theme.colors.background,
  },
  sectionTitle: {
    marginTop: 20,
    marginBottom: 10,
  },
  button: {
    marginBottom: 10,
  },
}));

export default SettingsScreen;

// components/StatisticsChart.tsx (No changes needed here)
// Remains the same as in the previous, corrected version.  The key changes were in SettingsScreen.
---------- END SettingsScreen.tsx ----------


---------- foodService.ts ----------
// services/foodService.ts
import { Food } from '../types/food';
import { saveFoods, loadFoods } from './storageService';
import 'react-native-get-random-values';
import { v4 as uuidv4 } from 'uuid';

export const createFood = async (foodData: Omit<Food, 'id'>): Promise<Food> => {
  const newFood: Food = {
    id: uuidv4(),
    ...foodData,
  };
  const foods = await loadFoods();
  foods.push(newFood);
  await saveFoods(foods);
  return newFood;
};

export const getFoods = async (): Promise<Food[]> => {
  return loadFoods();
};

export const updateFood = async (updatedFood: Food): Promise<Food> => {
  const foods = await loadFoods();
  const index = foods.findIndex((f) => f.id === updatedFood.id);
  if (index === -1) {
    throw new Error('Food not found'); // Throw an error if not found
  }
  foods[index] = updatedFood;
  await saveFoods(foods);
  return updatedFood;
};

export const deleteFood = async (foodId: string): Promise<void> => {
  const foods = await loadFoods();
  const filteredFoods = foods.filter((f) => f.id !== foodId);
  await saveFoods(filteredFoods);
};
---------- END foodService.ts ----------


---------- storageService.ts ----------
// services/storageService.ts (Modified for Timestamps)
import AsyncStorage from '@react-native-async-storage/async-storage';
import { DailyEntry } from '../types/dailyEntry';
import { Food } from '../types/food';
import { Settings } from '../types/settings';
import { formatISO, parseISO } from 'date-fns';


const DAILY_ENTRIES_KEY = 'dailyEntries';
const FOODS_KEY = 'foods';
const SETTINGS_KEY = 'settings';
const RECENT_FOODS = 'recentFoods';


export const saveDailyEntries = async (entries: DailyEntry[]): Promise<void> => {
  try {
    await AsyncStorage.setItem(DAILY_ENTRIES_KEY, JSON.stringify(entries));
  } catch (error) {
    console.error('Error saving daily entries:', error);
    throw error;
  }
};

export const loadDailyEntries = async (): Promise<DailyEntry[]> => {
  try {
    const entriesJson = await AsyncStorage.getItem(DAILY_ENTRIES_KEY);
    return entriesJson ? JSON.parse(entriesJson) : [];
  } catch (error) {
    console.error('Error loading daily entries:', error);
    return [];
  }
};

export const saveFoods = async (foods: Food[]): Promise<void> => {
  try {
    await AsyncStorage.setItem(FOODS_KEY, JSON.stringify(foods));
  } catch (error) {
    console.error('Error saving foods:', error);
    throw error; // Re-throw the error
  }
};

export const loadFoods = async (): Promise<Food[]> => {
  try {
    const foodsJson = await AsyncStorage.getItem(FOODS_KEY);
    return foodsJson ? JSON.parse(foodsJson) : [];
  } catch (error) {
    console.error('Error loading foods:', error);
    return []; // Return an empty array on error
  }
};



export const saveSettings = async (settings: Settings): Promise<void> => {
  try {
    await AsyncStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
  } catch (error) {
    console.error('Error saving settings:', error);
    throw error;
  }
};

export const loadSettings = async (): Promise<Settings> => {
  try {
    const settingsJson = await AsyncStorage.getItem(SETTINGS_KEY);
    const loadedSettings = settingsJson ? JSON.parse(settingsJson) : {};

    // Apply defaults and ensure structure
    const defaultSettings: Settings = {
      theme: 'system',
      dailyGoals: { calories: 2000, protein: 50, carbs: 200, fat: 70 },
      settingsHistory: [] // Ensure settingsHistory exists
    };


    return {
      ...defaultSettings, // Start with defaults
        ...loadedSettings, // Override with loaded values
        dailyGoals: {
          ...defaultSettings.dailyGoals,  //ensure no fields missing from daily goals
            ...(loadedSettings.dailyGoals || {}) // And override *those* with any loaded dailyGoals
        }
    }

  } catch (error: any) {
    console.error('Error loading settings:', error);

    // *** KEY CHANGE: Handle "Row too big" error ***
    if (error.message.includes('Row too big')) {
      console.warn('Detected oversized settings data. Clearing settings.');
      try {
        await AsyncStorage.removeItem(SETTINGS_KEY); // Clear the oversized data
      } catch (clearError) {
        console.error('Error clearing oversized settings:', clearError);
        // You might want to handle this more gracefully, e.g., by showing an error to the user.
      }
    }

    // Return defaults if loading fails (or after clearing)
    return {
      theme: 'system',
      dailyGoals: { calories: 2000, protein: 50, carbs: 200, fat: 70 },
      settingsHistory: [] // Ensure settingsHistory exists in default
    };
  }
};

export const clearAllData = async (): Promise<void> => {
  try {
    await AsyncStorage.clear();
  } catch (error) {
    console.error('Error clearing data:', error);
    throw error;
  }
};

// Function to save recent foods
export const saveRecentFoods = async (foods: Food[]) => {
    try {
        await AsyncStorage.setItem(RECENT_FOODS, JSON.stringify(foods));
    } catch (error) {
        console.error('Error saving recent foods:', error);
        throw error; // Important: Re-throw the error so calling code knows it failed
    }
};

// Function to load recent foods
export const loadRecentFoods = async (): Promise<Food[]> => {
    try {
        const foods = await AsyncStorage.getItem(RECENT_FOODS);
        return foods ? JSON.parse(foods) : [];
    } catch (error) {
        console.error('Error loading recent foods:', error);
        return []; // Return empty array on error, don't throw
    }
};
---------- END storageService.ts ----------


---------- tsconfig.json ----------
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true

  }
}
---------- END tsconfig.json ----------


---------- dailyEntry.ts ----------
// types/dailyEntry.ts (Modified)
import { Food } from "./food";

export interface DailyEntryItem {
  food: Food;
  grams: number;
}

export interface DailyEntry {
  date: string; // YYYY-MM-DD format
  items: DailyEntryItem[];
  goals?: {  // Optional goals
    calories?: number;
    protein?: number;
    carbs?: number;
    fat?: number;
  };
}

export interface FoodItem { //No changes here.
    id: string;
    name: string;
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
  }
---------- END dailyEntry.ts ----------


---------- food.ts ----------
// types/food.ts
export interface Food {
  id: string;
  name: string;
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
  // category: string;  // REMOVED
}
---------- END food.ts ----------


---------- openRouterTypes.ts ----------
// src/utils/types.ts
// Defining types here helps with autocompletion and type safety
export interface OpenRouterMessage {
  role: "user" | "assistant" | "system"; // Add system role
  content: string;
}

export interface OpenRouterChoice {
  message: OpenRouterMessage;
  finish_reason?: string; // Optional properties for handling different responses
  index?: number;
}

export interface OpenRouterChatCompletionResponse {
  choices: OpenRouterChoice[];
  // You might add other fields that OpenRouter returns if you need them.
  // Example: id, created, model, usage, etc.
  id?: string;
  created?: number;
  model?: string;
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}

---------- END openRouterTypes.ts ----------


---------- settings.ts ----------
// types/settings.ts (Modified)
export const macros = ["calories", "protein", "carbs", "fat"] as const;
export type MacroType = (typeof macros)[number];

export interface MacroData {
  x: number; // Timestamp
  y: number; // Macro value
}

export interface Statistics {
  calories: MacroData[][];
  protein: MacroData[][];
  carbs: MacroData[][];
  fat: MacroData[][];
}

export interface Settings {
  theme: "light" | "dark" | "system";
  dailyGoals: {
    [key in MacroType]: number;
  };
  settingsHistory?: { date: number; dailyGoals: { [key in MacroType]: number } }[]; // CHANGED: Store timestamp
}

export interface SettingsScreenProps {
  onThemeChange: (theme: "light" | "dark" | "system") => void;
}
---------- END settings.ts ----------


---------- ai.ts ----------
// src/utils/ai.ts
import {
  OpenRouterChatCompletionResponse,
  OpenRouterMessage,
} from "../types/openRouterTypes";

const OPENROUTER_API_URL = "https://openrouter.ai/api/v1/chat/completions";

// No API_KEY constant here anymore

export async function getChatCompletion(
  model: string,
  messages: OpenRouterMessage[],
  responseFormat: "json_object" | "text" = "text",
  apiKey?: string // apiKey is now optional, for easier testing
): Promise<OpenRouterChatCompletionResponse> {
  // Get the API key from the environment variable.
  const effectiveApiKey = apiKey || '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';

  const response = await fetch(OPENROUTER_API_URL, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${effectiveApiKey}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      model,
      messages,
      response_format:
        responseFormat === "json_object" ? { type: "json_object" } : undefined,
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(
      `API request failed with status code ${response.status}: ${errorText}`
    );
  }

  const data: OpenRouterChatCompletionResponse = await response.json();

  if (
    !data.choices ||
    data.choices.length === 0 ||
    !data.choices[0].message ||
    !data.choices[0].message.content
  ) {
    throw new Error("Could not find the expected content in the response.");
  }

  return data;
}

---------- END ai.ts ----------


---------- dateUtils.ts ----------
// utils/dateUtils.ts (Modified)
import { format, parseISO, formatISO } from 'date-fns';

// Format a timestamp as YYYY-MM-DD (for display and storage)
export const formatDate = (timestamp: number): string => {
    return formatISO(timestamp, { representation: 'date' });
};

// Format a timestamp as a readable date (for display)
export const formatDateReadable = (timestamp: number | string): string => {
    if (typeof timestamp === 'string') {
        return timestamp; // if it is a string, do nothing.
    }
  return format(timestamp, 'MMMM dd, yyyy');
};

// Get today's date as a timestamp
export const getTodayDateString = (): string => {
  return formatISO(new Date(), { representation: 'date' });
};
---------- END dateUtils.ts ----------


---------- iconUtils.ts ----------
// utils/iconUtils.ts

import AsyncStorage from '@react-native-async-storage/async-storage';

const API_KEY = '25170800-59d7530d1a73abe661796e093';
const API_ENDPOINT = "https://pixabay.com/api/";

// Define the cache entry type
type CacheEntry = {
  url: string | null;
  expiry: number;
};

// In-memory cache for fast access
const memoryCache = new Map<string, CacheEntry>();

// Cache TTL: 3 days in milliseconds
const CACHE_TTL = 3 * 24 * 60 * 60 * 1000;

// Prefix for AsyncStorage keys
const STORAGE_KEY_PREFIX = 'foodIconCache_';

export const getFoodIconUrl = async (foodName: string): Promise<string | null> => {
  const cacheKey = foodName.toLowerCase();
  const now = Date.now();

  // 1. Check the in-memory cache first.
  const memoryEntry = memoryCache.get(cacheKey);
  if (memoryEntry && memoryEntry.expiry > now) {
    return memoryEntry.url;
  }

  // 2. Check persistent AsyncStorage.
  try {
    const storedValue = await AsyncStorage.getItem(STORAGE_KEY_PREFIX + cacheKey);
    if (storedValue) {
      const parsed: CacheEntry = JSON.parse(storedValue);
      if (parsed.expiry > now) {
        // Update in-memory cache with the persistent value.
        memoryCache.set(cacheKey, parsed);
        return parsed.url;
      } else {
        // Remove expired entry.
        await AsyncStorage.removeItem(STORAGE_KEY_PREFIX + cacheKey);
      }
    }
  } catch (error) {
    console.error('Error accessing AsyncStorage:', error);
  }
  

  // 3. No valid cached result, fetch from the API.
  try {
    const query = encodeURIComponent(`${foodName} minimal icon transparent`);
    const url = `${API_ENDPOINT}?key=${API_KEY}&q=${query}&image_type=vector&category=food&safesearch=true`;
    
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    const data = await response.json();
    let iconUrl: string | null = null;
    
    if (data.hits && data.hits.length > 0) {
      const filtered = data.hits.filter((hit: any) => {
        const hitUrl: string = hit.webformatURL.toLowerCase();
        return (hitUrl.endsWith('.png') || hitUrl.includes('svg')) &&
               hit.tags?.toLowerCase().includes(foodName.toLowerCase());
      });
      
      if (filtered.length > 0) {
        iconUrl = filtered[0].webformatURL;
      }
    }
    
    // Create a new cache entry with expiry.
    const newCacheEntry: CacheEntry = { url: iconUrl, expiry: now + CACHE_TTL };
    
    // Update both in-memory and persistent caches.
    memoryCache.set(cacheKey, newCacheEntry);
    try {
      await AsyncStorage.setItem(STORAGE_KEY_PREFIX + cacheKey, JSON.stringify(newCacheEntry));
    } catch (error) {
      console.error('Error saving to AsyncStorage:', error);
    }
    
    return iconUrl;
  } catch (error) {
    console.error("Error fetching food icon:", error);
    return null;
  }
};

---------- END iconUtils.ts ----------


---------- macros.ts ----------
// utils/macros.ts
import { getChatCompletion } from "./ai";
import { OpenRouterMessage } from "../types/openRouterTypes";

export interface Macros {
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
}

export async function getMacrosForRecipe(foodName: string, Ingredients: string): Promise<Macros> { // Changed parameter
    const prompt = `
    Calculate the macros per 100g for the following food.  Output ONLY a JSON object with the keys "calories", "protein", "carbs", and "fat".  Do NOT include any other text, explanations, or calculations.

    Food: ${foodName}
    Ingredients:
    ${Ingredients}
    `;

    const messages: OpenRouterMessage[] = [{ role: "user", content: prompt }];

    try {
        const response = await getChatCompletion(
            "google/gemini-2.0-flash-thinking-exp-1219:free", // Or your chosen model
            messages,
            "json_object"
        );

        const content = response.choices[0].message.content;
        const cleanedContent = content.trim().replace(/^```json\s*|\s*```$/g, "");
        const macroInfo: Macros = JSON.parse(cleanedContent);
        return macroInfo;
    } catch (error) {
        if (error instanceof SyntaxError) {
            console.error("Error: The response was not valid JSON.");
            throw new Error("Invalid JSON response from AI.");
        }
        console.error("Error fetching macros:", error);
        throw error;
    }
}
---------- END macros.ts ----------


---------- validationUtils.ts ----------
// utils/validationUtils.ts

export const isValidNumberInput = (value: string): boolean => {
    return /^[0-9]*(\.[0-9]*)?$/.test(value) && !isNaN(parseFloat(value));
  };
  
  export const isNotEmpty = (value: string): boolean => {
    return value.trim() !== '';
  };
---------- END validationUtils.ts ----------

