.gitignore
app.json
App.tsx
assets/
  adaptive-icon.png
  favicon.png
  icon.png
  splash.png
components/
  AddEntryModal.tsx
  AddFoodModal.tsx
  ConfirmationModal.tsx
  DailyGoalsInput.tsx
  DailyProgress.tsx
  DataManagementButtons.tsx
  FoodItem.tsx
  StatisticsChart.tsx
  ThemeSwitch.tsx
eas.json
index.ts
navigation/
  AppNavigator.tsx
package.json
projectToFile.js
screens/
  DailyEntryScreen.tsx
  FoodListScreen.tsx
  SettingsScreen.tsx
services/
  foodService.ts
  storageService.ts
tsconfig.json
types/
  dailyEntry.ts
  food.ts
  openRouterTypes.ts
  settings.ts
utils/
  ai.ts
  dateUtils.ts
  iconUtils.ts
  macros.ts
  units.ts
  validationUtils.ts

---------- .gitignore ----------
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

---------- END .gitignore ----------


---------- app.json ----------

{
  "expo": {
    "name": "MacroTracker",
    "slug": "MacroTracker",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "automatic", 
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#000000"
    },
    "androidStatusBar": {
      "backgroundColor": "#000000",
      "translucent": false,
      "barStyle": "light-content"
    },
    "assetBundlePatterns": [
      "**/*"
    ],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.yourcompany.macrotracker",
      "infoPlist": { 
        "UIStatusBarStyle": "UIStatusBarStyleAutomatic" 
      }
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "package": "com.yourcompany.macrotracker",
      "userInterfaceStyle": "automatic", 
      "statusBar": { 
        "backgroundColor": "#00000000",  
        "translucent": true,             
        "barStyle": "auto"
      }
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      [
        "expo-document-picker",
        {
          "appleTeamId": "YOUR_TEAM_ID"
        }
      ]
    ],
    "extra": {
      "eas": {
        "projectId": "25ac2bcf-78a3-4f2c-a635-4fcaae7b93f1"
      }
    }
  }
}
---------- END app.json ----------


---------- App.tsx ----------
// App.tsx (Modified - Removed AppState-triggered remount)
import "react-native-get-random-values"; // MUST BE FIRST
import Toast from "react-native-toast-message";
import React, { useState, useEffect } from "react";
import AppNavigator from "./navigation/AppNavigator";
import { SafeAreaProvider, SafeAreaView } from "react-native-safe-area-context";
import { ThemeProvider, createTheme } from "@rneui/themed";
import { loadSettings, saveSettings } from "./services/storageService";
import {
  useColorScheme,
  AppState,
  AppStateStatus,
  Platform,
} from "react-native";
import {
  NavigationContainer,
  DefaultTheme,
  DarkTheme,
} from "@react-navigation/native";
import { Colors } from "@rneui/base";
import { Settings } from "./types/settings";
import { LogBox, View, Text } from "react-native"; //Import view for debug
import { StatusBar } from "expo-status-bar"; // changed import

LogBox.ignoreLogs(["Function components cannot be given refs"]);

declare module "@rneui/themed" {
  export interface Colors {
    text: string;
    card: string; // Added for better card styling
    successLight: string; // Lighter success color
  }
}

interface MyTheme {
  mode: "light" | "dark";
  colors: Colors;
}

const lightTheme: MyTheme = {
  mode: "light",
  colors: {
    primary: "#2e86de",
    secondary: "#6c757d",
    background: "#f8f9fa",
    grey5: "#e9ecef",
    white: "#ffffff",
    grey4: "#ced4da",
    success: "#28a745",
    successLight: "#d4edda",
    black: "#000000",
    text: "#212529",
    card: "#ffffff",
    error: "#dc3545",
    warning: "#ffc107",
    disabled: "#6c757d",
    divider: "#ced4da",
    platform: {
      ios: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      android: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      web: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      default: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
    },
    // Complete the missing grey colors
    grey0: "#f8f9fa", // Very light, almost white
    grey1: "#e9ecef", // Light grey, same as grey5 (can adjust)
    grey2: "#dee2e6", // Medium-light grey
    grey3: "#ced4da", // Medium grey, same as grey4
    greyOutline: "#adb5bd", // Slightly darker for outlines
    searchBg: "#ffffff", // Background for search input, usually white
  },
};

const darkTheme: MyTheme = {
  mode: "dark",
  colors: {
    primary: "#2e86de",
    secondary: "#adb5bd",
    background: "#121212",
    grey5: "#2c2c2c",
    white: "#ffffff",
    grey4: "#343a40",
    success: "#28a745",
    successLight: "#1f5139",
    black: "#000000",
    text: "#f8f9fa",
    card: "#1e1e1e",
    error: "#dc3545",
    warning: "#ffc107",
    disabled: "#6c757d",
    divider: "#343a40",
    platform: {
      ios: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      android: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      web: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      default: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
    },
    // Complete the missing grey colors
    grey0: "#212529", // Very dark, almost black
    grey1: "#2c2c2c", // Dark grey, same as grey5
    grey2: "#343a40", // Medium-dark grey, same as grey4
    grey3: "#495057", // Medium grey
    greyOutline: "#6c757d", // Lighter grey for outlines, same as disabled
    searchBg: "#1e1e1e", // Background for search, dark to match card
  },
};

const App = () => {
  const [themeMode, setThemeMode] = useState<"light" | "dark" | "system">(
    "system"
  );
  const [loadedSettings, setLoadedSettings] = useState<Settings | null>(null);
  const colorScheme = useColorScheme();
  // --- REMOVED: reloadKey state is no longer needed for AppState changes ---
  // const [reloadKey, setReloadKey] = useState(0);
  const [appState, setAppState] = useState(AppState.currentState); // AppState
  const [themeCheck, setThemeCheck] = useState(0); //Added theme check

  // Load initial settings
  useEffect(() => {
    const initializeApp = async () => {
      const settings = await loadSettings();
      setThemeMode(settings.theme);
      setLoadedSettings(settings);
    };
    initializeApp();
  }, []);

  // --- REMOVED: triggerReload function is no longer needed ---
  // const triggerReload = () => {
  //   setReloadKey((prevKey) => prevKey + 1);
  // };

  // --- MODIFIED: Removed triggerReload() from AppState listener ---
  useEffect(() => {
    const handleAppStateChange = (nextAppState: AppStateStatus) => {
      // --- REMOVED THIS BLOCK ---
      // This block caused the entire navigator to remount when the app
      // returned from the background (e.g., after image picker closed),
      // which prematurely closed the AddFoodModal.
      /*
      if (appState.match(/inactive|background/) && nextAppState === "active") {
        // App has come to the foreground, DON'T trigger reload anymore
        console.log("App came to foreground - Reload Trigger REMOVED");
        // triggerReload(); // <<< REMOVED THIS LINE
      }
      */
      // --- END REMOVED BLOCK ---

      setAppState(nextAppState); // Still track app state if needed elsewhere
    };

    const subscription = AppState.addEventListener(
      "change",
      handleAppStateChange
    );

    return () => {
      subscription.remove();
    };
  }, [appState]); // Keep appState dependency if you still use setAppState

  const updateTheme = (newThemeMode: "light" | "dark" | "system") => {
    const isDark =
      newThemeMode === "system"
        ? colorScheme === "dark"
        : newThemeMode === "dark";
    return isDark ? darkTheme : lightTheme;
  };

  const handleThemeChange = async (newTheme: "light" | "dark" | "system") => {
    setThemeMode(newTheme);
    if (loadedSettings) {
      const updatedSettings: Settings = {
        ...loadedSettings,
        theme: newTheme,
      };
      await saveSettings(updatedSettings);
      setLoadedSettings(updatedSettings);
    }
    setThemeCheck((t) => t + 1);
  };

  const currentTheme = updateTheme(themeMode);

  const navigationTheme = {
    dark: {
      ...DarkTheme,
      colors: {
        ...DarkTheme.colors,
        primary: currentTheme.colors.primary,
        background: currentTheme.colors.background,
        card: currentTheme.colors.card,
        text: currentTheme.colors.text,
        border: currentTheme.colors.divider,
        notification: currentTheme.colors.successLight,
      },
    },
    light: {
      ...DefaultTheme,
      colors: {
        ...DefaultTheme.colors,
        primary: currentTheme.colors.primary,
        background: currentTheme.colors.background,
        card: currentTheme.colors.card,
        text: currentTheme.colors.text,
        border: currentTheme.colors.divider,
        notification: currentTheme.colors.success,
      },
    },
  };

  // Determine status bar style based on theme
  const statusBarTheme = themeMode === "system" ? colorScheme : themeMode;

  const backgroundColor = currentTheme.colors.background;

  return (
    // --- REMOVED: key={themeMode} - Re-evalute if needed, usually not necessary for theme changes handled internally ---
    // <ThemeProvider theme={createTheme(currentTheme)} key={themeMode}>
    <ThemeProvider theme={createTheme(currentTheme)}>
      {/* Added to try force to behave like a normal text */}
      <SafeAreaView style={{ flex: 1, backgroundColor: backgroundColor }}>
        {/* Enclose everything in SafeAreaView */}
        <StatusBar
          style={statusBarTheme === "dark" ? "light" : "dark"} // Text color
          backgroundColor={backgroundColor} // Background color from theme
          translucent={false} // Disable translucency for now (easier debugging)
        />
        <NavigationContainer
          theme={
            currentTheme.mode === "dark"
              ? navigationTheme.dark
              : navigationTheme.light
          }
        >
          {/* --- REMOVED: key={reloadKey} - Navigator no longer forced to remount --- */}
          {/* <AppNavigator onThemeChange={handleThemeChange} key={reloadKey} /> */}
          <AppNavigator onThemeChange={handleThemeChange} />
        </NavigationContainer>
        <Toast />
      </SafeAreaView>
    </ThemeProvider>
  );
};

export default App;
---------- END App.tsx ----------


---------- adaptive-icon.png ----------
(Image file - content not included)
---------- END adaptive-icon.png ----------


---------- favicon.png ----------
(Image file - content not included)
---------- END favicon.png ----------


---------- icon.png ----------
(Image file - content not included)
---------- END icon.png ----------


---------- splash.png ----------
(Image file - content not included)
---------- END splash.png ----------


---------- AddEntryModal.tsx ----------
// AddEntryModal.tsx
import React, { useEffect, useState, useMemo } from "react";
import {
    View,
    FlatList,
    KeyboardAvoidingView,
    Platform,
    TouchableOpacity,
    ScrollView,
    Dimensions,
    Image,
    StyleSheet,
    ActivityIndicator,
    Alert,
} from "react-native";
import {
    Button,
    Input,
    Text,
    ListItem,
    Overlay,
    SearchBar,
    makeStyles,
    useTheme,
    Icon,
    ButtonGroup,
} from "@rneui/themed";
import { Food } from "../types/food";
import { isValidNumberInput } from "../utils/validationUtils";
import { loadRecentFoods, saveRecentFoods } from "../services/storageService";
import { getFoodIconUrl } from "../utils/iconUtils";
import { getGramsFromNaturalLanguage } from "../utils/units";
import Toast from "react-native-toast-message";

interface AddEntryModalProps {
    isVisible: boolean;
    toggleOverlay: () => void;
    selectedFood: Food | null;
    grams: string;
    setGrams: (grams: string) => void;
    handleAddEntry: () => void;
    foods: Food[];
    handleSelectFood: (item: Food | null) => void;
    updateSearch: (search: string) => void;
    search: string;
    isEditMode: boolean;
    initialGrams?: string;
}

const KEYBOARD_VERTICAL_OFFSET = Platform.OS === 'ios' ? 80 : 0;

type UnitMode = 'grams' | 'auto';

const AddEntryModal: React.FC<AddEntryModalProps> = ({
    isVisible,
    toggleOverlay,
    selectedFood,
    grams,
    setGrams,
    handleAddEntry,
    foods,
    handleSelectFood,
    updateSearch,
    search,
    isEditMode,
    initialGrams
}) => {
    const { theme } = useTheme();
    const styles = useStyles();
    const [recentFoods, setRecentFoods] = useState<Food[]>([]);
    const MAX_RECENT_FOODS = 5;
    const [foodIcons, setFoodIcons] = useState<{ [foodName: string]: string | null }>({});

    const [unitMode, setUnitMode] = useState<UnitMode>('grams');
    const [autoInput, setAutoInput] = useState("");
    const [isAiLoading, setIsAiLoading] = useState(false);

    const screenWidth = Dimensions.get('window').width;

    // Filtered foods based on search
    const filteredFoods = useMemo(() => {
        if (!search) return []; // Don't filter if search is empty
        return foods.filter((food) =>
            food.name.toLowerCase().includes(search.toLowerCase())
        );
    }, [foods, search]);

    // Effect to handle state resets based on visibility, edit mode, and selected food changes
    useEffect(() => {
        // --- Logging for Debugging ---
        // console.log(`>>> useEffect triggered - isVisible: ${isVisible}, isEditMode: ${isEditMode}, selectedFood: ${selectedFood?.id}, initialGrams: ${initialGrams}`);

        if (!isVisible) {
            // Reset everything when modal closes
            // console.log(">>> useEffect: Resetting state on close");
            handleSelectFood(null);
            setGrams("");
            updateSearch("");
            setUnitMode('grams');
            setAutoInput("");
            setIsAiLoading(false); // Ensure loading state is reset on close
        } else {
            // Modal is visible or just became visible
            // console.log(">>> useEffect: Modal is visible");

            // Always reset AI-related fields when modal becomes visible or food changes
            // Avoid resetting things that might have just been set by AI estimation
             if (!isAiLoading) { // Only reset these if AI isn't currently running
                 setAutoInput("");
                 // setIsAiLoading(false); // Don't reset loading here, handleEstimateGrams does it
             }


            // Determine the correct initial grams value and unit mode based on mode/food
            let targetGrams = grams; // Start with current grams
            let targetUnitMode = unitMode; // Start with current unit mode

            if (isEditMode && selectedFood && initialGrams) {
                // If editing the *same* item for which we have initial grams, restore it.
                // console.log(">>> useEffect: Setting state for EDIT mode with initialGrams");
                targetGrams = initialGrams;
                targetUnitMode = 'grams'; // Default to grams view when editing existing value
            } else if (!isEditMode && selectedFood) {
                // If adding a new entry and a food *is* selected (e.g., user just picked one)
                // Check if grams should be cleared or kept. Let's KEEP grams unless the food *changes*.
                // The handleSelectFood prop should handle clearing grams if desired when food changes.
                // console.log(">>> useEffect: Setting state for ADD mode with selected food");
                targetUnitMode = 'grams'; // Switch to grams mode when a food is selected
                // targetGrams = ""; // Option: Uncomment to clear grams whenever food changes in ADD mode
            } else if (!selectedFood) {
                // If no food is selected (either initially or cleared)
                // console.log(">>> useEffect: No food selected, clearing grams");
                targetGrams = ""; // Clear grams if no food is selected
                targetUnitMode = 'grams'; // Default mode
            }
            // Apply the determined state changes *only if they are different* to avoid loops
            if (grams !== targetGrams) {
                // console.log(`>>> useEffect: Setting grams from "${grams}" to "${targetGrams}"`);
                setGrams(targetGrams);
            }
            if (unitMode !== targetUnitMode && !isAiLoading) { // Don't override unit mode if AI is loading/just finished
                 // console.log(`>>> useEffect: Setting unitMode from "${unitMode}" to "${targetUnitMode}"`);
                 setUnitMode(targetUnitMode);
            }
             // Reset search only when modal *initially* becomes visible? Handled outside potentially.
             // updateSearch("");
        }

    // Dependencies: Trigger when visibility, edit mode, selected food, or initial grams change.
    // handleSelectFood and updateSearch are stable functions.
    // setGrams and setUnitMode are *not* included to prevent re-triggering the effect from its own actions.
    }, [isVisible, isEditMode, selectedFood, initialGrams, handleSelectFood, updateSearch]);


    // Load recent foods when modal becomes visible
    useEffect(() => {
        const loadRecents = async () => {
            const loadedRecentFoods = await loadRecentFoods();
            setRecentFoods(loadedRecentFoods);
        };
        if (isVisible) {
            loadRecents();
        }
    }, [isVisible]);

    // Load icons for visible foods (recent or filtered)
    useEffect(() => {
        const loadIcons = async () => {
            const iconsToLoad: { [foodName: string]: string | null } = {};
            const relevantFoods = search ? filteredFoods : recentFoods;
            const uniqueFoods = Array.from(new Map(relevantFoods.map(food => [food.id, food])).values());

            let shouldUpdateState = false;
            for (const food of uniqueFoods) {
                if (!(food.name in foodIcons)) {
                    try {
                        const iconUrl = await getFoodIconUrl(food.name);
                        iconsToLoad[food.name] = iconUrl;
                        shouldUpdateState = true;
                    } catch (error) {
                         console.warn(`Failed to load icon for ${food.name}:`, error);
                         iconsToLoad[food.name] = null;
                         shouldUpdateState = true;
                    }
                }
            }

            if (shouldUpdateState) {
                 setFoodIcons(prevIcons => ({ ...prevIcons, ...iconsToLoad }));
            }
        };

        if (isVisible && (foods.length > 0 || recentFoods.length > 0)) {
           loadIcons();
        }
    }, [isVisible, search, filteredFoods, recentFoods, foods]); // Keep foodIcons dependency out to avoid loop


    const addToRecentFoods = async (food: Food) => {
        if (recentFoods.length > 0 && recentFoods[0].id === food.id) return;

        const updatedRecentFoods = recentFoods.filter(recentFood => recentFood.id !== food.id);
        updatedRecentFoods.unshift(food);
        const trimmedRecentFoods = updatedRecentFoods.slice(0, MAX_RECENT_FOODS);
        setRecentFoods(trimmedRecentFoods);
        await saveRecentFoods(trimmedRecentFoods);
    };

    // Serving size suggestions based on selected food
    const servingSizeSuggestions = useMemo(() => {
        if (!selectedFood) return [];
        return [
            { label: "50g", value: "50" },
            { label: "100g", value: "100" },
            { label: "150g", value: "150" },
            { label: "200g", value: "200" },
        ];
    }, [selectedFood]);

    // Handler for AI gram estimation
    const handleEstimateGrams = async () => {
        if (!selectedFood || !autoInput.trim()) {
            Alert.alert("Input Missing", "Please select a food and enter a quantity description (e.g., '1 cup', '2 medium').");
            return;
        }

        setIsAiLoading(true);
        // console.log(`handleEstimateGrams - START - autoInput: "${autoInput}", food: ${selectedFood?.name}`);
        try {
            const estimatedGrams = await getGramsFromNaturalLanguage(selectedFood.name, autoInput);
            const roundedGrams = String(Math.round(estimatedGrams));

            // console.log(`handleEstimateGrams - SUCCESS - Estimated: ${estimatedGrams}, Rounded: "${roundedGrams}"`);
            // console.log(`handleEstimateGrams - BEFORE setGrams - current grams state: "${grams}"`);
            setGrams(roundedGrams); // Update the grams state
            // console.log(`handleEstimateGrams - AFTER setGrams (will re-render) - setting grams to: "${roundedGrams}"`);
            // console.log(`handleEstimateGrams - BEFORE setUnitMode - current unitMode state: "${unitMode}"`);
            setUnitMode('grams'); // Switch view back to grams input
            // console.log(`handleEstimateGrams - AFTER setUnitMode (will re-render) - setting unitMode to: "grams"`);

            Toast.show({
                type: 'success',
                text1: 'Grams Estimated',
                text2: `Estimated ${roundedGrams}g for ${selectedFood.name}`,
                position: 'bottom',
                visibilityTime: 3000,
            });
            // Keep autoInput for reference, or clear it:
            // setAutoInput("");
        } catch (error: any) {
            console.error("AI Estimation Error:", error);
            Alert.alert("AI Estimation Failed", error.message || "Could not estimate grams. Please enter manually.");
             // Keep unitMode as 'auto' on failure so user can retry or see input
        } finally {
            // console.log("handleEstimateGrams - FINALLY - setting isAiLoading to false");
            setIsAiLoading(false); // Ensure loading state is turned off
        }
    };

    // Handler for adding or updating the entry
    const handleAddOrUpdateEntry = async () => {
        if (!selectedFood) {
             Alert.alert("Food Not Selected", "Please select a food item.");
             return;
        }
        const numericGrams = parseFloat(grams);
        if (!isValidNumberInput(grams) || numericGrams <= 0) {
             Alert.alert(
                "Invalid Amount",
                "Please enter a valid positive number for grams."
            );
            return;
        }

        // Prevent adding if AI is still loading (belt and suspenders)
        if (isAiLoading) return;

        handleAddEntry(); // Call the prop function
        await addToRecentFoods(selectedFood); // Add to recents
        // toggleOverlay(); // Consider if closing should happen here or in parent
    };

    // Prepare styles and theme
    const combinedOverlayStyle = StyleSheet.flatten([
        styles.overlayStyle,
        { backgroundColor: theme.colors.background }
    ]);

    // Disable Add/Update button logic
    const isAddButtonDisabled = !selectedFood || !isValidNumberInput(grams) || parseFloat(grams) <= 0 || isAiLoading;
    // Disable AI Estimate button logic
    const isAiButtonDisabled = !selectedFood || !autoInput.trim() || isAiLoading;

    // Handler for selecting a food item
    const handleInternalSelectFood = (item: Food | null) => {
        // If the same food is selected again, do nothing
        if (selectedFood?.id === item?.id) return;

        handleSelectFood(item); // Call the prop function to update parent state

        // When a food is selected/changed (and not in edit mode with initial grams):
        if (item && (!isEditMode || !initialGrams)) {
            // Option 1: Clear grams whenever a new food is selected
            // setGrams("");

            // Option 2: Keep existing grams (current behavior implicitly)

            // Always switch to grams mode when selecting a food
            setUnitMode('grams');
            setAutoInput(""); // Clear any previous auto input
        } else if (!item) {
             // If food is deselected (set to null)
             setGrams(""); // Clear grams
             setUnitMode('grams');
             setAutoInput("");
        }
        // If isEditMode and initialGrams exist, the main useEffect will handle setting grams.
    };

    // --- Render ---
    // console.log(`Rendering AddEntryModal - grams: "${grams}", unitMode: "${unitMode}", selectedFood: ${selectedFood?.name || 'null'}`);

    return (
        <Overlay
            isVisible={isVisible}
            onBackdropPress={!isAiLoading ? toggleOverlay : undefined} // Prevent closing while AI loading
            animationType="slide"
            overlayStyle={styles.overlayContainer}
        >
            <KeyboardAvoidingView
                behavior={Platform.OS === "ios" ? "padding" : "height"}
                style={styles.keyboardAvoidingView}
                keyboardVerticalOffset={KEYBOARD_VERTICAL_OFFSET}
            >
                <View style={combinedOverlayStyle}>
                    {/* Header */}
                    <View style={styles.header}>
                         <TouchableOpacity onPress={!isAiLoading ? toggleOverlay : undefined} style={styles.closeIconTouchable} disabled={isAiLoading}>
                            <Icon
                                name="close"
                                type="material"
                                size={28}
                                color={isAiLoading ? theme.colors.grey3 : theme.colors.text}
                            />
                        </TouchableOpacity>
                        <Text h4 h4Style={[styles.overlayTitle, isEditMode && styles.editModeTitle]}>
                            {isEditMode ? "Edit Entry" : "Add Entry"}
                        </Text>
                        <Button
                            title={isEditMode ? "Update" : "Add"}
                            onPress={handleAddOrUpdateEntry}
                            disabled={isAddButtonDisabled}
                            buttonStyle={[styles.addButton, isEditMode && styles.updateButton]}
                            titleStyle={styles.buttonTitle}
                            // Loading indicator could be shown here too if needed during add/update action
                            // loading={someOtherLoadingState}
                        />
                    </View>

                    {/* Search Bar */}
                    <SearchBar
                        placeholder="Search Foods..."
                        onChangeText={updateSearch}
                        value={search}
                        platform={Platform.OS === "ios" ? "ios" : "android"}
                        containerStyle={styles.searchBarContainer}
                        inputContainerStyle={styles.searchBarInputContainer}
                        inputStyle={styles.searchInputStyle}
                        onCancel={() => updateSearch('')}
                        disabled={isAiLoading} // Disable search while AI loading?
                    />

                    {/* Recent Foods (Only show if NOT searching) */}
                    {!search && recentFoods.length > 0 && (
                        <View style={styles.recentFoodsSection}>
                            <Text style={styles.sectionTitle}>Recent</Text>
                            <FlatList
                                data={recentFoods}
                                keyExtractor={(item) => `recent-${item.id}`}
                                horizontal
                                showsHorizontalScrollIndicator={false}
                                contentContainerStyle={styles.recentFoodsContainer}
                                renderItem={({ item }) => (
                                    <TouchableOpacity
                                        style={[
                                            styles.recentFoodItem,
                                            screenWidth < 350 && styles.smallRecentFoodItem,
                                            selectedFood?.id === item.id && styles.selectedRecentFoodItem,
                                        ]}
                                        onPress={() => handleInternalSelectFood(item)} // Use internal handler
                                        disabled={isAiLoading}
                                    >
                                        {foodIcons[item.name] ? (
                                            <Image
                                                source={{ uri: foodIcons[item.name] as string }}
                                                style={styles.foodIconSmall}
                                                onError={() => setFoodIcons(prev => ({...prev, [item.name]: null}))}
                                            />
                                        ) : (
                                            <View style={[styles.foodIconSmall, styles.iconPlaceholderSmall]}>
                                                <Icon name="fastfood" type="material" size={12} color={theme.colors.grey2} />
                                            </View>
                                        )}
                                        <Text
                                            style={[styles.recentFoodText, screenWidth < 350 && styles.smallRecentFoodText]}
                                            numberOfLines={1}
                                            ellipsizeMode="tail"
                                        >
                                            {item.name}
                                        </Text>
                                    </TouchableOpacity>
                                )}
                            />
                        </View>
                    )}

                    {/* Food Search Results List (Only show IF searching) */}
                     {search && (
                        <FlatList
                            data={filteredFoods}
                            keyExtractor={(item) => `search-${item.id}`}
                            renderItem={({ item }) => (
                                <TouchableOpacity onPress={() => handleInternalSelectFood(item)} disabled={isAiLoading}>
                                    <ListItem
                                        bottomDivider
                                        containerStyle={[
                                            styles.listItemContainer,
                                            selectedFood?.id === item.id && styles.selectedListItem,
                                        ]}
                                    >
                                        {foodIcons[item.name] ? (
                                            <Image
                                                source={{ uri: foodIcons[item.name] as string }}
                                                style={styles.foodIcon}
                                                onError={() => setFoodIcons(prev => ({...prev, [item.name]: null}))}
                                            />
                                        ) : (
                                            <View style={styles.defaultIconContainer}>
                                                <Icon name="restaurant" type="material" size={18} color={theme.colors.grey3} />
                                            </View>
                                        )}
                                        <ListItem.Content>
                                            <ListItem.Title style={styles.listItemTitle}>{item.name}</ListItem.Title>
                                        </ListItem.Content>
                                         {selectedFood?.id === item.id && (
                                             <Icon name="checkmark-circle" type="ionicon" color={theme.colors.primary} size={24} />
                                         )}
                                    </ListItem>
                                </TouchableOpacity>
                            )}
                            style={styles.foodList}
                            ListEmptyComponent={
                                <Text style={styles.noFoodsText}>No foods found matching "{search}".</Text>
                            }
                            initialNumToRender={10}
                            maxToRenderPerBatch={10}
                            windowSize={5}
                            keyboardShouldPersistTaps="handled"
                        />
                     )}

                    {/* Amount Input Section (Only show if a food is selected) */}
                    {selectedFood && (
                        <View style={styles.amountSection}>
                             {/* Unit Mode Selector */}
                             <View style={styles.unitSelectorContainer}>
                                <Text style={styles.inputLabel}>Amount</Text>
                                <ButtonGroup
                                    buttons={['Grams', 'Auto (AI)']}
                                    selectedIndex={unitMode === 'grams' ? 0 : 1}
                                    onPress={(index) => {
                                        const newMode = index === 0 ? 'grams' : 'auto';
                                        if (unitMode !== newMode) { // Only update if mode changes
                                             setUnitMode(newMode);
                                             // Optional: Clear auto input when switching to it?
                                             // if (newMode === 'auto') setAutoInput("");
                                        }
                                    }}
                                    containerStyle={styles.buttonGroupContainer}
                                    selectedButtonStyle={{ backgroundColor: theme.colors.primary }}
                                    textStyle={styles.buttonGroupText}
                                    selectedTextStyle={{ color: theme.colors.white }}
                                    disabled={isAiLoading} // Disable switching modes while AI runs
                                />
                             </View>

                            {/* Conditional Input Field */}
                            {unitMode === 'grams' && (
                                <>
                                     {/* Serving Size Suggestions */}
                                     {servingSizeSuggestions.length > 0 && (
                                        <View style={styles.servingSizeRow}>
                                             <Text style={styles.servingSizeLabel}>Quick Add:</Text>
                                            <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={styles.servingSizeContainer}>
                                                {servingSizeSuggestions.map((suggestion) => (
                                                    <TouchableOpacity
                                                        key={suggestion.label}
                                                        style={styles.servingSizeButton}
                                                        onPress={() => {
                                                            // Only update if value is different
                                                            if (grams !== suggestion.value) {
                                                                setGrams(suggestion.value);
                                                            }
                                                        }}
                                                        disabled={isAiLoading}
                                                    >
                                                        <Text style={styles.servingSizeButtonTitle}>{suggestion.label}</Text>
                                                    </TouchableOpacity>
                                                ))}
                                            </ScrollView>
                                        </View>
                                     )}
                                    {/* Grams Input */}
                                    {/* {console.log(`Rendering GRAMS input - value prop: "${grams}"`)} */}
                                    <Input
                                        placeholder="Enter exact grams (e.g., 150)"
                                        keyboardType="numeric"
                                        value={grams} // Value is correctly bound to state
                                        onChangeText={(text) => {
                                            // Allow only numbers and one decimal point
                                            const cleanedText = text.replace(/[^0-9.]/g, "").replace(/(\..*)\./g, '$1');
                                            if (grams !== cleanedText) { // Prevent unnecessary state updates
                                                setGrams(cleanedText);
                                            }
                                        }}
                                        inputStyle={styles.gramInputStyle}
                                        inputContainerStyle={styles.gramInputContainerStyle}
                                        errorMessage={!isValidNumberInput(grams) && grams !== "" && grams !== "." ? "Enter a valid number" : ""}
                                        errorStyle={{ color: theme.colors.error }}
                                        rightIcon={<Text style={styles.unitText}> g</Text>}
                                        disabled={isAiLoading} // Disable input while AI processing
                                        containerStyle={{ paddingHorizontal: 0 }}
                                        // Add key to potentially help ensure re-render reflects state
                                        key={`grams-input-${selectedFood.id}`}
                                    />
                                </>
                            )}

                            {unitMode === 'auto' && (
                                <View style={styles.autoInputRow}>
                                    {/* {console.log(`Rendering AUTO input - autoInput: "${autoInput}"`)} */}
                                    <Input
                                        placeholder="Describe quantity (e.g., 1 cup cooked)"
                                        value={autoInput}
                                        onChangeText={setAutoInput}
                                        inputStyle={[styles.gramInputStyle, styles.autoInputField]}
                                        inputContainerStyle={styles.gramInputContainerStyle}
                                        containerStyle={styles.autoInputContainer}
                                        multiline={false}
                                        disabled={isAiLoading} // Disable while AI processing
                                        onSubmitEditing={handleEstimateGrams} // Trigger estimation on submit
                                        key={`auto-input-${selectedFood.id}`}
                                    />
                                    <Button
                                        onPress={handleEstimateGrams}
                                        disabled={isAiButtonDisabled}
                                        loading={isAiLoading} // Show loading indicator on the button itself
                                        buttonStyle={styles.aiButton}
                                        // title="" // Icon only
                                        icon={
                                            isAiLoading ? (
                                                <ActivityIndicator size="small" color={theme.colors.white} />
                                            ) : (
                                                <Icon name="calculator-variant" type="material-community" size={20} color={theme.colors.white} />
                                            )
                                        }
                                    />
                                </View>
                            )}
                        </View>
                    )}
                     {/* Spacer at the bottom */}
                     <View style={{ height: 20 }} />
                </View>
            </KeyboardAvoidingView>
             {/* Toast Component */}
             <Toast />
        </Overlay>
    );
};

// --- Styles ---
const useStyles = makeStyles((theme) => ({
    // Paste the full useStyles object here from your original code
    // ... (Styles remain the same as provided in the previous example) ...
    overlayContainer: {
        backgroundColor: 'transparent',
        width: '90%',
        maxWidth: 500,
        padding: 0,
        borderRadius: 15,
        shadowColor: "#000",
        shadowOffset: { width: 0, height: 3 },
        shadowOpacity: 0.2,
        shadowRadius: 5,
        elevation: 6,
        overflow: 'visible',
    },
    overlayStyle: {
        width: '100%',
        borderRadius: 15,
        padding: 15,
        paddingBottom: 0,
        maxHeight: Dimensions.get('window').height * 0.85,
        // backgroundColor applied via combinedOverlayStyle using theme.colors.background
    },
    keyboardAvoidingView: {
         width: "100%",
    },
    header: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: 15,
        paddingHorizontal: 5,
    },
     closeIconTouchable: {
        padding: 5,
        zIndex: 1, // Ensure it's clickable over title if overlap occurs
    },
    overlayTitle: {
        color: theme.colors.text,
        fontWeight: 'bold',
        fontSize: 20,
        textAlign: 'center',
        flex: 1,
        marginHorizontal: 5, // Reduced margin to give more space
    },
    editModeTitle: {
        color: theme.colors.warning,
    },
    addButton: {
        borderRadius: 20,
        paddingHorizontal: 15,
        paddingVertical: 8,
        minWidth: 70,
        backgroundColor: theme.colors.primary,
        zIndex: 1, // Ensure clickable
    },
     updateButton: {
        backgroundColor: theme.colors.warning,
    },
    buttonTitle: {
        color: theme.colors.white,
        fontWeight: '600',
        fontSize: 15,
    },
    searchBarContainer: {
        backgroundColor: "transparent",
        borderBottomColor: "transparent",
        borderTopColor: "transparent",
        paddingHorizontal: 0,
        marginBottom: 10,
    },
    searchBarInputContainer: {
        borderRadius: 25,
        backgroundColor: theme.colors.searchBg || theme.colors.grey5, // Use theme color with fallback
        height: 40,
    },
    searchInputStyle: {
        color: theme.colors.text,
        fontSize: 15,
        // Adjust if using custom fonts
    },
    // --- Recent Foods ---
     recentFoodsSection: {
        marginBottom: 15,
    },
    sectionTitle: {
        fontWeight: '600',
        marginBottom: 8,
        color: theme.colors.grey1,
        fontSize: 14,
        marginLeft: 5,
        textTransform: 'uppercase',
    },
     recentFoodsContainer: {
        paddingHorizontal: 5,
        paddingVertical: 2, // Small vertical padding for the container
    },
    recentFoodItem: {
        paddingHorizontal: 10,
        paddingVertical: 6,
        borderRadius: 16,
        backgroundColor: theme.colors.grey5,
        marginRight: 8,
        flexDirection: 'row',
        alignItems: 'center',
        borderWidth: 1.5, // Use slightly thicker border for selection
        borderColor: 'transparent',
    },
    selectedRecentFoodItem: {
        // backgroundColor: theme.colors.grey4, // Optional: darker background on select
        borderColor: theme.colors.primary,
    },
    smallRecentFoodItem: {
        paddingHorizontal: 8,
        paddingVertical: 5,
    },
    foodIconSmall: {
        width: 20,
        height: 20,
        marginRight: 6,
        borderRadius: 10,
        resizeMode: "contain",
    },
     iconPlaceholderSmall: {
        backgroundColor: theme.colors.grey4,
        alignItems: 'center',
        justifyContent: 'center',
    },
    recentFoodText: {
        color: theme.colors.text,
        fontSize: 13,
        maxWidth: 80,
    },
    smallRecentFoodText: {
        fontSize: 12,
        maxWidth: 70,
    },
    // --- Food List (Search Results) ---
    foodList: {
        maxHeight: Dimensions.get('window').height * 0.3, // Max height relative to screen
        minHeight: 60, // Ensure it has some minimum height even if few results
        flexGrow: 0,
        marginBottom: 15,
    },
    listItemContainer: {
        backgroundColor: 'transparent',
        paddingVertical: 8,
        paddingHorizontal: 5,
        borderBottomColor: theme.colors.divider,
    },
    selectedListItem: {
        backgroundColor: theme.colors.grey5,
        borderRadius: 8,
    },
     defaultIconContainer: {
        width: 35,
        height: 35,
        marginRight: 12,
        borderRadius: 17.5,
        backgroundColor: theme.colors.grey5,
        alignItems: 'center',
        justifyContent: 'center',
    },
    foodIcon: {
        width: 35,
        height: 35,
        marginRight: 12,
        borderRadius: 17.5,
        resizeMode: "contain",
        // Optional: add a background color if images have transparency
        // backgroundColor: theme.colors.grey5,
    },
    listItemTitle: {
        color: theme.colors.text,
        fontSize: 16,
        fontWeight: '500',
    },
    noFoodsText: {
        color: theme.colors.grey2,
        fontStyle: 'italic',
        textAlign: 'center',
        marginTop: 20,
        marginBottom: 10,
        paddingHorizontal: 10,
    },
    // --- Amount Section ---
    amountSection: {
        marginTop: 10,
        borderTopWidth: 1,
        borderTopColor: theme.colors.divider,
        paddingTop: 15,
    },
    unitSelectorContainer: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
        marginBottom: 15,
        paddingHorizontal: 5,
    },
    inputLabel: {
        fontWeight: '600',
        color: theme.colors.grey1,
        fontSize: 14,
        marginRight: 10,
        textTransform: 'uppercase',
    },
    buttonGroupContainer: {
        flex: 0.7,
        maxWidth: 220,
        height: 35,
        borderRadius: 8,
        backgroundColor: theme.colors.background // Ensure ButtonGroup background matches modal
    },
     buttonGroupText: {
        fontSize: 14,
        color: theme.colors.text,
    },
     servingSizeRow: {
        flexDirection: 'row',
        alignItems: 'center',
        marginBottom: 12, // Increased margin below suggestions
        paddingHorizontal: 5,
    },
    servingSizeLabel: {
        color: theme.colors.grey2,
        fontSize: 13,
        marginRight: 8,
    },
    servingSizeContainer: {
        flexGrow: 0, // Prevent ScrollView from taking full width
    },
    servingSizeButton: {
      backgroundColor: theme.colors.grey4,
      borderRadius: 15,
      marginRight: 8,
      paddingHorizontal: 12,
      paddingVertical: 5,
      justifyContent: 'center',
      alignItems: 'center',
      height: 30, // Give buttons a consistent height
    },
    servingSizeButtonTitle: {
        color: theme.colors.text,
        fontSize: 13,
    },
    gramInputStyle: {
        color: theme.colors.text,
        fontSize: 16,
        paddingVertical: 8, // Adjust vertical padding if needed
        height: 40, // Ensure consistent height with other inputs/buttons
    },
    gramInputContainerStyle: {
        borderBottomColor: theme.colors.grey3,
        paddingHorizontal: 5, // Consistent padding
    },
    unitText: {
        color: theme.colors.grey2,
        fontSize: 15,
        fontWeight: '500',
        paddingRight: 5, // Add padding so 'g' isn't touching edge
    },
     autoInputRow: {
        flexDirection: 'row',
        alignItems: 'center', // Vertically align input and button
    },
    autoInputContainer: {
       flex: 1, // Take available space
       paddingHorizontal: 0, // Remove default container padding
       marginRight: 10, // Space between input and button
    },
    autoInputField: {
       // Specific styles if needed, matches gramInputStyle height
       height: 40,
    },
    aiButton: {
        // marginLeft: 10, // Removed, using marginRight on autoInputContainer
        backgroundColor: theme.colors.secondary,
        borderRadius: 20, // Make it round
        width: 40, // Fixed width
        height: 40, // Fixed height for circle
        padding: 0, // Remove padding for icon centering
        justifyContent: 'center',
        alignItems: 'center',
    },
    aiButtonText: {
        // Not needed for icon-only button
    }
}));

export default AddEntryModal;
---------- END AddEntryModal.tsx ----------


---------- AddFoodModal.tsx ----------
// components/AddFoodModal.tsx
import React, { useState, useEffect } from "react";
import {
  View,
  KeyboardAvoidingView,
  Platform,
  ActivityIndicator,
  Alert,
  ScrollView,
  StyleSheet, // Import StyleSheet
  TouchableOpacity, // Import TouchableOpacity for icon button
} from "react-native";
import {
  Button,
  Input,
  Text,
  Overlay,
  makeStyles,
  useTheme,
  Icon,
} from "@rneui/themed";
import { Food } from "../types/food";
import { MaterialCommunityIcons } from "@expo/vector-icons";
import Toast from "react-native-toast-message";
// Import the necessary functions
import { getMacrosForRecipe, getMacrosForImageFile } from "../utils/macros";
import * as ImagePicker from "expo-image-picker";
// Import the type explicitly if needed for clarity, although often inferred
import { ImagePickerAsset, ImagePickerResult } from 'expo-image-picker';
import { isValidNumberInput, isNotEmpty } from "../utils/validationUtils"; // Added validation imports

interface AddFoodModalProps {
  isVisible: boolean;
  toggleOverlay: () => void;
  newFood: Omit<Food, "id">;
  editFood: Food | null;
  errors: { [key: string]: string };
  handleInputChange: (
    key: keyof Omit<Food, "id">,
    value: string,
    isEdit: boolean
  ) => void;
  handleCreateFood: () => void;
  handleUpdateFood: () => void;
  validateFood: (food: Omit<Food, "id">) => { [key: string]: string } | null;
  setErrors: React.Dispatch<React.SetStateAction<{ [key: string]: string }>>;
}

// Define a keyboard offset (adjust value based on testing, e.g., header height)
const KEYBOARD_VERTICAL_OFFSET = Platform.OS === "ios" ? 60 : 0;

const AddFoodModal: React.FC<AddFoodModalProps> = ({
  isVisible,
  toggleOverlay,
  newFood,
  editFood,
  errors,
  handleInputChange,
  handleCreateFood,
  handleUpdateFood,
  validateFood,
  setErrors,
}) => {
  const { theme } = useTheme();
  const styles = useStyles();
  const [loading, setLoading] = useState(false); // For save/update
  const [apiLoading, setApiLoading] = useState(false); // Keep or remove based on need for global overlay
  const [mode, setMode] = useState<"normal" | "ingredients">("normal");
  const [ingredients, setIngredients] = useState("");
  const [aiButtonLoading, setAiButtonLoading] = useState(false); // For ingredient AI
  const [imageLoading, setImageLoading] = useState(false); // For image analysis (camera/gallery)

  useEffect(() => {
    if (isVisible) {
      setErrors({});
      setMode("normal");
      setIngredients("");
      // Reset loading states when modal opens
      setAiButtonLoading(false);
      setImageLoading(false);
      setLoading(false);
    }
  }, [isVisible, setErrors]);

  const getValue = (key: keyof Omit<Food, "id">) => {
    // Ensure numeric fields default to empty string for input if 0
    const value = (editFood && editFood[key]) ?? newFood[key] ?? "";
    // Keep 0 as "0" if it's the initial state for a new food
    if (!editFood && typeof value === 'number' && value === 0 && key !== 'name') {
        return ""; // Show empty input for new food numeric fields initially
    }
    if (editFood && typeof value === 'number' && value === 0 && key !== 'name') {
        return "0"; // Show "0" if editing and value is actually 0
    }
    return String(value); // Always return string for Input component
  };


  const handleCreateOrUpdate = async (isUpdate: boolean) => {
    setLoading(true);
    const foodData = isUpdate ? editFood : newFood;
    if (!foodData) {
        setLoading(false);
        return; // Should not happen in practice
    }

     // Ensure numeric fields are numbers before validation/saving
     // Use parseFloat which handles empty strings as NaN, then default to 0
     const dataToValidate: Omit<Food, "id"> = {
        ...foodData,
        name: String(foodData.name).trim(), // Trim name
        // Use getValue to ensure consistency with displayed value before parsing
        calories: parseFloat(getValue("calories")) || 0,
        protein: parseFloat(getValue("protein")) || 0,
        carbs: parseFloat(getValue("carbs")) || 0,
        fat: parseFloat(getValue("fat")) || 0,
    };


    const validationErrors = validateFood(dataToValidate);

    if (validationErrors) {
      setErrors(validationErrors);
      setLoading(false);
      Toast.show({
        type: "error",
        text1: "Please fix the errors",
        position: 'bottom',
      });
      return;
    }
    // Clear errors if validation passes
    setErrors({});

    try {
      // Assumes handleUpdateFood/handleCreateFood use the respective state (editFood/newFood)
      // which was updated via handleInputChange. They need to handle parsing strings back to numbers if needed.
      if (isUpdate) {
          await handleUpdateFood();
      } else {
          await handleCreateFood();
      }

      Toast.show({
        type: "success",
        text1: `Food ${isUpdate ? "Updated" : "Created"} Successfully!`,
        position: 'bottom',
      });
      toggleOverlay();
    } catch (error: any) {
      Alert.alert(
        "Error",
        error.message || `Failed to ${isUpdate ? "update" : "create"} food.`
      );
    } finally {
      setLoading(false);
    }
  };

  const handleAiButtonClick = async () => {
    const foodName = getValue("name");
     // Require name only when switching to ingredients mode or submitting from it
    if (!foodName && mode === 'ingredients') {
      Alert.alert("Missing Name", "Please enter a food name first.");
      return;
    }

    if (mode === "normal") {
      setMode("ingredients");
      // Clear macro fields when switching to ingredients mode
      handleInputChange("calories", "", !!editFood);
      handleInputChange("protein", "", !!editFood);
      handleInputChange("carbs", "", !!editFood);
      handleInputChange("fat", "", !!editFood);
    } else if (mode === "ingredients") {
       // Ensure name exists before proceeding (should be caught above, but good failsafe)
      const currentFoodName = getValue("name");
      if (!currentFoodName) {
        Alert.alert("Missing Name", "Please enter a food name before calculating macros.");
        return;
      }

      setAiButtonLoading(true);
      try {
        const macros = await getMacrosForRecipe(currentFoodName, ingredients);

        // Update fields with AI results (rounded)
        handleInputChange("calories", String(Math.round(macros.calories)), !!editFood);
        handleInputChange("protein", String(Math.round(macros.protein)), !!editFood);
        handleInputChange("carbs", String(Math.round(macros.carbs)), !!editFood);
        handleInputChange("fat", String(Math.round(macros.fat)), !!editFood);

        setMode("normal"); // Switch back to normal mode to show results
         Toast.show({ type: 'info', text1: 'Macros estimated from ingredients.', position: 'bottom' });
      } catch (error) {
        console.error("AI Macro fetch error (recipe):", error);
        Alert.alert(
          "AI Error",
           `Could not calculate macros from text. ${error instanceof Error ? error.message : "Please try again or input manually."}`
        );
      } finally {
        setAiButtonLoading(false);
      }
    }
  };

  // --- Function to handle image acquisition (Camera or Gallery) and analysis ---
  const handleGetImageAndAnalyze = async () => {

    const processImage = async (pickerResult: ImagePickerResult) => {
        if (pickerResult.canceled) {
            console.log("Image selection/capture cancelled");
            return; // Exit if cancelled
        }

        if (pickerResult.assets && pickerResult.assets.length > 0) {
            const asset = pickerResult.assets[0]; // asset is of type ImagePickerAsset
            console.log("Image acquired:", asset.uri);
            setImageLoading(true); // Start loading indicator *before* analysis

            const fileInfoForApi = {
                uri: asset.uri,
                fileName: asset.fileName ?? `photo_${Date.now()}.jpg`, // Provide a default filename if null
                type: asset.mimeType ?? 'image/jpeg' // Provide a default mimetype if null
            };

            try {
                const result = await getMacrosForImageFile(fileInfoForApi);

                // Update form fields with results
                handleInputChange("name", result.foodName, !!editFood); // Update name too
                handleInputChange("calories", String(Math.round(result.calories)), !!editFood);
                handleInputChange("protein", String(Math.round(result.protein)), !!editFood);
                handleInputChange("carbs", String(Math.round(result.carbs)), !!editFood);
                handleInputChange("fat", String(Math.round(result.fat)), !!editFood);

                // Switch back to normal mode if in ingredients mode
                setMode("normal");
                setIngredients(""); // Clear ingredients if image analysis was successful

                Toast.show({
                    type: 'success',
                    text1: 'Food Identified!',
                    text2: `Identified as ${result.foodName}. Macros estimated.`,
                    position: 'bottom',
                });

            } catch (analysisError) {
                console.error("Error during image analysis:", analysisError);
                Alert.alert(
                    "Analysis Failed",
                    `Could not get macros from the image. ${analysisError instanceof Error ? analysisError.message : "Please try again or enter manually."}`
                );
            } finally {
                 // Stop loading indicator regardless of success/failure
                 // Delay slightly to allow UI update before loading stops visually
                 setTimeout(() => setImageLoading(false), 100);
            }
        } else {
            console.log("No assets selected or returned.");
            // Optional: show a message if no asset was returned unexpectedly
        }
    }; // end processImage

    // --- Present choice to user ---
    Alert.alert(
      "Get Image",
      "Choose a source for the food image:",
      [
        {
          text: "Cancel",
          style: "cancel",
        },
        {
          text: "Camera",
          onPress: async () => {
            setImageLoading(true); // Indicate loading for permission/camera launch
            try {
                // Request Camera Permissions
                const permissionResult = await ImagePicker.requestCameraPermissionsAsync();
                if (permissionResult.granted === false) {
                    Alert.alert("Permission Required", "Camera access is needed to take a photo.");
                    setImageLoading(false);
                    return;
                }
                // Launch Camera
                const cameraResult = await ImagePicker.launchCameraAsync({
                    quality: 0.6, // Keep quality reasonable
                    allowsEditing: false, // Optional: allow editing after capture
                });
                await processImage(cameraResult); // Process the result from camera
            } catch (error) {
                console.error("Error launching camera:", error);
                Alert.alert("Camera Error", "Could not open the camera.");
                setImageLoading(false); // Ensure loading is stopped on error
            }
            // Note: setImageLoading(false) is handled within processImage's finally block on success/analysis error
          },
        },
        {
          text: "Gallery",
          onPress: async () => {
            setImageLoading(true); // Indicate loading for permission/gallery launch
            try {
                // Request Media Library Permissions
                const permissionResult = await ImagePicker.requestMediaLibraryPermissionsAsync();
                if (permissionResult.granted === false) {
                    Alert.alert("Permission Required", "Gallery access is needed to choose an image.");
                    setImageLoading(false);
                    return;
                }
                // Launch Image Library
                const libraryResult = await ImagePicker.launchImageLibraryAsync({
                    mediaTypes: ImagePicker.MediaTypeOptions.Images,
                    quality: 0.6,
                });
                await processImage(libraryResult); // Process the result from gallery
            } catch (error) {
                console.error("Error launching image library:", error);
                Alert.alert("Gallery Error", "Could not open the image library.");
                 setImageLoading(false); // Ensure loading is stopped on error
            }
             // Note: setImageLoading(false) is handled within processImage's finally block on success/analysis error
          },
        },
      ],
      { cancelable: true } // Allow dismissing the alert by tapping outside
    );
  };


    // Combine theme-dependent and static styles
    const combinedOverlayStyle = StyleSheet.flatten([
        styles.overlayStyle, // Get base styles from useStyles
        { backgroundColor: theme.colors.background } // Apply theme background color here
    ]);

  return (
    <Overlay
      isVisible={isVisible}
      onBackdropPress={!imageLoading && !aiButtonLoading && !loading ? toggleOverlay : undefined} // Prevent closing while loading
      animationType="fade"
      overlayStyle={styles.overlayContainer} // Use container style
    >
      {/* KeyboardAvoidingView now directly inside Overlay */}
      <KeyboardAvoidingView
        behavior={Platform.OS === "ios" ? "padding" : "height"}
        style={styles.keyboardAvoidingView}
        keyboardVerticalOffset={KEYBOARD_VERTICAL_OFFSET} // Added offset
      >
        {/* This View now acts as the visible modal background and content container */}
        <View style={combinedOverlayStyle}>
          <View style={styles.header}>
            <Text h4 style={styles.overlayTitle}>
              {editFood ? "Edit Food" : "Add New Food"}
            </Text>
            <Button
              title={editFood ? "Update" : "Add"}
              onPress={() => handleCreateOrUpdate(!!editFood)}
              buttonStyle={[
                styles.button,
                {
                  backgroundColor: editFood
                    ? theme.colors.warning
                    : theme.colors.primary,
                },
              ]}
              titleStyle={{ color: theme.colors.white, fontWeight: "600" }}
              loading={loading} // Use the specific loading state
              disabled={loading || aiButtonLoading || imageLoading} // Disable while any operation is running
              containerStyle={styles.buttonContainer}
            />
             {/* Disable close button when loading */}
            <Icon
              name="close"
              type="material"
              size={28}
              color={theme.colors.text}
              onPress={!imageLoading && !aiButtonLoading && !loading ? toggleOverlay : undefined}
              containerStyle={styles.closeIcon}
              disabled={imageLoading || aiButtonLoading || loading}
              disabledStyle={{ backgroundColor: 'transparent' }} // Prevent visual change on disable
            />
          </View>

          {/* Use ScrollView to ensure content is scrollable, especially with keyboard */}
          <ScrollView keyboardShouldPersistTaps="handled">
             {/* --- Food Name Input with Image Icon --- */}
            <View style={styles.inputRow}>
                <Input
                    label="Food Name"
                    labelStyle={{ color: theme.colors.text }}
                    value={getValue("name")}
                    onChangeText={(text) =>
                        handleInputChange("name", text, !!editFood)
                    }
                    errorMessage={errors.name}
                    inputContainerStyle={[styles.inputContainerStyle, styles.inputContainerFlex]} // Adjust style
                    inputStyle={styles.inputStyle}
                    containerStyle={{ flex: 1 }} // Make input take available space
                    leftIcon={
                        <MaterialCommunityIcons
                        name="food-apple"
                        size={24}
                        color={errors.name ? theme.colors.error : theme.colors.grey1} // Use less prominent color when no error
                        />
                    }
                />
                {/* --- Image Picker/Camera Icon Button --- */}
                <TouchableOpacity
                    onPress={handleGetImageAndAnalyze} // Updated function call
                    disabled={imageLoading || aiButtonLoading || loading} // Disable while loading
                    style={styles.iconButtonContainer}
                 >
                    {imageLoading ? (
                        <ActivityIndicator size="small" color={theme.colors.primary} />
                    ) : (
                        <Icon
                            name="camera-enhance-outline" // Icon represents getting an image (camera or gallery)
                            type="material-community"
                            size={28}
                            color={theme.colors.primary}
                        />
                    )}
                </TouchableOpacity>
            </View>
            {/* --- End Food Name Input with Image Icon --- */}

            {mode === "normal" && (
              <>
                <Input
                  label="Calories (per 100g)"
                  labelStyle={{ color: theme.colors.text }}
                  keyboardType="numeric"
                  value={getValue("calories")}
                  onChangeText={(text) =>
                    handleInputChange(
                      "calories",
                      // Allow only numbers and one decimal point
                      text.replace(/[^0-9.]/g, "").replace(/(\..*)\./g, "$1"),
                      !!editFood
                    )
                  }
                  errorMessage={errors.calories}
                  inputContainerStyle={styles.inputContainerStyle}
                  inputStyle={styles.inputStyle}
                  leftIcon={
                    <MaterialCommunityIcons
                      name="fire"
                      size={24}
                      color={
                        errors.calories
                          ? theme.colors.error
                          : theme.colors.grey1
                      }
                    />
                  }
                />

                <Input
                  label="Protein (per 100g)"
                  labelStyle={{ color: theme.colors.text }}
                  keyboardType="numeric"
                  value={getValue("protein")}
                  onChangeText={(text) =>
                    handleInputChange(
                      "protein",
                      // Allow only numbers and one decimal point
                      text.replace(/[^0-9.]/g, "").replace(/(\..*)\./g, "$1"),
                      !!editFood
                    )
                  }
                  errorMessage={errors.protein}
                  inputContainerStyle={styles.inputContainerStyle}
                  inputStyle={styles.inputStyle}
                  leftIcon={
                    <MaterialCommunityIcons
                      name="food-drumstick"
                      size={24}
                      color={
                        errors.protein
                          ? theme.colors.error
                          : theme.colors.grey1
                      }
                    />
                  }
                />

                <Input
                  label="Carbs (per 100g)"
                  labelStyle={{ color: theme.colors.text }}
                  keyboardType="numeric"
                  value={getValue("carbs")}
                  onChangeText={(text) =>
                    handleInputChange(
                      "carbs",
                      // Allow only numbers and one decimal point
                      text.replace(/[^0-9.]/g, "").replace(/(\..*)\./g, "$1"),
                      !!editFood
                    )
                  }
                  errorMessage={errors.carbs}
                  inputContainerStyle={styles.inputContainerStyle}
                  inputStyle={styles.inputStyle}
                  leftIcon={
                    <MaterialCommunityIcons
                      name="bread-slice"
                      size={24}
                      color={
                        errors.carbs ? theme.colors.error : theme.colors.grey1
                      }
                    />
                  }
                />
                <Input
                  label="Fat (per 100g)"
                  labelStyle={{ color: theme.colors.text }}
                  keyboardType="numeric"
                  value={getValue("fat")}
                  onChangeText={(text) =>
                    handleInputChange(
                      "fat",
                      // Allow only numbers and one decimal point
                      text.replace(/[^0-9.]/g, "").replace(/(\..*)\./g, "$1"),
                      !!editFood
                    )
                  }
                  errorMessage={errors.fat}
                  inputContainerStyle={styles.inputContainerStyle}
                  inputStyle={styles.inputStyle}
                  leftIcon={
                    <MaterialCommunityIcons
                      name="oil" // Changed icon to 'oil'
                      size={24}
                      color={
                        errors.fat ? theme.colors.error : theme.colors.grey1
                      }
                    />
                  }
                />
              </>
            )}

            {mode === "ingredients" && (
              <>
                <View style={styles.backButtonContainer}>
                  <Icon
                    name="arrow-left"
                    type="material-community"
                    size={24}
                    color={theme.colors.primary}
                    onPress={() => !aiButtonLoading && setMode("normal")} // Prevent switching during AI call
                    disabled={aiButtonLoading}
                    containerStyle={styles.backIcon}
                  />
                  <Text style={[styles.backButtonText, aiButtonLoading && styles.disabledText]} onPress={() => !aiButtonLoading && setMode("normal")}>
                      Back to Manual Input
                  </Text>
                </View>

                <Input
                  label="Ingredients (Optional - Add if known)" // Updated label
                  labelStyle={{ color: theme.colors.text }}
                  value={ingredients}
                  onChangeText={setIngredients}
                  multiline={true}
                  numberOfLines={4} // Suggests height but allows expansion
                  inputContainerStyle={[
                    styles.inputContainerStyle,
                    styles.multilineInputContainer,
                  ]}
                  inputStyle={[styles.inputStyle, styles.multilineInput]}
                  placeholder="e.g.\n100g Chicken Breast\n50g Rice\n1 tbsp Olive Oil"
                  placeholderTextColor={theme.colors.grey3}
                  leftIcon={
                    <MaterialCommunityIcons
                      name="format-list-bulleted" // Better icon for list
                      size={24}
                      color={theme.colors.grey1}
                      style={styles.multilineIcon} // Adjust icon position if needed
                    />
                  }
                />
              </>
            )}
            {/* --- AI (Text) Button --- */}
            <Button
              title={
                mode === "normal"
                  ? "Calculate with AI (Recipe/Text)" // Clarify it's for text
                  : ingredients // Check if ingredients have been entered
                  ? "Get Macros from Ingredients"
                  : "Get Macros from Name Only" // New title
              }
              onPress={handleAiButtonClick}
              buttonStyle={[
                styles.button,
                styles.aiButton, // Specific style for AI button
                { backgroundColor: theme.colors.secondary },
              ]}
              titleStyle={[styles.aiButtonTitle, { color: theme.colors.white }]}
              loading={aiButtonLoading} // Use specific loading state
              disabled={aiButtonLoading || imageLoading || loading} // Disable while other ops run
              icon={
                mode === "normal" ? (
                  <MaterialCommunityIcons
                    name="text-box-search-outline" // Changed icon
                    size={18}
                    color={theme.colors.white}
                    style={{ marginRight: 8 }}
                  />
                ) : undefined
              }
              containerStyle={[styles.buttonContainer, { marginTop: 15 }]}
            />

            <View style={styles.futureInputContainer}>
              <Text style={styles.futureInputLabel}>
                Barcode Input (Coming Soon)
              </Text>
            </View>
          </ScrollView>
        </View>
      </KeyboardAvoidingView>
      {/* Optional: Central loading overlay (can be removed if specific indicators are sufficient) */}
      {apiLoading && ( // You might not need this if button indicators are enough
        <View style={styles.loadingOverlay}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
        </View>
      )}
    </Overlay>
  );
};


// --- Styles (Includes previous fixes and new styles for image icon) ---
const useStyles = makeStyles((theme) => ({
  // Style for the Overlay container itself (positioning, width)
  overlayContainer: {
    backgroundColor: 'transparent', // Make the overlay container transparent
    width: '90%',
    maxWidth: 500, // Max width for larger screens
    padding: 0, // Remove padding from overlay itself
    borderRadius: 15,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2, },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
    overflow: 'hidden', // Prevent content spilling before borderRadius
  },
  // Style for the main content View inside KeyboardAvoidingView (visuals, padding)
  overlayStyle: {
    width: '100%', // Takes width from overlayContainer
    borderRadius: 15,
    padding: 20,
    paddingBottom: 30, // Add extra padding at the bottom
    maxHeight: '90%', // Limit max height
    // backgroundColor is applied dynamically based on theme
  },
  keyboardAvoidingView: {
    width: "100%",
    // Let KAV manage its size based on content and keyboard
  },
  header: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 20,
    paddingBottom: 10, // Add padding below header
    borderBottomWidth: 1, // Add a separator
    borderBottomColor: theme.colors.divider,
  },
  overlayTitle: {
    color: theme.colors.text,
    fontWeight: "bold",
    fontSize: 20, // Slightly smaller
    flexShrink: 1,
    marginRight: 10,
  },
  closeIcon: {
    padding: 5,
    marginLeft: 10,
  },
  // *** Styles for Input Row with Icon Button ***
  inputRow: {
    flexDirection: 'row',
    alignItems: 'flex-end', // Align items to bottom (aligns icon with input line)
    marginBottom: 5, // Consistent margin like other inputs
  },
  inputContainerFlex: {
    flex: 1, // Allow input container to grow
    marginRight: 10, // Space between input and icon button
    marginBottom: 0, // Remove margin bottom from container inside row
  },
  iconButtonContainer: {
    height: 40, // Match input height approximately
    width: 40,  // Make it square
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 10, // Align button bottom with input field bottom roughly (adjust if needed)
    // backgroundColor: theme.colors.grey5, // Optional: Subtle background
    // borderRadius: 20, // Optional: Make it circular
  },
  // *** End Styles for Input Row ***
  inputContainerStyle: {
    borderBottomWidth: 1,
    borderBottomColor: theme.colors.grey4,
    marginBottom: 5, // Reduced margin
    paddingBottom: 2, // Add slight padding for input line
  },
  inputStyle: {
    color: theme.colors.text,
    marginLeft: 10,
    fontSize: 16,
  },
  multilineInputContainer: {
    borderWidth: 1, // Add border for multiline
    borderColor: theme.colors.grey4,
    borderRadius: 8,
    paddingVertical: 8,
    paddingHorizontal: 5, // Add horizontal padding
    marginBottom: 10,
    borderBottomWidth: 1, // Keep consistent border style
    borderBottomColor: theme.colors.grey4, // Keep consistent border style
  },
  multilineInput: {
    marginLeft: 5,
    textAlignVertical: 'top', // Align text top in multiline
    minHeight: 80, // Ensure a minimum height
    fontSize: 16, // Consistent font size
    color: theme.colors.text, // Ensure text color
  },
  multilineIcon: {
      marginTop: 8, // Adjust vertical position to align better with text
      marginRight: 5,
  },
  futureInputContainer: {
    backgroundColor: theme.colors.grey5,
    padding: 15,
    borderRadius: 10,
    marginTop: 20, // Increased margin
    marginBottom: 10, // Add bottom margin
    alignItems: "center",
  },
  futureInputLabel: {
    color: theme.colors.grey2,
    fontStyle: "italic",
  },
  buttonContainer: {
    // No specific style needed now
  },
  button: {
    borderRadius: 8,
    paddingHorizontal: 15,
    paddingVertical: 10,
  },
  aiButton: {
     paddingVertical: 12,
  },
  aiButtonTitle: {
      fontWeight: "600",
      fontSize: 15,
      textAlign: 'center', // Center button text
  },
  loadingOverlay: { // For general overlay if needed
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    justifyContent: "center",
    alignItems: "center",
    zIndex: 10,
    borderRadius: 15, // Match overlay border radius
  },
  backButtonContainer: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 15, // Add space below
    marginTop: 5,
  },
  backIcon: {
    marginRight: 5,
    padding: 5, // Make icon easier to tap
  },
  backButtonText: {
    color: theme.colors.primary, // Make text match icon color
    fontSize: 16,
    fontWeight: '500',
  },
  disabledText: {
      color: theme.colors.grey3, // Style for disabled text
  }
}));


export default AddFoodModal;
---------- END AddFoodModal.tsx ----------


---------- ConfirmationModal.tsx ----------
// components/ConfirmationModal.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Overlay, Button, Input, Text, useTheme } from '@rneui/themed';

interface ConfirmationModalProps {
  isVisible: boolean;
  onCancel: () => void;
  onConfirm: () => void;
  confirmationText: string;
  setConfirmationText: (text: string) => void;
  title?: string; // Optional title
  message?: string;  //Optional message
}

const ConfirmationModal: React.FC<ConfirmationModalProps> = ({
  isVisible,
  onCancel,
  onConfirm,
  confirmationText,
  setConfirmationText,
  title = "Confirm Action", //default title
  message = "Are you sure you want to perform this action?"
}) => {
  const { theme } = useTheme();

  return (
    <Overlay
      isVisible={isVisible}
      onBackdropPress={onCancel}
      overlayStyle={styles.overlay}
      backdropStyle={styles.backdrop} // Add the backdropStyle
    >
      <View style={[styles.container, {backgroundColor: theme.colors.background}]}>
        <Text style={[styles.title, {color: theme.colors.text}]}>{title}</Text>
        <Text style={[styles.message, {color: theme.colors.text}]}>{message}</Text>
        <Input
          placeholder="Enter confirmation text"
          placeholderTextColor={theme.colors.text}
          value={confirmationText}
          onChangeText={setConfirmationText}
          containerStyle={styles.inputContainer}
          inputStyle={{ color: theme.colors.text }}
          inputContainerStyle={{borderBottomColor: theme.colors.text}}
        />
        <View style={styles.buttonContainer}>
          <Button title="Cancel" onPress={onCancel} type="outline" buttonStyle={styles.button} />
          <Button
            title="Confirm"
            onPress={onConfirm}
            color="error"
            buttonStyle={styles.button}
            disabled={confirmationText === ""}  //Disable when empty
          />
        </View>
      </View>
    </Overlay>
  );
};

const styles = StyleSheet.create({
    overlay: {
        borderRadius: 10,
        width: '80%', // Responsive width
        padding: 6,
        backgroundColor: 'rgba(200, 200, 200, 0.5)'
    },
  container: {
    padding: 20,
    borderRadius: 7,
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 10,
    textAlign: 'center', //center align
  },
  message: {
    marginBottom: 15,
    textAlign: 'center'
  },
  inputContainer: {
    marginBottom: 20,
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
  },
  button: {
    width: 100,
    padding: 10,
  },
  backdrop: {  // Add styles for the backdrop
    backgroundColor: 'rgba(0, 0, 0, 0.5)', // Semi-transparent black
  },
});

export default ConfirmationModal;
---------- END ConfirmationModal.tsx ----------


---------- DailyGoalsInput.tsx ----------
// components/DailyGoalsInput.tsx
import React from "react";
import { Input, Text } from "@rneui/themed";
import { MacroType } from "../types/settings";
import { useTheme } from "@rneui/themed";


interface DailyGoalsInputProps {
    dailyGoals: { [key in MacroType]: number };
    onGoalChange: (goalType: MacroType, value: string) => void;
}

const DailyGoalsInput: React.FC<DailyGoalsInputProps> = ({
  dailyGoals,
  onGoalChange,
}) => {

    const { theme } = useTheme();

  return (
    <>
      {["calories", "protein", "carbs", "fat"].map((macro) => (
        <Input
          key={macro}
          label={<Text style={{ color: theme.colors.text }}>{`${macro.charAt(0).toUpperCase() + macro.slice(1)} Goal`}</Text>} // Wrap label in <Text>
          keyboardType="numeric"
          value={dailyGoals?.[macro as MacroType]?.toString() || ""}
          onChangeText={(value) => onGoalChange(macro as MacroType, value)}
          style={{ color: theme.colors.text }}
          inputContainerStyle={{ borderBottomColor: theme.colors.text }}
          labelStyle={{ color: theme.colors.text }}
        />
      ))}
    </>
  );
};

export default DailyGoalsInput;
---------- END DailyGoalsInput.tsx ----------


---------- DailyProgress.tsx ----------
// components/DailyProgress.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, useTheme } from '@rneui/themed';

interface DailyProgressProps {
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
  goals: {
    calories?: number;
    protein?: number;
    carbs?: number;
    fat?: number;
  };
}

const DailyProgress: React.FC<DailyProgressProps> = ({
  calories,
  protein,
  carbs,
  fat,
  goals,
}) => {
  const { theme } = useTheme();

  const calculateProgress = (current: number, goal?: number) => {
    if (!goal || goal <= 0) return 0; // Avoid division by zero and handle undefined goals
    return Math.min(current / goal, 1); // Cap at 100%
  };

  const renderProgressBar = (label: string, current: number, goal: number | undefined, color: string) => {
      const progress = calculateProgress(current, goal);
      return (
          <View style={styles.macroContainer} key={label}>
              <View style={styles.labelContainer}>
                    <Text style={[styles.macroLabel, {color: theme.colors.text}]}>{label}:</Text>
                    <Text style={[styles.macroValue, {color: theme.colors.text}]}>
                        {`${Math.round(current)} / ${goal || 0}`}
                    </Text>
              </View>
              <View style={styles.progressBarContainer}>
                  <View style={[styles.progressBar, { width: `${progress * 100}%`, backgroundColor: color }]} />
              </View>
          </View>
      )
  }


  return (
    <View style={styles.container}>
        {renderProgressBar('Calories', calories, goals.calories, theme.colors.primary)}
        {renderProgressBar('Protein', protein, goals.protein, 'green')}
        {renderProgressBar('Carbs', carbs, goals.carbs, 'orange')}
        {renderProgressBar('Fat', fat, goals.fat, 'blue')}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: 20,
    padding: 10,
    borderRadius: 8, // Rounded corners for the container
    //backgroundColor: '#f0f0f0', // Light background for contrast Removed for theme consistency
  },
  macroContainer: {
    marginBottom: 10,
  },
  labelContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 5,
  },
  macroLabel: {
    fontWeight: 'bold',
  },
  macroValue: {},
  progressBarContainer: {
      backgroundColor: '#e0e0e0', //Light grey for track
      borderRadius: 5,
      height: 10
  },
  progressBar: {
    height: 10,
    borderRadius: 5,
  },
});

export default DailyProgress;
---------- END DailyProgress.tsx ----------


---------- DataManagementButtons.tsx ----------
// components/DataManagementButtons.tsx (Modified callback)

import React, { useState } from "react";
import { Alert, Platform } from "react-native"; // Import Platform
import { Button } from "@rneui/themed";
import * as DocumentPicker from "expo-document-picker";
import * as FileSystem from "expo-file-system";
import * as Sharing from 'expo-sharing'; // Import Sharing
import { formatDate } from "../utils/dateUtils";
import {
  clearAllData,
  loadDailyEntries,
  saveDailyEntries,
  loadFoods,
  saveFoods,
  loadSettings,
  saveSettings
} from "../services/storageService";
import ConfirmationModal from "./ConfirmationModal";
import { DailyEntry } from "../types/dailyEntry";
import { Food } from "../types/food";
import { Settings } from "../types/settings";
import { useTheme } from "@rneui/themed";


interface DataManagementButtonsProps {
  onDataOperation: () => void; // Changed prop name
}

const DataManagementButtons: React.FC<DataManagementButtonsProps> = ({
    onDataOperation
}) => {
  const [isConfirmationVisible, setIsConfirmationVisible] = useState(false);
  const [confirmationText, setConfirmationText] = useState("");
  const { theme } = useTheme();

  const handleExportData = async () => {
    try {
      const dailyEntries = await loadDailyEntries();
      const foods = await loadFoods();
      const settings = await loadSettings();

      const exportData = {
        dailyEntries,
        foods,
        settings
      };

      const exportDataString = JSON.stringify(exportData);
      const formattedDate = formatDate(new Date()).replace(/\//g, '-'); // Replace slashes
      const fileName = `macro_data_${formattedDate}.json`;
      const fileUri = FileSystem.documentDirectory + fileName;

      await FileSystem.writeAsStringAsync(fileUri, exportDataString, {
        encoding: FileSystem.EncodingType.UTF8,
      });

      // Use expo-sharing to share the file
      if (!(await Sharing.isAvailableAsync())) {
        Alert.alert('Sharing is not available on your platform');
        return;
      }

      await Sharing.shareAsync(fileUri);
      onDataOperation(); // Trigger reload after export

    } catch (error: any) {
      console.error(error);
      Alert.alert(
        "Export Failed",
        error.message || "An error occurred while exporting data."
      );
    }
  };

  const handleImportData = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: ["application/json"], // Only accept JSON files
      });

      if (result.assets && result.assets.length > 0) {
        const file = result.assets[0];

        // Check file extension
        if (!file.name?.toLowerCase().endsWith(".json")) {
          Alert.alert("Invalid File", "Please select a JSON file.");
          return;
        }

        const fileContent = await FileSystem.readAsStringAsync(file.uri, {
          encoding: FileSystem.EncodingType.UTF8,
        });


        try {
          const importedData = JSON.parse(fileContent);

          // Basic structure validation:
          if (
            !importedData.hasOwnProperty("dailyEntries") ||
            !importedData.hasOwnProperty("foods") ||
            !importedData.hasOwnProperty("settings")
          ) {
            Alert.alert(
              "Import Failed",
              "The imported file is missing required data (dailyEntries, foods, or settings)."
            );
            return;
          }


          await saveDailyEntries(importedData.dailyEntries);
          await saveFoods(importedData.foods);
          await saveSettings(importedData.settings)
          Alert.alert("Import Successful", "Data imported and saved.");
          onDataOperation(); //trigger reload

        } catch (parseError) {
          Alert.alert(
            "Import Failed",
            "The imported file is not valid JSON."
          );
          return;
        }


      } else {
        // Explicitly check for cancelled
        if (result.canceled) {
          // User cancelled, do nothing
        } else {
          Alert.alert("Import Failed", "Invalid file selected.");
        }
      }
    } catch (error: any) {
      console.error("Import Error:", error);
      Alert.alert(
        "Import Failed",
        error.message || "An unknown error occurred."
      );
    }
  };

  const handleClearData = () => setIsConfirmationVisible(true);

  const confirmClearData = async () => {
    if (confirmationText === "CLEAR DATA") {
      try {
        await clearAllData();
        Alert.alert("Data Cleared", "All data has been cleared.");
        onDataOperation(); // Trigger reload after clearing
      } catch (error) {
        Alert.alert("Error", "Failed to clear data.");
      } finally {
        setConfirmationText("");
        setIsConfirmationVisible(false);
      }
    } else {
      Alert.alert("Error", "Incorrect confirmation text.");
    }
  };

  return (
    <>
      <Button
        title="Export Data"
        onPress={handleExportData}
        buttonStyle={{ marginBottom: 10, backgroundColor: theme.colors.primary }}
      />
      <Button
        title="Import Data"
        onPress={handleImportData}
        buttonStyle={{ marginBottom: 10, backgroundColor: theme.colors.primary }}
      />
      <Button
        title="Clear All Data"
        onPress={handleClearData}
        color="error"
        buttonStyle={{ marginBottom: 10 }}
      />

      <ConfirmationModal
        isVisible={isConfirmationVisible}
        onCancel={() => setIsConfirmationVisible(false)}
        onConfirm={confirmClearData}
        confirmationText={confirmationText}
        setConfirmationText={setConfirmationText}
        title="Clear All Data?"
        message="This action cannot be undone. Confirmation Text: CLEAR DATA"
      />
    </>
  );
};

export default DataManagementButtons;
---------- END DataManagementButtons.tsx ----------


---------- FoodItem.tsx ----------
// FoodItem.tsx (Corrected with forwardRef and Icon Handling)
import React, { forwardRef } from "react"; // Import forwardRef
import { StyleSheet, View, Image } from "react-native"; // Import View and Image
import { ListItem, Icon, useTheme, Button } from "@rneui/themed";
import { Food } from "../types/food";
import Toast from "react-native-toast-message";

interface FoodItemProps {
  food: Food;
  onEdit: (food: Food) => void;
  onDelete: (foodId: string) => void;
  onUndoDelete: (food: Food) => void;
  foodIconUrl: string | null; // Add foodIconUrl prop
}

// Use forwardRef to receive the ref from the parent
const FoodItem = forwardRef<any, FoodItemProps>(
  ({ food, onEdit, onDelete, onUndoDelete, foodIconUrl }, ref) => {
    const { theme } = useTheme();

    const handleDelete = () => {
      onDelete(food.id);
      Toast.show({
        type: "success",
        text1: `${food.name} deleted`,
        text2: "Tap to undo",
        position: "bottom",
        bottomOffset: 80,
        onPress: () => onUndoDelete(food), // Call undo function
        visibilityTime: 3000, // Show for 3 seconds
      });
    };

    return (
      // Attach the received ref to ListItem.Swipeable
      <ListItem.Swipeable
        ref={ref} // Pass the forwarded ref here!
        bottomDivider
        leftContent={(reset) => (
          <Button
            title="Edit"
            onPress={() => {
              onEdit(food);
              reset();
            }}
            icon={{ name: "edit", color: "white" }}
            buttonStyle={styles.swipeButtonEdit}
          />
        )}
        rightContent={(reset) => (
          <Button
            title="Delete"
            onPress={handleDelete} // Call handleDelete
            icon={{ name: "delete", color: "white" }}
            buttonStyle={styles.swipeButtonDelete}
          />
        )}
        containerStyle={[
          styles.listItemContainer,
          { backgroundColor: theme.colors.background },
        ]}
      >
        {/* Use Image component if foodIconUrl exists, otherwise use default Icon */}
        {foodIconUrl ? (
          <Image source={{ uri: foodIconUrl }} style={styles.foodIcon} />
        ) : (
          <Icon
            name="fast-food-outline"
            type="ionicon"
            color={theme.colors.text}
          />
        )}
        <ListItem.Content>
          <ListItem.Title style={[styles.title, { color: theme.colors.text }]}>
            {food.name}
          </ListItem.Title>
          <ListItem.Subtitle style={{ color: theme.colors.text }}>
            {`Cal: ${food.calories}, P: ${food.protein}g, C: ${food.carbs}g, F: ${food.fat}g`}
          </ListItem.Subtitle>
        </ListItem.Content>
        <ListItem.Chevron />
      </ListItem.Swipeable>
    );
  }
);

const styles = StyleSheet.create({
  listItemContainer: {
    paddingVertical: 15,
    borderRadius: 0,
    marginVertical: 0,
  },
  title: {
    fontWeight: "bold",
    fontSize: 16,
  },
  swipeButtonEdit: {
    minHeight: "100%",
    backgroundColor: "orange",
  },
  swipeButtonDelete: {
    minHeight: "100%",
    backgroundColor: "red",
  },
  foodIcon: {
    width: 30,
    height: 30,
    marginRight: 10,
    borderRadius: 15,
    resizeMode: "stretch", // Or 'cover', or 'stretch', see below
  },
});

export default FoodItem;

---------- END FoodItem.tsx ----------


---------- StatisticsChart.tsx ----------
// components/StatisticsChart.tsx (Modified)
import React from "react";
import { View, StyleSheet } from "react-native";
import { WebView } from "react-native-webview";
import { Statistics, MacroType, macros } from "../types/settings"; // Import types
import { useTheme } from "@rneui/themed";


interface StatisticsChartProps {
  statistics: Statistics;
}

const StatisticsChart: React.FC<StatisticsChartProps> = ({ statistics }) => {

  const { theme } = useTheme();

  const generateChartHTML = () => {
    const chartData = macros.reduce((acc, macro) => {
      // Prepare data for each macro, including goal if applicable
      acc[macro] = statistics[macro].map((series) =>
        series.map((item) => [item.x / 1000, item.y])
      );
      return acc;
    }, {} as { [key in MacroType]: number[][][] });

    const textColor = theme.colors.text;
    const gridColor = theme.colors.grey5; // Lighter grid
    const axisColor = theme.colors.grey3; // Slightly darker axis
    const fontFamily = "Helvetica, Arial, sans-serif";

    // Define color palette for the lines, using theme colors if possible
    const lineColors = {
      calories: theme.colors.primary,
      protein: theme.colors.success,
      carbs: theme.colors.warning,
      fat: theme.colors.error,
    };


    // Re-enabled caching, but *only* cache the HTML itself, not the data.  The data is now dynamic.
    return `
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>Macro Charts</title>
            <style>
            body { font-family: ${fontFamily}; margin: 0; padding: 0; background-color: ${theme.colors.background}; color: ${textColor};}
                .chart-container { width: 95%; height: 250px; margin: 10px auto; }
            </style>
            <link rel="stylesheet" href="https://unpkg.com/uplot@1.6.27/dist/uPlot.min.css">
            <script src="https://unpkg.com/uplot@1.6.27/dist/uPlot.iife.min.js"></script>
        </head>
        <body>
            ${macros
      .map((macro) => {
        const isCalories = macro === "calories";
        const seriesCount = isCalories ? 2 : 1; // Two series for calories (intake, goal)

        const seriesConfig = isCalories
          ? `[
                      {},
                      {
                        stroke: "${lineColors[macro] || theme.colors.primary}",
                        width: 2,
                        label: "Intake",
                        points: { show: false }
                      },
                      {
                        stroke: "red",
                        width: 1,
                        dash: [5, 5],
                        label: "Goal",
                        points: { show: false }
                      }
                    ]`
          : `[
                      {},
                      {
                        stroke: "${lineColors[macro] || theme.colors.primary}",
                        width: 2,
                        label: "${macro.charAt(0).toUpperCase() + macro.slice(1)}",
                        points: { show: false }
                      }
                    ]`;


        const uPlotData =
          seriesCount === 2
            ? `[data[0].map(d => d[0]), data[0].map(d => d[1]), data[1].map(d => d[1])]`
            : `[data[0].map(d => d[0]), data[0].map(d => d[1])]`;



        return `
                <div id="${macro}-chart" class="chart-container"></div>
                <script>
                    const data = ${JSON.stringify(chartData[macro])};
                    const opts = {
                        title: "${macro.charAt(0).toUpperCase() + macro.slice(1)}",
                        width: window.innerWidth * 0.95,
                        height: 250,
                        scales: {
                            x: { time: true },
                            y: { },
                        },
                        axes: [
                            {
                                stroke: "${textColor}",
                                font: "14px ${fontFamily}",
                            grid: {
                                    stroke: "${gridColor}",
                                    width: 1
                                },
                                ticks: {
                                    stroke: "${gridColor}",
                                    width: 1
                                }
                            },
                            {
                                stroke: "${textColor}",
                                font: "14px ${fontFamily}",
                                grid: {
                                    stroke: "${gridColor}",
                                    width: 1
                                },
                                ticks: {
                                    stroke: "${gridColor}",
                                    width: 1
                                }
                            }
                        ],
                        series: ${seriesConfig},
                        cursor: {
                            drag: { setScale: false },
                            points: {
                                size: 6,
                                fill: (self, i) => self.series[i]._stroke,
                                stroke: (self, i) => self.series[i]._stroke,
                            }
                        },
                        ${isCalories ? `
                        hooks: {
                            draw: [
                                (u) => {
                                   const ctx = u.ctx;
                                    u.series.forEach((series, seriesIdx) => {
                                      if (seriesIdx === 1) {
                                        const intakeData = data[0];
                                        const goalData = data[1];

                                        ctx.beginPath();
                                        ctx.fillStyle = "rgba(255, 0, 0, 0.3)"; // Semi-transparent red

                                        for (let i = 0; i < intakeData.length; i++) {
                                          const intakeY = intakeData[i][1];
                                          const goalY = goalData[i][1];
                                          const x = u.valToPos(intakeData[i][0], "x", true);
                                          
                                           // Check if intake exceeds the goal
                                            if(intakeY > goalY){
                                                const intakeYPos = u.valToPos(intakeY, 'y', true);
                                                const goalYPos = u.valToPos(goalY, 'y', true);
                                               
                                                //if this is the first point or last point, move to x, other wise line to x
                                                if(i === 0){
                                                   ctx.moveTo(x, intakeYPos);
                                                }else{
                                                  ctx.lineTo(x, intakeYPos);
                                                }
                                            }
                                        }
                                        //go back along the goal data
                                         for (let i = intakeData.length-1; i >= 0; i--) {
                                            const intakeY = intakeData[i][1];
                                            const goalY = goalData[i][1];
                                             const x = u.valToPos(intakeData[i][0], "x", true);
                                               // Check if intake exceeds the goal
                                            if(intakeY > goalY){
                                                 const goalYPos = u.valToPos(goalY, 'y', true);
                                                ctx.lineTo(x, goalYPos);
                                            }
                                         }

                                        ctx.closePath();
                                        ctx.fill();
                                        }

                                    });

                                }
                            ]
                        }
                        ` : ''}
                    };
                    new uPlot(opts, ${uPlotData}, document.getElementById('${macro}-chart'));
                </script>
            `;
      })
      .join("")}
        </body>
        </html>
        `;

  };

  return (
    <View style={styles.webViewContainer}>
      <WebView
        originWhitelist={["*"]}
        source={{ html: generateChartHTML() }}
        style={styles.webView}
        scalesPageToFit={false}
        scrollEnabled={false}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  webViewContainer: {
    height: 'auto',
    width: "100%",
    marginTop: 10,
  },
  webView: {
    height: 340, // Explicit height, adjust as needed.
  },
});

export default StatisticsChart;
---------- END StatisticsChart.tsx ----------


---------- ThemeSwitch.tsx ----------
// components/ThemeSwitch.tsx (Corrected)
import React from "react";
import { ListItem, Switch } from "@rneui/themed";
import { useTheme } from "@rneui/themed";

interface ThemeSwitchProps {
  currentTheme: 'light' | 'dark' | 'system'; // Use theme string
  onToggle: (theme: 'light' | 'dark' | 'system') => void; // Pass the theme string
}

const ThemeSwitch: React.FC<ThemeSwitchProps> = ({ currentTheme, onToggle }) => {
  const { theme } = useTheme();

  return (
    <ListItem
      bottomDivider
      containerStyle={{ backgroundColor: theme.colors.background }}
    >
      <ListItem.Content>
        <ListItem.Title style={{ color: theme.colors.text }}>
          Dark Mode
        </ListItem.Title>
      </ListItem.Content>
      <Switch
        value={currentTheme === 'dark'} // Correctly reflect theme
        onValueChange={(newValue) => {
          onToggle(newValue ? 'dark' : 'light'); // Toggle between 'light' and 'dark'
        }}
      />
    </ListItem>
  );
};

export default ThemeSwitch;
---------- END ThemeSwitch.tsx ----------


---------- eas.json ----------
{
  "cli": {
    "version": ">= 13.4.1",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal"
    },
    "preview": {
      "android": {
        "buildType": "apk"
      }
    },
    "production": {
      "autoIncrement": true
    }
  },
  "submit": {
    "production": {}
  }
}

---------- END eas.json ----------


---------- index.ts ----------
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);

---------- END index.ts ----------


---------- AppNavigator.tsx ----------
// navigation/AppNavigator.tsx
import React, { useState, useCallback } from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { Icon, useTheme } from '@rneui/themed';
import DailyEntryScreen from '../screens/DailyEntryScreen';
import FoodListScreen from '../screens/FoodListScreen';
import SettingsScreen from '../screens/SettingsScreen';

const Tab = createBottomTabNavigator();

interface AppNavigatorProps {
  onThemeChange: (theme: 'light' | 'dark' | 'system') => void;
}

const AppNavigator: React.FC<AppNavigatorProps> = ({ onThemeChange }) => {
  const { theme } = useTheme();
  const [foodListRefresh, setFoodListRefresh] = useState(false);

  const handleFoodChange = useCallback(() => {
    setFoodListRefresh(prev => !prev); // Toggle the state to trigger refresh
  }, []);

  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        tabBarIcon: ({ focused, color, size }) => {
          let iconName: string = '';
          let type: string = '';

          if (route.name === 'Daily Entry') {
            iconName = focused ? 'calendar' : 'calendar-outline';
            type = 'ionicon';
          } else if (route.name === 'Foods') {
            iconName = focused ? 'fast-food' : 'fast-food-outline';
            type = 'ionicon'; // Consistent icon set
          } else if (route.name === 'Settings') {
            iconName = focused ? 'settings' : 'settings-outline';
            type = 'ionicon';
          }

          return <Icon name={iconName} type={type} size={size} color={color} />;
        },
        tabBarActiveTintColor: theme.colors.primary,
        tabBarInactiveTintColor: theme.colors.secondary, // Use secondary color
        headerShown: false,
        tabBarStyle: {
          backgroundColor: theme.colors.background,
          borderTopColor: theme.colors.divider, // Add a subtle border
        },
        tabBarLabelStyle: {
          fontWeight: 'bold', // Make labels more prominent
        }
      })}
    >
      <Tab.Screen name="Daily Entry">
        {() => <DailyEntryScreen key={foodListRefresh ? 'refresh' : 'normal'} />}
      </Tab.Screen>
      <Tab.Screen name="Foods">
        {() => <FoodListScreen onFoodChange={handleFoodChange} />}
      </Tab.Screen>
      <Tab.Screen name="Settings">
        {() => <SettingsScreen onThemeChange={onThemeChange} onDataOperation={function (): void {
          throw new Error('Function not implemented.');
        } } />}
      </Tab.Screen>
    </Tab.Navigator>
  );
};

export default AppNavigator;
---------- END AppNavigator.tsx ----------


---------- package.json ----------
{
  "name": "macrotracker",
  "license": "0BSD",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@react-native-async-storage/async-storage": "^2.1.2",
    "@react-native-community/datetimepicker": "8.2.0",
    "@react-navigation/bottom-tabs": "^7.3.1",
    "@react-navigation/native": "^7.0.17",
    "@rneui/base": "^4.0.0-rc.7",
    "@rneui/themed": "^4.0.0-rc.8",
    "@types/d3-scale": "^4.0.9",
    "d3-scale": "^4.0.2",
    "date-fns": "^4.1.0",
    "expo": "~52.0.40",
    "expo-document-picker": "^13.0.3",
    "expo-file-system": "^18.0.12",
    "expo-sharing": "~13.0.1",
    "expo-status-bar": "~2.0.1",
    "react": "18.3.1",
    "react-native": "0.76.7",
    "react-native-config": "^1.5.5",
    "react-native-get-random-values": "^1.11.0",
    "react-native-reanimated": "~3.16.1",
    "react-native-safe-area-context": "^4.14.1",
    "react-native-screens": "^4.9.2",
    "react-native-svg": "^15.11.2",
    "react-native-toast-message": "^2.2.1",
    "react-native-webview": "^13.13.4",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/react": "~18.3.12",
    "@types/react-native": "^0.73.0",
    "@types/react-native-svg-charts": "^5.0.16",
    "@types/uuid": "^10.0.0",
    "typescript": "^5.3.3",
    "victory": "^37.3.6"
  },
  "private": true
}

---------- END package.json ----------


---------- projectToFile.js ----------
const fs = require('fs');
const path = require('path');

async function generateProjectStructureAndContent(projectRoot, outputFile) {
    const excludedDirs = ['node_modules', '.git', '.expo', 'android', 'ios', '__tests__', 'dist', 'build', '.vscode'];
    const excludedFiles = ['.DS_Store', 'package-lock.json', 'yarn.lock', 'bun.lockb', 'metro.config.js', 'babel.config.js'];
    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.webp', '.ico']; // Add more if needed

    let fileStructureTree = '';  // For the initial tree structure
    let fileContents = '';      // For the file contents

    async function traverseDirectory(dir, indent = '') {
        const entries = await fs.promises.readdir(dir, { withFileTypes: true });

        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);

            if (excludedDirs.includes(entry.name)) {
                continue;
            }

            if (entry.isDirectory()) {
                fileStructureTree += `${indent}${entry.name}/\n`;
                await traverseDirectory(fullPath, indent + '  ');
            } else if (entry.isFile()) {
                if (excludedFiles.includes(entry.name)) {
                    continue;
                }
                fileStructureTree += `${indent}${entry.name}\n`;
                const fileExtension = path.extname(entry.name).toLowerCase();

                if (!imageExtensions.includes(fileExtension)) {
                    fileContents += `\n---------- ${entry.name} ----------\n`;
                    try {
                        const fileContent = await fs.promises.readFile(fullPath, 'utf-8');
                        fileContents += `${fileContent}\n`;
                    } catch (readError) {
                        fileContents += `ERROR READING FILE: ${readError.message}\n`;
                    }
                    fileContents += `---------- END ${entry.name} ----------\n\n`;
                } else {
                     fileContents += `\n---------- ${entry.name} ----------\n`;
                     fileContents += `(Image file - content not included)\n`;
                     fileContents += `---------- END ${entry.name} ----------\n\n`;
                }
            }
        }
    }

    try {
        await traverseDirectory(projectRoot);
        const fullOutput = fileStructureTree + fileContents;

        await fs.promises.writeFile(outputFile, fullOutput);
        console.log(`Project structure and content written to ${outputFile}`);

    } catch (error) {
        console.error('An error occurred:', error);
        process.exit(1);
    }
}

// --- Main execution ---

const projectRoot = process.cwd(); // Use the current working directory
const outputFile = 'project_structure.txt';

// Check if the projectRoot exists.
fs.stat(projectRoot, (err, stats) => {
    if (err) {
        console.error(`Error: Project root directory "${projectRoot}" not found or not accessible.`);
        process.exit(1);
    }

    if (!stats.isDirectory()) {
        console.error(`Error: "${projectRoot}" is not a directory.`);
        process.exit(1);
    }

    generateProjectStructureAndContent(projectRoot, outputFile);
});
---------- END projectToFile.js ----------


---------- DailyEntryScreen.tsx ----------
// DailyEntryScreen.tsx (Corrected and Fully Functional with Reversed List)
import React, { useState, useEffect, useCallback, useMemo } from "react";
import { View, FlatList, Alert, Platform, Image, StyleSheet } from "react-native"; // Import Image and StyleSheet
import { DailyEntry, DailyEntryItem } from "../types/dailyEntry";
import { Food } from "../types/food";
import { getFoods } from "../services/foodService";
import {
    saveDailyEntries,
    loadDailyEntries,
    loadSettings,
} from "../services/storageService";
import {
    formatDate,
    formatDateReadable,
    getTodayDateString,
} from "../utils/dateUtils";
import { isValidNumberInput } from "../utils/validationUtils";
import DailyProgress from "../components/DailyProgress";
import {
    Button,
    Text,
    ListItem,
    FAB,
    makeStyles,
    useTheme,
    Divider,
    Input,
} from "@rneui/themed";
import DateTimePicker from "@react-native-community/datetimepicker";
import { addDays, subDays, parseISO, formatISO } from "date-fns";
import { Icon } from "@rneui/base";
import { SafeAreaView } from "react-native-safe-area-context";
import AddEntryModal from "../components/AddEntryModal";
import "react-native-get-random-values";
import Toast from "react-native-toast-message";
import { useFocusEffect } from '@react-navigation/native';
import { getFoodIconUrl } from "./../utils/iconUtils"; // Import the icon helper function

interface DailyGoals {
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
}

const DailyEntryScreen: React.FC = () => {
    const [dailyEntries, setDailyEntries] = useState<DailyEntry[]>([]);
    const [selectedDate, setSelectedDate] = useState<string>(getTodayDateString());
    const [foods, setFoods] = useState<Food[]>([]);
    const [selectedFood, setSelectedFood] = useState<Food | null>(null);
    const [grams, setGrams] = useState("");
    const [isOverlayVisible, setIsOverlayVisible] = useState(false);
    const [showDatePicker, setShowDatePicker] = useState(false);
    const [dailyGoals, setDailyGoals] = useState<DailyGoals>({
        calories: 2000,
        protein: 50,
        carbs: 200,
        fat: 70,
    });
    const [editingIndex, setEditingIndex] = useState<number | null>(null); // Index for inline editing
    const [tempGrams, setTempGrams] = useState(""); // Temporary grams for inline editing
    const [search, setSearch] = useState("");
    const [editIndex, setEditIndex] = useState<number | null>(null); // Index for modal editing
    const [foodIcons, setFoodIcons] = useState<{ [foodName: string]: string | null }>({});

    const { theme } = useTheme();
    const styles = useStyles();

    const loadData = useCallback(async () => {
        const loadedFoods = await getFoods();
        const loadedEntries = await loadDailyEntries();
        const loadedSettings = await loadSettings();

        if (loadedSettings.dailyGoals) {
            setDailyGoals(loadedSettings.dailyGoals);
        }

        setFoods(loadedFoods);
        setDailyEntries(loadedEntries);
    }, []);

    useFocusEffect(
        useCallback(() => {
            loadData();
            return () => {
                // Optional cleanup when screen loses focus
                setSearch('');
                setIsOverlayVisible(false); // Close modal if navigating away
                setEditingIndex(null); // Cancel inline edit if navigating away
            };
        }, [loadData])
    );

    // Load food icons when component mounts or foods change
    useEffect(() => {
        const loadIcons = async () => {
            const icons: { [foodName: string]: string | null } = {};
            for (const food of foods) {
                const iconUrl = await getFoodIconUrl(food.name);
                icons[food.name] = iconUrl;
            }
            setFoodIcons(icons);
        };

        if (foods.length > 0) {
           loadIcons();
        }
    }, [foods]);

    // Memoize the current entry items to avoid unnecessary recalculations
    const currentEntryItems = useMemo(() => {
        const entry = dailyEntries.find((e) => e.date === selectedDate);
        // --- REVERSE THE LIST HERE ---
        // Create a shallow copy and reverse it for display
        return entry ? [...entry.items].reverse() : [];
    }, [dailyEntries, selectedDate]);

    // Helper to get the *original* index based on the reversed list index
    const getOriginalIndex = (reversedIndex: number): number => {
         const entry = dailyEntries.find((e) => e.date === selectedDate);
         if (!entry) return -1; // Should not happen if reversedIndex is valid
         return entry.items.length - 1 - reversedIndex;
    }

    const updateAndSaveEntries = async (updatedEntries: DailyEntry[]) => {
        await saveDailyEntries(updatedEntries);
        setDailyEntries(updatedEntries);
    };

    // --- INLINE EDITING LOGIC (Uses Original Index) ---
    const handleStartEditing = (reversedIndex: number) => {
        const originalIndex = getOriginalIndex(reversedIndex);
        if (originalIndex === -1) return; // Safety check

        const currentEntry = dailyEntries.find((e) => e.date === selectedDate);
        if (!currentEntry) return;

        setEditingIndex(originalIndex); // Store the original index
        setTempGrams(String(currentEntry.items[originalIndex].grams));
    };

    const handleSaveInlineEdit = async () => {
        if (editingIndex === null) return; // No item being edited

        if (!isValidNumberInput(tempGrams) || parseFloat(tempGrams) <= 0) {
            Alert.alert(
                "Invalid Input",
                "Please enter a valid, positive number for grams."
            );
            return;
        }

        const currentEntry = dailyEntries.find((e) => e.date === selectedDate);
        if (!currentEntry) return;

        const updatedItems = [...currentEntry.items];
        // Use the stored original index to update the correct item
        updatedItems[editingIndex] = { ...updatedItems[editingIndex], grams: parseFloat(tempGrams) };

        const updatedEntries = dailyEntries.map((entry) =>
            entry.date === selectedDate ? { ...entry, items: updatedItems } : entry
        );

        await updateAndSaveEntries(updatedEntries);
        setEditingIndex(null); // Clear editing state
        setTempGrams("");
    };

    const handleCancelInlineEdit = () => {
        setEditingIndex(null);
        setTempGrams("");
    };
    // --- END INLINE EDITING LOGIC ---


    const handleAddEntry = async () => {
        if (!selectedFood || !isValidNumberInput(grams) || parseFloat(grams) <= 0) {
            Alert.alert(
                "Invalid Input",
                "Please select a food and enter a valid, positive number for grams."
            );
            return;
        }

        const newEntryItem: DailyEntryItem = {
            food: selectedFood,
            grams: parseFloat(grams),
        };

        let existingEntry = dailyEntries.find((entry) => entry.date === selectedDate);
        let updatedEntries: DailyEntry[];

        if (existingEntry) {
            // Entry for the date exists
             let updatedItems;
            if (editIndex !== null) {
                // Editing an existing item within this entry
                 const originalEditIndex = getOriginalIndex(editIndex); // Get original index if needed
                 if (originalEditIndex === -1) {
                      console.error("Could not find original index for editing");
                      return; // Should not happen
                 }
                updatedItems = existingEntry.items.map((item, index) =>
                    index === originalEditIndex ? newEntryItem : item // Use original index
                );
            } else {
                // Adding a new item to this entry
                updatedItems = [...existingEntry.items, newEntryItem]; // Add to the end (will be reversed for display)
            }
             const updatedEntry = { ...existingEntry, items: updatedItems };
            updatedEntries = dailyEntries.map((entry) =>
                entry.date === selectedDate ? updatedEntry : entry
            );
        } else {
            // No entry for this date yet, create a new one
            const newDailyEntry: DailyEntry = {
                date: selectedDate,
                items: [newEntryItem], // Start with the new item
            };
            updatedEntries = [...dailyEntries, newDailyEntry];
        }


        await updateAndSaveEntries(updatedEntries);
        setSelectedFood(null);
        setGrams("");
        setEditIndex(null); // Clear modal edit index
        setIsOverlayVisible(false);
        setSearch(""); // Clear search on successful add/edit
    };

    const handleSelectFood = (item: Food | null) => {
        setSelectedFood(item);
    };

    // --- REMOVE ENTRY LOGIC (Uses Original Index) ---
    const handleRemoveEntry = async (reversedIndex: number) => {
        const originalIndex = getOriginalIndex(reversedIndex);
         if (originalIndex === -1) return; // Safety check

        const currentEntry = dailyEntries.find((e) => e.date === selectedDate);
        if (!currentEntry) return; // Should not happen

        const itemToRemove = currentEntry.items[originalIndex]; // Get item using original index
        const updatedItems = currentEntry.items.filter((_, i) => i !== originalIndex); // Filter using original index

        let finalEntries: DailyEntry[];

        if (updatedItems.length === 0) {
            // If the entry becomes empty, remove it completely
            finalEntries = dailyEntries.filter((entry) => entry.date !== selectedDate);
        } else {
            // Otherwise, just update the items for the current date
             const updatedEntry = { ...currentEntry, items: updatedItems };
            finalEntries = dailyEntries.map((entry) =>
                entry.date === selectedDate ? updatedEntry : entry
            );
        }

        await updateAndSaveEntries(finalEntries);

        Toast.show({
            type: 'success',
            text1: `${itemToRemove.food.name} entry deleted`,
            text2: 'Tap to undo',
            position: 'bottom',
            bottomOffset: 80,
            onPress: () => handleUndoRemoveEntry(itemToRemove, selectedDate, originalIndex), // Pass original index
            visibilityTime: 3000,
        });
    };

    const handleUndoRemoveEntry = (
        itemToRestore: DailyEntryItem,
        entryDate: string,
        originalIndex: number // Use the original index where it was removed
    ) => {
        // Find the index of the *DailyEntry* for the given date
        const existingEntryIndex = dailyEntries.findIndex(e => e.date === entryDate); // Correctly find the ENTRY index

        let updatedEntries;

        // Check if the DailyEntry for that date exists in the current state
        if (existingEntryIndex > -1) { // *** CORRECTED: Use existingEntryIndex here ***
            // Entry exists, insert the item back at its original position
            const entryToUpdate = dailyEntries[existingEntryIndex];
            const updatedItems = [...entryToUpdate.items];
            // Insert the item back at the specific index it was removed from
            updatedItems.splice(originalIndex, 0, itemToRestore);

            // Map over entries and replace the updated one
            updatedEntries = dailyEntries.map((entry, index) =>
                index === existingEntryIndex ? { ...entry, items: updatedItems } : entry
            );
        } else {
            // Entry was removed because it became empty, need to re-create it
            const newEntry: DailyEntry = { date: entryDate, items: [itemToRestore] };
            // Add the newly created entry back to the list
            updatedEntries = [...dailyEntries, newEntry];
            // Optional: Sort entries by date if needed, though usually handled by display logic
            // updatedEntries.sort((a, b) => a.date.localeCompare(b.date));
        }

        updateAndSaveEntries(updatedEntries);
        Toast.hide();
    };
    // --- END REMOVE ENTRY LOGIC ---

    const updateSearch = (search: string) => setSearch(search);

    // --- TOGGLE OVERLAY / MODAL EDIT LOGIC (Uses Reversed Index) ---
    const toggleOverlay = (
        item: DailyEntryItem | null = null,
        reversedIndex: number | null = null // This is the index from the reversed list
    ) => {
        setIsOverlayVisible(!isOverlayVisible);
        if (item && reversedIndex !== null) {
            // Editing existing item via modal
            setSelectedFood(item.food);
            setGrams(String(item.grams));
            setEditIndex(reversedIndex); // Store the reversed index for modal context
        } else {
            // Adding new item or closing modal
            setSelectedFood(null);
            setGrams("");
            setEditIndex(null); // Clear modal edit index
            setSearch(""); // Clear search when opening for add
        }
    };

     // Triggered by swipe-to-edit button (passes reversed index)
    const handleEditEntryViaModal = (item: DailyEntryItem, reversedIndex: number) => {
        toggleOverlay(item, reversedIndex);
    };
    // --- END TOGGLE OVERLAY ---

    // Key Change: Update date handling
    const handleDateChange = (event: any, selectedDateVal?: Date) => {
        setShowDatePicker(false);
        if (event.type === "set" && selectedDateVal) {
            // Format the selected date to a string
            const formattedDate = formatISO(selectedDateVal, { representation: 'date' });
            setSelectedDate(formattedDate);
        }
    };

    const handlePreviousDay = () => {
        const currentDate = parseISO(selectedDate);
        const newDate = subDays(currentDate, 1);
        setSelectedDate(formatISO(newDate, { representation: 'date' }));
    }

    const handleNextDay = () => {
        const currentDate = parseISO(selectedDate);
        const newDate = addDays(currentDate, 1);
        setSelectedDate(formatISO(newDate, { representation: 'date' }));
    }

    // Calculate totals based on the original data structure
     const calculateTotals = () => {
        const currentOriginalEntry = dailyEntries.find((entry) => entry.date === selectedDate);
        let [totalCalories, totalProtein, totalCarbs, totalFat] = [0, 0, 0, 0];

        if (currentOriginalEntry) {
            currentOriginalEntry.items.forEach((item) => {
                totalCalories += (item.food.calories / 100) * item.grams;
                totalProtein += (item.food.protein / 100) * item.grams;
                totalCarbs += (item.food.carbs / 100) * item.grams;
                totalFat += (item.food.fat / 100) * item.grams;
            });
        }


        return {
            totalCalories: Math.round(totalCalories),
            totalProtein: Math.round(totalProtein),
            totalCarbs: Math.round(totalCarbs),
            totalFat: Math.round(totalFat),
        };
    };

    const { totalCalories, totalProtein, totalCarbs, totalFat } = calculateTotals();


    return (
        <SafeAreaView style={styles.container}>
            {/* Date Navigation */}
            <View style={styles.dateNavigation}>
                <Button
                    type="clear"
                    onPress={handlePreviousDay}
                    icon={
                        <Icon name="arrow-back" type="ionicon" color={theme.colors.text} />
                    }
                />
                <Text h4 style={styles.dateText} onPress={() => setShowDatePicker(true)}>
                    {formatDateReadable(selectedDate)}
                </Text>
                <Button
                    type="clear"
                    onPress={handleNextDay}
                    icon={
                        <Icon
                            name="arrow-forward"
                            type="ionicon"
                            color={theme.colors.text}
                        />
                    }
                />
            </View>

            {showDatePicker && (
                <DateTimePicker
                    value={parseISO(selectedDate)} // Use parseISO here
                    mode="date"
                    display={Platform.OS === 'ios' ? 'spinner' : 'default'}
                    onChange={handleDateChange}
                />
            )}

            {/* Daily Progress */}
            <DailyProgress
                calories={totalCalories}
                protein={totalProtein}
                carbs={totalCarbs}
                fat={totalFat}
                goals={dailyGoals}
            />
            <Divider style={styles.divider} />

            <Text h4 style={[styles.sectionTitle, { color: theme.colors.text }]}>
                Entries:
            </Text>

            {/* Entries List - Use the memoized and reversed list */}
            <FlatList
                // Use the reversed list for display
                data={currentEntryItems}
                // Key extractor uses the reversed index
                keyExtractor={(item, index) => `${item.food.id}-${index}`} // More robust key
                renderItem={({ item, index: reversedIndex }) => {
                    // Check if the current item is being inline-edited
                    // Need to convert reversedIndex back to originalIndex for comparison
                    const originalIndex = getOriginalIndex(reversedIndex);
                    const isInlineEditing = editingIndex === originalIndex;

                    return (
                        <ListItem.Swipeable
                            bottomDivider
                            leftContent={(reset) => (
                                <Button
                                    title="Edit"
                                    // Pass the reversed index to the modal edit handler
                                    onPress={() => {
                                        handleEditEntryViaModal(item, reversedIndex);
                                        reset();
                                    }}
                                    icon={{ name: "edit", color: "white" }}
                                    buttonStyle={{ minHeight: "100%", backgroundColor: theme.colors.warning }}
                                />
                            )}
                            rightContent={(reset) => (
                                <Button
                                    title="Delete"
                                    // Pass the reversed index to the remove handler
                                    onPress={() => {
                                        handleRemoveEntry(reversedIndex);
                                        reset();
                                    }}
                                    icon={{ name: "delete", color: "white" }}
                                    buttonStyle={{ minHeight: "100%", backgroundColor: theme.colors.error }}
                                />
                            )}
                            containerStyle={{ backgroundColor: theme.colors.background }}
                        >
                            {/* Food Icon */}
                            {foodIcons[item.food.name] ? (
                                <Image
                                    source={{ uri: foodIcons[item.food.name] as string }}
                                    style={styles.foodIcon}
                                    onError={(e) => console.warn(`Failed to load image: ${foodIcons[item.food.name]}`, e.nativeEvent.error)} // Add error handling
                                />
                            ) : (
                                <Icon
                                    name="nutrition-outline"
                                    type="ionicon"
                                    color={theme.colors.grey3}
                                    containerStyle={styles.defaultIconContainer}
                                />
                            )}
                             {/* List Item Content */}
                            <ListItem.Content>
                                <ListItem.Title style={{ color: theme.colors.text, fontWeight: 'bold' }}>
                                    {item.food.name}
                                </ListItem.Title>
                                {isInlineEditing ? (
                                    // Inline Edit View
                                    <View style={styles.inlineEditContainer}>
                                        <Input
                                            value={tempGrams}
                                            onChangeText={setTempGrams}
                                            keyboardType="numeric"
                                            containerStyle={styles.inlineInputContainer}
                                            inputContainerStyle={styles.inlineInputInnerContainer}
                                            inputStyle={[styles.inlineInput, { color: theme.colors.text }]}
                                            autoFocus // Focus when editing starts
                                            selectTextOnFocus // Select text for easy replacement
                                        />
                                        <Text style={styles.inlineInputSuffix}>g</Text>
                                        <Button
                                            type="clear"
                                            onPress={handleSaveInlineEdit} // No index needed here, uses state
                                            icon={<Icon name="checkmark-circle" type="ionicon" color={theme.colors.success} size={24} />}
                                            containerStyle={styles.inlineButtonContainer}
                                        />
                                        <Button
                                            type="clear"
                                            onPress={handleCancelInlineEdit}
                                            icon={<Icon name="close-circle" type="ionicon" color={theme.colors.error} size={24} />}
                                            containerStyle={styles.inlineButtonContainer}
                                        />
                                    </View>
                                ) : (
                                    // Display View
                                    <ListItem.Subtitle
                                        style={{ color: theme.colors.grey1 }}
                                        // Pass the reversed index to start inline editing
                                        onPress={() => handleStartEditing(reversedIndex)}
                                    >
                                        {`${item.grams}g • ${Math.round((item.food.calories / 100) * item.grams)} kcal`}
                                    </ListItem.Subtitle>
                                )}
                            </ListItem.Content>
                            {/* Display calculated calories for the item */}
                            {!isInlineEditing && (
                                <Text style={{ color: theme.colors.grey2 }}>
                                     {/* {`${Math.round((item.food.calories / 100) * item.grams)} kcal`} */}
                                     {/* Removed kcal display here as it's now in subtitle */}
                                </Text>
                            )}
                            {/* Add chevron for visual cue (optional) */}
                           {!isInlineEditing && <ListItem.Chevron color={theme.colors.grey3} />}
                        </ListItem.Swipeable>
                    )
                }}
                // Add message for when the list is empty
                ListEmptyComponent={
                    <View style={styles.emptyListContainer}>
                        <Text style={styles.emptyListText}>No entries for this day yet.</Text>
                        <Text style={styles.emptyListSubText}>Tap the '+' button to add food.</Text>
                    </View>
                }
            />

            {/* FAB to add new entry */}
            <FAB
                icon={<Icon name="add" color="white" />}
                color={theme.colors.primary}
                onPress={() => toggleOverlay()} // Open modal for adding
                placement="right"
                size="large"
                style={styles.fab} // Use style instead of containerStyle for better positioning control maybe? Check docs.
            />

            {/* Add/Edit Entry Modal */}
            <AddEntryModal
                isVisible={isOverlayVisible}
                toggleOverlay={toggleOverlay}
                selectedFood={selectedFood}
                grams={grams}
                setGrams={setGrams}
                foods={foods} // Pass all foods
                handleAddEntry={handleAddEntry} // Handles both add and edit commit
                handleSelectFood={handleSelectFood}
                search={search}
                updateSearch={updateSearch}
                isEditMode={editIndex !== null} // Determine if modal is in edit mode
                 // Pass initial grams if in edit mode (get from original data using original index if needed, or just pass from item)
                initialGrams={
                    editIndex !== null && currentEntryItems[editIndex]
                        ? String(currentEntryItems[editIndex].grams)
                        : grams // Fallback to grams state if needed
                }
            />
        </SafeAreaView>
    );
};

// Styles
const useStyles = makeStyles((theme) => ({
    container: {
        flex: 1,
        backgroundColor: theme.colors.background,
    },
    dateNavigation: {
        flexDirection: "row",
        alignItems: "center",
        justifyContent: "space-between",
        paddingVertical: 8,
        paddingHorizontal: 10,
        borderBottomWidth: 1,
        borderBottomColor: theme.colors.divider,
    },
    dateText: {
        fontSize: 18,
        fontWeight: "bold",
        color: theme.colors.text,
        textAlign: 'center', // Center the date text
    },
    foodIcon: {
        width: 40, // Slightly larger icon
        height: 40,
        marginRight: 15, // More spacing
        borderRadius: 20, // Keep it circular
        resizeMode: "contain", // 'contain' might be better if icons have transparency/padding
        backgroundColor: theme.colors.grey5, // Background color for loading/error state
    },
    defaultIconContainer: {
        width: 40,
        height: 40,
        marginRight: 15,
        borderRadius: 20,
        backgroundColor: theme.colors.grey5,
        alignItems: 'center',
        justifyContent: 'center',
    },
    divider: {
        marginVertical: 10,
    },
    sectionTitle: {
        marginTop: 10,
        marginBottom: 5,
        paddingHorizontal: 15,
        fontWeight: 'bold',
    },
    fab: { // Changed from fabContainer to style
        position: 'absolute', // Keep absolute positioning
        margin: 16, // Standard margin
        right: 0,
        bottom: 0,
    },
     emptyListContainer: {
        flex: 1,
        alignItems: 'center',
        justifyContent: 'center',
        marginTop: 50, // Add some margin from the top
        paddingHorizontal: 20,
    },
    emptyListText: {
        fontSize: 18,
        color: theme.colors.grey2,
        textAlign: 'center',
    },
     emptyListSubText: {
        fontSize: 14,
        color: theme.colors.grey3,
        textAlign: 'center',
        marginTop: 5,
    },
    // Inline Editing Styles
    inlineEditContainer: {
        flexDirection: "row",
        alignItems: "center",
        marginTop: 5, // Add some space below the title
    },
    inlineInputContainer: {
        // flex: 1, // Take up available space
        paddingHorizontal: 0,
         width: 70, // Fixed width for the input
         height: 40, // Match button height
    },
    inlineInputInnerContainer: {
        borderBottomWidth: 1, // Simple underline
         borderColor: theme.colors.primary,
         paddingHorizontal: 6,
         height: '100%', // Fill container height
         justifyContent: 'center',
    },
    inlineInput: {
        fontSize: 14, // Match subtitle size
        paddingVertical: 0, // Remove default padding
        textAlign: 'right', // Align text to right
    },
    inlineInputSuffix: {
         fontSize: 14,
         color: theme.colors.grey1,
         marginLeft: 2, // Space before 'g'
         marginRight: 8, // Space after 'g'
    },
     inlineButtonContainer: {
        marginLeft: 0,
        padding: 0,
        minWidth: 30, // Ensure button tap area
    },
}));

export default DailyEntryScreen;
---------- END DailyEntryScreen.tsx ----------


---------- FoodListScreen.tsx ----------
// FoodListScreen.tsx (Corrected)

import React, { useState, useEffect, useCallback } from "react";
import { View, FlatList, Alert, Platform, Image } from "react-native";
import {
    createFood,
    getFoods,
    updateFood,
    deleteFood,
} from "../services/foodService";
import { Food } from "../types/food";
import { isValidNumberInput, isNotEmpty } from "../utils/validationUtils";
import FoodItem from "../components/FoodItem";
import { Button, SearchBar, useTheme, makeStyles } from "@rneui/themed";
import { FAB } from "@rneui/base";
import { SafeAreaView } from "react-native-safe-area-context";
import AddFoodModal from "../components/AddFoodModal";
import Toast from "react-native-toast-message";
import { useFocusEffect } from "@react-navigation/native";
import { Icon } from "@rneui/base";
import { getFoodIconUrl } from "./../utils/iconUtils";

interface FoodListScreenProps {
    onFoodChange?: () => void;
}

const FoodListScreen: React.FC<FoodListScreenProps> = ({ onFoodChange }) => {
    const [foods, setFoods] = useState<Food[]>([]);
    const [foodIcons, setFoodIcons] = useState<{ [foodName: string]: string | null }>({});
    const [isOverlayVisible, setIsOverlayVisible] = useState(false);
    const [search, setSearch] = useState("");
    const [newFood, setNewFood] = useState<Omit<Food, "id">>({
        name: "",
        calories: 0,
        protein: 0,
        carbs: 0,
        fat: 0,
    });
    const [editFood, setEditFood] = useState<Food | null>(null);
    const [errors, setErrors] = useState<{ [key: string]: string }>({});
    const { theme } = useTheme();
    const styles = useStyles();

    const loadFoodData = useCallback(async () => {
        const loadedFoods = await getFoods();
        setFoods(loadedFoods);
    }, []);

    useFocusEffect(
        useCallback(() => {
            loadFoodData();
        }, [loadFoodData])
    );
    useEffect(() => {
        const loadIcons = async () => {
            const icons: { [foodName: string]: string | null } = {};
            for (const food of foods) {
                const iconUrl = await getFoodIconUrl(food.name);
                icons[food.name] = iconUrl;
            }
            setFoodIcons(icons);
        };

        loadIcons();
    }, [foods]);

    const validateFood = (food: Omit<Food, "id">) => {
        const newErrors: { [key: string]: string } = {};
        if (!isNotEmpty(food.name)) newErrors.name = "Name is required";
        if (!isValidNumberInput(String(food.calories)))
            newErrors.calories = "Invalid input";
        if (!isValidNumberInput(String(food.protein)))
            newErrors.protein = "Invalid input";
        if (!isValidNumberInput(String(food.carbs)))
            newErrors.carbs = "Invalid input";
        if (!isValidNumberInput(String(food.fat)))
            newErrors.fat = "Invalid input";

        return Object.keys(newErrors).length === 0 ? null : newErrors;
    };

    const handleCreateFood = async () => {
        const validationErrors = validateFood(newFood);
        if (validationErrors) {
            setErrors(validationErrors);
            return;
        }
        setErrors({});
        try {
            const createdFood = await createFood(newFood);
            setFoods([...foods, createdFood]);
            setNewFood({
                name: "",
                calories: 0,
                protein: 0,
                carbs: 0,
                fat: 0,
            });
            setIsOverlayVisible(false);
            onFoodChange && onFoodChange();
        } catch (error: any) {
            Alert.alert("Error", error.message || "Failed to create food.");
        }
    };

    const handleUpdateFood = async () => {
        if (!editFood) return;
        const validationErrors = validateFood(editFood);
        if (validationErrors) {
            setErrors(validationErrors);
            return;
        }
        setErrors({});
        try {
            const updated = await updateFood(editFood);
            setFoods(foods.map((f) => (f.id === updated.id ? updated : f)));
            setEditFood(null);
            setIsOverlayVisible(false);
            onFoodChange && onFoodChange();
        } catch (error: any) {
            Alert.alert("Error", error.message || "Failed to update food.");
        }
    };

    const handleDeleteFood = async (foodId: string) => {
        const foodToDelete = foods.find((f) => f.id === foodId);
        if (!foodToDelete) return;
        setFoods(foods.filter((f) => f.id !== foodId));

        try {
            await deleteFood(foodId);
            Toast.show({
                type: "success",
                text1: `${foodToDelete.name} deleted`,
                text2: "Tap to undo",
                position: "bottom",
                bottomOffset: 80,
                onPress: () => handleUndoDeleteFood(foodToDelete),
                visibilityTime: 3000,
            });
            onFoodChange && onFoodChange();
        } catch (error) {
            setFoods((prevFoods) => [...prevFoods, foodToDelete]);
            Alert.alert("Error", "Failed to delete food.");
        }
    };

    const handleUndoDeleteFood = (food: Food) => {
        setFoods((prevFoods) => [...prevFoods, food]);
        Toast.hide();
        onFoodChange && onFoodChange();
    };

    const toggleOverlay = (food?: Food) => {
        if (food) {
            setEditFood(food);
        } else {
            setEditFood(null);
            setNewFood({
                name: "",
                calories: 0,
                protein: 0,
                carbs: 0,
                fat: 0,
            });
        }
        setErrors({});
        setIsOverlayVisible(!isOverlayVisible);
    };

    const updateSearch = (search: string) => setSearch(search);

    const filteredFoods = foods.filter((food) =>
        food.name.toLowerCase().includes(search.toLowerCase())
    );

   const handleInputChange = (
        key: keyof Omit<Food, "id">,
        value: string,
        isEdit: boolean
    ) => {
        if (isEdit) {
            setEditFood((prevEditFood) => {
                if (!prevEditFood) return null; // Or some default empty Food object
                return {
                    ...prevEditFood,
                    [key]: key === "name" ? value : value === "" ? 0 : parseFloat(value),
                };
            });
        } else {
            setNewFood((prevNewFood) => ({
                ...prevNewFood,
                [key]: key === "name" ? value : value === "" ? 0 : parseFloat(value),
            }));
        }
    };

    return (
        <SafeAreaView style={styles.container}>
            <SearchBar
                placeholder="Search Foods..."
                onChangeText={updateSearch}
                value={search}
                platform={Platform.OS === "ios" ? "ios" : "android"}
                containerStyle={styles.searchBarContainer}
                inputContainerStyle={[
                    styles.searchBarInputContainer,
                    { backgroundColor: theme.colors.grey5 },
                ]}
                inputStyle={{ color: theme.colors.text }}
            />
            <FlatList
                data={filteredFoods}
                keyExtractor={(item) => item.id}
                renderItem={({ item }) => (
                    <FoodItem
                        food={item}
                        onEdit={toggleOverlay}
                        onDelete={handleDeleteFood}
                        onUndoDelete={handleUndoDeleteFood}
                        foodIconUrl={foodIcons[item.name]}
                    />
                )}
            />

            <FAB
                icon={{ name: "add", color: "white" }}
                color={theme.colors.primary}
                onPress={() => toggleOverlay()}
                placement="right"
                title=""
                style={{ marginBottom: 10, marginRight: 8 }}
            />

            <AddFoodModal
                isVisible={isOverlayVisible}
                toggleOverlay={toggleOverlay}
                newFood={newFood}
                editFood={editFood}
                errors={errors}
                handleInputChange={handleInputChange}
                handleCreateFood={handleCreateFood}
                handleUpdateFood={handleUpdateFood}
                validateFood={validateFood}
                setErrors={setErrors}
            />
        </SafeAreaView>
    );
};

const useStyles = makeStyles((theme) => ({
    container: {
        flex: 1,
        backgroundColor: theme.colors.background,
    },
    searchBarContainer: {
        backgroundColor: "transparent",
        borderBottomColor: "transparent",
        borderTopColor: "transparent",
        marginBottom: 10,
        padding: 0,
    },
    searchBarInputContainer: {
        borderRadius: 10,
    },
      foodIcon: {
      width: 30,
      height: 30,
      marginRight: 10,
      borderRadius: 15,
      resizeMode: "stretch", // Or 'cover', or 'stretch', see below
    },
}));

export default FoodListScreen;
---------- END FoodListScreen.tsx ----------


---------- SettingsScreen.tsx ----------
// SettingsScreen.tsx
import React, { useState, useEffect, useCallback } from "react";
import { View, ScrollView, Alert } from "react-native";
import { Text, makeStyles } from "@rneui/themed";
import DailyGoalsInput from "../components/DailyGoalsInput";
import DataManagementButtons from "../components/DataManagementButtons";
import ThemeSwitch from "../components/ThemeSwitch";
import StatisticsChart from "../components/StatisticsChart";
import { loadSettings, saveSettings, loadDailyEntries } from "../services/storageService";
import { Settings, Statistics, MacroType, MacroData } from "../types/settings";
import { parseISO, isBefore, formatISO } from "date-fns";
import { formatDate, formatDateReadable } from "../utils/dateUtils"; // Use custom formatDate
import { useTheme } from "@rneui/themed";
import { DailyEntry } from "../types/dailyEntry";
import { useFocusEffect } from "@react-navigation/native";

interface SettingsScreenProps {
  onThemeChange: (theme: "light" | "dark" | "system") => void;
  onDataOperation: () => void;
}

const SettingsScreen: React.FC<SettingsScreenProps> = ({ onThemeChange, onDataOperation }) => {
  const [settings, setSettings] = useState<Settings>({
    theme: "system",
    dailyGoals: {
      calories: 2000,
      protein: 50,
      carbs: 200,
      fat: 70,
    },
  });

  const [statistics, setStatistics] = useState<Statistics>({
    calories: [],
    protein: [],
    carbs: [],
    fat: [],
  });
  // Removed settingsHistory
  const [chartUpdateKey, setChartUpdateKey] = useState(0);
  const [dataChangeCounter, setDataChangeCounter] = useState(0);

  const { theme } = useTheme();
  const styles = useStyles();

  const loadInitialSettings = useCallback(async () => {
    const loadedSettings = await loadSettings();

    setSettings((prevSettings) => ({
      ...prevSettings,
      ...loadedSettings,
      dailyGoals: {
        ...prevSettings.dailyGoals,
        ...(loadedSettings?.dailyGoals || {}),
      },
    }));
  }, []);

  useEffect(() => {
    loadInitialSettings();
  }, [loadInitialSettings]);


  const handleGoalChange = useCallback(async (goalType: MacroType, value: string) => {
    const numericValue = parseFloat(value) || 0;

    setSettings((prevSettings) => {
      const updatedGoals = { ...prevSettings.dailyGoals, [goalType]: numericValue };
      const updatedSettings: Settings = {
        ...prevSettings,
        dailyGoals: updatedGoals,
      };

      // Removed settings history update

      (async () => {
        await saveSettings(updatedSettings); // Simplified save
        setChartUpdateKey((prevKey) => prevKey + 1);
      })();

      return updatedSettings;
    });
    }, []); // Removed settingsHistory dependency


    const getStatisticsData = useCallback(
      (
        dailyEntries: DailyEntry[],
        macro: MacroType,
      ): MacroData[][] => { // Return type annotation
        const intakeData: MacroData[] = [];
        const goalData: MacroData[] = []; // For calories goal

          dailyEntries.forEach((entry) => {
              const entryDate = parseISO(entry.date);
            // Use current settings for all entries
            const relevantGoals = settings.dailyGoals;

            const intakeValue = entry.items.reduce(
              (total, item) => total + (item.food[macro] / 100) * item.grams,
              0
            );
            const goalValue = relevantGoals[macro] ?? 0;

            // Add to intake data (for all macros)
            intakeData.push({ x: entryDate.getTime(), y: intakeValue });

            // Add to goal data (only for calories)
            if (macro === "calories") {
              goalData.push({ x: entryDate.getTime(), y: goalValue });
            }
          });

          // Sort both arrays by date
        intakeData.sort((a, b) => a.x - b.x);
          if (macro === "calories") {
              goalData.sort((a,b) => a.x - b.x);
          }

        // Return as an array of arrays
        if (macro === "calories") {
          return [intakeData, goalData]; // Two series: intake and goal
        } else {
          return [intakeData]; // One series: intake only
        }
      },
      [settings.dailyGoals] // Only settings.dailyGoals as dependency
    );


  const updateStatistics = useCallback(async () => {
    const loadedEntries = await loadDailyEntries();

    // Calculate statistics for each macro
    const updatedStats: Statistics = {
      calories: getStatisticsData(loadedEntries, "calories"),
      protein: getStatisticsData(loadedEntries, "protein"),
      carbs: getStatisticsData(loadedEntries, "carbs"),
      fat: getStatisticsData(loadedEntries, "fat"),
    };

    setStatistics(updatedStats);
  }, [getStatisticsData]);

   useFocusEffect(
    useCallback(() => {
      (async () => {
        await loadInitialSettings();
        await updateStatistics();
      })();
    }, [loadInitialSettings, updateStatistics])
  );

  useEffect(() => {
    (async () => {
      if (dataChangeCounter > 0) {
        await updateStatistics();
        setChartUpdateKey((prevKey) => prevKey + 1);
      }
    })();
  }, [dataChangeCounter, updateStatistics]);

  const handleDataOperation = useCallback(() => {
    setDataChangeCounter((prevCounter) => prevCounter + 1);
  }, []);

  return (
    <ScrollView style={styles.container}>
      <Text h3 style={[styles.sectionTitle, { color: theme.colors.text }]}>General</Text>
      <ThemeSwitch currentTheme={settings.theme} onToggle={onThemeChange} />

      <Text h3 style={[styles.sectionTitle, { color: theme.colors.text }]}>Daily Goals</Text>
      <DailyGoalsInput dailyGoals={settings.dailyGoals} onGoalChange={handleGoalChange} />

      <Text h3 style={[styles.sectionTitle, { color: theme.colors.text }]}>Statistics</Text>
      <StatisticsChart statistics={statistics} key={chartUpdateKey} />

      <Text h3 style={[styles.sectionTitle, { color: theme.colors.text }]}>Data Management</Text>
      <DataManagementButtons onDataOperation={handleDataOperation} />
    </ScrollView>
  );
};
const useStyles = makeStyles((theme) => ({
  container: {
    flex: 1,
    padding: 10,
    backgroundColor: theme.colors.background,
  },
  sectionTitle: {
    marginTop: 20,
    marginBottom: 10,
  },
  button: {
    marginBottom: 10,
  },
}));

export default SettingsScreen;

// components/StatisticsChart.tsx (No changes needed here)
// Remains the same as in the previous, corrected version.  The key changes were in SettingsScreen.
---------- END SettingsScreen.tsx ----------


---------- foodService.ts ----------
// services/foodService.ts
import { Food } from '../types/food';
import { saveFoods, loadFoods } from './storageService';
import 'react-native-get-random-values';
import { v4 as uuidv4 } from 'uuid';

export const createFood = async (foodData: Omit<Food, 'id'>): Promise<Food> => {
  const newFood: Food = {
    id: uuidv4(),
    ...foodData,
  };
  const foods = await loadFoods();
  foods.push(newFood);
  await saveFoods(foods);
  return newFood;
};

export const getFoods = async (): Promise<Food[]> => {
  return loadFoods();
};

export const updateFood = async (updatedFood: Food): Promise<Food> => {
  const foods = await loadFoods();
  const index = foods.findIndex((f) => f.id === updatedFood.id);
  if (index === -1) {
    throw new Error('Food not found'); // Throw an error if not found
  }
  foods[index] = updatedFood;
  await saveFoods(foods);
  return updatedFood;
};

export const deleteFood = async (foodId: string): Promise<void> => {
  const foods = await loadFoods();
  const filteredFoods = foods.filter((f) => f.id !== foodId);
  await saveFoods(filteredFoods);
};
---------- END foodService.ts ----------


---------- storageService.ts ----------
// services/storageService.ts (Modified for Timestamps)
import AsyncStorage from '@react-native-async-storage/async-storage';
import { DailyEntry } from '../types/dailyEntry';
import { Food } from '../types/food';
import { Settings } from '../types/settings';
import { formatISO, parseISO } from 'date-fns';


const DAILY_ENTRIES_KEY = 'dailyEntries';
const FOODS_KEY = 'foods';
const SETTINGS_KEY = 'settings';
const RECENT_FOODS = 'recentFoods';


export const saveDailyEntries = async (entries: DailyEntry[]): Promise<void> => {
  try {
    await AsyncStorage.setItem(DAILY_ENTRIES_KEY, JSON.stringify(entries));
  } catch (error) {
    console.error('Error saving daily entries:', error);
    throw error;
  }
};

export const loadDailyEntries = async (): Promise<DailyEntry[]> => {
  try {
    const entriesJson = await AsyncStorage.getItem(DAILY_ENTRIES_KEY);
    return entriesJson ? JSON.parse(entriesJson) : [];
  } catch (error) {
    console.error('Error loading daily entries:', error);
    return [];
  }
};

export const saveFoods = async (foods: Food[]): Promise<void> => {
  try {
    await AsyncStorage.setItem(FOODS_KEY, JSON.stringify(foods));
  } catch (error) {
    console.error('Error saving foods:', error);
    throw error; // Re-throw the error
  }
};

export const loadFoods = async (): Promise<Food[]> => {
  try {
    const foodsJson = await AsyncStorage.getItem(FOODS_KEY);
    return foodsJson ? JSON.parse(foodsJson) : [];
  } catch (error) {
    console.error('Error loading foods:', error);
    return []; // Return an empty array on error
  }
};



export const saveSettings = async (settings: Settings): Promise<void> => {
  try {
    await AsyncStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
  } catch (error) {
    console.error('Error saving settings:', error);
    throw error;
  }
};

export const loadSettings = async (): Promise<Settings> => {
  try {
    const settingsJson = await AsyncStorage.getItem(SETTINGS_KEY);
    const loadedSettings = settingsJson ? JSON.parse(settingsJson) : {};

    // Apply defaults and ensure structure
    const defaultSettings: Settings = {
      theme: 'system',
      dailyGoals: { calories: 2000, protein: 50, carbs: 200, fat: 70 },
      settingsHistory: [] // Ensure settingsHistory exists
    };


    return {
      ...defaultSettings, // Start with defaults
        ...loadedSettings, // Override with loaded values
        dailyGoals: {
          ...defaultSettings.dailyGoals,  //ensure no fields missing from daily goals
            ...(loadedSettings.dailyGoals || {}) // And override *those* with any loaded dailyGoals
        }
    }

  } catch (error: any) {
    console.error('Error loading settings:', error);

    // *** KEY CHANGE: Handle "Row too big" error ***
    if (error.message.includes('Row too big')) {
      console.warn('Detected oversized settings data. Clearing settings.');
      try {
        await AsyncStorage.removeItem(SETTINGS_KEY); // Clear the oversized data
      } catch (clearError) {
        console.error('Error clearing oversized settings:', clearError);
        // You might want to handle this more gracefully, e.g., by showing an error to the user.
      }
    }

    // Return defaults if loading fails (or after clearing)
    return {
      theme: 'system',
      dailyGoals: { calories: 2000, protein: 50, carbs: 200, fat: 70 },
      settingsHistory: [] // Ensure settingsHistory exists in default
    };
  }
};

export const clearAllData = async (): Promise<void> => {
  try {
    await AsyncStorage.clear();
  } catch (error) {
    console.error('Error clearing data:', error);
    throw error;
  }
};

// Function to save recent foods
export const saveRecentFoods = async (foods: Food[]) => {
    try {
        await AsyncStorage.setItem(RECENT_FOODS, JSON.stringify(foods));
    } catch (error) {
        console.error('Error saving recent foods:', error);
        throw error; // Important: Re-throw the error so calling code knows it failed
    }
};

// Function to load recent foods
export const loadRecentFoods = async (): Promise<Food[]> => {
    try {
        const foods = await AsyncStorage.getItem(RECENT_FOODS);
        return foods ? JSON.parse(foods) : [];
    } catch (error) {
        console.error('Error loading recent foods:', error);
        return []; // Return empty array on error, don't throw
    }
};
---------- END storageService.ts ----------


---------- tsconfig.json ----------
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true

  }
}
---------- END tsconfig.json ----------


---------- dailyEntry.ts ----------
// types/dailyEntry.ts (Modified)
import { Food } from "./food";

export interface DailyEntryItem {
  food: Food;
  grams: number;
}

export interface DailyEntry {
  date: string; // YYYY-MM-DD format
  items: DailyEntryItem[];
  goals?: {  // Optional goals
    calories?: number;
    protein?: number;
    carbs?: number;
    fat?: number;
  };
}

export interface FoodItem { //No changes here.
    id: string;
    name: string;
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
  }
---------- END dailyEntry.ts ----------


---------- food.ts ----------
// types/food.ts
export interface Food {
  id: string;
  name: string;
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
  // category: string;  // REMOVED
}
---------- END food.ts ----------


---------- openRouterTypes.ts ----------
// src/utils/types.ts

// =====================================
// Consolidated OpenRouter Type Definitions
// =====================================

// --- Content Parts (for multi-modal input like images) ---
export type OpenRouterContentPart =
  | { type: "text"; text: string }
  | { type: "image_url"; image_url: { url: string; detail?: "low" | "high" | "auto" } };

// --- Message Structure ---
// Allows content to be a simple string OR an array of content parts for vision models
export interface OpenRouterMessage {
  role: "user" | "assistant" | "system";
  content: string | OpenRouterContentPart[]; // Consolidated definition
  name?: string; // Optional name field
}

// --- Choice Structure (within the response) ---
// This structure aligns with standard Chat Completion APIs (like OpenAI/OpenRouter)
export interface OpenRouterChatChoice {
  index: number;
  message: OpenRouterMessage; // Contains the actual message content and role
  logprobs?: any | null; // Optional log probabilities (use a specific type if known)
  finish_reason: string | null; // Can be null sometimes
  // text?: string; // Usually the content is inside message.content, keep optional if some models return it differently
}

// --- API Usage Information ---
export interface OpenRouterUsage {
  prompt_tokens: number;
  completion_tokens: number;
  total_tokens: number;
}

// --- Main Chat Completion Response Structure ---
// Consolidates the fields from both previous declarations
export interface OpenRouterChatCompletionResponse {
  id: string;
  object: string; // Typically "chat.completion"
  created: number; // Timestamp
  model: string; // Model used
  choices: OpenRouterChatChoice[]; // Array of choices using the defined structure
  usage?: OpenRouterUsage; // Usage information is often optional
  // Add any other relevant fields you might encounter from OpenRouter
  // system_fingerprint?: string; // Example optional field
}


// =====================================
// Removed Redundant/Conflicting Declarations:
// =====================================

/*
// REMOVED - Duplicate/Outdated OpenRouterMessage
export interface OpenRouterMessage {
  role: "user" | "assistant" | "system"; // Add system role
  content: string;
}

// REMOVED - Less standard choice structure (often message.content is used instead of top-level text)
export interface OpenRouterChoice {
  text: any; // 'any' is vague, content is usually in message
  message: OpenRouterMessage; // This duplicates content info if 'text' is also present
  finish_reason?: string;
  index?: number;
}

// REMOVED - Duplicate/Simpler OpenRouterChatCompletionResponse
export interface OpenRouterChatCompletionResponse {
  choices: OpenRouterChoice[]; // Used the less standard choice type
  id?: string;
  created?: number;
  model?: string;
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}
*/
---------- END openRouterTypes.ts ----------


---------- settings.ts ----------
// types/settings.ts (Modified)
export const macros = ["calories", "protein", "carbs", "fat"] as const;
export type MacroType = (typeof macros)[number];

export interface MacroData {
  x: number; // Timestamp
  y: number; // Macro value
}

export interface Statistics {
  calories: MacroData[][];
  protein: MacroData[][];
  carbs: MacroData[][];
  fat: MacroData[][];
}

export interface Settings {
  theme: "light" | "dark" | "system";
  dailyGoals: {
    [key in MacroType]: number;
  };
  settingsHistory?: { date: number; dailyGoals: { [key in MacroType]: number } }[]; // CHANGED: Store timestamp
}

export interface SettingsScreenProps {
  onThemeChange: (theme: "light" | "dark" | "system") => void;
}
---------- END settings.ts ----------


---------- ai.ts ----------
// src/utils/ai.ts
import {
  OpenRouterChatCompletionResponse,
  OpenRouterMessage,
} from "../types/openRouterTypes";

const OPENROUTER_API_URL = "https://openrouter.ai/api/v1/chat/completions";

// No API_KEY constant here anymore

export async function getChatCompletion(
  model: string,
  messages: OpenRouterMessage[],
  responseFormat: "json_object" | "text" = "text",
  apiKey?: string // apiKey is now optional, for easier testing
): Promise<OpenRouterChatCompletionResponse> {
  // Get the API key from the environment variable.
  const effectiveApiKey = apiKey || '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';

  const response = await fetch(OPENROUTER_API_URL, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${effectiveApiKey}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      model,
      messages,
      response_format:
        responseFormat === "json_object" ? { type: "json_object" } : undefined,
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(
      `API request failed with status code ${response.status}: ${errorText}`
    );
  }

  const data: OpenRouterChatCompletionResponse = await response.json();

  if (
    !data.choices ||
    data.choices.length === 0 ||
    !data.choices[0].message ||
    !data.choices[0].message.content
  ) {
    throw new Error("Could not find the expected content in the response.");
  }

  return data;
}

---------- END ai.ts ----------


---------- dateUtils.ts ----------
// utils/dateUtils.ts (Modified)
import { format, parseISO, formatISO } from 'date-fns';

// Format a timestamp as YYYY-MM-DD (for display and storage)
export const formatDate = (timestamp: number): string => {
    return formatISO(timestamp, { representation: 'date' });
};

// Format a timestamp as a readable date (for display)
export const formatDateReadable = (timestamp: number | string): string => {
    if (typeof timestamp === 'string') {
        return timestamp; // if it is a string, do nothing.
    }
  return format(timestamp, 'MMMM dd, yyyy');
};

// Get today's date as a timestamp
export const getTodayDateString = (): string => {
  return formatISO(new Date(), { representation: 'date' });
};
---------- END dateUtils.ts ----------


---------- iconUtils.ts ----------
// utils/iconUtils.ts

import AsyncStorage from '@react-native-async-storage/async-storage';

const API_KEY = '25170800-59d7530d1a73abe661796e093';
const API_ENDPOINT = "https://pixabay.com/api/";

// Define the cache entry type
type CacheEntry = {
  url: string | null;
  expiry: number;
};

// In-memory cache for fast access
const memoryCache = new Map<string, CacheEntry>();

// Cache TTL: 3 days in milliseconds
const CACHE_TTL = 3 * 24 * 60 * 60 * 1000;

// Prefix for AsyncStorage keys
const STORAGE_KEY_PREFIX = 'foodIconCache_';

export const getFoodIconUrl = async (foodName: string): Promise<string | null> => {
  const cacheKey = foodName.toLowerCase();
  const now = Date.now();

  // 1. Check the in-memory cache first.
  const memoryEntry = memoryCache.get(cacheKey);
  if (memoryEntry && memoryEntry.expiry > now) {
    return memoryEntry.url;
  }

  // 2. Check persistent AsyncStorage.
  try {
    const storedValue = await AsyncStorage.getItem(STORAGE_KEY_PREFIX + cacheKey);
    if (storedValue) {
      const parsed: CacheEntry = JSON.parse(storedValue);
      if (parsed.expiry > now) {
        // Update in-memory cache with the persistent value.
        memoryCache.set(cacheKey, parsed);
        return parsed.url;
      } else {
        // Remove expired entry.
        await AsyncStorage.removeItem(STORAGE_KEY_PREFIX + cacheKey);
      }
    }
  } catch (error) {
    console.error('Error accessing AsyncStorage:', error);
  }
  

  // 3. No valid cached result, fetch from the API.
  try {
    const query = encodeURIComponent(`${foodName} minimal icon transparent`);
    const url = `${API_ENDPOINT}?key=${API_KEY}&q=${query}&image_type=vector&category=food&safesearch=true`;
    
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    
    const data = await response.json();
    let iconUrl: string | null = null;
    
    if (data.hits && data.hits.length > 0) {
      const filtered = data.hits.filter((hit: any) => {
        const hitUrl: string = hit.webformatURL.toLowerCase();
        return (hitUrl.endsWith('.png') || hitUrl.includes('svg')) &&
               hit.tags?.toLowerCase().includes(foodName.toLowerCase());
      });
      
      if (filtered.length > 0) {
        iconUrl = filtered[0].webformatURL;
      }
    }
    
    // Create a new cache entry with expiry.
    const newCacheEntry: CacheEntry = { url: iconUrl, expiry: now + CACHE_TTL };
    
    // Update both in-memory and persistent caches.
    memoryCache.set(cacheKey, newCacheEntry);
    try {
      await AsyncStorage.setItem(STORAGE_KEY_PREFIX + cacheKey, JSON.stringify(newCacheEntry));
    } catch (error) {
      console.error('Error saving to AsyncStorage:', error);
    }
    
    return iconUrl;
  } catch (error) {
    console.error("Error fetching food icon:", error);
    return null;
  }
};

---------- END iconUtils.ts ----------


---------- macros.ts ----------
// utils/macros.ts
import * as FileSystem from "expo-file-system";
// Use the React Native compatible library
import MimeTypes from 'react-native-mime-types';
import {
  OpenRouterChatCompletionResponse,
  OpenRouterMessage,
  // Make sure these types are correctly defined in your types file
} from "../types/openRouterTypes"; // Adjust path if needed (e.g., "../utils/types")

// Interfaces
export interface Macros {
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
}

export interface MacrosWithFoodName extends Macros {
  foodName: string;
}


// --- MOCK/Placeholder getChatCompletion ---
// Replace this with your actual implementation if it lives elsewhere
async function getChatCompletion(model: string, messages: OpenRouterMessage[], response_format?: string): Promise<OpenRouterChatCompletionResponse> {
    console.log("Mock getChatCompletion called for model:", model);
    const effectiveApiKey = "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"; // Use your key securely

    const body: any = {
        model: model,
        messages: messages,
    };
    if (response_format) {
        body.response_format = { type: response_format };
    }

    const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
        method: "POST",
        headers: {
            "Authorization": `Bearer ${effectiveApiKey}`,
            "Content-Type": "application/json",
        },
        body: JSON.stringify(body),
    });
    if (!response.ok) {
        const errorText = await response.text();
        console.error("Mock API Error:", errorText);
        throw new Error(`Mock API request failed: ${response.status} ${errorText}`);
    }
    const data = await response.json();
    return data as OpenRouterChatCompletionResponse;
}
// --- END MOCK ---


// Function to get macros from text description
export async function getMacrosForRecipe(
    foodName: string,
    Ingredients: string
): Promise<Macros> {
    const prompt = `
      Calculate the macros per 100g for the following food. Output ONLY a JSON object with the keys "calories", "protein", "carbs", and "fat". Do NOT include any other text, explanations, or calculations.

      Food: ${foodName}
      Ingredients:
      ${Ingredients}
      `;

    // Content here is definitely a string
    const messages: OpenRouterMessage[] = [{ role: "user", content: prompt }];

    try {
        const response = await getChatCompletion(
            "google/gemini-2.0-flash-thinking-exp-1219:free", // Model for text
            messages,
            "json_object" // Request JSON output
        );

        if (!response.choices || response.choices.length === 0 || !response.choices[0].message) {
            throw new Error("Invalid response structure from AI.");
        }

        const messageContent = response.choices[0].message.content;
        if (typeof messageContent === 'string') {
            const cleanedContent = messageContent.trim().replace(/^```json\s*|\s*```$/g, "");
            try {
                 const macroInfo: Macros = JSON.parse(cleanedContent);
                 if (typeof macroInfo.calories !== 'number' || typeof macroInfo.protein !== 'number' || typeof macroInfo.carbs !== 'number' || typeof macroInfo.fat !== 'number') {
                    console.error("Parsed JSON has incorrect structure (recipe):", macroInfo);
                    throw new Error("AI returned data in an unexpected format.");
                 }
                 return macroInfo;
            } catch (parseError) {
                 if (parseError instanceof SyntaxError) {
                    console.error("Error: The recipe response content was not valid JSON.", parseError);
                    console.error("Cleaned content:", cleanedContent);
                    throw new Error("Invalid JSON response from AI.");
                 }
                 throw parseError;
            }
        } else {
            console.error("Error: AI recipe response content was not a string:", messageContent);
            throw new Error("Unexpected AI response format: content is not a string.");
        }

    } catch (error) {
        console.error("Error fetching/processing macros for recipe:", error);
        if (error instanceof Error && (error.message.startsWith("Invalid JSON") || error.message.startsWith("Unexpected AI response"))) {
             throw error; // Re-throw specific errors
        }
        throw new Error(`Failed to get macros for recipe: ${error instanceof Error ? error.message : String(error)}`);
    }
}

// Utility function to convert a file URI to base64
export async function getBase64FromUri(uri: string): Promise<string> {
  try {
    const base64 = await FileSystem.readAsStringAsync(uri, {
      encoding: FileSystem.EncodingType.Base64,
    });
    return base64;
  } catch (error) {
    console.error(`Failed to convert file to base64: ${uri}`, error);
    throw new Error(`Failed to convert file to base64: ${error}`);
  }
}

// Function to get macros from an image file
export async function getMacrosForImageFile(asset: {
  uri: string;
  fileName?: string; // Optional filename from ImagePicker
  type?: string; // Optional MIME type from ImagePicker
}): Promise<MacrosWithFoodName> {
  const prompt = `
    Analyze the food in the image provided and guess the food name, ingredients, and their approximate proportions based on visual estimation or nutrients table if it exists in the image.
    Some nutrients tables might have nutrients per portion in addition to 100g one, be careful to take only the 100g one.
    Then, calculate the estimated macros per 100g (calories, protein, carbs, fat) for the food.
    Output ONLY a JSON object with the keys "foodName", "calories", "protein", "carbs", and "fat".
    Do NOT include any extra text, explanations, calculations, or markdown formatting like \`\`\`json.
    Just the raw JSON object.
  `;

  // 1. Get Base64 Data
  let base64File: string;
  try {
      base64File = await getBase64FromUri(asset.uri);
  } catch (err) {
      console.error("Error getting base64 from URI:", err);
      throw new Error("Failed to read image file.");
  }

  // 2. Determine MIME Type using react-native-mime-types
  let mimeType = asset.type; // Prioritize type from ImagePicker asset

  if (!mimeType && asset.fileName) {
      console.warn(`mimeType missing from ImagePicker asset (fileName: ${asset.fileName}). Attempting lookup.`);
      // Use the compatible library's lookup function
      mimeType = MimeTypes.lookup(asset.fileName) || undefined; // Returns false if not found, convert to undefined
  }

  // Default to jpeg if still undetermined (last resort)
  if (!mimeType) {
      console.warn(`Could not determine mimeType for ${asset.fileName}. Defaulting to image/jpeg.`);
      mimeType = 'image/jpeg';
  }

  console.log(`Using mimeType: ${mimeType} for image processing.`);
  const imageUrl = `data:${mimeType};base64,${base64File}`;

  // 3. Construct Messages for Vision Model
  const messages: OpenRouterMessage[] = [
    {
      role: "user",
      content: [ // Content is an array for multi-modal
        { type: "text", text: prompt },
        {
          type: "image_url",
          image_url: {
            url: imageUrl,
          },
        },
      ],
    },
  ];

  // 4. Prepare API Request Body
  const bodyData = {
    model: "google/gemini-2.0-flash-thinking-exp-1219:free", // DO NOT CHANGE MODEL per user request
    messages: messages,
    response_format: { type: "json_object" },
    // max_tokens: 512, // Optional: Consider adding if responses get cut off
  };

  // 5. API Key (Use secure storage in production!)
  const effectiveApiKey =
    "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";
  if (!effectiveApiKey) {
    throw new Error("API key is missing");
  }

  // 6. Make API Call and Process Response
  try {
    console.log("Sending request to OpenRouter vision model...");
    const response = await fetch(
      "https://openrouter.ai/api/v1/chat/completions",
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${effectiveApiKey}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify(bodyData),
      }
    );

    const responseBodyText = await response.text(); // Read body once

    if (!response.ok) {
      console.error("OpenRouter API Error Response Text:", responseBodyText);
      // Attempt to parse error for more details if possible
      try {
          const errorJson = JSON.parse(responseBodyText);
          console.error("Parsed API Error:", errorJson);
      } catch (e) { /* Ignore parsing error if body wasn't JSON */ }
      throw new Error(
        `API request failed with status ${response.status}: ${responseBodyText}`
      );
    }

    console.log("OpenRouter API Success Response Text:", responseBodyText);
    const data: OpenRouterChatCompletionResponse = JSON.parse(responseBodyText);

    // Validate response structure
    if (!data.choices || data.choices.length === 0 || !data.choices[0].message) {
         console.error("API Response missing choices or message:", data);
         throw new Error("Could not find message structure in the AI response.");
    }

    const choice = data.choices[0];
    const messageContent = choice.message.content; // Type is string | OpenRouterContentPart[]

    // Use Type Guard to ensure response content is a string
    let responseContentString: string;
    if (typeof messageContent === 'string') {
        responseContentString = messageContent;
    }
    // Less likely fallback (check if needed based on testing)
    // else if (typeof (choice as any).text === 'string') {
    //     console.warn("Using fallback 'text' field from choice.");
    //     responseContentString = (choice as any).text;
    // }
    else {
        // Handle unexpected content format (array, null, etc.)
        console.error("Error: AI response content was not a string as expected:", messageContent);
        throw new Error("Unexpected AI response format: content is not a string.");
    }

    console.log("Raw AI content string:", responseContentString);

    // Clean and Parse the JSON String
    const cleanedContent = responseContentString.trim().replace(/^```json\s*|\s*```$/g, "");

    try {
        const macroInfo: MacrosWithFoodName = JSON.parse(cleanedContent);
        // Validate parsed object structure
        if (typeof macroInfo.foodName !== 'string' ||
            typeof macroInfo.calories !== 'number' ||
            typeof macroInfo.protein !== 'number' ||
            typeof macroInfo.carbs !== 'number' ||
            typeof macroInfo.fat !== 'number') {
            console.error("Parsed JSON has incorrect structure (image):", macroInfo);
            throw new Error("AI returned data in an unexpected format.");
        }
        console.log('macroInfo: ', macroInfo);
        return macroInfo;
    } catch (parseError) {
        if (parseError instanceof SyntaxError) {
            console.error("Error: The AI response was not valid JSON after cleaning.");
            console.error("Cleaned content:", cleanedContent);
            throw new Error("Invalid JSON response from AI.");
        }
        throw parseError; // Re-throw other parsing errors
    }

  } catch (error) {
    // Handle fetch/network errors
    if (error instanceof TypeError && error.message === 'Network request failed') {
       console.error("Network Error: Could not connect to the API. Check internet connection and OpenRouter status.");
       throw new Error("Network error: Failed to reach AI service.");
    }
    // Log and re-throw other errors
    console.error("Error processing image analysis request:", error);
    if (error instanceof Error && (error.message.startsWith("Invalid JSON") || error.message.startsWith("Unexpected AI response") || error.message.startsWith("Could not find") || error.message.startsWith("API request failed"))) {
         throw error; // Re-throw specific known error types
    }
    // General fallback error
    throw new Error(`Failed to get macros from image: ${error instanceof Error ? error.message : String(error)}`);
  }
}
---------- END macros.ts ----------


---------- units.ts ----------
// --- NEW FUNCTION ---

import { OpenRouterMessage } from "../types/openRouterTypes";
import { getChatCompletion } from "./ai";

/**
 * Estimates the weight in grams based on a natural language description and food item.
 * @param foodName The name of the food item (e.g., "Apple").
 * @param quantityDescription The natural language description (e.g., "2 small", "1 cup chopped").
 * @returns A promise that resolves with the estimated weight in grams (number).
 */
export async function getGramsFromNaturalLanguage(
    foodName: string,
    quantityDescription: string
): Promise<number> {
    const prompt = `
    Estimate the approximate weight in grams for the following quantity of food.
    Food: "${foodName}"
    Quantity: "${quantityDescription}"

    Respond with ONLY the estimated numeric value in grams. Do not include units (like 'g' or 'grams'), explanations, or any other text. Just the number.
    Example response: 150
    `;

    const messages: OpenRouterMessage[] = [{ role: "user", content: prompt }];

    try {
        // Using a capable but potentially free/cheap model
        const response = await getChatCompletion(
            "google/gemini-2.0-flash-thinking-exp-1219:free", // Or try "mistralai/mistral-7b-instruct:free", "nousresearch/nous-hermes-2-mixtral-8x7b-dpo:free"
            messages,
            "text" // Expecting plain text number
        );

        const content = response.choices[0].message.content.trim();

        // Try to parse the response as a number
        const estimatedGrams = parseFloat(content);

        if (isNaN(estimatedGrams)) {
            console.error(`AI response was not a valid number: "${content}"`);
            throw new Error("AI did not return a valid number for grams.");
        }

        return Math.round(estimatedGrams); // Return rounded integer grams

    } catch (error) {
        console.error("Error getting grams estimation from AI:", error);
        // Re-throw the error so the calling component can handle it
        throw error;
    }
}
---------- END units.ts ----------


---------- validationUtils.ts ----------
// utils/validationUtils.ts

export const isValidNumberInput = (value: string): boolean => {
    return /^[0-9]*(\.[0-9]*)?$/.test(value) && !isNaN(parseFloat(value));
  };
  
  export const isNotEmpty = (value: string): boolean => {
    return value.trim() !== '';
  };
---------- END validationUtils.ts ----------

