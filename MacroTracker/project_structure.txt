.gitignore
app.json
App.tsx
assets/
  adaptive-icon.png
  favicon.png
  icon.png
  splash-icon.png
components/
  ConfirmationModal.tsx
  DailyProgress.tsx
  FoodItem.tsx
index.ts
navigation/
  AppNavigator.tsx
package.json
projectToFile.js
screens/
  DailyEntryScreen.tsx
  FoodListScreen.tsx
  SettingsScreen.tsx
services/
  foodService.ts
  storageService.ts
tsconfig.json
types/
  dailyEntry.ts
  food.ts
utils/
  dateUtils.ts
  validationUtils.ts

---------- .gitignore ----------
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

---------- END .gitignore ----------


---------- app.json ----------
{
  "expo": {
    "name": "MacroTracker",
    "slug": "MacroTracker",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "automatic",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "assetBundlePatterns": ["**/*"],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.yourcompany.macrotracker"
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "package": "com.yourcompany.macrotracker"
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      [
        "expo-document-picker",
        {
          "appleTeamId": "YOUR_TEAM_ID"
        }
      ]
    ]
  }
}

---------- END app.json ----------


---------- App.tsx ----------
// App.tsx
import 'react-native-get-random-values'; // <-- MUST BE FIRST
import React from 'react';
import AppNavigator from './navigation/AppNavigator';
import { SafeAreaProvider } from 'react-native-safe-area-context';

const App = () => {
  return (
    <SafeAreaProvider>
      <AppNavigator />
    </SafeAreaProvider>
  );
};

export default App;
---------- END App.tsx ----------


---------- adaptive-icon.png ----------
(Image file - content not included)
---------- END adaptive-icon.png ----------


---------- favicon.png ----------
(Image file - content not included)
---------- END favicon.png ----------


---------- icon.png ----------
(Image file - content not included)
---------- END icon.png ----------


---------- splash-icon.png ----------
(Image file - content not included)
---------- END splash-icon.png ----------


---------- ConfirmationModal.tsx ----------
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Overlay, Button, Input, Text } from '@rneui/themed';

interface ConfirmationModalProps {
    isVisible: boolean;
    onCancel: () => void;
    onConfirm: () => void;
    confirmationText: string;
    setConfirmationText: (text: string) => void;
}
const ConfirmationModal: React.FC<ConfirmationModalProps> = ({ isVisible, onCancel, onConfirm, confirmationText, setConfirmationText }) => {


    return (
        <Overlay isVisible={isVisible} onBackdropPress={onCancel}>
            <View style={styles.container}>
                <Text style={styles.text}>Type "CLEAR DATA" to confirm:</Text>
                <Input
                    placeholder="Enter confirmation text"
                    value={confirmationText}
                    onChangeText={setConfirmationText}
                />
                <View style={styles.buttonContainer}>
                    <Button title="Cancel" onPress={onCancel} type="outline" buttonStyle={styles.button}/>
                    <Button title="Confirm" onPress={onConfirm} color="error" buttonStyle={styles.button}/>
                </View>
            </View>
        </Overlay>
    );
};
const styles = StyleSheet.create({
    container: {
        padding: 20,
        width: 300,
    },
    text: {
        marginBottom: 10
    },
    buttonContainer: {
        flexDirection: 'row',
        justifyContent: 'space-around',
        marginTop: 20,
    },
    button: {
        width: 100
    }
});

export default ConfirmationModal;
---------- END ConfirmationModal.tsx ----------


---------- DailyProgress.tsx ----------
// components/DailyProgress.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, useTheme } from '@rneui/themed';

interface DailyProgressProps {
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
  goals: {
    calories?: number;
    protein?: number;
    carbs?: number;
    fat?: number;
  };
}

const DailyProgress: React.FC<DailyProgressProps> = ({ calories, protein, carbs, fat, goals }) => {
  const { theme } = useTheme();

  const calorieProgress = goals.calories ? Math.min(calories / goals.calories, 1) : 0;
  const proteinProgress = goals.protein ? Math.min(protein / goals.protein, 1) : 0;
  const carbsProgress = goals.carbs ? Math.min(carbs / goals.carbs, 1) : 0;
  const fatProgress = goals.fat ? Math.min(fat / goals.fat, 1) : 0;

  return (
    <View style={styles.container}>
      <View style={styles.macroContainer}>
        <Text style={styles.macroLabel}>Calories: {Math.round(calories)} / {goals.calories || 0}</Text>
        <View style={[styles.progressBar, { width: `${calorieProgress * 100}%`, backgroundColor: theme.colors.primary }]} />
      </View>
      <View style={styles.macroContainer}>
        <Text style={styles.macroLabel}>Protein: {Math.round(protein)}g / {goals.protein || 0}g</Text>
        <View style={[styles.progressBar, { width: `${proteinProgress * 100}%`, backgroundColor: 'green' }]} />
      </View>
      <View style={styles.macroContainer}>
        <Text style={styles.macroLabel}>Carbs: {Math.round(carbs)}g / {goals.carbs || 0}g</Text>
        <View style={[styles.progressBar, { width: `${carbsProgress * 100}%`, backgroundColor: 'orange' }]} />
      </View>
      <View style={styles.macroContainer}>
        <Text style={styles.macroLabel}>Fat: {Math.round(fat)}g / {goals.fat || 0}g</Text>
        <View style={[styles.progressBar, { width: `${fatProgress * 100}%`, backgroundColor: 'blue' }]} />
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: 20,
  },
  macroContainer: {
    marginBottom: 10,
  },
  macroLabel: {
    marginBottom: 5,
  },
  progressBar: {
    height: 10,
    borderRadius: 5,
  },
});

export default DailyProgress;
---------- END DailyProgress.tsx ----------


---------- FoodItem.tsx ----------
// components/FoodItem.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Food } from '../types/food';
import { ListItem, Icon, Text, Button } from '@rneui/themed';

interface FoodItemProps {
  food: Food;
  onEdit: (food: Food) => void;
  onDelete: (foodId: string) => void;
}

const FoodItem: React.FC<FoodItemProps> = ({ food, onEdit, onDelete }) => {
  return (
    <ListItem.Swipeable
      bottomDivider
      leftContent={(reset) => (
          <Button
              title="Edit"
              onPress={() => {onEdit(food); reset()}}
              icon={{ name: 'edit', color: 'white' }}
              buttonStyle={{ minHeight: '100%', backgroundColor: 'orange' }}
          />
      )}
      rightContent={(reset) => (
        <Button
          title="Delete"
          onPress={() => {onDelete(food.id); reset()}}
          icon={{ name: 'delete', color: 'white' }}
          buttonStyle={{ minHeight: '100%', backgroundColor: 'red' }}
        />
      )}
    >
        <ListItem.Content>
            <ListItem.Title>{food.name}</ListItem.Title>
            <ListItem.Subtitle>
                {`Calories: ${food.calories}, Protein: ${food.protein}, Carbs: ${food.carbs}, Fat: ${food.fat}`}
            </ListItem.Subtitle>
        </ListItem.Content>
        <ListItem.Chevron />
    </ListItem.Swipeable>
  );
};

export default FoodItem;
---------- END FoodItem.tsx ----------


---------- index.ts ----------
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);

---------- END index.ts ----------


---------- AppNavigator.tsx ----------
// navigation/AppNavigator.tsx
import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { NavigationContainer, DefaultTheme, DarkTheme } from '@react-navigation/native';
import { useColorScheme } from 'react-native';
import { ThemeProvider, createTheme, Icon, useTheme } from '@rneui/themed';
import DailyEntryScreen from '../screens/DailyEntryScreen';
import FoodListScreen from '../screens/FoodListScreen';
import SettingsScreen from '../screens/SettingsScreen';
import { loadSettings } from '../services/storageService';

const Tab = createBottomTabNavigator();

// Define a custom theme interface that extends the RNE UI Theme
interface MyTheme {
  mode: 'light' | 'dark';
  colors: {
    primary: string;
    background: string;
    grey5: string;
    white: string;
    grey4: string;
    success: string;
    black: string;
    // Add other custom colors if needed
  };
  // You can add other theme properties here if needed, like fonts, spacing, etc.
}

const lightTheme: MyTheme = {
  mode: 'light',
  colors: {
    primary: '#007bff',
    background: '#ffffff',
    grey5: '#f2f2f2',
    white: '#ffffff',
    grey4: '#cccccc',
    success: '#28a745',
    black: '#000000',
  },
};

const darkTheme: MyTheme = {
  mode: 'dark',
  colors: {
    primary: '#007bff',
    background: '#121212',
    grey5: '#2c2c2c',
    white: '#ffffff',
    grey4: '#333333',
    success: '#28a745',
    black: '#000000',
  },
};

const AppNavigator = () => {
  const [themeMode, setThemeMode] = React.useState<'light' | 'dark' | 'system'>('system');

  React.useEffect(() => {
    const loadInitialSettings = async () => {
      const settings = await loadSettings();
      setThemeMode(settings.theme);
    };
    loadInitialSettings();
  }, []);

  const colorScheme = useColorScheme();
  const currentTheme = themeMode === 'system' ? (colorScheme === 'dark' ? darkTheme : lightTheme) : (themeMode === 'dark' ? darkTheme : lightTheme);


    const navigationDarkTheme = {
    ...DarkTheme,
    colors: {
      ...DarkTheme.colors,
      primary: currentTheme.colors.primary,
      background: currentTheme.colors.background,
      card: currentTheme.colors.grey5,
      text: currentTheme.colors.white,
      border: currentTheme.colors.grey4,
      notification: currentTheme.colors.success,
    },
  };

    const navigationLightTheme = {
        ...DefaultTheme,
        colors: {
          ...DefaultTheme.colors,
          primary: currentTheme.colors.primary,
          background: currentTheme.colors.background,
          card: currentTheme.colors.white,
          text: currentTheme.colors.black,
          border: currentTheme.colors.grey4,
          notification: currentTheme.colors.success,
        },
    };


  return (
    <ThemeProvider theme={createTheme(currentTheme)}>
      <NavigationContainer theme={currentTheme.mode === 'dark' ? navigationDarkTheme : navigationLightTheme}>
        <Tab.Navigator
          screenOptions={({ route }) => ({
            tabBarIcon: ({ focused, color, size }) => {
              let iconName = '';
              let type = '';

              if (route.name === 'Daily Entry') {
                iconName = 'calendar';
                type = 'ionicon'
              } else if (route.name === 'Foods') {
                iconName = 'fastfood';
                type = 'material'
              } else if (route.name === 'Settings') {
                iconName = 'settings';
                type = 'ionicon'
              }

              return <Icon name={iconName} type={type} size={size} color={color} />;
            },
            tabBarActiveTintColor: currentTheme.colors.primary,
            tabBarInactiveTintColor: 'gray',
            headerShown: false,
          })}
        >
          <Tab.Screen name="Daily Entry" component={DailyEntryScreen} />
          <Tab.Screen name="Foods" component={FoodListScreen} />
          <Tab.Screen name="Settings" component={SettingsScreen} />
        </Tab.Navigator>
      </NavigationContainer>
    </ThemeProvider>
  );
};

export default AppNavigator;
---------- END AppNavigator.tsx ----------


---------- package.json ----------
{
  "name": "macrotracker",
  "license": "0BSD",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@react-native-async-storage/async-storage": "^2.1.2",
    "@react-native-community/datetimepicker": "8.2.0",
    "@react-navigation/bottom-tabs": "^7.3.1",
    "@react-navigation/native": "^7.0.17",
    "@rneui/base": "^4.0.0-rc.7",
    "@rneui/themed": "^4.0.0-rc.8",
    "date-fns": "^4.1.0",
    "expo": "~52.0.40",
    "expo-document-picker": "^13.0.3",
    "expo-file-system": "^18.0.12",
    "expo-status-bar": "~2.0.1",
    "react": "18.3.1",
    "react-native": "0.76.7",
    "react-native-get-random-values": "^1.11.0",
    "react-native-safe-area-context": "^4.14.1",
    "react-native-screens": "^4.9.2",
    "react-native-svg": "^15.11.2",
    "uuid": "^11.1.0",
    "victory-native": "^41.16.1",
    "react-native-reanimated": "~3.16.1"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/react": "~18.3.12",
    "@types/react-native": "^0.73.0",
    "@types/uuid": "^10.0.0",
    "typescript": "^5.3.3",
    "victory": "^37.3.6"
  },
  "private": true
}

---------- END package.json ----------


---------- projectToFile.js ----------
const fs = require('fs');
const path = require('path');

async function generateProjectStructureAndContent(projectRoot, outputFile) {
    const excludedDirs = ['node_modules', '.git', '.expo', 'android', 'ios', '__tests__', 'dist', 'build', '.vscode'];
    const excludedFiles = ['.DS_Store', 'package-lock.json', 'yarn.lock', 'bun.lockb', 'metro.config.js', 'babel.config.js'];
    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.webp', '.ico']; // Add more if needed

    let fileStructureTree = '';  // For the initial tree structure
    let fileContents = '';      // For the file contents

    async function traverseDirectory(dir, indent = '') {
        const entries = await fs.promises.readdir(dir, { withFileTypes: true });

        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);

            if (excludedDirs.includes(entry.name)) {
                continue;
            }

            if (entry.isDirectory()) {
                fileStructureTree += `${indent}${entry.name}/\n`;
                await traverseDirectory(fullPath, indent + '  ');
            } else if (entry.isFile()) {
                if (excludedFiles.includes(entry.name)) {
                    continue;
                }
                fileStructureTree += `${indent}${entry.name}\n`;
                const fileExtension = path.extname(entry.name).toLowerCase();

                if (!imageExtensions.includes(fileExtension)) {
                    fileContents += `\n---------- ${entry.name} ----------\n`;
                    try {
                        const fileContent = await fs.promises.readFile(fullPath, 'utf-8');
                        fileContents += `${fileContent}\n`;
                    } catch (readError) {
                        fileContents += `ERROR READING FILE: ${readError.message}\n`;
                    }
                    fileContents += `---------- END ${entry.name} ----------\n\n`;
                } else {
                     fileContents += `\n---------- ${entry.name} ----------\n`;
                     fileContents += `(Image file - content not included)\n`;
                     fileContents += `---------- END ${entry.name} ----------\n\n`;
                }
            }
        }
    }

    try {
        await traverseDirectory(projectRoot);
        const fullOutput = fileStructureTree + fileContents;

        await fs.promises.writeFile(outputFile, fullOutput);
        console.log(`Project structure and content written to ${outputFile}`);

    } catch (error) {
        console.error('An error occurred:', error);
        process.exit(1);
    }
}

// --- Main execution ---

const projectRoot = process.cwd(); // Use the current working directory
const outputFile = 'project_structure.txt';

// Check if the projectRoot exists.
fs.stat(projectRoot, (err, stats) => {
    if (err) {
        console.error(`Error: Project root directory "${projectRoot}" not found or not accessible.`);
        process.exit(1);
    }

    if (!stats.isDirectory()) {
        console.error(`Error: "${projectRoot}" is not a directory.`);
        process.exit(1);
    }

    generateProjectStructureAndContent(projectRoot, outputFile);
});
---------- END projectToFile.js ----------


---------- DailyEntryScreen.tsx ----------
// screens/DailyEntryScreen.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { View, FlatList, Alert, StyleSheet, ScrollView } from 'react-native';
import { DailyEntry, DailyEntryItem } from '../types/dailyEntry';
import { Food } from '../types/food';
import { getFoods } from '../services/foodService';
import { saveDailyEntries, loadDailyEntries, loadSettings } from '../services/storageService';
import { formatDate, formatDateReadable, getTodayDateString } from '../utils/dateUtils';
import { isValidNumberInput } from '../utils/validationUtils';
import DailyProgress from '../components/DailyProgress';
import { Button, Input, Text, ListItem, FAB, Overlay, SearchBar, makeStyles, useTheme, Divider } from '@rneui/themed';
import DateTimePicker from '@react-native-community/datetimepicker';
import { addDays, subDays, parseISO } from 'date-fns';
import Icon from "@rneui/base/dist/Icon/Icon";  // Keep this import
import { Icon as RNEIcon } from "@rneui/themed"; // Import Icon from @rneui/themed


interface DailyGoals {
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
}

const DailyEntryScreen: React.FC = () => {
    const [dailyEntries, setDailyEntries] = useState<DailyEntry[]>([]);
    const [selectedDate, setSelectedDate] = useState<string>(getTodayDateString());
    const [foods, setFoods] = useState<Food[]>([]);
    const [selectedFood, setSelectedFood] = useState<Food | null>(null);
    const [grams, setGrams] = useState('');
    const [isOverlayVisible, setIsOverlayVisible] = useState(false);
    const [search, setSearch] = useState('');
    const [showDatePicker, setShowDatePicker] = useState(false);
    const [dailyGoals, setDailyGoals] = useState<DailyGoals>({  // Add type annotation
        calories: 2000,
        protein: 50,
        carbs: 200,
        fat: 70
    });

    const { theme } = useTheme();
    const styles = useStyles();


    const loadData = useCallback(async () => {
        const loadedFoods = await getFoods();
        const loadedEntries = await loadDailyEntries();
        const loadedSettings = await loadSettings();

        // Merge loaded settings with defaults.  Crucial for fixing the error.
        if (loadedSettings.dailyGoals) {
            setDailyGoals(prevGoals => ({
                ...prevGoals,  // Start with the current/default goals
                ...loadedSettings.dailyGoals  // Override with any values from loadedSettings
            }));
        }

        setFoods(loadedFoods);
        setDailyEntries(loadedEntries);
    }, []);

    useEffect(() => {
        loadData();
    }, [loadData]);

    const getCurrentEntry = (): DailyEntry => {
        return (
            dailyEntries.find((entry) => entry.date === selectedDate) || {
                date: selectedDate,
                items: [],
            }
        );
    };

    const handleAddEntry = async () => {
        if (!selectedFood || !isValidNumberInput(grams)) {
            Alert.alert('Invalid Input', 'Please select a food and enter a valid weight.');
            return;
        }

        const newEntryItem: DailyEntryItem = {
            food: selectedFood,
            grams: parseFloat(grams),
        };

        const currentEntry = getCurrentEntry();
        const updatedItems = [...currentEntry.items, newEntryItem];
        const updatedEntry: DailyEntry = { ...currentEntry, items: updatedItems };

        const updatedEntries = dailyEntries.filter((entry) => entry.date !== selectedDate);
        updatedEntries.push(updatedEntry);

        try {
            await saveDailyEntries(updatedEntries);
            setDailyEntries(updatedEntries);
            setSelectedFood(null);
            setGrams('');
            setIsOverlayVisible(false);
        } catch (error) {
            Alert.alert('Error', 'Failed to add entry.');
        }
    };

    const handleRemoveEntry = async (index: number) => {
        const currentEntry = getCurrentEntry();
        const updatedItems = currentEntry.items.filter((_, i) => i !== index);
        const updatedEntry: DailyEntry = { ...currentEntry, items: updatedItems };

        const updatedEntries = dailyEntries.filter((entry) => entry.date !== selectedDate);
        if (updatedItems.length > 0) { // Only add back if there are items
            updatedEntries.push(updatedEntry);
        }

        try {
            await saveDailyEntries(updatedEntries);
            setDailyEntries(updatedEntries);
        } catch (error) {
            Alert.alert('Error', 'Failed to remove entry.');
        }
    };

    const toggleOverlay = () => {
        setIsOverlayVisible(!isOverlayVisible);
    };

    const updateSearch = (search: string) => {
        setSearch(search);
    };

    const filteredFoods = foods.filter((food) => {
        return food.name.toLowerCase().includes(search.toLowerCase());
    });

    const handleDateChange = (event: any, selectedDateVal?: Date) => {

        const currentDate = selectedDateVal || new Date();

        setShowDatePicker(false);

        if (event.type === "set") {
            setSelectedDate(formatDate(currentDate));
        }
    };
    const handlePreviousDay = () => {
        setSelectedDate(formatDate(subDays(parseISO(selectedDate), 1)));
    };

    const handleNextDay = () => {
        setSelectedDate(formatDate(addDays(parseISO(selectedDate), 1)));
    };

    const calculateTotals = () => {
        const currentEntry = getCurrentEntry();
        let totalCalories = 0;
        let totalProtein = 0;
        let totalCarbs = 0;
        let totalFat = 0;

        currentEntry.items.forEach((item) => {
            totalCalories += (item.food.calories / 100) * item.grams;
            totalProtein += (item.food.protein / 100) * item.grams;
            totalCarbs += (item.food.carbs / 100) * item.grams;
            totalFat += (item.food.fat / 100) * item.grams;
        });

        return { totalCalories, totalProtein, totalCarbs, totalFat };
    };
    const { totalCalories, totalProtein, totalCarbs, totalFat } = calculateTotals();

    return (
        <View style={styles.container}>
            <View style={styles.dateNavigation}>
                <Button type="clear" onPress={handlePreviousDay} icon={<RNEIcon name="arrow-back" type="ionicon" />} />
                <Text style={styles.dateText} onPress={() => setShowDatePicker(true)}>{formatDateReadable(selectedDate)}</Text>
                <Button type="clear" onPress={handleNextDay} icon={<RNEIcon name="arrow-forward" type="ionicon" />} />
            </View>
            {showDatePicker && (
                <DateTimePicker
                    value={parseISO(selectedDate)}
                    mode="date"
                    is24Hour={true}
                    display="default"
                    onChange={handleDateChange}
                />
            )}
            <DailyProgress
                calories={totalCalories}
                protein={totalProtein}
                carbs={totalCarbs}
                fat={totalFat}
                goals={dailyGoals}
            />
            <Divider style={{ marginVertical: 10 }} />
            <Text h4>Entries:</Text>
            <FlatList
                data={getCurrentEntry().items}
                keyExtractor={(_, index) => index.toString()}
                renderItem={({ item, index }) => (
                    <ListItem bottomDivider>
                        <ListItem.Content>
                            <ListItem.Title>{item.food.name}</ListItem.Title>
                            <ListItem.Subtitle>{`${item.grams}g`}</ListItem.Subtitle>
                        </ListItem.Content>
                        <Button type="clear" onPress={() => handleRemoveEntry(index)} icon={<RNEIcon name="trash" type="ionicon" color="red" />} />
                    </ListItem>
                )}
            />

            <FAB
                icon={<RNEIcon name="add" color="white" />}
                color={theme.colors.primary}
                onPress={toggleOverlay}
                placement="right"
                title="Add" // Add button text to pass accessibility test
            />


            <Overlay isVisible={isOverlayVisible} onBackdropPress={toggleOverlay} fullScreen={false}>
                <View style={{flex: 1, padding: 10}}>
                <Text h4 style={{ marginBottom: 10 }}>Add Entry</Text>
                <SearchBar
                    placeholder="Search Foods..."
                    onChangeText={updateSearch}
                    value={search}
                    platform="ios"
                />
                <FlatList
                    data={filteredFoods}
                    keyExtractor={(item) => item.id}
                    renderItem={({ item }) => (
                        <ListItem bottomDivider onPress={() => { setSelectedFood(item); setSearch('') }}>
                            <ListItem.Content>
                                <ListItem.Title>{item.name}</ListItem.Title>
                            </ListItem.Content>
                        </ListItem>
                    )}
                />

                <Input
                    placeholder="Grams"
                    keyboardType="numeric"
                    value={grams}
                    onChangeText={setGrams}
                />
                <Button title="Add Entry" onPress={handleAddEntry} disabled={!selectedFood} />
                </View>
            </Overlay>
        </View>
    );
};
const useStyles = makeStyles((theme) => ({
    container: {
        flex: 1,
        padding: 10,
        backgroundColor: theme.colors.background,
    },
    dateNavigation: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
        marginBottom: 10,
    },
    dateText: {
        fontSize: 18,
        fontWeight: 'bold',
    },
}));

export default DailyEntryScreen;
---------- END DailyEntryScreen.tsx ----------


---------- FoodListScreen.tsx ----------
// screens/FoodListScreen.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { View, FlatList, StyleSheet, Alert, TextInput, ScrollView, Platform } from 'react-native';
import { createFood, getFoods, updateFood, deleteFood } from '../services/foodService';
import { Food } from '../types/food';
import { isValidNumberInput, isNotEmpty } from '../utils/validationUtils';
import FoodItem from '../components/FoodItem';
import { Button, Input, Text, ListItem, FAB, Overlay, SearchBar, useTheme, makeStyles } from '@rneui/themed';
import { formatDate } from '../utils/dateUtils';
import Icon from "@rneui/base/dist/Icon/Icon";

const FoodListScreen: React.FC = () => {
  const [foods, setFoods] = useState<Food[]>([]);
  const [isOverlayVisible, setIsOverlayVisible] = useState(false);
  const [search, setSearch] = useState('');
  const [newFood, setNewFood] = useState<Omit<Food, 'id'>>({
    name: '',
    calories: 0,
    protein: 0,
    carbs: 0,
    fat: 0,
  });
  const [editFood, setEditFood] = useState<Food | null>(null);
  const { theme } = useTheme();
  const styles = useStyles();

  const loadFoodData = useCallback(async () => {
    const loadedFoods = await getFoods();
    setFoods(loadedFoods);
  }, []);

  useEffect(() => {
    loadFoodData();
  }, [loadFoodData]);

  const handleCreateFood = async () => {
    if (!isNotEmpty(newFood.name) || !isValidNumberInput(String(newFood.calories)) || !isValidNumberInput(String(newFood.protein)) || !isValidNumberInput(String(newFood.carbs)) || !isValidNumberInput(String(newFood.fat))) {
      Alert.alert('Invalid Input', 'Please enter valid food data.');
      return;
    }

    try {
      const createdFood = await createFood(newFood);
      setFoods([...foods, createdFood]);
      setNewFood({ name: '', calories: 0, protein: 0, carbs: 0, fat: 0 });
      setIsOverlayVisible(false);
    } catch (error) {
      Alert.alert('Error', 'Failed to create food.');
    }
  };

  const handleUpdateFood = async () => {
    if (!editFood || !isNotEmpty(editFood.name) || !isValidNumberInput(String(editFood.calories)) || !isValidNumberInput(String(editFood.protein)) || !isValidNumberInput(String(editFood.carbs)) || !isValidNumberInput(String(editFood.fat))) {
      Alert.alert('Invalid Input', 'Please enter valid food data.');
      return;
    }

    try {
      const updated = await updateFood(editFood);
      setFoods(foods.map(f => f.id === updated.id ? updated : f));
      setEditFood(null);
      setIsOverlayVisible(false);
    } catch (error) {
      Alert.alert('Error', 'Failed to update food.');
    }
  };

  const handleDeleteFood = async (foodId: string) => {
    try {
      await deleteFood(foodId);
      setFoods(foods.filter((f) => f.id !== foodId));
    } catch (error) {
      Alert.alert('Error', 'Failed to delete food.');
    }
  };

  const toggleOverlay = (food?: Food) => {
    if (food) {
      setEditFood(food);
    } else {
      setNewFood({ name: '', calories: 0, protein: 0, carbs: 0, fat: 0 });
    }

    setIsOverlayVisible(!isOverlayVisible);
  };

  const updateSearch = (search: string) => {
    setSearch(search);
  };

  const filteredFoods = foods.filter((food) => {
    return food.name.toLowerCase().includes(search.toLowerCase());
  });

  return (
    <View style={styles.container}>
      <SearchBar
        placeholder="Search Foods..."
        onChangeText={updateSearch}
        value={search}
        platform={Platform.select({ ios: 'ios', android: 'android', default: 'default' })} // Use Platform.select
      />
      <FlatList
        data={filteredFoods}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <FoodItem food={item} onEdit={toggleOverlay} onDelete={handleDeleteFood} />
        )}
      />

      <FAB
        icon={{ name: 'add', color: 'white' }}
        color={theme.colors.primary}
        onPress={() => toggleOverlay()}
        placement="right"
      />

      <Overlay isVisible={isOverlayVisible} onBackdropPress={() => toggleOverlay()}>
        <ScrollView>
          <Text h4 style={{ marginBottom: 10 }}>{editFood ? 'Edit Food' : 'Add New Food'}</Text>
          <Input
            placeholder="Food Name"
            value={editFood ? editFood.name : newFood.name}
            onChangeText={(text) => editFood ? setEditFood({ ...editFood, name: text }) : setNewFood({ ...newFood, name: text })}
          />
          <Input
            placeholder="Calories (per 100g)"
            keyboardType="numeric"
            value={editFood ? String(editFood.calories) : String(newFood.calories)}
            onChangeText={(text) => editFood ? setEditFood({ ...editFood, calories: parseFloat(text) || 0 }) : setNewFood({ ...newFood, calories: parseFloat(text) || 0 })}
          />
          <Input
            placeholder="Protein (per 100g)"
            keyboardType="numeric"
            value={editFood ? String(editFood.protein) : String(newFood.protein)}
            onChangeText={(text) => editFood ? setEditFood({ ...editFood, protein: parseFloat(text) || 0 }) : setNewFood({ ...newFood, protein: parseFloat(text) || 0 })}
          />
          <Input
            placeholder="Carbs (per 100g)"
            keyboardType="numeric"
            value={editFood ? String(editFood.carbs) : String(newFood.carbs)}
            onChangeText={(text) => editFood ? setEditFood({ ...editFood, carbs: parseFloat(text) || 0 }) : setNewFood({ ...newFood, carbs: parseFloat(text) || 0 })}
          />
          <Input
            placeholder="Fat (per 100g)"
            keyboardType="numeric"
            value={editFood ? String(editFood.fat) : String(newFood.fat)}
            onChangeText={(text) => editFood ? setEditFood({ ...editFood, fat: parseFloat(text) || 0 }) : setNewFood({ ...newFood, fat: parseFloat(text) || 0 })}
          />
          <Button title={editFood ? "Update Food" : "Add Food"} onPress={editFood ? handleUpdateFood : handleCreateFood} />
        </ScrollView>
      </Overlay>
    </View>
  );
};
const useStyles = makeStyles((theme) => ({
  container: {
    flex: 1,
    backgroundColor: theme.colors.background,
  }
}));
export default FoodListScreen;
---------- END FoodListScreen.tsx ----------


---------- SettingsScreen.tsx ----------
import React, { useState, useEffect, useCallback } from 'react';
import { View, Alert, ScrollView } from 'react-native';
import { saveSettings, loadSettings, Settings, clearAllData, loadDailyEntries } from '../services/storageService';
import { Button, ListItem, Text, Switch, Input, makeStyles, useTheme } from '@rneui/themed';
import * as DocumentPicker from 'expo-document-picker';
import * as FileSystem from 'expo-file-system';
import { formatDate } from '../utils/dateUtils';
// Import Victory with the type any to bypass type checking
import Victory from 'victory-native';
import ConfirmationModal from '../components/ConfirmationModal';
import { DailyEntry } from '../types/dailyEntry';

// Define a type for the Victory module to suppress errors
type VictoryType = any;
const V: VictoryType = Victory;

const macros = ['calories', 'protein', 'carbs', 'fat'] as const;
type MacroType = (typeof macros)[number];

interface MacroData {
  x: Date;
  y: number;
}

interface Statistics {
  calories: MacroData[];
  protein: MacroData[];
  carbs: MacroData[];
  fat: MacroData[];
}

const SettingsScreen: React.FC = () => {
  const [settings, setSettings] = useState<Settings>({ theme: 'system', dailyGoals: {} });
  const [isConfirmationVisible, setIsConfirmationVisible] = useState(false);
  const [confirmationText, setConfirmationText] = useState('');
  const [statistics, setStatistics] = useState<Statistics>({ calories: [], protein: [], carbs: [], fat: [] });

  const { theme } = useTheme();
  const styles = useStyles();

  const loadInitialSettings = useCallback(async () => {
    const loadedSettings = await loadSettings();
    setSettings(loadedSettings || { theme: 'system', dailyGoals: {} });
  }, []);

  useEffect(() => {
    loadInitialSettings();
  }, [loadInitialSettings]);

  const handleThemeChange = async (newTheme: 'light' | 'dark' | 'system') => {
    const updatedSettings = { ...settings, theme: newTheme };
    setSettings(updatedSettings);
    await saveSettings(updatedSettings);
  };

  const handleGoalChange = async (goalType: MacroType, value: string) => {
    const numericValue = parseFloat(value) || 0;
    const updatedGoals = { ...settings.dailyGoals, [goalType]: numericValue };
    const updatedSettings = { ...settings, dailyGoals: updatedGoals };
    setSettings(updatedSettings);
    await saveSettings(updatedSettings);
  };

  const handleExportData = async () => {
    try {
      const dailyEntries = await loadDailyEntries();
      const csvData = [
        ['Date', 'Food Name', 'Grams', 'Calories', 'Protein', 'Carbs', 'Fat'],
        ...dailyEntries.flatMap(entry =>
          entry.items.map(item => [
            entry.date,
            item.food.name,
            item.grams,
            item.food.calories,
            item.food.protein,
            item.food.carbs,
            item.food.fat
          ])
        )
      ];
      const csvString = csvData.map(row => row.join(',')).join('\n');
      const fileUri = FileSystem.documentDirectory + `macro_data_${formatDate(new Date())}.csv`;
      await FileSystem.writeAsStringAsync(fileUri, csvString, { encoding: FileSystem.EncodingType.UTF8 });
      Alert.alert('Export Successful', `Data exported to ${fileUri}`);
    } catch (error) {
      console.error(error);
      Alert.alert('Export Failed', 'An error occurred while exporting data.');
    }
  };

  const handleImportData = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({ type: '*/*', copyToCacheDirectory: true });
      if (!result.canceled && result.assets?.length > 0) {
        const fileUri = result.assets[0].uri;
        const fileContent = await FileSystem.readAsStringAsync(fileUri, { encoding: FileSystem.EncodingType.UTF8 });
        console.log("Imported File Content:", fileContent);

        const lines = fileContent.trim().split('\n');
        const headers = lines[0].split(',');
        const data = lines.slice(1).map(line => {
          const values = line.split(',');
          return headers.reduce((obj: any, header, index) => {
            obj[header.trim()] = values[index]?.trim();
            return obj;
          }, {});
        });

        console.log("Parsed Data:", data);
        Alert.alert('Import Successful', 'Data imported (parsing complete). Storage implementation pending.');

      } else {
        Alert.alert('Import Failed', 'No file selected');
      }
    } catch (error: any) {
      console.error("Import Error:", error);
      Alert.alert('Import Failed', error.message || 'An unknown error occurred.');
    }
  };

  const handleClearData = async () => setIsConfirmationVisible(true);

  const confirmClearData = async () => {
    if (confirmationText === 'CLEAR DATA') {
      try {
        await clearAllData();
        Alert.alert('Data Cleared', 'All data has been cleared.');
        setConfirmationText('');
        setIsConfirmationVisible(false);
        await loadInitialSettings();
      } catch (error) {
        Alert.alert('Error', 'Failed to clear data.');
      }
    } else {
      Alert.alert('Error', 'Incorrect confirmation text.');
    }
  };

  const getStatisticsData = (dailyEntries: DailyEntry[], macro: MacroType) => {
    return dailyEntries.map(entry => ({
      x: new Date(entry.date),
      y: entry.items.reduce((total, item) => total + ((item.food[macro] / 100) * item.grams), 0)
    })).sort((a, b) => a.x.getTime() - b.x.getTime());
  };

  useEffect(() => {
    const loadStatistics = async () => {
      const loadedEntries = await loadDailyEntries();
      setStatistics({
        calories: getStatisticsData(loadedEntries, 'calories'),
        protein: getStatisticsData(loadedEntries, 'protein'),
        carbs: getStatisticsData(loadedEntries, 'carbs'),
        fat: getStatisticsData(loadedEntries, 'fat')
      });
    };
    loadStatistics();
  }, []);

  return (
    <ScrollView style={styles.container}>
      <Text h3 style={styles.sectionTitle}>General</Text>
      <ListItem bottomDivider>
        <ListItem.Content>
          <ListItem.Title>Dark Mode</ListItem.Title>
        </ListItem.Content>
        <Switch
          value={settings.theme === 'dark'}
          onValueChange={() => handleThemeChange(settings.theme === 'dark' ? 'light' : 'dark')}
        />
      </ListItem>

      <Text h3 style={styles.sectionTitle}>Daily Goals</Text>
      {macros.map(macro => (
        <Input
          key={macro}
          label={`${macro.charAt(0).toUpperCase() + macro.slice(1)} Goal`}
          keyboardType="numeric"
          value={settings.dailyGoals?.[macro]?.toString() || ''}
          onChangeText={(value) => handleGoalChange(macro, value)}
        />
      ))}

      <Text h3 style={styles.sectionTitle}>Statistics</Text>
      {macros.map(macro => (
        <View key={macro}>
          <Text h4 style={{ textAlign: 'center' }}>{macro.charAt(0).toUpperCase() + macro.slice(1)}</Text>
          {/* Use the 'any' typed V variable to bypass type checking */}
          <V.VictoryChart height={200}>
            <V.VictoryAxis 
              tickFormat={(date: any) => formatDate(date)} 
              tickLabelComponent={<V.VictoryLabel angle={-45} textAnchor="end" />} 
            />
            <V.VictoryAxis dependentAxis />
            <V.VictoryLine 
              style={{ data: { stroke: theme.colors.primary } }} 
              data={statistics[macro]} 
            />
          </V.VictoryChart>
        </View>
      ))}

      <Text h3 style={styles.sectionTitle}>Data Management</Text>
      <Button title="Export Data" onPress={handleExportData} buttonStyle={{ marginBottom: 10 }} />
      <Button title="Import Data" onPress={handleImportData} buttonStyle={{ marginBottom: 10 }} />
      <Button title="Clear All Data" onPress={handleClearData} color="error" />

      <ConfirmationModal 
        isVisible={isConfirmationVisible} 
        onCancel={() => setIsConfirmationVisible(false)} 
        onConfirm={confirmClearData} 
        confirmationText={confirmationText} 
        setConfirmationText={setConfirmationText} 
      />
    </ScrollView>
  );
};

const useStyles = makeStyles((theme) => ({ 
  container: { 
    flex: 1, 
    padding: 10, 
    backgroundColor: theme.colors.background 
  }, 
  sectionTitle: { 
    marginTop: 20, 
    marginBottom: 10 
  } 
}));

export default SettingsScreen;
---------- END SettingsScreen.tsx ----------


---------- foodService.ts ----------
// services/foodService.ts
import { Food } from '../types/food';
import { saveFoods, loadFoods } from './storageService';
import 'react-native-get-random-values';
import { v4 as uuidv4 } from 'uuid';

export const createFood = async (foodData: Omit<Food, 'id'>): Promise<Food> => {
  const newFood: Food = {
    id: uuidv4(),
    ...foodData,
  };
  const foods = await loadFoods();
  foods.push(newFood);
  await saveFoods(foods);
  return newFood;
};

export const getFoods = async (): Promise<Food[]> => {
  return loadFoods();
};

export const updateFood = async (updatedFood: Food): Promise<Food> => {
  const foods = await loadFoods();
  const index = foods.findIndex((f) => f.id === updatedFood.id);
  if (index === -1) {
    throw new Error('Food not found');
  }
  foods[index] = updatedFood;
  await saveFoods(foods);
  return updatedFood;
};

export const deleteFood = async (foodId: string): Promise<void> => {
  const foods = await loadFoods();
  const filteredFoods = foods.filter((f) => f.id !== foodId);
  await saveFoods(filteredFoods);
};
---------- END foodService.ts ----------


---------- storageService.ts ----------
// services/storageService.ts
import AsyncStorage from '@react-native-async-storage/async-storage';
import { DailyEntry } from '../types/dailyEntry';
import { Food } from '../types/food';

const DAILY_ENTRIES_KEY = 'dailyEntries';
const FOODS_KEY = 'foods';
const SETTINGS_KEY = 'settings';

export const saveDailyEntries = async (entries: DailyEntry[]): Promise<void> => {
  try {
    await AsyncStorage.setItem(DAILY_ENTRIES_KEY, JSON.stringify(entries));
  } catch (error) {
    console.error('Error saving daily entries:', error);
    throw error; // Re-throw to handle upstream
  }
};

export const loadDailyEntries = async (): Promise<DailyEntry[]> => {
  try {
    const entriesJson = await AsyncStorage.getItem(DAILY_ENTRIES_KEY);
    return entriesJson ? JSON.parse(entriesJson) : [];
  } catch (error) {
    console.error('Error loading daily entries:', error);
    return []; // Return empty array on error
  }
};

export const saveFoods = async (foods: Food[]): Promise<void> => {
  try {
    await AsyncStorage.setItem(FOODS_KEY, JSON.stringify(foods));
  } catch (error) {
    console.error('Error saving foods:', error);
    throw error;
  }
};

export const loadFoods = async (): Promise<Food[]> => {
  try {
    const foodsJson = await AsyncStorage.getItem(FOODS_KEY);
    return foodsJson ? JSON.parse(foodsJson) : [];
  } catch (error) {
    console.error('Error loading foods:', error);
    return [];
  }
};

// Settings (example: theme)
export interface Settings {
  theme: 'light' | 'dark' | 'system';
  dailyGoals?: {  // Optional goals
    calories?: number;
    protein?: number;
    carbs?: number;
    fat?: number;
  };
}

export const saveSettings = async (settings: Settings): Promise<void> => {
  try {
    await AsyncStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
  } catch (error) {
    console.error('Error saving settings:', error);
    throw error;
  }
};

export const loadSettings = async (): Promise<Settings> => {
  try {
    const settingsJson = await AsyncStorage.getItem(SETTINGS_KEY);
    return settingsJson ? JSON.parse(settingsJson) : { theme: 'system' }; // Default settings
  } catch (error) {
    console.error('Error loading settings:', error);
    return { theme: 'system' };
  }
};

export const clearAllData = async (): Promise<void> => {
  try {
    await AsyncStorage.clear();
  } catch (error) {
    console.error('Error clearing data:', error);
    throw error;
  }
};
---------- END storageService.ts ----------


---------- tsconfig.json ----------
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true

  }
}
---------- END tsconfig.json ----------


---------- dailyEntry.ts ----------
// types/dailyEntry.ts
import { Food } from "./food";

export interface DailyEntryItem {
  food: Food;
  grams: number;
}

export interface DailyEntry {
  date: string; // YYYY-MM-DD format
  items: DailyEntryItem[];
  goals?: {  // Optional goals
    calories?: number;
    protein?: number;
    carbs?: number;
    fat?: number;
  };
}
---------- END dailyEntry.ts ----------


---------- food.ts ----------
// types/food.ts
export interface Food {
    id: string;
    name: string;
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
  }
---------- END food.ts ----------


---------- dateUtils.ts ----------
// utils/dateUtils.ts
import { format, parseISO } from 'date-fns';

export const formatDate = (date: Date | string): string => {
  if (typeof date === 'string') {
    date = parseISO(date);
  }
  return format(date, 'yyyy-MM-dd');
};

export const formatDateReadable = (date: Date | string): string => {
    if (typeof date === 'string') {
        date = parseISO(date);
    }
    return format(date, 'MMMM dd, yyyy');
}

export const getTodayDateString = (): string => {
  return formatDate(new Date());
};
---------- END dateUtils.ts ----------


---------- validationUtils.ts ----------
// utils/validationUtils.ts

export const isValidNumberInput = (value: string): boolean => {
    return /^[0-9]*(\.[0-9]*)?$/.test(value) && !isNaN(parseFloat(value));
  };
  
  export const isNotEmpty = (value: string): boolean => {
    return value.trim() !== '';
  };
---------- END validationUtils.ts ----------

