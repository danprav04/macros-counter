.gitignore
app.json
App.tsx
assets/
  adaptive-icon.png
  favicon.png
  icon.png
  splash.png
eas.json
index.ts
package.json
projectToFile.js
src/
  components/
    AddEntryModal.tsx
    AddFoodModal.tsx
    ConfirmationModal.tsx
    DailyGoalsInput.tsx
    DailyProgress.tsx
    DataManagementButtons.tsx
    FoodItem.tsx
    QuickAddList.tsx
    StatisticsChart.tsx
    ThemeSwitch.tsx
  hooks/
  navigation/
    AppNavigator.tsx
  screens/
    DailyEntryScreen.tsx
    FoodListScreen.tsx
    SettingsScreen.tsx
  services/
    backendService.ts
    clientIDService.ts
    foodService.ts
    storageService.ts
  types/
    dailyEntry.ts
    food.ts
    macros.ts
    openRouterTypes.ts
    settings.ts
  utils/
    dateUtils.ts
    iconUtils.ts
    macros.ts
    units.ts
    validationUtils.ts
tsconfig.json

---------- .gitignore ----------
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

---------- END .gitignore ----------


---------- app.json ----------
{
  "expo": {
    "name": "MacroTracker",
    "slug": "MacroTracker",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "automatic",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#000000"
    },
    "androidStatusBar": {
      "backgroundColor": "#000000",
      "translucent": false,
      "barStyle": "light-content"
    },
    "assetBundlePatterns": [
      "**/*"
    ],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.yourcompany.macrotracker",
      "infoPlist": {
        "UIStatusBarStyle": "UIStatusBarStyleAutomatic",
        "NSCameraUsageDescription": "Allow $(PRODUCT_NAME) to access your camera to take photos of food for macro analysis.",
        "NSPhotoLibraryUsageDescription": "Allow $(PRODUCT_NAME) to access your photos to select food images for macro analysis."
      }
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "package": "com.yourcompany.macrotracker",
      "userInterfaceStyle": "automatic",
      "statusBar": {
        "backgroundColor": "#00000000",
        "translucent": true,
        "barStyle": "auto"
      },
      "permissions": [
        "android.permission.CAMERA",
        "android.permission.READ_EXTERNAL_STORAGE",
        "android.permission.WRITE_EXTERNAL_STORAGE"
      ]
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      [
        "expo-document-picker",
        {
          "appleTeamId": "YOUR_TEAM_ID"
        }
      ],
      [
        "expo-image-picker",
        {
          "photosPermission": "Allow $(PRODUCT_NAME) to access your photos to select food images for macro analysis.",
          "cameraPermission": "Allow $(PRODUCT_NAME) to access your camera to take photos of food for macro analysis."
        }
      ]
    ],
    "extra": {
      "eas": {
        "projectId": "25ac2bcf-78a3-4f2c-a635-4fcaae7b93f1"
      },
      "env": {
         "BACKEND_URL": "https://macros-counter.mooo.com"
      }
    }
  }
}
---------- END app.json ----------


---------- App.tsx ----------
// App.tsx
// App.tsx (Initialize Client ID)
import "react-native-get-random-values"; // MUST BE FIRST
import Toast from "react-native-toast-message";
import React, { useState, useEffect } from "react";
import AppNavigator from "./src/navigation/AppNavigator";
import { SafeAreaProvider, SafeAreaView } from "react-native-safe-area-context";
import { ThemeProvider, createTheme } from "@rneui/themed";
import { loadSettings, saveSettings } from "./src/services/storageService";
import {
  useColorScheme,
  AppState,
  AppStateStatus,
  Platform,
} from "react-native";
import {
  NavigationContainer,
  DefaultTheme,
  DarkTheme,
} from "@react-navigation/native";
import { Colors } from "@rneui/base";
import { Settings } from "./src/types/settings";
import { LogBox, View, Text } from "react-native"; //Import view for debug
import { StatusBar } from "expo-status-bar"; // changed import
import { getClientId } from "./src/services/clientIDService"; // Import client ID service

LogBox.ignoreLogs(["Function components cannot be given refs"]);

declare module "@rneui/themed" {
  export interface Colors {
    text: string;
    card: string; // Added for better card styling
    successLight: string; // Lighter success color
  }
}

interface MyTheme {
  mode: "light" | "dark";
  colors: Colors;
}

const lightTheme: MyTheme = {
  mode: "light",
  colors: {
    primary: "#2e86de",
    secondary: "#6c757d",
    background: "#f8f9fa",
    grey5: "#e9ecef",
    white: "#ffffff",
    grey4: "#ced4da",
    success: "#28a745",
    successLight: "#d4edda",
    black: "#000000",
    text: "#212529",
    card: "#ffffff",
    error: "#dc3545",
    warning: "#ffc107",
    disabled: "#6c757d",
    divider: "#ced4da",
    platform: {
      ios: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      android: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      web: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      default: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
    },
    grey0: "#f8f9fa",
    grey1: "#e9ecef",
    grey2: "#dee2e6",
    grey3: "#ced4da",
    greyOutline: "#adb5bd",
    searchBg: "#ffffff",
  },
};

const darkTheme: MyTheme = {
  mode: "dark",
  colors: {
    primary: "#2e86de",
    secondary: "#adb5bd",
    background: "#121212",
    grey5: "#2c2c2c",
    white: "#ffffff",
    grey4: "#343a40",
    success: "#28a745",
    successLight: "#1f5139",
    black: "#000000",
    text: "#f8f9fa",
    card: "#1e1e1e",
    error: "#dc3545",
    warning: "#ffc107",
    disabled: "#6c757d",
    divider: "#343a40",
    platform: {
      ios: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      android: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      web: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      default: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
    },
    grey0: "#212529",
    grey1: "#2c2c2c",
    grey2: "#343a40",
    grey3: "#495057",
    greyOutline: "#6c757d",
    searchBg: "#1e1e1e",
  },
};

const App = () => {
  const [themeMode, setThemeMode] = useState<"light" | "dark" | "system">(
    "system"
  );
  const [loadedSettings, setLoadedSettings] = useState<Settings | null>(null);
  const colorScheme = useColorScheme();
  const [appState, setAppState] = useState(AppState.currentState);
  const [themeCheck, setThemeCheck] = useState(0);
  const [isClientIdReady, setIsClientIdReady] = useState(false); // Track client ID readiness

  // Initialize Client ID and Load initial settings
  useEffect(() => {
    const initializeApp = async () => {
      try {
          // Ensure Client ID is ready before loading other data
          await getClientId(); // This generates/retrieves and caches the ID
          setIsClientIdReady(true);
          console.log('Client ID is ready.');

          // Load settings after client ID is confirmed
          const settings = await loadSettings();
          setThemeMode(settings.theme);
          setLoadedSettings(settings);
          console.log('Settings loaded.');
      } catch (error) {
            console.error("Initialization Error:", error);
            // Handle error, maybe show an error screen
      }
    };
    initializeApp();
  }, []); // Run only once on mount

  // AppState Listener
  useEffect(() => {
    const handleAppStateChange = (nextAppState: AppStateStatus) => {
      setAppState(nextAppState);
    };

    const subscription = AppState.addEventListener(
      "change",
      handleAppStateChange
    );

    return () => {
      subscription.remove();
    };
  }, []); // No appState dependency needed here

  const updateTheme = (newThemeMode: "light" | "dark" | "system") => {
    const isDark =
      newThemeMode === "system"
        ? colorScheme === "dark"
        : newThemeMode === "dark";
    return isDark ? darkTheme : lightTheme;
  };

  const handleThemeChange = async (newTheme: "light" | "dark" | "system") => {
    setThemeMode(newTheme);
    if (loadedSettings) {
      const updatedSettings: Settings = {
        ...loadedSettings,
        theme: newTheme,
      };
      await saveSettings(updatedSettings);
      setLoadedSettings(updatedSettings);
    }
    setThemeCheck((t) => t + 1);
  };

  const currentTheme = updateTheme(themeMode);

  const navigationTheme = {
    dark: {
      ...DarkTheme,
      colors: {
        ...DarkTheme.colors,
        primary: currentTheme.colors.primary,
        background: currentTheme.colors.background,
        card: currentTheme.colors.card,
        text: currentTheme.colors.text,
        border: currentTheme.colors.divider,
        notification: currentTheme.colors.successLight,
      },
    },
    light: {
      ...DefaultTheme,
      colors: {
        ...DefaultTheme.colors,
        primary: currentTheme.colors.primary,
        background: currentTheme.colors.background,
        card: currentTheme.colors.card,
        text: currentTheme.colors.text,
        border: currentTheme.colors.divider,
        notification: currentTheme.colors.success,
      },
    },
  };

  const statusBarTheme = themeMode === "system" ? colorScheme : themeMode;
  const backgroundColor = currentTheme.colors.background;

  // Show loading or placeholder until client ID is ready
  if (!isClientIdReady) {
      return (
          <SafeAreaView style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: backgroundColor }}>
              <Text style={{ color: currentTheme.colors.text }}>Initializing...</Text>
              {/* Optionally add an ActivityIndicator */}
          </SafeAreaView>
      );
  }

  return (
    <ThemeProvider theme={createTheme(currentTheme)}>
      <SafeAreaView style={{ flex: 1, backgroundColor: backgroundColor }}>
        <StatusBar
          style={statusBarTheme === "dark" ? "light" : "dark"}
          backgroundColor={backgroundColor}
          translucent={false}
        />
        <NavigationContainer
          theme={
            currentTheme.mode === "dark"
              ? navigationTheme.dark
              : navigationTheme.light
          }
        >
          <AppNavigator onThemeChange={handleThemeChange} />
        </NavigationContainer>
        <Toast />
      </SafeAreaView>
    </ThemeProvider>
  );
};

export default App;
---------- END App.tsx ----------


---------- adaptive-icon.png ----------
(Image file - content not included)
---------- END adaptive-icon.png ----------


---------- favicon.png ----------
(Image file - content not included)
---------- END favicon.png ----------


---------- icon.png ----------
(Image file - content not included)
---------- END icon.png ----------


---------- splash.png ----------
(Image file - content not included)
---------- END splash.png ----------


---------- eas.json ----------
{
  "cli": {
    "version": ">= 13.4.1",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal"
    },
    "preview": {
      "android": {
        "buildType": "apk"
      }
    },
    "production": {
      "autoIncrement": true
    }
  },
  "submit": {
    "production": {}
  }
}

---------- END eas.json ----------


---------- index.ts ----------
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);

---------- END index.ts ----------


---------- package.json ----------
{
  "name": "macrotracker",
  "license": "0BSD",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@react-native-async-storage/async-storage": "^2.1.2",
    "@react-native-community/datetimepicker": "8.2.0",
    "@react-navigation/bottom-tabs": "^7.3.1",
    "@react-navigation/native": "^7.0.17",
    "@rneui/base": "^4.0.0-rc.7",
    "@rneui/themed": "^4.0.0-rc.8",
    "@types/d3-scale": "^4.0.9",
    "d3-scale": "^4.0.2",
    "date-fns": "^4.1.0",
    "expo": "~52.0.40",
    "expo-constants": "~16.0.2",
    "expo-document-picker": "^13.0.3",
    "expo-file-system": "^18.0.12",
    "expo-image-manipulator": "~13.0.5",
    "expo-image-picker": "^16.0.6",
    "expo-sharing": "~13.0.1",
    "expo-status-bar": "~2.0.1",
    "react": "18.3.1",
    "react-native": "0.76.7",
    "react-native-config": "^1.5.5",
    "react-native-get-random-values": "^1.11.0",
    "react-native-mime-types": "^2.5.0",
    "react-native-reanimated": "~3.16.1",
    "react-native-safe-area-context": "^4.14.1",
    "react-native-screens": "^4.9.2",
    "react-native-svg": "^15.11.2",
    "react-native-toast-message": "^2.2.1",
    "react-native-uuid": "^2.0.3",
    "react-native-webview": "^13.13.4",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/react": "~18.3.12",
    "@types/react-native": "^0.73.0",
    "@types/react-native-svg-charts": "^5.0.16",
    "@types/uuid": "^10.0.0",
    "typescript": "^5.3.3",
    "victory": "^37.3.6"
  },
  "private": true
}
---------- END package.json ----------


---------- projectToFile.js ----------
const fs = require('fs');
const path = require('path');

async function generateProjectStructureAndContent(projectRoot, outputFile) {
    const excludedDirs = ['node_modules', '.git', '.expo', 'android', 'ios', '__tests__', 'dist', 'build', '.vscode'];
    const excludedFiles = ['.DS_Store', 'package-lock.json', 'yarn.lock', 'bun.lockb', 'metro.config.js', 'babel.config.js'];
    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.webp', '.ico']; // Add more if needed

    let fileStructureTree = '';  // For the initial tree structure
    let fileContents = '';      // For the file contents

    async function traverseDirectory(dir, indent = '') {
        const entries = await fs.promises.readdir(dir, { withFileTypes: true });

        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);

            if (excludedDirs.includes(entry.name)) {
                continue;
            }

            if (entry.isDirectory()) {
                fileStructureTree += `${indent}${entry.name}/\n`;
                await traverseDirectory(fullPath, indent + '  ');
            } else if (entry.isFile()) {
                if (excludedFiles.includes(entry.name)) {
                    continue;
                }
                fileStructureTree += `${indent}${entry.name}\n`;
                const fileExtension = path.extname(entry.name).toLowerCase();

                if (!imageExtensions.includes(fileExtension)) {
                    fileContents += `\n---------- ${entry.name} ----------\n`;
                    try {
                        const fileContent = await fs.promises.readFile(fullPath, 'utf-8');
                        fileContents += `${fileContent}\n`;
                    } catch (readError) {
                        fileContents += `ERROR READING FILE: ${readError.message}\n`;
                    }
                    fileContents += `---------- END ${entry.name} ----------\n\n`;
                } else {
                     fileContents += `\n---------- ${entry.name} ----------\n`;
                     fileContents += `(Image file - content not included)\n`;
                     fileContents += `---------- END ${entry.name} ----------\n\n`;
                }
            }
        }
    }

    try {
        await traverseDirectory(projectRoot);
        const fullOutput = fileStructureTree + fileContents;

        await fs.promises.writeFile(outputFile, fullOutput);
        console.log(`Project structure and content written to ${outputFile}`);

    } catch (error) {
        console.error('An error occurred:', error);
        process.exit(1);
    }
}

// --- Main execution ---

const projectRoot = process.cwd(); // Use the current working directory
const outputFile = 'project_structure.txt';

// Check if the projectRoot exists.
fs.stat(projectRoot, (err, stats) => {
    if (err) {
        console.error(`Error: Project root directory "${projectRoot}" not found or not accessible.`);
        process.exit(1);
    }

    if (!stats.isDirectory()) {
        console.error(`Error: "${projectRoot}" is not a directory.`);
        process.exit(1);
    }

    generateProjectStructureAndContent(projectRoot, outputFile);
});
---------- END projectToFile.js ----------


---------- AddEntryModal.tsx ----------
// src/components/AddEntryModal.tsx
// ---------- AddEntryModal.tsx (Corrected ImageManipulator Action) ----------
import React, {
    useEffect,
    useState,
    useMemo,
    useCallback,
    useRef,
  } from "react";
  import {
    View,
    FlatList,
    KeyboardAvoidingView,
    Platform,
    TouchableOpacity,
    ScrollView,
    Dimensions,
    Image,
    StyleSheet,
    ActivityIndicator,
    Alert,
    Keyboard,
  } from "react-native";
  import {
    Button,
    Input,
    Text,
    ListItem,
    Overlay,
    SearchBar,
    makeStyles,
    useTheme,
    Icon,
    ButtonGroup,
  } from "@rneui/themed";
  import { Food } from "../types/food";
  import { isValidNumberInput } from "../utils/validationUtils";
  import { loadRecentFoods, saveRecentFoods } from "../services/storageService";
  import { getFoodIconUrl } from "../utils/iconUtils";
  import { getGramsFromNaturalLanguage } from "../utils/units";
  import Toast from "react-native-toast-message";
  import * as ImagePicker from "expo-image-picker";
  import * as ImageManipulator from 'expo-image-manipulator'; // Import manipulator
  import { EstimatedFoodItem, getMultipleFoodsFromImage, BackendError } from "../utils/macros"; // Include BackendError
  import { v4 as uuidv4 } from "uuid";
  
  interface AddEntryModalProps {
    isVisible: boolean;
    toggleOverlay: () => void;
    selectedFood: Food | null;
    grams: string;
    setGrams: (grams: string) => void;
    handleAddEntry: () => void;
    handleAddMultipleEntries: (entries: { food: Food; grams: number }[]) => void;
    foods: Food[];
    handleSelectFood: (item: Food | null) => void;
    updateSearch: (search: string) => void;
    search: string;
    isEditMode: boolean;
    initialGrams?: string; // This is the grams value passed IN for editing
  }
  
  const KEYBOARD_VERTICAL_OFFSET = Platform.OS === "ios" ? 80 : 0;
  const MAX_IMAGE_DIMENSION = 1024; // Max width/height for compressed image
  const IMAGE_COMPRESSION_QUALITY = 0.7; // Compression quality (0.0 - 1.0)
  
  type UnitMode = "grams" | "auto";
  type ModalMode = "normal" | "quickAddSelect";
  
  // Define types for the items in our main FlatList data structure
  type ListItemType =
    | { type: "searchBar"; key: string }
    | { type: "recentFoods"; key: string }
    | { type: "searchResults"; key: string; data: Food } // Individual search result
    | { type: "noResults"; key: string }
    | { type: "amountInput"; key: string }
    | { type: "quickAddHeader"; key: string }
    | { type: "quickAddItem"; key: string; data: EstimatedFoodItem; index: number } // Individual quick add item
    | { type: "quickAddLoading"; key: string }
    | { type: "quickAddEditForm"; key: string; index: number} // Edit form for quick add
    | { type: "spacer"; key: string; height: number };
  
  const AddEntryModal: React.FC<AddEntryModalProps> = ({
    isVisible,
    toggleOverlay,
    selectedFood,
    grams,
    setGrams,
    handleAddEntry,
    handleAddMultipleEntries,
    foods,
    handleSelectFood,
    updateSearch,
    search,
    isEditMode,
    initialGrams,
  }) => {
    const { theme } = useTheme();
    const styles = useStyles();
    const [recentFoods, setRecentFoods] = useState<Food[]>([]);
    const MAX_RECENT_FOODS = 5;
    const [foodIcons, setFoodIcons] = useState<{
        [foodName: string]: string | null | undefined;
    }>({});
  
    const [unitMode, setUnitMode] = useState<UnitMode>("grams");
    const [autoInput, setAutoInput] = useState("");
    const [isAiLoading, setIsAiLoading] = useState(false); // Loading for natural language grams
  
    // --- Quick Add State ---
    const [modalMode, setModalMode] = useState<ModalMode>("normal");
    const [quickAddLoading, setQuickAddLoading] = useState(false); // Loading for image analysis
    const [quickAddItems, setQuickAddItems] = useState<EstimatedFoodItem[]>([]);
    const [selectedQuickAddIndices, setSelectedQuickAddIndices] = useState<
        Set<number>
    >(new Set());
    const [editingQuickAddItemIndex, setEditingQuickAddItemIndex] = useState<
        number | null
    >(null);
    const [editedFoodName, setEditedFoodName] = useState<string>("");
    const [editedGrams, setEditedGrams] = useState<string>("");
    // --- End Quick Add State ---
  
    const screenWidth = Dimensions.get("window").width;
    const isModalOpening = useRef(false);
  
    const filteredFoods = useMemo(() => {
        if (!search) return [];
        return foods.filter((food) =>
            food.name.toLowerCase().includes(search.toLowerCase())
        );
    }, [foods, search]);
  
    // --- Effects (largely unchanged, focus on state resets) ---
    useEffect(() => {
        if (!isVisible) {
            // Reset general states when modal actually closes
            handleSelectFood(null);
            updateSearch("");
            setModalMode("normal");
            setQuickAddItems([]);
            setSelectedQuickAddIndices(new Set());
            setEditingQuickAddItemIndex(null);
            setGrams("");
            setUnitMode("grams");
            setAutoInput("");
            setIsAiLoading(false);
             setQuickAddLoading(false); // Ensure all loading states are reset
        }
    }, [isVisible, handleSelectFood, updateSearch, setGrams]);
  
  
    useEffect(() => {
        if (isVisible && modalMode === 'normal') {
            isModalOpening.current = true;
  
            if (isEditMode && selectedFood && initialGrams !== undefined) {
                setGrams(initialGrams);
                setUnitMode('grams');
                setAutoInput('');
            } else if (!isEditMode) { // Only reset if not in edit mode opening
                setGrams('');
                setUnitMode('grams');
                setAutoInput('');
            }
  
            const loadRecents = async () => {
                const loadedRecentFoods = await loadRecentFoods();
                setRecentFoods(loadedRecentFoods);
            };
            loadRecents();
  
            const timer = setTimeout(() => {
                isModalOpening.current = false;
            }, 100); // Short delay to prevent effect races
  
            return () => clearTimeout(timer);
        } else if (isVisible && modalMode === 'quickAddSelect') {
             // Reset normal mode stuff if switching to quick add
            handleSelectFood(null);
            updateSearch('');
            setGrams('');
            setUnitMode("grams");
            setAutoInput("");
        }
    }, [isVisible, modalMode, isEditMode, selectedFood, initialGrams, setGrams]);
  
  
    // Effect 3: Reset grams/mode if selectedFood changes while modal is open in ADD mode
    useEffect(() => {
        if (isVisible && modalMode === 'normal' && !isEditMode && !isModalOpening.current) {
            setGrams("");
            setUnitMode("grams");
            setAutoInput("");
        }
    }, [selectedFood, isVisible, modalMode, isEditMode]);
  
    // Load icons (unchanged)
    useEffect(() => {
        if (!isVisible || modalMode !== 'normal') return;
  
        const loadIcons = async () => {
            const relevantFoods = search ? filteredFoods : recentFoods;
            const uniqueFoodsMap = new Map(relevantFoods.map(food => [food.id ?? food.name, food]));
  
            for (const food of uniqueFoodsMap.values()) {
                const foodName = food.name;
                if (foodIcons[foodName] === undefined) {
                    getFoodIconUrl(foodName)
                        .then(iconUrl => {
                            setFoodIcons(prevIcons => ({ ...prevIcons, [foodName]: iconUrl }));
                        })
                        .catch(error => {
                            console.warn(`Icon fetch failed for ${foodName}:`, error);
                            setFoodIcons(prevIcons => ({ ...prevIcons, [foodName]: null }));
                        });
                }
            }
        };
        loadIcons();
    }, [isVisible, modalMode, search, filteredFoods, recentFoods, foodIcons]);
  
  
    // --- Utility Functions ---
    const addToRecentFoods = useCallback(async (food: Food) => {
        if (!food || !food.id) return;
        if (recentFoods.length > 0 && recentFoods[0].id === food.id) return;
  
        setRecentFoods((prevRecent) => {
            const updated = prevRecent.filter((rf) => rf.id !== food.id);
            updated.unshift(food);
            const trimmed = updated.slice(0, MAX_RECENT_FOODS);
            saveRecentFoods(trimmed).catch(err => console.error("Failed to save recent foods:", err));
            return trimmed;
        });
    }, [recentFoods]);
  
    const servingSizeSuggestions = useMemo(() => {
        if (!selectedFood) return [];
        return [
            { label: "50g", value: "50" },
            { label: "100g", value: "100" },
            { label: "150g", value: "150" },
            { label: "200g", value: "200" },
        ];
    }, [selectedFood]);
  
    // --- Action Handlers ---
    const handleEstimateGrams = useCallback(async () => {
        Keyboard.dismiss();
        if (!selectedFood || !autoInput.trim()) {
            Alert.alert("Input Missing", "Please select a food and enter a quantity description.");
            return;
        }
        if (isAiLoading) return;
        setIsAiLoading(true);
        try {
            const estimatedGrams = await getGramsFromNaturalLanguage(selectedFood.name, autoInput);
            const roundedGrams = String(Math.round(estimatedGrams));
            setGrams(roundedGrams);
            setUnitMode("grams"); // Switch back to grams view
            setAutoInput("");
            Toast.show({ type: "success", text1: "Grams Estimated", text2: `Estimated ${roundedGrams}g for ${selectedFood.name}`, position: "bottom" });
        } catch (error: any) {
            console.error("AI Gram Estimation Error:", error);
            // Error already shown by getGramsFromNaturalLanguage via Alert
        } finally {
            setIsAiLoading(false);
        }
    }, [selectedFood, autoInput, isAiLoading, setGrams]);
  
    const handleAddOrUpdateSingleEntry = useCallback(async () => {
        Keyboard.dismiss();
        if (!selectedFood) {
            Alert.alert("Food Not Selected", "Please select a food item."); return;
        }
        const numericGrams = parseFloat(grams);
        if (!isValidNumberInput(grams) || numericGrams <= 0) {
            Alert.alert("Invalid Amount", "Please enter a valid positive number for grams."); return;
        }
        if (isAiLoading || quickAddLoading) return;
  
        handleAddEntry();
        if (!isEditMode) { // Only add to recents on ADD, not UPDATE
             addToRecentFoods(selectedFood);
        }
  
    }, [selectedFood, grams, isAiLoading, quickAddLoading, handleAddEntry, addToRecentFoods, isEditMode]);
  
    const handleInternalSelectFood = useCallback((item: Food | null) => {
        handleSelectFood(item);
        updateSearch(""); // Clear search when a food is selected from results/recent
        Keyboard.dismiss();
    }, [handleSelectFood, updateSearch]);
  
  
    // --- Quick Add Functions ---
  
    // Function to compress image before processing
    const compressImage = async (asset: ImagePicker.ImagePickerAsset): Promise<ImageManipulator.ImageResult | null> => {
       console.log(`Original image dimensions: ${asset.width}x${asset.height}`);
       try {
           // *** CORRECTED Action Structure ***
           const actions: ImageManipulator.Action[] = [];
           const resizeOptions: ImageManipulator.ActionResize = {
               resize: {
                   width: undefined,
                   height: undefined
               }
           }; // Define resize options object
  
           // Determine target dimensions based on MAX_IMAGE_DIMENSION
           if (asset.width > MAX_IMAGE_DIMENSION || asset.height > MAX_IMAGE_DIMENSION) {
               if (asset.width > asset.height) {
                  resizeOptions.resize.width = MAX_IMAGE_DIMENSION;
              } else {
                  resizeOptions.resize.height = MAX_IMAGE_DIMENSION;
              }
               // Add the resize action object to the actions array
               actions.push({ resize: resizeOptions.resize });
               console.log(`Resizing image to max dimension ${MAX_IMAGE_DIMENSION}`);
           }
           // *** End of Correction ***
  
           const saveOptions: ImageManipulator.SaveOptions = {
               compress: IMAGE_COMPRESSION_QUALITY,
               format: ImageManipulator.SaveFormat.JPEG, // Compress to JPEG for smaller size
               base64: false, // We'll read base64 later if needed
           };
  
           const result = await ImageManipulator.manipulateAsync(asset.uri, actions, saveOptions);
           console.log(`Compressed image dimensions: ${result.width}x${result.height}`);
           console.log(`Compressed image URI: ${result.uri}`);
           return result;
       } catch (error) {
            console.error("Failed to compress image:", error);
            Alert.alert("Compression Error", "Could not process the image for compression.");
            return null; // Return null if compression fails
       }
    };
  
  
    const pickImageAndAnalyze = useCallback(async (source: "camera" | "gallery") => {
        if (isEditMode) return;
  
        let permissionResult;
        let pickerResult: ImagePicker.ImagePickerResult;
  
        setQuickAddLoading(true);
        setQuickAddItems([]);
        setSelectedQuickAddIndices(new Set());
        setEditingQuickAddItemIndex(null);
        setModalMode("quickAddSelect"); // Switch view mode
        handleSelectFood(null);
        updateSearch("");
        setGrams("");
  
        try {
            if (source === "camera") {
                permissionResult = await ImagePicker.requestCameraPermissionsAsync();
                if (!permissionResult.granted) { Alert.alert("Permission Required", "Camera access needed."); setModalMode("normal"); setQuickAddLoading(false); return; }
                pickerResult = await ImagePicker.launchCameraAsync({ quality: 1, exif: false });
            } else {
                permissionResult = await ImagePicker.requestMediaLibraryPermissionsAsync();
                if (!permissionResult.granted) { Alert.alert("Permission Required", "Gallery access needed."); setModalMode("normal"); setQuickAddLoading(false); return; }
                pickerResult = await ImagePicker.launchImageLibraryAsync({ mediaTypes: ImagePicker.MediaTypeOptions.Images, quality: 1 });
            }
  
            if (pickerResult.canceled) { setModalMode("normal"); setQuickAddLoading(false); return; }
  
            if (pickerResult.assets && pickerResult.assets.length > 0) {
                const originalAsset = pickerResult.assets[0];
                const compressedAsset = await compressImage(originalAsset);
                if (!compressedAsset) {
                    setModalMode("normal"); setQuickAddLoading(false); return;
                }
                const assetForAnalysis: ImagePicker.ImagePickerAsset = {
                   ...originalAsset,
                   uri: compressedAsset.uri,
                   width: compressedAsset.width,
                   height: compressedAsset.height,
                   mimeType: 'image/jpeg',
                };
  
                const results = await getMultipleFoodsFromImage(assetForAnalysis);
                if (results.length === 0) {
                    Alert.alert("No Foods Found", "Couldn't identify food items. Try again or add manually.");
                    setModalMode("normal");
                } else {
                    setQuickAddItems(results);
                    setSelectedQuickAddIndices(new Set(results.map((_, i) => i)));
                }
            } else {
                Alert.alert("Error", "Could not select image."); setModalMode("normal");
            }
        } catch (error: any) {
             if (error instanceof BackendError) {
                  console.error("Error during Quick Add image analysis (BackendError):", error.message, error.status, error.detail);
             } else {
                  console.error("Error during Quick Add image process (General):", error);
             }
             setModalMode("normal"); setQuickAddItems([]); setSelectedQuickAddIndices(new Set());
        } finally {
            setTimeout(() => setQuickAddLoading(false), 150);
        }
    }, [isEditMode, handleSelectFood, updateSearch, setGrams]);
  
    // Other handlers remain the same...
    const handleQuickAddImage = useCallback(async () => {
        Keyboard.dismiss();
        if (isEditMode) return;
        if (editingQuickAddItemIndex !== null) {
            Alert.alert("Finish Editing", "Please save or cancel the current edit first."); return;
        }
        Alert.alert("Quick Add from Image", "Identify multiple foods from an image.",
            [ { text: "Cancel", style: "cancel" },
              { text: "Camera", onPress: () => pickImageAndAnalyze("camera") },
              { text: "Gallery", onPress: () => pickImageAndAnalyze("gallery") }, ]
        );
    }, [isEditMode, editingQuickAddItemIndex, pickImageAndAnalyze]);
  
    const handleToggleQuickAddItem = useCallback((index: number) => {
        if (editingQuickAddItemIndex !== null) return;
        setSelectedQuickAddIndices((prev) => {
            const newSet = new Set(prev);
            if (newSet.has(index)) newSet.delete(index);
            else newSet.add(index);
            return newSet;
        });
    }, [editingQuickAddItemIndex]);
  
    const handleEditQuickAddItem = useCallback((index: number) => {
        if (editingQuickAddItemIndex !== null) {
            Alert.alert("Finish Editing", "Please save or cancel the current edit first."); return;
        }
        const item = quickAddItems[index];
        setEditingQuickAddItemIndex(index);
        setEditedFoodName(item.foodName);
        setEditedGrams(String(Math.round(item.estimatedWeightGrams)));
    }, [editingQuickAddItemIndex, quickAddItems]);
  
    const handleSaveQuickAddItemEdit = useCallback(() => {
        if (editingQuickAddItemIndex === null) return;
  
        const trimmedName = editedFoodName.trim();
        if (!trimmedName) { Alert.alert("Invalid Name", "Food name cannot be empty."); return; }
        const numericGrams = parseFloat(editedGrams);
        if (!isValidNumberInput(editedGrams) || numericGrams <= 0) { Alert.alert("Invalid Grams", "Please enter a valid positive number."); return; }
        const roundedGrams = Math.round(numericGrams);
  
        setQuickAddItems((prevItems) =>
            prevItems.map((item, index) =>
                index === editingQuickAddItemIndex
                    ? { ...item, foodName: trimmedName, estimatedWeightGrams: roundedGrams }
                    : item
            )
        );
  
        setEditingQuickAddItemIndex(null);
        setEditedFoodName("");
        setEditedGrams("");
        Keyboard.dismiss();
    }, [editingQuickAddItemIndex, editedFoodName, editedGrams]);
  
    const handleCancelQuickAddItemEdit = useCallback(() => {
        setEditingQuickAddItemIndex(null);
        setEditedFoodName("");
        setEditedGrams("");
        Keyboard.dismiss();
    }, []);
  
    const handleConfirmQuickAdd = useCallback(() => {
        Keyboard.dismiss();
        if (isEditMode || editingQuickAddItemIndex !== null || selectedQuickAddIndices.size === 0) {
           if(editingQuickAddItemIndex !== null) Alert.alert("Finish Editing", "Save or cancel your edit before adding.");
           else if(selectedQuickAddIndices.size === 0) Alert.alert("No Items Selected", "Select items to add.");
          return;
        }
  
        try {
            const entriesToAdd: { food: Food; grams: number }[] = [];
            Array.from(selectedQuickAddIndices).forEach((index) => {
                 if (index >= 0 && index < quickAddItems.length) {
                    const item = quickAddItems[index];
                    const quickFood: Food = {
                        id: uuidv4(),
                        name: item.foodName,
                        calories: Math.round(Number(item.calories_per_100g) || 0),
                        protein: Math.round(Number(item.protein_per_100g) || 0),
                        carbs: Math.round(Number(item.carbs_per_100g) || 0),
                        fat: Math.round(Number(item.fat_per_100g) || 0),
                    };
                    const entryGrams = Math.max(1, Math.round(Number(item.estimatedWeightGrams) || 1));
                    entriesToAdd.push({ food: quickFood, grams: entryGrams });
                 } else {
                     console.warn(`Skipping invalid index ${index} during quick add confirm.`);
                 }
            });
  
            if (entriesToAdd.length > 0) {
                 handleAddMultipleEntries(entriesToAdd);
            } else {
                 Alert.alert("Nothing to Add", "No valid items were selected or prepared.");
            }
  
        } catch (error) {
            console.error("Error confirming Quick Add:", error);
            Alert.alert("Error", "Could not prepare items to add.");
        }
    }, [quickAddItems, selectedQuickAddIndices, editingQuickAddItemIndex, handleAddMultipleEntries, isEditMode]);
  
  
    const handleQuickAddGramsChange = useCallback((text: string) => {
        const cleanedText = text.replace(/[^0-9.]/g, "").replace(/(\..*?)\./g, "$1");
        setEditedGrams(cleanedText);
    }, []);
  
    // --- Computed States ---
    const isActionDisabled = isAiLoading || quickAddLoading;
    const isAddButtonDisabled = modalMode !== "normal" || !selectedFood || !isValidNumberInput(grams) || parseFloat(grams) <= 0 || isAiLoading;
    const isAiButtonDisabled = modalMode !== "normal" || !selectedFood || !autoInput.trim() || isAiLoading;
    const isQuickAddConfirmDisabled = isEditMode || modalMode !== "quickAddSelect" || selectedQuickAddIndices.size === 0 || editingQuickAddItemIndex !== null || quickAddLoading;
    const isQuickAddImageButtonDisabled = isEditMode || isAiLoading || quickAddLoading;
  
    // --- Build list data for the main FlatList ---
    const listData = useMemo((): ListItemType[] => {
        const items: ListItemType[] = [];
        if (modalMode === "normal") {
            items.push({ type: "searchBar", key: "searchBar" });
            if (!search && recentFoods.length > 0) {
                items.push({ type: "recentFoods", key: "recentFoods" });
            }
            if (search) {
                if (filteredFoods.length > 0) {
                    filteredFoods.forEach((food) =>
                        items.push({ type: "searchResults", key: `search-${food.id}`, data: food })
                    );
                } else {
                    items.push({ type: "noResults", key: "noResults" });
                }
            }
            if (selectedFood) {
                items.push({ type: "amountInput", key: "amountInput" });
            }
        }
        else if (modalMode === "quickAddSelect") {
             items.push({ type: "quickAddHeader", key: "quickAddHeader" });
             if (quickAddLoading) {
                 items.push({ type: "quickAddLoading", key: "quickAddLoading"});
             } else if (quickAddItems.length > 0) {
                 quickAddItems.forEach((item, index) => {
                     if (editingQuickAddItemIndex === index) {
                         items.push({ type: "quickAddEditForm", key: `qa-edit-${index}`, index });
                     } else {
                         items.push({ type: "quickAddItem", key: `qa-${index}`, data: item, index });
                     }
                 });
             } else {
                 items.push({ type: "noResults", key: "quick-add-no-results" });
             }
        }
        items.push({ type: "spacer", key: "bottom-spacer", height: 60 });
        return items;
    }, [
        modalMode, search, recentFoods, filteredFoods, selectedFood,
        quickAddLoading, quickAddItems, editingQuickAddItemIndex,
    ]);
  
    // --- Render individual item types for the main FlatList ---
    const renderListItem = useCallback(({ item }: { item: ListItemType }): React.ReactElement | null => {
        // Switch case logic remains the same as before...
        switch (item.type) {
            case "searchBar":
                return (
                    <SearchBar
                        placeholder="Search Foods..."
                        onChangeText={updateSearch}
                        value={search}
                        platform={Platform.OS === "ios" ? "ios" : "android"}
                        containerStyle={styles.searchBarContainer}
                        inputContainerStyle={styles.searchBarInputContainer}
                        inputStyle={styles.searchInputStyle}
                        onCancel={() => updateSearch("")}
                        showCancel={Platform.OS === 'ios'}
                        onClear={() => updateSearch("")}
                        disabled={isActionDisabled || modalMode !== 'normal'}
                    />
                );
  
            case "recentFoods":
                if (!recentFoods || recentFoods.length === 0) return null;
                return (
                     <View style={styles.recentFoodsSection}>
                         <Text style={styles.sectionTitle}>Recent</Text>
                         <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={styles.recentFoodsContainer}>
                             {recentFoods.map((food) => (
                                 <TouchableOpacity
                                     key={`recent-${food.id}`}
                                     style={[styles.recentFoodItem, screenWidth < 350 && styles.smallRecentFoodItem, selectedFood?.id === food.id && styles.selectedRecentFoodItem]}
                                     onPress={() => handleInternalSelectFood(food)}
                                     disabled={isActionDisabled}
                                     >
                                     {foodIcons[food.name] !== undefined ? (
                                         foodIcons[food.name] ? (
                                             <Image source={{ uri: foodIcons[food.name] as string }} style={styles.foodIconSmall} onError={() => setFoodIcons((prev) => ({ ...prev, [food.name]: null }))}/>
                                         ) : (
                                             <View style={[styles.foodIconSmall, styles.iconPlaceholderSmall]}><Icon name="fastfood" type="material" size={12} color={theme.colors.grey2} /></View>
                                         )
                                     ) : (
                                         <ActivityIndicator size="small" color={theme.colors.grey3} style={styles.foodIconSmall} />
                                     )}
                                     <Text style={[styles.recentFoodText, screenWidth < 350 && styles.smallRecentFoodText]} numberOfLines={1} ellipsizeMode="tail">
                                         {food.name}
                                     </Text>
                                 </TouchableOpacity>
                             ))}
                         </ScrollView>
                     </View>
                 );
  
            case "searchResults": {
                const food = item.data;
                return (
                    <TouchableOpacity onPress={() => handleInternalSelectFood(food)} disabled={isActionDisabled}>
                        <ListItem bottomDivider containerStyle={[styles.listItemContainer, selectedFood?.id === food.id && styles.selectedListItem]}>
                             {foodIcons[food.name] !== undefined ? (
                                foodIcons[food.name] ? (
                                    <Image source={{ uri: foodIcons[food.name] as string }} style={styles.foodIcon} onError={() => setFoodIcons((prev) => ({ ...prev, [food.name]: null }))} />
                                ) : (
                                    <View style={styles.defaultIconContainer}><Icon name="restaurant" type="material" size={18} color={theme.colors.grey3} /></View>
                                )
                            ) : (
                                <ActivityIndicator size="small" color={theme.colors.grey3} style={styles.foodIcon} />
                            )}
                            <ListItem.Content>
                                <ListItem.Title style={styles.listItemTitle}>{food.name}</ListItem.Title>
                            </ListItem.Content>
                            {selectedFood?.id === food.id && (
                                <Icon name="checkmark-circle" type="ionicon" color={theme.colors.primary} size={24} />
                            )}
                        </ListItem>
                    </TouchableOpacity>
                );
            }
  
            case "noResults":
                 if (modalMode === 'quickAddSelect') {
                     return <Text style={styles.noFoodsText}> No food items found in the image. </Text>;
                 } else {
                     return <Text style={styles.noFoodsText}> No foods found matching "{search}". </Text>;
                 }
  
            case "amountInput":
                if (!selectedFood) return null;
                return (
                    <View style={styles.amountSection}>
                        <View style={styles.unitSelectorContainer}>
                            <Text style={styles.inputLabel}>Amount</Text>
                            <ButtonGroup
                                buttons={["Grams", "Auto (AI)"]}
                                selectedIndex={unitMode === "grams" ? 0 : 1}
                                onPress={(index) => !isActionDisabled && setUnitMode(index === 0 ? "grams" : "auto")}
                                containerStyle={styles.buttonGroupContainer}
                                selectedButtonStyle={{ backgroundColor: theme.colors.primary }}
                                textStyle={styles.buttonGroupText}
                                selectedTextStyle={{ color: theme.colors.white }}
                                disabled={isEditMode ? [1] : (isActionDisabled ? [0, 1] : [])}
                                disabledStyle={{ backgroundColor: theme.colors.grey5 }}
                                disabledTextStyle={{ color: theme.colors.grey3 }}
                            />
                        </View>
                        {unitMode === "grams" && (
                            <>
                                {!isEditMode && servingSizeSuggestions.length > 0 && (
                                    <View style={styles.servingSizeRow}>
                                        <Text style={styles.servingSizeLabel}>Quick Add:</Text>
                                        <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={styles.servingSizeContainer}>
                                            {servingSizeSuggestions.map((suggestion) => (
                                                <TouchableOpacity key={suggestion.label} style={styles.servingSizeButton} onPress={() => !isActionDisabled && setGrams(suggestion.value)} disabled={isActionDisabled}>
                                                    <Text style={styles.servingSizeButtonTitle}>{suggestion.label}</Text>
                                                </TouchableOpacity>
                                            ))}
                                        </ScrollView>
                                    </View>
                                )}
                                <Input
                                    placeholder={isEditMode ? "Update grams" : "Enter grams (e.g., 150)"}
                                    keyboardType="numeric" value={grams}
                                    onChangeText={(text) => {
                                        const cleanedText = text.replace(/[^0-9.]/g, "").replace(/(\..*?)\./g, "$1");
                                        setGrams(cleanedText);
                                    }}
                                    inputStyle={styles.gramInputStyle}
                                    inputContainerStyle={styles.gramInputContainerStyle}
                                    errorMessage={!isValidNumberInput(grams) && grams !== "" && grams !== "." ? "Enter a valid number" : ""}
                                    errorStyle={{ color: theme.colors.error }}
                                    rightIcon={<Text style={styles.unitText}>g</Text>}
                                    containerStyle={{ paddingHorizontal: 0 }}
                                    key={`grams-input-${selectedFood.id}`}
                                    disabled={isActionDisabled}
                                />
                            </>
                        )}
                        {unitMode === "auto" && !isEditMode && (
                            <View style={styles.autoInputRow}>
                                <Input
                                    placeholder="Describe quantity (e.g., 1 cup cooked)"
                                    value={autoInput} onChangeText={setAutoInput}
                                    inputStyle={[styles.gramInputStyle, styles.autoInputField]}
                                    inputContainerStyle={styles.gramInputContainerStyle}
                                    containerStyle={styles.autoInputContainer}
                                    multiline={false}
                                    onSubmitEditing={handleEstimateGrams}
                                    key={`auto-input-${selectedFood.id}`}
                                    disabled={isActionDisabled}
                                />
                                <Button
                                    onPress={handleEstimateGrams}
                                    disabled={isAiButtonDisabled || isActionDisabled}
                                    loading={isAiLoading}
                                    buttonStyle={styles.aiButton}
                                    icon={isAiLoading ? undefined : (<Icon name="calculator-variant" type="material-community" size={20} color={theme.colors.white} />)}
                                    title={isAiLoading ? '' : ''}
                                />
                            </View>
                        )}
                    </View>
                );
  
            case "quickAddHeader":
                return (
                     <View style={styles.quickAddHeader}>
                        <Text style={styles.sectionTitle}>
                            {editingQuickAddItemIndex !== null ? "Editing Item Details" : "Select Items from Image"}
                        </Text>
                        {editingQuickAddItemIndex === null && (
                            <Button type="clear" title="Back"
                                onPress={() => {
                                    if (quickAddLoading) return;
                                    setModalMode("normal");
                                    setQuickAddItems([]);
                                    setSelectedQuickAddIndices(new Set());
                                    setEditingQuickAddItemIndex(null);
                                }}
                                titleStyle={{ color: theme.colors.primary, fontSize: 14 }}
                                icon={<Icon name="arrow-back" type="ionicon" size={18} color={theme.colors.primary} />}
                                disabled={quickAddLoading}
                            />
                        )}
                    </View>
                );
  
            case "quickAddLoading":
                return (
                     <View style={styles.centeredContent}>
                        <ActivityIndicator size="large" color={theme.colors.primary} />
                        <Text style={styles.loadingText}>Analyzing Image...</Text>
                    </View>
                );
  
            case "quickAddItem": {
                const { data: itemData, index } = item;
                const isSelected = selectedQuickAddIndices.has(index);
                return (
                    <ListItem
                         bottomDivider
                         containerStyle={[
                            styles.quickAddItemContainer,
                            isSelected && styles.quickAddItemSelected,
                            editingQuickAddItemIndex !== null && editingQuickAddItemIndex !== index && { opacity: 0.6 }
                         ]}
                         onPress={() => handleToggleQuickAddItem(index)}
                         disabled={editingQuickAddItemIndex !== null || isActionDisabled}
                         >
                         <ListItem.Content style={styles.quickAddItemContent}>
                            <ListItem.Title style={styles.quickAddItemTitle} numberOfLines={1}>
                                {itemData.foodName}
                            </ListItem.Title>
                            <ListItem.Subtitle style={styles.quickAddItemSubtitle}>
                                {`~${Math.round(itemData.estimatedWeightGrams)}g`}
                                {itemData.calories_per_100g ? ` (${Math.round(itemData.calories_per_100g * itemData.estimatedWeightGrams / 100)} kcal)` : ''}
                            </ListItem.Subtitle>
                        </ListItem.Content>
                        <View style={styles.quickAddItemActions}>
                           <TouchableOpacity onPress={() => handleEditQuickAddItem(index)} disabled={editingQuickAddItemIndex !== null || isActionDisabled} style={styles.quickAddActionButton}>
                                <Icon name="pencil" type="material-community" size={20} color={editingQuickAddItemIndex !== null ? theme.colors.grey3 : theme.colors.primary} />
                           </TouchableOpacity>
                            <Icon
                                name={isSelected ? "checkbox-marked" : "checkbox-blank-outline"}
                                type="material-community"
                                color={editingQuickAddItemIndex !== null ? theme.colors.grey3 : (isSelected ? theme.colors.success : theme.colors.grey1)}
                                size={24}
                                containerStyle={styles.quickAddCheckbox}
                                />
                        </View>
                    </ListItem>
                );
            }
  
            case "quickAddEditForm": {
                 const { index } = item;
                 return (
                    <View style={styles.quickAddEditContainer}>
                        <Input
                            label="Food Name"
                            placeholder="Enter food name"
                            value={editedFoodName}
                            onChangeText={setEditedFoodName}
                            inputContainerStyle={styles.quickAddEditInput}
                            inputStyle={{fontSize: 15}}
                            labelStyle={{fontSize: 13, fontWeight:'normal', color: theme.colors.grey2}}
                            disabled={isActionDisabled}
                        />
                        <Input
                            label="Estimated Grams"
                            placeholder="Enter grams"
                            value={editedGrams}
                            onChangeText={handleQuickAddGramsChange}
                            keyboardType="numeric"
                            inputContainerStyle={styles.quickAddEditInput}
                             inputStyle={{fontSize: 15}}
                            labelStyle={{fontSize: 13, fontWeight:'normal', color: theme.colors.grey2}}
                            rightIcon={<Text style={styles.unitText}>g</Text>}
                            disabled={isActionDisabled}
                        />
                        <View style={styles.quickAddEditButtons}>
                            <Button title="Cancel" type="outline" onPress={handleCancelQuickAddItemEdit} buttonStyle={styles.quickAddEditButton} titleStyle={styles.quickAddEditButtonTitle} disabled={isActionDisabled} />
                            <Button title="Save" onPress={handleSaveQuickAddItemEdit} buttonStyle={[styles.quickAddEditButton, {backgroundColor: theme.colors.primary}]} titleStyle={[styles.quickAddEditButtonTitle, {color: theme.colors.white}]} disabled={isActionDisabled}/>
                        </View>
                    </View>
                 );
            }
  
            case "spacer":
                return <View style={{ height: item.height }} />;
  
            default:
                return null;
        }
    }, [
        search, updateSearch, isActionDisabled, modalMode, recentFoods, screenWidth, selectedFood, foodIcons, setFoodIcons,
        handleInternalSelectFood, filteredFoods, unitMode, setUnitMode, isEditMode, servingSizeSuggestions, setGrams, grams,
        autoInput, setAutoInput, handleEstimateGrams, isAiLoading, isAiButtonDisabled, theme, styles,
        quickAddLoading, quickAddItems, editingQuickAddItemIndex, selectedQuickAddIndices, handleToggleQuickAddItem, handleEditQuickAddItem,
        editedFoodName, setEditedFoodName, editedGrams, handleQuickAddGramsChange, handleCancelQuickAddItemEdit, handleSaveQuickAddItemEdit,
        handleAddMultipleEntries, pickImageAndAnalyze, addToRecentFoods, handleAddEntry,
    ]);
  
    // --- Render ---
    const combinedOverlayStyle = StyleSheet.flatten([
        styles.overlayStyle,
        { backgroundColor: theme.colors.background },
    ]);
  
    return (
        <Overlay
            isVisible={isVisible}
            onBackdropPress={!isActionDisabled ? toggleOverlay : undefined}
            animationType="slide"
            overlayStyle={styles.overlayContainer}
        >
            <KeyboardAvoidingView
                behavior={Platform.OS === "ios" ? "padding" : "height"}
                style={styles.keyboardAvoidingView}
                keyboardVerticalOffset={KEYBOARD_VERTICAL_OFFSET}
            >
                <View style={combinedOverlayStyle}>
                    {/* Header */}
                    <View style={styles.header}>
                        <TouchableOpacity onPress={!isActionDisabled ? toggleOverlay : undefined} style={styles.closeIconTouchable} disabled={isActionDisabled}>
                            <Icon name="close" type="material" size={28} color={isActionDisabled ? theme.colors.grey3 : theme.colors.text} />
                        </TouchableOpacity>
  
                        <Text h4 h4Style={[styles.overlayTitle, isEditMode && modalMode === "normal" && styles.editModeTitle]} numberOfLines={1} ellipsizeMode="tail">
                            {modalMode === "quickAddSelect"
                                ? editingQuickAddItemIndex !== null ? "Edit Item" : "Select Items to Add"
                                : isEditMode ? "Edit Entry" : "Add Entry"
                            }
                        </Text>
  
                        {modalMode === "normal" && (
                            <>
                                {!isEditMode && (
                                    <TouchableOpacity onPress={handleQuickAddImage} disabled={isQuickAddImageButtonDisabled} style={styles.headerIcon}>
                                        {(quickAddLoading && modalMode === 'normal') ? (
                                            <ActivityIndicator size="small" color={theme.colors.primary} />
                                        ) : (
                                            <Icon name="camera-burst" type="material-community" size={26} color={isQuickAddImageButtonDisabled ? theme.colors.grey3 : theme.colors.primary} />
                                        )}
                                    </TouchableOpacity>
                                )}
                                <Button
                                    title={isEditMode ? "Update" : "Add"}
                                    onPress={handleAddOrUpdateSingleEntry}
                                    disabled={isAddButtonDisabled || isActionDisabled}
                                    buttonStyle={[styles.addButton, isEditMode && styles.updateButton]}
                                    titleStyle={styles.buttonTitle}
                                    loading={isAiLoading && unitMode === 'auto'}
                                />
                            </>
                        )}
                        {modalMode === "quickAddSelect" && !isEditMode && (
                            editingQuickAddItemIndex === null ? (
                                <Button
                                    title={`Add ${selectedQuickAddIndices.size}`}
                                    onPress={handleConfirmQuickAdd}
                                    disabled={isQuickAddConfirmDisabled || isActionDisabled}
                                    buttonStyle={[styles.addButton, { backgroundColor: theme.colors.success }]}
                                    titleStyle={styles.buttonTitle}
                                    loading={quickAddLoading}
                                />
                            ) : (
                                <View style={{ width: 70, marginLeft: 5}} />
                            )
                        )}
                    </View>
  
                    {/* Content Area */}
                    <FlatList
                        data={listData}
                        renderItem={renderListItem}
                        keyExtractor={(item) => item.key}
                        extraData={{ selectedFood, grams, unitMode, autoInput, isAiLoading, search, foodIcons, modalMode, quickAddItems, selectedQuickAddIndices, editingQuickAddItemIndex, editedFoodName, editedGrams, isActionDisabled, quickAddLoading }}
                        style={styles.flatListContainer}
                        contentContainerStyle={styles.flatListContentContainer}
                        keyboardShouldPersistTaps="handled"
                        initialNumToRender={10}
                        maxToRenderPerBatch={10}
                        windowSize={5}
                    />
                </View>
            </KeyboardAvoidingView>
            <Toast />
        </Overlay>
    );
  };
  
  // --- Styles (Keep existing styles) ---
  const useStyles = makeStyles((theme) => ({
    overlayContainer: {
        backgroundColor: "transparent", width: "90%", maxWidth: 500, padding: 0,
        borderRadius: 15, shadowColor: "#000", shadowOffset: { width: 0, height: 3 },
        shadowOpacity: 0.2, shadowRadius: 5, elevation: 6, overflow: "hidden",
        maxHeight: Dimensions.get("window").height * 0.85,
    },
    overlayStyle: {
        width: "100%", height: "100%", borderRadius: 15, padding: 15, paddingBottom: 0,
        backgroundColor: theme.colors.background, flex: 1,
    },
    keyboardAvoidingView: { width: "100%", height: "100%" },
    header: {
        flexDirection: "row", justifyContent: "space-between", alignItems: "center",
        marginBottom: 15, paddingHorizontal: 0,
    },
    closeIconTouchable: { padding: 5, zIndex: 1 },
    overlayTitle: {
        color: theme.colors.text, fontWeight: "bold", fontSize: 20, textAlign: "center",
        flex: 1, marginHorizontal: 5,
    },
    editModeTitle: { color: theme.colors.warning },
    headerIcon: { padding: 5, marginHorizontal: 5, zIndex: 1 },
    addButton: {
        borderRadius: 20, paddingHorizontal: 15, paddingVertical: 8, minWidth: 70,
        marginLeft: 5, backgroundColor: theme.colors.primary, zIndex: 1,
    },
    updateButton: { backgroundColor: theme.colors.warning },
    buttonTitle: { color: theme.colors.white, fontWeight: "600", fontSize: 15 },
    flatListContainer: { flex: 1, width: '100%' },
    flatListContentContainer: { paddingBottom: 30 },
    searchBarContainer: {
        backgroundColor: "transparent", borderBottomColor: "transparent", borderTopColor: "transparent",
        paddingHorizontal: 0, marginBottom: 10,
    },
    searchBarInputContainer: {
        borderRadius: 25, backgroundColor: theme.colors.searchBg || theme.colors.grey5, height: 40,
    },
    searchInputStyle: { color: theme.colors.text, fontSize: 15 },
    recentFoodsSection: { marginBottom: 15 },
    sectionTitle: {
        fontWeight: "600", marginBottom: 8, color: theme.colors.text, fontSize: 14,
        marginLeft: 5, textTransform: "uppercase",
    },
    recentFoodsContainer: { paddingHorizontal: 5, paddingVertical: 2 },
    recentFoodItem: {
        paddingHorizontal: 10, paddingVertical: 6, borderRadius: 16,
        backgroundColor: theme.colors.grey5, marginRight: 8, flexDirection: "row",
        alignItems: "center", borderWidth: 1.5, borderColor: "transparent",
    },
    selectedRecentFoodItem: { borderColor: theme.colors.primary },
    smallRecentFoodItem: { paddingHorizontal: 8, paddingVertical: 5 },
    foodIconSmall: {
        width: 20, height: 20, marginRight: 6, borderRadius: 10, resizeMode: "contain",
        alignItems: "center", justifyContent: "center", backgroundColor: theme.colors.grey4,
    },
    iconPlaceholderSmall: {
        backgroundColor: theme.colors.grey4, alignItems: "center", justifyContent: "center",
    },
    recentFoodText: { color: theme.colors.text, fontSize: 13, maxWidth: 80 },
    smallRecentFoodText: { fontSize: 12, maxWidth: 70 },
    listItemContainer: {
        backgroundColor: "transparent", paddingVertical: 8, paddingHorizontal: 5,
        borderBottomColor: theme.colors.divider,
    },
    selectedListItem: { backgroundColor: theme.colors.grey5, borderRadius: 8 },
    defaultIconContainer: {
        width: 35, height: 35, marginRight: 12, borderRadius: 17.5,
        backgroundColor: theme.colors.grey5, alignItems: "center", justifyContent: "center",
    },
    foodIcon: {
        width: 35, height: 35, marginRight: 12, borderRadius: 17.5, resizeMode: "contain",
        backgroundColor: theme.colors.grey5, alignItems: "center", justifyContent: "center",
    },
    listItemTitle: { color: theme.colors.text, fontSize: 16, fontWeight: "500" },
    noFoodsText: {
        color: theme.colors.grey2, fontStyle: "italic", textAlign: "center",
        marginTop: 20, marginBottom: 10, paddingHorizontal: 10,
    },
    amountSection: {
        marginTop: 10, borderTopWidth: 1, borderTopColor: theme.colors.divider,
        paddingTop: 15, paddingHorizontal: 0,
    },
    unitSelectorContainer: {
        flexDirection: "row", alignItems: "center", justifyContent: "space-between",
        marginBottom: 15, paddingHorizontal: 5,
    },
    inputLabel: {
        fontWeight: "600", color: theme.colors.grey1, fontSize: 14, marginRight: 10,
        textTransform: "uppercase",
    },
    buttonGroupContainer: {
        flex: 0.7, maxWidth: 220, height: 35, borderRadius: 8,
        borderColor: theme.colors.primary, borderWidth: 1,
        backgroundColor: theme.colors.background,
    },
    buttonGroupText: { fontSize: 14, color: theme.colors.text },
    servingSizeRow: {
        flexDirection: "row", alignItems: "center", marginBottom: 12, paddingHorizontal: 5,
    },
    servingSizeLabel: { color: theme.colors.grey2, fontSize: 13, marginRight: 8 },
    servingSizeContainer: { flexGrow: 0 },
    servingSizeButton: {
        backgroundColor: theme.colors.grey4, borderRadius: 15, marginRight: 8,
        paddingHorizontal: 12, paddingVertical: 5, justifyContent: "center",
        alignItems: "center", height: 30,
    },
    servingSizeButtonTitle: { color: theme.colors.text, fontSize: 13 },
    gramInputStyle: { color: theme.colors.text, fontSize: 16, paddingVertical: 8, height: 40, },
    gramInputContainerStyle: { borderBottomColor: theme.colors.grey3, paddingHorizontal: 5, },
    unitText: { color: theme.colors.grey2, fontSize: 15, fontWeight: "500", paddingRight: 5, },
    autoInputRow: { flexDirection: "row", alignItems: "center", paddingHorizontal: 0 },
    autoInputContainer: { flex: 1, paddingHorizontal: 0, marginRight: 10 },
    autoInputField: { height: 40 },
    aiButton: {
        backgroundColor: theme.colors.secondary, borderRadius: 20, width: 40, height: 40,
        padding: 0, justifyContent: "center", alignItems: "center", minWidth: 40,
    },
    quickAddHeader: {
        flexDirection: "row", justifyContent: "space-between", alignItems: "center",
        marginBottom: 10, paddingHorizontal: 5, borderBottomWidth: 1,
        borderBottomColor: theme.colors.divider, paddingBottom: 8,
    },
    centeredContent: {
        alignItems: 'center', justifyContent: 'center', padding: 20, minHeight: 150,
    },
    loadingText: { marginTop: 10, color: theme.colors.text, fontSize: 16, fontWeight: "500" },
    quickAddItemContainer: {
        paddingVertical: 10, paddingHorizontal: 5,
        backgroundColor: theme.colors.background,
    },
     quickAddItemSelected: {
        backgroundColor: theme.colors.successLight || '#d4edda',
        borderRadius: 8,
    },
    quickAddItemContent: { flex: 1, marginRight: 10 },
     quickAddItemTitle: { color: theme.colors.text, fontWeight: '500', fontSize: 15 },
    quickAddItemSubtitle: { color: theme.colors.grey1, fontSize: 13, marginTop: 2 },
    quickAddItemActions: { flexDirection: 'row', alignItems: 'center' },
    quickAddActionButton: { padding: 5, marginRight: 10 },
    quickAddCheckbox: {},
     quickAddEditContainer: {
        padding: 10, marginVertical: 5, backgroundColor: theme.colors.grey5,
        borderRadius: 8, borderWidth: 1, borderColor: theme.colors.primary,
    },
    quickAddEditInput: {
        borderBottomWidth: 1, borderColor: theme.colors.grey3,
        paddingHorizontal: 0, marginBottom: 5,
    },
     quickAddEditButtons: {
        flexDirection: 'row', justifyContent: 'flex-end', marginTop: 10,
    },
    quickAddEditButton: {
        marginLeft: 10, paddingHorizontal: 15, minWidth: 80, borderRadius: 15,
    },
    quickAddEditButtonTitle: { fontSize: 14, fontWeight: '600' }
  }));
  
  export default AddEntryModal;
---------- END AddEntryModal.tsx ----------


---------- AddFoodModal.tsx ----------
// src/components/AddFoodModal.tsx
// components/AddFoodModal.tsx (With Image Compression)
import React, { useState, useEffect, useCallback } from "react";
import {
  View,
  KeyboardAvoidingView,
  Platform,
  ActivityIndicator,
  Alert,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
} from "react-native";
import {
  Button,
  Input,
  Text,
  Overlay,
  makeStyles,
  useTheme,
  Icon,
} from "@rneui/themed";
import { Food } from "../types/food";
import { MaterialCommunityIcons } from "@expo/vector-icons";
import Toast from "react-native-toast-message";
import {
    getMacrosFromText, // Utility using backend
    getMacrosForImageFile, // Utility using backend
    BackendError, // Import error type
} from "../utils/macros";
import * as ImagePicker from "expo-image-picker";
import * as ImageManipulator from 'expo-image-manipulator'; // Import manipulator
import { ImagePickerAsset, ImagePickerResult } from 'expo-image-picker';
import { isValidNumberInput } from "../utils/validationUtils"; // Keep isNotEmpty validation

interface AddFoodModalProps {
  isVisible: boolean;
  toggleOverlay: () => void;
  newFood: Omit<Food, "id">;
  editFood: Food | null;
  errors: { [key: string]: string };
  handleInputChange: (
    key: keyof Omit<Food, "id">,
    value: string,
    isEdit: boolean
  ) => void;
  handleCreateFood: () => void; // Still used to update local list state
  handleUpdateFood: () => void; // Still used to update local list state
  validateFood: (food: Omit<Food, "id">) => { [key: string]: string } | null;
  setErrors: React.Dispatch<React.SetStateAction<{ [key: string]: string }>>;
}

const KEYBOARD_VERTICAL_OFFSET = Platform.OS === "ios" ? 60 : 0;
const MAX_IMAGE_DIMENSION = 1024; // Max width/height for compressed image
const IMAGE_COMPRESSION_QUALITY = 0.7; // Compression quality (0.0 - 1.0)

const AddFoodModal: React.FC<AddFoodModalProps> = ({
  isVisible,
  toggleOverlay,
  newFood,
  editFood,
  errors,
  handleInputChange,
  handleCreateFood,
  handleUpdateFood,
  validateFood,
  setErrors,
}) => {
  const { theme } = useTheme();
  const styles = useStyles();
  const [loading, setLoading] = useState(false); // For save/update button
  // const [apiLoading, setApiLoading] = useState(false); // Not currently used, imageLoading is specific
  const [mode, setMode] = useState<"normal" | "ingredients">("normal");
  const [ingredients, setIngredients] = useState("");
  const [aiButtonLoading, setAiButtonLoading] = useState(false); // For ingredient text AI
  const [imageLoading, setImageLoading] = useState(false); // For image analysis AI

  useEffect(() => {
    if (isVisible) {
      setErrors({});
      setMode("normal");
      setIngredients("");
      setAiButtonLoading(false);
      setImageLoading(false);
      setLoading(false);
    }
  }, [isVisible, setErrors]);

  // Helper to get value from correct state (edit or new)
  const getValue = (key: keyof Omit<Food, "id">) => {
    const source = editFood ?? newFood;
    const value = source[key];

    // Handle display formatting for numeric fields
    if (typeof value === 'number' && key !== 'name') {
        // Return "0" if value is 0, otherwise string representation
        // Return empty string if it's the initial 0 in the newFood state
        if (value === 0 && source === newFood) return "";
        return String(value);
    }
    return String(value ?? ""); // Ensure name is treated as string
  };


  // Handles local state update and triggers parent save/update (Unchanged)
  const handleCreateOrUpdate = async (isUpdate: boolean) => {
    setLoading(true);
    const foodData = isUpdate ? editFood : newFood;
    if (!foodData) {
        setLoading(false);
        return;
    }

     const dataToValidate: Omit<Food, "id"> = {
        name: getValue("name").trim(), // Trim name for validation
        // Ensure numeric values are parsed correctly, defaulting to 0 if invalid/empty
        calories: parseFloat(getValue("calories")) || 0,
        protein: parseFloat(getValue("protein")) || 0,
        carbs: parseFloat(getValue("carbs")) || 0,
        fat: parseFloat(getValue("fat")) || 0,
    };

    const validationErrors = validateFood(dataToValidate);

    if (validationErrors) {
      setErrors(validationErrors);
      setLoading(false);
      Toast.show({
        type: "error", text1: "Please fix the errors", position: 'bottom',
      });
      return;
    }
    setErrors({});

    try {
      // Call the parent function which handles storage/state update
      if (isUpdate) {
          await handleUpdateFood();
      } else {
          await handleCreateFood();
      }

      Toast.show({
        type: "success",
        text1: `Food ${isUpdate ? "Updated" : "Created"} Successfully!`,
        position: 'bottom',
      });
      toggleOverlay(); // Close modal on success
    } catch (error: any) {
      console.error(`Error during ${isUpdate ? 'update' : 'create'} food handler:`, error);
      Alert.alert(
        "Error",
        error.message || `Failed to ${isUpdate ? "update" : "create"} food.`
      );
    } finally {
      setLoading(false);
    }
  };

  // Uses backend service for recipe text analysis (Unchanged)
  const handleAiButtonClick = async () => {
    const foodName = getValue("name");
    if (!foodName && mode === 'ingredients') {
      Alert.alert("Missing Name", "Please enter a food name first.");
      return;
    }

    if (mode === "normal") {
      setMode("ingredients");
      handleInputChange("calories", "", !!editFood);
      handleInputChange("protein", "", !!editFood);
      handleInputChange("carbs", "", !!editFood);
      handleInputChange("fat", "", !!editFood);
    } else if (mode === "ingredients") {
      const currentFoodName = getValue("name");
      if (!currentFoodName) {
        Alert.alert("Missing Name", "Please enter a food name before calculating macros.");
        return;
      }

      setAiButtonLoading(true);
      try {
        const macros = await getMacrosFromText(currentFoodName, ingredients);
        handleInputChange("calories", String(Math.round(macros.calories)), !!editFood);
        handleInputChange("protein", String(Math.round(macros.protein)), !!editFood);
        handleInputChange("carbs", String(Math.round(macros.carbs)), !!editFood);
        handleInputChange("fat", String(Math.round(macros.fat)), !!editFood);
        setMode("normal");
        Toast.show({ type: 'info', text1: 'Macros estimated from text.', position: 'bottom' });
      } catch (error) {
         // Alert is handled within getMacrosFromText utility now
         console.error("AI Macro fetch error (recipe - modal):", error);
      } finally {
        setAiButtonLoading(false);
      }
    }
  };

  // Function to compress image before processing
  const compressImage = async (asset: ImagePicker.ImagePickerAsset): Promise<ImageManipulator.ImageResult | null> => {
     console.log(`Original image dimensions: ${asset.width}x${asset.height}`);
     try {
         const actions: ImageManipulator.Action[] = [];
         // Resize if dimensions exceed max
         if (asset.width > MAX_IMAGE_DIMENSION || asset.height > MAX_IMAGE_DIMENSION) {
              const options: ImageManipulator.ActionResize = {
                resize: {
                  width: undefined,
                  height: undefined
                }
              };
              if (asset.width > asset.height) {
                 options.resize.width = MAX_IMAGE_DIMENSION;
             } else {
                 options.resize.height = MAX_IMAGE_DIMENSION;
             }
             actions.push({ resize: options.resize });
             console.log(`Resizing image to max dimension ${MAX_IMAGE_DIMENSION}`);
         }

         const saveOptions: ImageManipulator.SaveOptions = {
             compress: IMAGE_COMPRESSION_QUALITY,
             format: ImageManipulator.SaveFormat.JPEG, // Compress to JPEG for smaller size
             base64: false, // We don't need base64 from manipulator
         };

         const result = await ImageManipulator.manipulateAsync(asset.uri, actions, saveOptions);
         console.log(`Compressed image dimensions: ${result.width}x${result.height}`);
         console.log(`Compressed image URI: ${result.uri}`);
         return result;
     } catch (error) {
          console.error("Failed to compress image:", error);
          Alert.alert("Compression Error", "Could not process the image for compression.");
          return null;
     }
  };

  // Uses backend service for image analysis
  const handleGetImageAndAnalyze = async () => {

    const processImage = async (pickerResult: ImagePickerResult) => {
        if (pickerResult.canceled) {
            console.log("Image selection/capture cancelled");
            setImageLoading(false); return;
        }

        if (pickerResult.assets && pickerResult.assets.length > 0) {
            const originalAsset = pickerResult.assets[0];
            console.log("Image acquired:", originalAsset.uri);
            setImageLoading(true); // Loading starts

            // *** Compress the image ***
            const compressedAsset = await compressImage(originalAsset);
            if (!compressedAsset) {
                 setImageLoading(false); // Stop loading if compression failed
                 return;
            }

            // *** Use compressed asset for analysis ***
            const assetForAnalysis: ImagePicker.ImagePickerAsset = {
               ...originalAsset,
               uri: compressedAsset.uri,
               width: compressedAsset.width,
               height: compressedAsset.height,
               mimeType: 'image/jpeg', // Compressed to JPEG
            };

            try {
                 // Call utility function (uses backend) with compressed asset
                 const result = await getMacrosForImageFile(assetForAnalysis);

                // Update form fields with results
                handleInputChange("name", result.foodName, !!editFood);
                handleInputChange("calories", String(Math.round(result.calories)), !!editFood);
                handleInputChange("protein", String(Math.round(result.protein)), !!editFood);
                handleInputChange("carbs", String(Math.round(result.carbs)), !!editFood);
                handleInputChange("fat", String(Math.round(result.fat)), !!editFood);

                setMode("normal");
                setIngredients("");

                Toast.show({
                    type: 'success',
                    text1: 'Food Identified!',
                    text2: `Identified as ${result.foodName}. Macros estimated.`,
                    position: 'bottom',
                });

            } catch (analysisError) {
                // Alert is handled within getMacrosForImageFile utility now
                console.error("Error during image analysis (modal):", analysisError);
            } finally {
                 setTimeout(() => setImageLoading(false), 100); // Stop loading
            }
        } else {
            console.log("No assets selected or returned.");
            setImageLoading(false);
        }
    };

    // --- Image Picker Logic ---
    Alert.alert(
      "Get Image",
      "Choose a source for the food image:",
      [
        { text: "Cancel", style: "cancel", onPress: () => setImageLoading(false) },
        {
          text: "Camera",
          onPress: async () => {
            setImageLoading(true); // Indicate loading immediately
            try {
                const permissionResult = await ImagePicker.requestCameraPermissionsAsync();
                if (!permissionResult.granted) {
                    Alert.alert("Permission Required", "Camera access is needed.");
                    setImageLoading(false); return;
                }
                const cameraResult = await ImagePicker.launchCameraAsync({
                    quality: 1, // Capture high quality
                    exif: false,
                });
                await processImage(cameraResult);
            } catch (error) {
                console.error("Error launching camera:", error);
                Alert.alert("Camera Error", "Could not open the camera.");
                setImageLoading(false);
            }
          },
        },
        {
          text: "Gallery",
          onPress: async () => {
            setImageLoading(true); // Indicate loading immediately
            try {
                const permissionResult = await ImagePicker.requestMediaLibraryPermissionsAsync();
                if (!permissionResult.granted) {
                    Alert.alert("Permission Required", "Gallery access needed.");
                    setImageLoading(false); return;
                }
                const libraryResult = await ImagePicker.launchImageLibraryAsync({
                    mediaTypes: ImagePicker.MediaTypeOptions.Images,
                    quality: 1, // Select high quality
                });
                await processImage(libraryResult);
            } catch (error) {
                console.error("Error launching image library:", error);
                Alert.alert("Gallery Error", "Could not open the image library.");
                 setImageLoading(false);
            }
          },
        },
      ],
      { cancelable: true, onDismiss: () => setImageLoading(false) }
    );
  };

    const combinedOverlayStyle = StyleSheet.flatten([
        styles.overlayStyle,
        { backgroundColor: theme.colors.background }
    ]);

    const isAnyLoading = loading || aiButtonLoading || imageLoading; // Combined loading state

  return (
    <Overlay
      isVisible={isVisible}
      onBackdropPress={!isAnyLoading ? toggleOverlay : undefined} // Prevent closing while loading
      animationType="fade"
      overlayStyle={styles.overlayContainer}
    >
      <KeyboardAvoidingView
        behavior={Platform.OS === "ios" ? "padding" : "height"}
        style={styles.keyboardAvoidingView}
        keyboardVerticalOffset={KEYBOARD_VERTICAL_OFFSET}
      >
        <View style={combinedOverlayStyle}>
          <View style={styles.header}>
            <Text h4 style={styles.overlayTitle}>
              {editFood ? "Edit Food" : "Add New Food"}
            </Text>
            <Button
              title={editFood ? "Update" : "Add"}
              onPress={() => handleCreateOrUpdate(!!editFood)}
              buttonStyle={[
                styles.button,
                { backgroundColor: editFood ? theme.colors.warning : theme.colors.primary },
              ]}
              titleStyle={{ color: theme.colors.white, fontWeight: "600" }}
              loading={loading} // Only show loading for the save/update action itself
              disabled={isAnyLoading} // Disable if any operation is running
              containerStyle={styles.buttonContainer}
            />
            <Icon
              name="close"
              type="material"
              size={28}
              color={theme.colors.text}
              onPress={!isAnyLoading ? toggleOverlay : undefined} // Disable close when loading
              containerStyle={styles.closeIcon}
              disabled={isAnyLoading}
              disabledStyle={{ backgroundColor: 'transparent' }}
            />
          </View>

          <ScrollView keyboardShouldPersistTaps="handled">
             {/* Food Name Input with Image Icon */}
            <View style={styles.inputRow}>
                <Input
                    label="Food Name"
                    labelStyle={{ color: theme.colors.text }}
                    value={getValue("name")}
                    onChangeText={(text) => handleInputChange("name", text, !!editFood)}
                    errorMessage={errors.name}
                    inputContainerStyle={[styles.inputContainerStyle, styles.inputContainerFlex]}
                    inputStyle={styles.inputStyle}
                    containerStyle={{ flex: 1 }}
                    leftIcon={
                        <MaterialCommunityIcons
                        name="food-apple" size={24}
                        color={errors.name ? theme.colors.error : theme.colors.grey1}
                        />
                    }
                    disabled={isAnyLoading} // Disable input while loading
                />
                {/* Image Picker/Camera Icon Button */}
                <TouchableOpacity
                    onPress={handleGetImageAndAnalyze}
                    disabled={isAnyLoading} // Disable while loading
                    style={styles.iconButtonContainer}
                 >
                    {imageLoading ? ( // Use specific loading state for this button
                        <ActivityIndicator size="small" color={theme.colors.primary} />
                    ) : (
                        <Icon
                            name="camera-enhance-outline"
                            type="material-community" size={28}
                            color={isAnyLoading ? theme.colors.grey3 : theme.colors.primary} // Dim icon when disabled
                        />
                    )}
                </TouchableOpacity>
            </View>

            {/* Macro Inputs or Ingredient Input */}
            {mode === "normal" && (
              <>
                <Input
                  label="Calories (per 100g)" labelStyle={{ color: theme.colors.text }}
                  keyboardType="numeric" value={getValue("calories")}
                  onChangeText={(text) => handleInputChange("calories", text, !!editFood)}
                  errorMessage={errors.calories} inputContainerStyle={styles.inputContainerStyle}
                  inputStyle={styles.inputStyle}
                  leftIcon={<MaterialCommunityIcons name="fire" size={24} color={errors.calories ? theme.colors.error : theme.colors.grey1}/>}
                  disabled={isAnyLoading}
                />
                <Input
                  label="Protein (per 100g)" labelStyle={{ color: theme.colors.text }}
                  keyboardType="numeric" value={getValue("protein")}
                  onChangeText={(text) => handleInputChange("protein", text, !!editFood)}
                  errorMessage={errors.protein} inputContainerStyle={styles.inputContainerStyle}
                  inputStyle={styles.inputStyle}
                  leftIcon={<MaterialCommunityIcons name="food-drumstick" size={24} color={errors.protein ? theme.colors.error : theme.colors.grey1}/>}
                   disabled={isAnyLoading}
               />
                <Input
                  label="Carbs (per 100g)" labelStyle={{ color: theme.colors.text }}
                  keyboardType="numeric" value={getValue("carbs")}
                  onChangeText={(text) => handleInputChange("carbs", text, !!editFood)}
                  errorMessage={errors.carbs} inputContainerStyle={styles.inputContainerStyle}
                  inputStyle={styles.inputStyle}
                  leftIcon={<MaterialCommunityIcons name="bread-slice" size={24} color={errors.carbs ? theme.colors.error : theme.colors.grey1}/>}
                   disabled={isAnyLoading}
               />
                <Input
                  label="Fat (per 100g)" labelStyle={{ color: theme.colors.text }}
                  keyboardType="numeric" value={getValue("fat")}
                  onChangeText={(text) => handleInputChange("fat", text, !!editFood)}
                  errorMessage={errors.fat} inputContainerStyle={styles.inputContainerStyle}
                  inputStyle={styles.inputStyle}
                  leftIcon={<MaterialCommunityIcons name="oil" size={24} color={errors.fat ? theme.colors.error : theme.colors.grey1}/>}
                   disabled={isAnyLoading}
               />
              </>
            )}

            {mode === "ingredients" && (
              <>
                <View style={styles.backButtonContainer}>
                  <Icon name="arrow-left" type="material-community" size={24} color={theme.colors.primary}
                    onPress={() => !isAnyLoading && setMode("normal")} // Prevent switching during AI call
                    disabled={isAnyLoading} containerStyle={styles.backIcon}
                  />
                  <Text style={[styles.backButtonText, isAnyLoading && styles.disabledText]} onPress={() => !isAnyLoading && setMode("normal")}>
                      Back to Manual Input
                  </Text>
                </View>
                <Input
                  label="Ingredients (Optional)" labelStyle={{ color: theme.colors.text }}
                  value={ingredients} onChangeText={setIngredients} multiline={true}
                  numberOfLines={4} inputContainerStyle={[styles.inputContainerStyle, styles.multilineInputContainer]}
                  inputStyle={[styles.inputStyle, styles.multilineInput]}
                  placeholder="e.g.\n100g Chicken Breast\n50g Rice\n1 tbsp Olive Oil"
                  placeholderTextColor={theme.colors.grey3}
                  leftIcon={<MaterialCommunityIcons name="format-list-bulleted" size={24} color={theme.colors.grey1} style={styles.multilineIcon}/>}
                  disabled={isAnyLoading}
                />
              </>
            )}

            {/* AI (Text) Button */}
            <Button
              title={mode === "normal" ? "Calculate with AI (Recipe/Text)" : ingredients ? "Get Macros from Ingredients" : "Get Macros from Name Only"}
              onPress={handleAiButtonClick}
              buttonStyle={[styles.button, styles.aiButton, { backgroundColor: theme.colors.secondary }]}
              titleStyle={[styles.aiButtonTitle, { color: theme.colors.white }]}
              loading={aiButtonLoading} // Use specific loading state
              disabled={isAnyLoading} // Disable while any op runs
              icon={mode === "normal" ? <MaterialCommunityIcons name="text-box-search-outline" size={18} color={theme.colors.white} style={{ marginRight: 8 }}/> : undefined}
              containerStyle={[styles.buttonContainer, { marginTop: 15 }]}
            />

            {/* Barcode Placeholder (Unchanged) */}
            <View style={styles.futureInputContainer}>
              <Text style={styles.futureInputLabel}>
                Barcode Input (Coming Soon)
              </Text>
            </View>
          </ScrollView>
        </View>
      </KeyboardAvoidingView>
    </Overlay>
  );
};

// --- Styles (Keep existing styles) ---
const useStyles = makeStyles((theme) => ({
    overlayContainer: {
        backgroundColor: 'transparent', width: '90%', maxWidth: 500, padding: 0, borderRadius: 15,
        shadowColor: "#000", shadowOffset: { width: 0, height: 2, }, shadowOpacity: 0.25,
        shadowRadius: 3.84, elevation: 5, overflow: 'hidden',
    },
    overlayStyle: {
        width: '100%', borderRadius: 15, padding: 20, paddingBottom: 30, maxHeight: '90%',
    },
    keyboardAvoidingView: { width: "100%", },
    header: {
        flexDirection: "row", justifyContent: "space-between", alignItems: "center",
        marginBottom: 20, paddingBottom: 10, borderBottomWidth: 1, borderBottomColor: theme.colors.divider,
    },
    overlayTitle: { color: theme.colors.text, fontWeight: "bold", fontSize: 20, flexShrink: 1, marginRight: 10, },
    closeIcon: { padding: 5, marginLeft: 10, },
    inputRow: { flexDirection: 'row', alignItems: 'flex-end', marginBottom: 5, },
    inputContainerFlex: { flex: 1, marginRight: 10, marginBottom: 0, },
    iconButtonContainer: {
        height: 40, width: 40, justifyContent: 'center', alignItems: 'center', marginBottom: 10, // Align with input bottom
    },
    inputContainerStyle: { borderBottomWidth: 1, borderBottomColor: theme.colors.grey4, marginBottom: 5, paddingBottom: 2, },
    inputStyle: { color: theme.colors.text, marginLeft: 10, fontSize: 16, },
    multilineInputContainer: {
        borderWidth: 1, borderColor: theme.colors.grey4, borderRadius: 8, paddingVertical: 8,
        paddingHorizontal: 5, marginBottom: 10, borderBottomWidth: 1, borderBottomColor: theme.colors.grey4,
    },
    multilineInput: { marginLeft: 5, textAlignVertical: 'top', minHeight: 80, fontSize: 16, color: theme.colors.text, },
    multilineIcon: { marginTop: 8, marginRight: 5, },
    futureInputContainer: {
        backgroundColor: theme.colors.grey5, padding: 15, borderRadius: 10,
        marginTop: 20, marginBottom: 10, alignItems: "center",
    },
    futureInputLabel: { color: theme.colors.grey2, fontStyle: "italic", },
    buttonContainer: { },
    button: { borderRadius: 8, paddingHorizontal: 15, paddingVertical: 10, },
    aiButton: { paddingVertical: 12, },
    aiButtonTitle: { fontWeight: "600", fontSize: 15, textAlign: 'center', },
    loadingOverlay: { // Keep if generic overlay is needed
        position: "absolute", top: 0, left: 0, right: 0, bottom: 0, backgroundColor: "rgba(0, 0, 0, 0.5)",
        justifyContent: "center", alignItems: "center", zIndex: 10, borderRadius: 15,
    },
    backButtonContainer: { flexDirection: "row", alignItems: "center", marginBottom: 15, marginTop: 5, },
    backIcon: { marginRight: 5, padding: 5, },
    backButtonText: { color: theme.colors.primary, fontSize: 16, fontWeight: '500', },
    disabledText: { color: theme.colors.grey3, }
}));


export default AddFoodModal;
---------- END AddFoodModal.tsx ----------


---------- ConfirmationModal.tsx ----------
// components/ConfirmationModal.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Overlay, Button, Input, Text, useTheme } from '@rneui/themed';

interface ConfirmationModalProps {
  isVisible: boolean;
  onCancel: () => void;
  onConfirm: () => void;
  confirmationText: string;
  setConfirmationText: (text: string) => void;
  title?: string; // Optional title
  message?: string;  //Optional message
}

const ConfirmationModal: React.FC<ConfirmationModalProps> = ({
  isVisible,
  onCancel,
  onConfirm,
  confirmationText,
  setConfirmationText,
  title = "Confirm Action", //default title
  message = "Are you sure you want to perform this action?"
}) => {
  const { theme } = useTheme();

  return (
    <Overlay
      isVisible={isVisible}
      onBackdropPress={onCancel}
      overlayStyle={styles.overlay}
      backdropStyle={styles.backdrop} // Add the backdropStyle
    >
      <View style={[styles.container, {backgroundColor: theme.colors.background}]}>
        <Text style={[styles.title, {color: theme.colors.text}]}>{title}</Text>
        <Text style={[styles.message, {color: theme.colors.text}]}>{message}</Text>
        <Input
          placeholder="Enter confirmation text"
          placeholderTextColor={theme.colors.text}
          value={confirmationText}
          onChangeText={setConfirmationText}
          containerStyle={styles.inputContainer}
          inputStyle={{ color: theme.colors.text }}
          inputContainerStyle={{borderBottomColor: theme.colors.text}}
        />
        <View style={styles.buttonContainer}>
          <Button title="Cancel" onPress={onCancel} type="outline" buttonStyle={styles.button} />
          <Button
            title="Confirm"
            onPress={onConfirm}
            color="error"
            buttonStyle={styles.button}
            disabled={confirmationText === ""}  //Disable when empty
          />
        </View>
      </View>
    </Overlay>
  );
};

const styles = StyleSheet.create({
    overlay: {
        borderRadius: 10,
        width: '80%', // Responsive width
        padding: 6,
        backgroundColor: 'rgba(200, 200, 200, 0.5)'
    },
  container: {
    padding: 20,
    borderRadius: 7,
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 10,
    textAlign: 'center', //center align
  },
  message: {
    marginBottom: 15,
    textAlign: 'center'
  },
  inputContainer: {
    marginBottom: 20,
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
  },
  button: {
    width: 100,
    padding: 10,
  },
  backdrop: {  // Add styles for the backdrop
    backgroundColor: 'rgba(0, 0, 0, 0.5)', // Semi-transparent black
  },
});

export default ConfirmationModal;
---------- END ConfirmationModal.tsx ----------


---------- DailyGoalsInput.tsx ----------
// components/DailyGoalsInput.tsx
import React from "react";
import { Input, Text } from "@rneui/themed";
import { MacroType } from "../types/settings";
import { useTheme } from "@rneui/themed";


interface DailyGoalsInputProps {
    dailyGoals: { [key in MacroType]: number };
    onGoalChange: (goalType: MacroType, value: string) => void;
}

const DailyGoalsInput: React.FC<DailyGoalsInputProps> = ({
  dailyGoals,
  onGoalChange,
}) => {

    const { theme } = useTheme();

  return (
    <>
      {["calories", "protein", "carbs", "fat"].map((macro) => (
        <Input
          key={macro}
          label={<Text style={{ color: theme.colors.text }}>{`${macro.charAt(0).toUpperCase() + macro.slice(1)} Goal`}</Text>} // Wrap label in <Text>
          keyboardType="numeric"
          value={dailyGoals?.[macro as MacroType]?.toString() || ""}
          onChangeText={(value) => onGoalChange(macro as MacroType, value)}
          style={{ color: theme.colors.text }}
          inputContainerStyle={{ borderBottomColor: theme.colors.text }}
          labelStyle={{ color: theme.colors.text }}
        />
      ))}
    </>
  );
};

export default DailyGoalsInput;
---------- END DailyGoalsInput.tsx ----------


---------- DailyProgress.tsx ----------
// components/DailyProgress.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, useTheme } from '@rneui/themed';

interface DailyProgressProps {
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
  goals: {
    calories?: number;
    protein?: number;
    carbs?: number;
    fat?: number;
  };
}

const DailyProgress: React.FC<DailyProgressProps> = ({
  calories,
  protein,
  carbs,
  fat,
  goals,
}) => {
  const { theme } = useTheme();

  const calculateProgress = (current: number, goal?: number) => {
    if (!goal || goal <= 0) return 0; // Avoid division by zero and handle undefined goals
    return Math.min(current / goal, 1); // Cap at 100%
  };

  const renderProgressBar = (label: string, current: number, goal: number | undefined, color: string) => {
      const progress = calculateProgress(current, goal);
      return (
          <View style={styles.macroContainer} key={label}>
              <View style={styles.labelContainer}>
                    <Text style={[styles.macroLabel, {color: theme.colors.text}]}>{label}:</Text>
                    <Text style={[styles.macroValue, {color: theme.colors.text}]}>
                        {`${Math.round(current)} / ${goal || 0}`}
                    </Text>
              </View>
              <View style={styles.progressBarContainer}>
                  <View style={[styles.progressBar, { width: `${progress * 100}%`, backgroundColor: color }]} />
              </View>
          </View>
      )
  }


  return (
    <View style={styles.container}>
        {renderProgressBar('Calories', calories, goals.calories, theme.colors.primary)}
        {renderProgressBar('Protein', protein, goals.protein, 'green')}
        {renderProgressBar('Carbs', carbs, goals.carbs, 'orange')}
        {renderProgressBar('Fat', fat, goals.fat, 'blue')}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: 20,
    padding: 10,
    borderRadius: 8, // Rounded corners for the container
    //backgroundColor: '#f0f0f0', // Light background for contrast Removed for theme consistency
  },
  macroContainer: {
    marginBottom: 10,
  },
  labelContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 5,
  },
  macroLabel: {
    fontWeight: 'bold',
  },
  macroValue: {},
  progressBarContainer: {
      backgroundColor: '#e0e0e0', //Light grey for track
      borderRadius: 5,
      height: 10
  },
  progressBar: {
    height: 10,
    borderRadius: 5,
  },
});

export default DailyProgress;
---------- END DailyProgress.tsx ----------


---------- DataManagementButtons.tsx ----------
// src/components/DataManagementButtons.tsx
import React, { useState } from "react";
import { Alert, Platform } from "react-native"; // Import Platform
import { Button, Icon } from "@rneui/themed";
import * as DocumentPicker from "expo-document-picker";
import * as FileSystem from "expo-file-system";
import * as Sharing from 'expo-sharing'; // Import Sharing
import { formatDateISO } from "../utils/dateUtils"; // CORRECTED IMPORT
import {
  clearAllData,
  loadDailyEntries,
  saveDailyEntries,
  loadFoods,
  saveFoods,
  loadSettings,
  saveSettings
} from "../services/storageService";
import ConfirmationModal from "./ConfirmationModal";
import { DailyEntry } from "../types/dailyEntry";
import { Food } from "../types/food";
import { Settings } from "../types/settings";
import { useTheme } from "@rneui/themed";


interface DataManagementButtonsProps {
  onDataOperation: () => void; // Callback to signal data changes
}

const DataManagementButtons: React.FC<DataManagementButtonsProps> = ({
    onDataOperation
}) => {
  const [isConfirmationVisible, setIsConfirmationVisible] = useState(false);
  const [confirmationText, setConfirmationText] = useState("");
  const { theme } = useTheme();

  const handleExportData = async () => {
    try {
      const dailyEntries = await loadDailyEntries();
      const foods = await loadFoods();
      const settings = await loadSettings();

      const exportData = {
        dailyEntries,
        foods,
        settings
      };

      const exportDataString = JSON.stringify(exportData, null, 2); // Pretty print JSON
      // Use the correct formatting function and remove unnecessary replace
      const formattedDate = formatDateISO(new Date());
      const fileName = `macro_data_${formattedDate}.json`;
      const fileUri = FileSystem.documentDirectory + fileName;

      await FileSystem.writeAsStringAsync(fileUri, exportDataString, {
        encoding: FileSystem.EncodingType.UTF8,
      });

      // Use expo-sharing to share the file
      if (!(await Sharing.isAvailableAsync())) {
        Alert.alert('Sharing Error', 'Sharing is not available on your platform.');
        return;
      }

      await Sharing.shareAsync(fileUri, {
          mimeType: 'application/json',
          dialogTitle: 'Export Macro Data',
          UTI: 'public.json' // For iOS
      });
      // No need to call onDataOperation on export, as data didn't change locally

    } catch (error: any) {
      console.error("Export Error:", error);
      Alert.alert(
        "Export Failed",
        error.message || "An error occurred while exporting data."
      );
    }
  };

  const handleImportData = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: ["application/json", "public.json"], // Accept JSON files, public.json for iOS compatibility
        copyToCacheDirectory: true // Recommended for reliability
      });

      if (result.canceled) {
          console.log("Import cancelled by user.");
          return; // User cancelled, do nothing
      }

      if (result.assets && result.assets.length > 0) {
        const file = result.assets[0];

        // Check file extension more robustly
        if (!file.name?.toLowerCase().endsWith(".json")) {
          Alert.alert("Invalid File Type", "Please select a valid '.json' file.");
          return;
        }

        // Check file size (optional, but good practice)
        if (file.size && file.size > 10 * 1024 * 1024) { // Example: 10MB limit
            Alert.alert("File Too Large", "The selected file is too large (max 10MB).");
            return;
        }

        const fileContent = await FileSystem.readAsStringAsync(file.uri, {
          encoding: FileSystem.EncodingType.UTF8,
        });

        try {
          const importedData = JSON.parse(fileContent);

          // Basic structure validation:
          if (
            typeof importedData !== 'object' || importedData === null ||
            !importedData.hasOwnProperty("dailyEntries") || !Array.isArray(importedData.dailyEntries) ||
            !importedData.hasOwnProperty("foods") || !Array.isArray(importedData.foods) ||
            !importedData.hasOwnProperty("settings") || typeof importedData.settings !== 'object'
          ) {
            Alert.alert(
              "Import Failed",
              "The imported file has an invalid structure or is missing required data (dailyEntries, foods, settings)."
            );
            return;
          }

          // Add more specific validation if needed (e.g., check types within arrays)

          // Perform saves
          await saveDailyEntries(importedData.dailyEntries as DailyEntry[]);
          await saveFoods(importedData.foods as Food[]);
          await saveSettings(importedData.settings as Settings);

          Alert.alert("Import Successful", "Data imported and saved successfully.");
          onDataOperation(); // Trigger reload in parent screen

        } catch (parseError) {
          console.error("JSON Parse Error during import:", parseError);
          Alert.alert(
            "Import Failed",
            "The imported file is not valid JSON or has corrupted content."
          );
          return;
        }
      } else {
        // Should not happen if !result.canceled, but handle defensively
        console.warn("Document picker returned no assets without cancellation.");
        Alert.alert("Import Failed", "Could not access the selected file.");
      }
    } catch (error: any) {
      console.error("Import Error:", error);
      // Handle specific DocumentPicker errors if necessary
      if (error.code === 'NO_PERMISSIONS') {
           Alert.alert("Permission Error", "Storage permissions are required to import files.");
      } else {
           Alert.alert(
             "Import Failed",
             error.message || "An unknown error occurred during import."
           );
      }
    }
  };

  const handleClearData = () => {
      // Check if there's actually data to clear (optional)
      // const entries = await loadDailyEntries(); // Example check
      // if (entries.length === 0 && ...) { Alert.alert("No Data", "There is no data to clear."); return; }

      setIsConfirmationVisible(true);
  };

  const confirmClearData = async () => {
    // Case-insensitive and trim check for robustness
    if (confirmationText.trim().toUpperCase() === "CLEAR DATA") {
      try {
        await clearAllData();
        Alert.alert("Data Cleared", "All application data has been successfully cleared.");
        onDataOperation(); // Trigger reload in parent screen
      } catch (error: any) {
        console.error("Clear Data Error:", error);
        Alert.alert("Clear Data Failed", error.message || "Failed to clear data.");
      } finally {
        setConfirmationText(""); // Clear input regardless of outcome
        setIsConfirmationVisible(false);
      }
    } else {
      Alert.alert("Confirmation Failed", "Incorrect confirmation text entered. Data was not cleared.");
      // Keep modal open and text field populated for user correction
    }
  };

  return (
    <>
      <Button
        title="Export Data"
        onPress={handleExportData}
        buttonStyle={{ marginBottom: 10, backgroundColor: theme.colors.primary }}
        icon={<Icon name="export" type="material-community" color="white" size={20} style={{ marginRight: 8 }} />}
      />
      <Button
        title="Import Data"
        onPress={handleImportData}
        buttonStyle={{ marginBottom: 10, backgroundColor: theme.colors.primary }}
        icon={<Icon name="import" type="material-community" color="white" size={20} style={{ marginRight: 8 }} />}
      />
      <Button
        title="Clear All Data"
        onPress={handleClearData}
        color="error" // Use theme's error color directly
        buttonStyle={{ marginBottom: 10 }}
        icon={<Icon name="trash-can-outline" type="material-community" color="white" size={20} style={{ marginRight: 8 }} />}
      />

      <ConfirmationModal
        isVisible={isConfirmationVisible}
        onCancel={() => {
            setIsConfirmationVisible(false);
            setConfirmationText(""); // Clear text on cancel
        }}
        onConfirm={confirmClearData}
        confirmationText={confirmationText}
        setConfirmationText={setConfirmationText}
        title="Confirm Clear All Data"
        message={'This action is irreversible and will delete all entries, foods, and settings.\n\nEnter "CLEAR DATA" to proceed.'}
      />
    </>
  );
};

export default DataManagementButtons;
---------- END DataManagementButtons.tsx ----------


---------- FoodItem.tsx ----------
// src/components/FoodItem.tsx
import React, { forwardRef, useState, useCallback, memo } from "react";
import { StyleSheet, View, Image, ActivityIndicator } from "react-native"; // Added ActivityIndicator
import { ListItem, Icon as RNEIcon, useTheme, Button, makeStyles, Text } from "@rneui/themed";
import { Food } from "../types/food";
import Toast from "react-native-toast-message";

interface FoodItemProps {
  food: Food;
  onEdit: (food: Food) => void;
  onDelete: (foodId: string) => void;
  onUndoDelete: (food: Food) => void;
  foodIconUrl: string | null | undefined;
}

const FoodItem = memo(forwardRef<any, FoodItemProps>(
  ({ food, onEdit, onDelete, onUndoDelete, foodIconUrl }, ref) => {
    const { theme } = useTheme();
    const styles = useStyles();
    const [iconLoadError, setIconLoadError] = useState(false);

    // --- Declare handleUndo FIRST ---
    const handleUndo = useCallback(() => {
         onUndoDelete(food); // Parent handles actual restoration
    }, [food, onUndoDelete]);

    // --- Declare handleDelete SECOND, now it can safely use handleUndo ---
    const handleDelete = useCallback(() => {
      onDelete(food.id); // Parent handles logic and initial toast
       Toast.show({ // Show UNDO toast here for consistency
            type: 'info',
            text1: `${food.name} deleted`,
            text2: 'Tap here to undo',
            position: 'bottom',
            visibilityTime: 4000,
            onPress: handleUndo, // Call local undo handler declared above
            bottomOffset: 80,
        });
    }, [food.id, food.name, onDelete, handleUndo]); // Dependency array is now valid

    const handleImageError = useCallback(() => {
        console.warn(`Failed to load image for ${food.name} from URL: ${foodIconUrl}`);
        setIconLoadError(true);
    }, [food.name, foodIconUrl]);

    // Reset error state if the URL changes
    React.useEffect(() => {
        setIconLoadError(false);
    }, [foodIconUrl]);

    const renderIcon = () => {
        const isLoadingIcon = foodIconUrl === undefined;
        if (isLoadingIcon) {
            return (
                <View style={[styles.foodIcon, styles.iconPlaceholder]}>
                    <ActivityIndicator size="small" color={theme.colors.grey3} />
                </View>
            );
        } else if (foodIconUrl && !iconLoadError) {
             return (
                <Image
                    source={{ uri: foodIconUrl }}
                    style={styles.foodIconImage}
                    onError={handleImageError}
                    resizeMode="contain"
                />
            );
        } else {
            return (
                <View style={[styles.foodIcon, styles.iconPlaceholder]}>
                    <RNEIcon
                        name="fast-food-outline" // Consistent placeholder
                        type="ionicon"
                        size={20}
                        color={theme.colors.grey3}
                    />
                </View>
            );
        }
    };

    return (
      <ListItem.Swipeable
        ref={ref}
        bottomDivider
        leftContent={(reset) => (
          <Button
            title="Edit"
            onPress={() => {
              onEdit(food);
              reset();
            }}
            icon={{ name: "edit", color: theme.colors.white }}
            buttonStyle={styles.swipeButtonEdit} // Consistent style
            titleStyle={styles.swipeButtonTitle}
          />
        )}
        rightContent={(reset) => (
          <Button
            title="Delete"
            onPress={() => {
                handleDelete(); // Use local handler to show toast
                reset();
            }}
            icon={{ name: "delete", color: theme.colors.white }}
            buttonStyle={styles.swipeButtonDelete} // Consistent style
            titleStyle={styles.swipeButtonTitle}
          />
        )}
        containerStyle={styles.listItemContainer} // Consistent container style
      >
        {renderIcon()}

        <ListItem.Content>
          <ListItem.Title style={styles.title}>
            {food.name}
          </ListItem.Title>
          <ListItem.Subtitle style={styles.subtitle}>
            {`100g: Cal: ${Math.round(food.calories)} P: ${Math.round(food.protein)} C: ${Math.round(food.carbs)} F: ${Math.round(food.fat)}`}
          </ListItem.Subtitle>
        </ListItem.Content>
         {/* Chevron indicates interactibility (swipe) */}
        <ListItem.Chevron color={theme.colors.grey3} />
      </ListItem.Swipeable>
    );
  }
));

// Consistent Styles matching DailyEntryScreen where applicable
const useStyles = makeStyles((theme) => ({
    listItemContainer: {
        backgroundColor: theme.colors.background, // Use theme background
        paddingVertical: 12,
        paddingHorizontal: 15,
        borderBottomColor: theme.colors.divider, // Use theme divider
    },
    title: {
        color: theme.colors.text, // Use theme text color
        fontWeight: "600",
        fontSize: 16,
        marginBottom: 3,
    },
    subtitle: {
        color: theme.colors.grey1, // Use theme grey
        fontSize: 13, // Slightly smaller subtitle
        marginTop: 2,
    },
    swipeButtonEdit: {
        minHeight: "100%",
        backgroundColor: theme.colors.warning, // Theme color
        justifyContent: 'center',
        alignItems: 'flex-start',
        paddingLeft: 20,
    },
    swipeButtonDelete: {
        minHeight: "100%",
        backgroundColor: theme.colors.error, // Theme color
        justifyContent: 'center',
        alignItems: 'flex-end',
        paddingRight: 20,
    },
    swipeButtonTitle: {
        color: theme.colors.white, // White text on colored buttons
        fontWeight: 'bold',
        fontSize: 15,
    },
   // Consistent Icon styles
   foodIcon: {
       width: 40,
       height: 40,
       marginRight: 15,
       borderRadius: 8, // Slightly rounded square
       alignItems: 'center',
       justifyContent: 'center',
   },
   foodIconImage: {
       width: 40,
       height: 40,
       marginRight: 15,
       borderRadius: 8,
   },
   iconPlaceholder: {
      backgroundColor: theme.colors.grey5, // Consistent placeholder background
   }
}));

export default FoodItem;
---------- END FoodItem.tsx ----------


---------- QuickAddList.tsx ----------
// src/components/QuickAddList.tsx
// ---------- NEW FILE ----------
import React from 'react';
import {
    View,
    FlatList,
    StyleSheet,
    TouchableOpacity,
    Pressable,
    Dimensions,
    ActivityIndicator,
} from 'react-native';
import {
    ListItem,
    CheckBox,
    Input,
    Icon,
    Text,
    useTheme,
    makeStyles,
} from '@rneui/themed';
import { EstimatedFoodItem } from '../types/macros';
import { isValidNumberInput } from '../utils/validationUtils';

interface QuickAddListProps {
    items: EstimatedFoodItem[];
    selectedIndices: Set<number>;
    editingIndex: number | null;
    editedName: string;
    editedGrams: string;
    onToggleItem: (index: number) => void;
    onEditItem: (index: number) => void;
    onSaveEdit: () => void;
    onCancelEdit: () => void;
    onNameChange: (name: string) => void;
    onGramsChange: (grams: string) => void;
    style?: object; // Optional style prop for the FlatList container
    isLoading?: boolean; // Optional loading state for the list itself
}

const QuickAddList: React.FC<QuickAddListProps> = ({
    items,
    selectedIndices,
    editingIndex,
    editedName,
    editedGrams,
    onToggleItem,
    onEditItem,
    onSaveEdit,
    onCancelEdit,
    onNameChange,
    onGramsChange,
    style,
    isLoading,
}) => {
    const { theme } = useTheme();
    const styles = useStyles();

    const renderItem = ({ item, index }: { item: EstimatedFoodItem; index: number }) => {
        const isSelected = selectedIndices.has(index);
        const isEditingThisItem = editingIndex === index;
        const isAnyItemEditing = editingIndex !== null;
        const estimatedCalories = Math.round(
            (item.calories_per_100g / 100) * item.estimatedWeightGrams
        );

        return (
            <Pressable
                onPress={() => !isEditingThisItem && onToggleItem(index)}
                disabled={(isAnyItemEditing && !isEditingThisItem)}
            >
                <ListItem
                    bottomDivider
                    containerStyle={[
                        styles.quickAddItemContainer,
                        isEditingThisItem && styles.quickAddItemEditing,
                        isSelected && styles.quickAddItemSelected,
                        isAnyItemEditing && !isEditingThisItem && { opacity: 0.6 },
                    ]}
                >
                    {isEditingThisItem ? (
                        // --- EDIT VIEW for Quick Add Item ---
                        <View style={styles.quickAddEditView}>
                            <Input
                                value={editedName}
                                onChangeText={onNameChange}
                                placeholder="Food Name"
                                inputContainerStyle={styles.quickEditInputContainer}
                                inputStyle={styles.quickEditInput}
                                containerStyle={styles.quickEditNameContainer}
                                autoFocus
                                selectTextOnFocus
                            />
                            <View style={styles.quickEditGramsRow}>
                                <Input
                                    value={editedGrams}
                                    onChangeText={onGramsChange} // Use the specific handler for cleaning
                                    placeholder="Grams"
                                    keyboardType="numeric"
                                    inputContainerStyle={styles.quickEditInputContainer}
                                    inputStyle={styles.quickEditInput}
                                    containerStyle={styles.quickEditGramsContainer}
                                    rightIcon={<Text style={styles.quickEditUnitText}> g </Text>}
                                    errorMessage={ !isValidNumberInput(editedGrams) && editedGrams !== "" ? "Invalid" : "" }
                                    errorStyle={styles.inputError}
                                />
                                {/* Save/Cancel Edit Buttons */}
                                <TouchableOpacity onPress={onSaveEdit} style={styles.quickEditButton}>
                                    <Icon name="checkmark" type="ionicon" color={theme.colors.success} size={26} />
                                </TouchableOpacity>
                                <TouchableOpacity onPress={onCancelEdit} style={styles.quickEditButton}>
                                    <Icon name="close-circle-outline" type="ionicon" color={theme.colors.error} size={26} />
                                </TouchableOpacity>
                            </View>
                        </View>
                    ) : (
                        // --- DISPLAY VIEW for Quick Add Item ---
                        <>
                            <CheckBox
                                checked={isSelected}
                                onPress={() => onToggleItem(index)}
                                containerStyle={styles.quickAddCheckbox}
                                checkedColor={theme.colors.primary}
                                disabled={isAnyItemEditing}
                            />
                            <ListItem.Content>
                                <ListItem.Title style={styles.quickAddItemTitle}>
                                    {item.foodName}
                                </ListItem.Title>
                                <ListItem.Subtitle style={styles.quickAddItemSubtitle}>
                                    {`Est: ${Math.round(item.estimatedWeightGrams)}g  ~${estimatedCalories} kcal`}
                                </ListItem.Subtitle>
                            </ListItem.Content>
                            {/* Edit Icon */}
                            {!isAnyItemEditing && (
                                <TouchableOpacity onPress={() => onEditItem(index)} style={styles.quickEditIconButton}>
                                    <Icon name="pencil" type="material-community" size={20} color={theme.colors.grey1} />
                                </TouchableOpacity>
                            )}
                        </>
                    )}
                </ListItem>
            </Pressable>
        );
    };

    if (isLoading) {
         return (
             <View style={styles.centeredContent}>
                 <ActivityIndicator size="large" color={theme.colors.primary} />
                 <Text style={styles.loadingText}>Analyzing...</Text>
             </View>
         );
    }

    return (
        <FlatList
            data={items}
            keyExtractor={(item, index) => `quickadd-${index}-${item.foodName}`}
            renderItem={renderItem}
            ListEmptyComponent={ // Show if API returned no items initially
                <View style={styles.emptyListContainer}>
                    <Icon name="image-off-outline" type="material-community" size={40} color={theme.colors.grey3} />
                    <Text style={styles.emptyListText}> No identifiable foods found in the image. </Text>
                    <Text style={styles.emptyListSubText}> Try a different image or add manually. </Text>
                </View>
            }
            style={[styles.listDefaults, style]} // Combine default styles with passed styles
            extraData={{ selectedIndices, editingIndex }} // Ensure re-render on state change
            keyboardShouldPersistTaps="handled"
            contentContainerStyle={items.length === 0 ? styles.listContentContainerEmpty : {}}
        />
    );
};

const useStyles = makeStyles((theme) => ({
    listDefaults: { // Default styles for the FlatList itself
        // maxHeight: Dimensions.get("window").height * 0.55, // Moved to parent or style prop
        // flexGrow: 0, // Moved to parent or style prop
        // marginBottom: 10, // Moved to parent or style prop
    },
    listContentContainerEmpty: {
        flexGrow: 1,
        justifyContent: 'center',
    },
    quickAddItemContainer: {
        paddingVertical: 6, paddingHorizontal: 5, backgroundColor: theme.colors.background,
        borderBottomColor: theme.colors.divider, flexDirection: "row", alignItems: "center",
        minHeight: 60, // Ensure consistent item height
    },
    quickAddItemSelected: { backgroundColor: theme.colors.successLight || '#d4edda' },
    quickAddItemEditing: { backgroundColor: theme.colors.grey5, paddingVertical: 8, },
    quickAddCheckbox: { padding: 0, margin: 0, marginRight: 10, backgroundColor: "transparent", borderWidth: 0, },
    quickAddItemTitle: { fontWeight: "bold", color: theme.colors.text, fontSize: 16, },
    quickAddItemSubtitle: { color: theme.colors.grey1, fontSize: 13, marginTop: 2, },
    quickEditIconButton: { padding: 8, marginLeft: 8, },
    quickAddEditView: { flex: 1, paddingLeft: 10, },
    quickEditInputContainer: {
        borderBottomWidth: 1, borderBottomColor: theme.colors.primary, height: 35, paddingHorizontal: 0,
        // paddingBottom: 0, // Reduce bottom padding to avoid height issues
        // marginBottom: 0, // Reduce margin
    },
    quickEditInput: {
        fontSize: 15, color: theme.colors.text, paddingVertical: 0, // Remove vertical padding
        // lineHeight: 18, // Control line height if needed
        // height: 'auto', // Auto height? Test this carefully
    },
    quickEditNameContainer: { paddingHorizontal: 0, marginBottom: 5, },
    quickEditGramsRow: { flexDirection: "row", alignItems: "center", },
    quickEditGramsContainer: { flex: 1, paddingHorizontal: 0, },
    quickEditUnitText: { color: theme.colors.grey2, fontSize: 14, fontWeight: "500", },
    quickEditButton: { paddingLeft: 10, paddingVertical: 5, },
    emptyListContainer: {
        alignItems: "center", paddingVertical: 30, paddingHorizontal: 15,
    },
    emptyListText: { color: theme.colors.grey2, fontSize: 16, textAlign: "center", marginTop: 10 },
    emptyListSubText: { fontSize: 14, color: theme.colors.grey3, textAlign: "center", marginTop: 5, },
    inputError: { color: theme.colors.error, fontSize: 10, marginVertical: 0, height: 12 }, // Compact error message
     centeredContent: { // Centered loading/empty states within main area
      flex: 1,
      alignItems: 'center',
      justifyContent: 'center',
      padding: 20,
      minHeight: 150, // Ensure it takes some space
   },
    loadingText: { marginTop: 10, color: theme.colors.text, fontSize: 16, fontWeight: "500", },
}));

export default QuickAddList;
---------- END QuickAddList.tsx ----------


---------- StatisticsChart.tsx ----------
// components/StatisticsChart.tsx (Modified)
import React from "react";
import { View, StyleSheet } from "react-native";
import { WebView } from "react-native-webview";
import { Statistics, MacroType, macros } from "../types/settings"; // Import types
import { useTheme } from "@rneui/themed";


interface StatisticsChartProps {
  statistics: Statistics;
}

const StatisticsChart: React.FC<StatisticsChartProps> = ({ statistics }) => {

  const { theme } = useTheme();

  const generateChartHTML = () => {
    const chartData = macros.reduce((acc, macro) => {
      // Prepare data for each macro, including goal if applicable
      acc[macro] = statistics[macro].map((series) =>
        series.map((item) => [item.x / 1000, item.y])
      );
      return acc;
    }, {} as { [key in MacroType]: number[][][] });

    const textColor = theme.colors.text;
    const gridColor = theme.colors.grey5; // Lighter grid
    const axisColor = theme.colors.grey3; // Slightly darker axis
    const fontFamily = "Helvetica, Arial, sans-serif";

    // Define color palette for the lines, using theme colors if possible
    const lineColors = {
      calories: theme.colors.primary,
      protein: theme.colors.success,
      carbs: theme.colors.warning,
      fat: theme.colors.error,
    };


    // Re-enabled caching, but *only* cache the HTML itself, not the data.  The data is now dynamic.
    return `
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>Macro Charts</title>
            <style>
            body { font-family: ${fontFamily}; margin: 0; padding: 0; background-color: ${theme.colors.background}; color: ${textColor};}
                .chart-container { width: 95%; height: 250px; margin: 10px auto; }
            </style>
            <link rel="stylesheet" href="https://unpkg.com/uplot@1.6.27/dist/uPlot.min.css">
            <script src="https://unpkg.com/uplot@1.6.27/dist/uPlot.iife.min.js"></script>
        </head>
        <body>
            ${macros
      .map((macro) => {
        const isCalories = macro === "calories";
        const seriesCount = isCalories ? 2 : 1; // Two series for calories (intake, goal)

        const seriesConfig = isCalories
          ? `[
                      {},
                      {
                        stroke: "${lineColors[macro] || theme.colors.primary}",
                        width: 2,
                        label: "Intake",
                        points: { show: false }
                      },
                      {
                        stroke: "red",
                        width: 1,
                        dash: [5, 5],
                        label: "Goal",
                        points: { show: false }
                      }
                    ]`
          : `[
                      {},
                      {
                        stroke: "${lineColors[macro] || theme.colors.primary}",
                        width: 2,
                        label: "${macro.charAt(0).toUpperCase() + macro.slice(1)}",
                        points: { show: false }
                      }
                    ]`;


        const uPlotData =
          seriesCount === 2
            ? `[data[0].map(d => d[0]), data[0].map(d => d[1]), data[1].map(d => d[1])]`
            : `[data[0].map(d => d[0]), data[0].map(d => d[1])]`;



        return `
                <div id="${macro}-chart" class="chart-container"></div>
                <script>
                    const data = ${JSON.stringify(chartData[macro])};
                    const opts = {
                        title: "${macro.charAt(0).toUpperCase() + macro.slice(1)}",
                        width: window.innerWidth * 0.95,
                        height: 250,
                        scales: {
                            x: { time: true },
                            y: { },
                        },
                        axes: [
                            {
                                stroke: "${textColor}",
                                font: "14px ${fontFamily}",
                            grid: {
                                    stroke: "${gridColor}",
                                    width: 1
                                },
                                ticks: {
                                    stroke: "${gridColor}",
                                    width: 1
                                }
                            },
                            {
                                stroke: "${textColor}",
                                font: "14px ${fontFamily}",
                                grid: {
                                    stroke: "${gridColor}",
                                    width: 1
                                },
                                ticks: {
                                    stroke: "${gridColor}",
                                    width: 1
                                }
                            }
                        ],
                        series: ${seriesConfig},
                        cursor: {
                            drag: { setScale: false },
                            points: {
                                size: 6,
                                fill: (self, i) => self.series[i]._stroke,
                                stroke: (self, i) => self.series[i]._stroke,
                            }
                        },
                        ${isCalories ? `
                        hooks: {
                            draw: [
                                (u) => {
                                   const ctx = u.ctx;
                                    u.series.forEach((series, seriesIdx) => {
                                      if (seriesIdx === 1) {
                                        const intakeData = data[0];
                                        const goalData = data[1];

                                        ctx.beginPath();
                                        ctx.fillStyle = "rgba(255, 0, 0, 0.3)"; // Semi-transparent red

                                        for (let i = 0; i < intakeData.length; i++) {
                                          const intakeY = intakeData[i][1];
                                          const goalY = goalData[i][1];
                                          const x = u.valToPos(intakeData[i][0], "x", true);
                                          
                                           // Check if intake exceeds the goal
                                            if(intakeY > goalY){
                                                const intakeYPos = u.valToPos(intakeY, 'y', true);
                                                const goalYPos = u.valToPos(goalY, 'y', true);
                                               
                                                //if this is the first point or last point, move to x, other wise line to x
                                                if(i === 0){
                                                   ctx.moveTo(x, intakeYPos);
                                                }else{
                                                  ctx.lineTo(x, intakeYPos);
                                                }
                                            }
                                        }
                                        //go back along the goal data
                                         for (let i = intakeData.length-1; i >= 0; i--) {
                                            const intakeY = intakeData[i][1];
                                            const goalY = goalData[i][1];
                                             const x = u.valToPos(intakeData[i][0], "x", true);
                                               // Check if intake exceeds the goal
                                            if(intakeY > goalY){
                                                 const goalYPos = u.valToPos(goalY, 'y', true);
                                                ctx.lineTo(x, goalYPos);
                                            }
                                         }

                                        ctx.closePath();
                                        ctx.fill();
                                        }

                                    });

                                }
                            ]
                        }
                        ` : ''}
                    };
                    new uPlot(opts, ${uPlotData}, document.getElementById('${macro}-chart'));
                </script>
            `;
      })
      .join("")}
        </body>
        </html>
        `;

  };

  return (
    <View style={styles.webViewContainer}>
      <WebView
        originWhitelist={["*"]}
        source={{ html: generateChartHTML() }}
        style={styles.webView}
        scalesPageToFit={false}
        scrollEnabled={false}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  webViewContainer: {
    height: 'auto',
    width: "100%",
    marginTop: 10,
  },
  webView: {
    height: 340, // Explicit height, adjust as needed.
  },
});

export default StatisticsChart;
---------- END StatisticsChart.tsx ----------


---------- ThemeSwitch.tsx ----------
// components/ThemeSwitch.tsx (Corrected)
import React from "react";
import { ListItem, Switch } from "@rneui/themed";
import { useTheme } from "@rneui/themed";

interface ThemeSwitchProps {
  currentTheme: 'light' | 'dark' | 'system'; // Use theme string
  onToggle: (theme: 'light' | 'dark' | 'system') => void; // Pass the theme string
}

const ThemeSwitch: React.FC<ThemeSwitchProps> = ({ currentTheme, onToggle }) => {
  const { theme } = useTheme();

  return (
    <ListItem
      bottomDivider
      containerStyle={{ backgroundColor: theme.colors.background }}
    >
      <ListItem.Content>
        <ListItem.Title style={{ color: theme.colors.text }}>
          Dark Mode
        </ListItem.Title>
      </ListItem.Content>
      <Switch
        value={currentTheme === 'dark'} // Correctly reflect theme
        onValueChange={(newValue) => {
          onToggle(newValue ? 'dark' : 'light'); // Toggle between 'light' and 'dark'
        }}
      />
    </ListItem>
  );
};

export default ThemeSwitch;
---------- END ThemeSwitch.tsx ----------


---------- AppNavigator.tsx ----------
// navigation/AppNavigator.tsx
import React, { useState, useCallback } from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { Icon, useTheme } from '@rneui/themed';
import DailyEntryScreen from '../screens/DailyEntryScreen';
import FoodListScreen from '../screens/FoodListScreen';
import SettingsScreen from '../screens/SettingsScreen';

const Tab = createBottomTabNavigator();

interface AppNavigatorProps {
  onThemeChange: (theme: 'light' | 'dark' | 'system') => void;
}

const AppNavigator: React.FC<AppNavigatorProps> = ({ onThemeChange }) => {
  const { theme } = useTheme();
  const [foodListRefresh, setFoodListRefresh] = useState(false);

  const handleFoodChange = useCallback(() => {
    setFoodListRefresh(prev => !prev); // Toggle the state to trigger refresh
  }, []);

  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        tabBarIcon: ({ focused, color, size }) => {
          let iconName: string = '';
          let type: string = '';

          if (route.name === 'Daily Entry') {
            iconName = focused ? 'calendar' : 'calendar-outline';
            type = 'ionicon';
          } else if (route.name === 'Foods') {
            iconName = focused ? 'fast-food' : 'fast-food-outline';
            type = 'ionicon'; // Consistent icon set
          } else if (route.name === 'Settings') {
            iconName = focused ? 'settings' : 'settings-outline';
            type = 'ionicon';
          }

          return <Icon name={iconName} type={type} size={size} color={color} />;
        },
        tabBarActiveTintColor: theme.colors.primary,
        tabBarInactiveTintColor: theme.colors.secondary, // Use secondary color
        headerShown: false,
        tabBarStyle: {
          backgroundColor: theme.colors.background,
          borderTopColor: theme.colors.divider, // Add a subtle border
        },
        tabBarLabelStyle: {
          fontWeight: 'bold', // Make labels more prominent
        }
      })}
    >
      <Tab.Screen name="Daily Entry">
        {() => <DailyEntryScreen key={foodListRefresh ? 'refresh' : 'normal'} />}
      </Tab.Screen>
      <Tab.Screen name="Foods">
        {() => <FoodListScreen onFoodChange={handleFoodChange} />}
      </Tab.Screen>
      <Tab.Screen name="Settings">
        {() => <SettingsScreen onThemeChange={onThemeChange} onDataOperation={function (): void {
          throw new Error('Function not implemented.');
        } } />}
      </Tab.Screen>
    </Tab.Navigator>
  );
};

export default AppNavigator;
---------- END AppNavigator.tsx ----------


---------- DailyEntryScreen.tsx ----------
// src/screens/DailyEntryScreen.tsx
import React, { useState, useEffect, useCallback, useMemo } from "react";
import {
  View,
  FlatList,
  Alert,
  Platform,
  Image,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
} from "react-native";
import { DailyEntry, DailyEntryItem } from "../types/dailyEntry";
import { Food } from "../types/food";
import { getFoods } from "../services/foodService";
import {
  saveDailyEntries,
  loadDailyEntries,
  loadSettings,
} from "../services/storageService";
import {
  formatDateReadable,
  getTodayDateString,
  formatDateISO,
} from "../utils/dateUtils";
import { isValidNumberInput } from "../utils/validationUtils";
import DailyProgress from "../components/DailyProgress";
import {
  Button,
  Text,
  ListItem,
  FAB,
  makeStyles,
  useTheme,
  Divider,
  Icon as RNEIcon, // Renamed import
} from "@rneui/themed";
import DateTimePicker, { DateTimePickerEvent } from "@react-native-community/datetimepicker";
import { addDays, subDays, parseISO, formatISO, isValid } from "date-fns";
import { SafeAreaView } from "react-native-safe-area-context";
import AddEntryModal from "../components/AddEntryModal";
import "react-native-get-random-values";
import Toast from "react-native-toast-message";
import { useFocusEffect } from "@react-navigation/native";
import { getFoodIconUrl } from "../utils/iconUtils";

interface DailyGoals {
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
}

const DailyEntryScreen: React.FC = () => {
  const [dailyEntries, setDailyEntries] = useState<DailyEntry[]>([]);
  const [selectedDate, setSelectedDate] = useState<string>(getTodayDateString());
  const [foods, setFoods] = useState<Food[]>([]);
  const [selectedFood, setSelectedFood] = useState<Food | null>(null);
  const [grams, setGrams] = useState("");
  const [isOverlayVisible, setIsOverlayVisible] = useState(false);
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [dailyGoals, setDailyGoals] = useState<DailyGoals>({
    calories: 2000, protein: 150, carbs: 200, fat: 70,
  });
  const [search, setSearch] = useState("");
  const [editIndex, setEditIndex] = useState<number | null>(null); // Modal edit index (reversed)
  const [foodIcons, setFoodIcons] = useState<{ [foodName: string]: string | null | undefined }>({});
  const [isLoadingData, setIsLoadingData] = useState(true);
  const [isSaving, setIsSaving] = useState(false);

  const { theme } = useTheme();
  const styles = useStyles();

  // --- Data Loading and Icon Fetching ---
  const loadData = useCallback(async () => {
    console.log(`DailyEntryScreen: Loading data for date: ${selectedDate}`);
    setIsLoadingData(true);
    try {
      const [loadedFoods, loadedEntries, loadedSettings] = await Promise.all([
        getFoods(),
        loadDailyEntries(),
        loadSettings(),
      ]);

      const currentGoals = loadedSettings?.dailyGoals ?? { calories: 2000, protein: 150, carbs: 200, fat: 70 };
      setDailyGoals(currentGoals);

      loadedFoods.sort((a, b) => a.name.localeCompare(b.name));
      setFoods(loadedFoods);

      setDailyEntries(loadedEntries);
      console.log(`DailyEntryScreen: Loaded ${loadedFoods.length} foods, ${loadedEntries.length} entry days.`);

      triggerIconFetches(loadedFoods, loadedEntries, selectedDate);
    } catch (error) {
      console.error("DailyEntryScreen: Error loading data:", error);
      Alert.alert("Load Error", "Failed to load necessary data.");
      setFoods([]);
      setDailyEntries([]);
      setDailyGoals({ calories: 0, protein: 0, carbs: 0, fat: 0 });
    } finally {
      setIsLoadingData(false);
    }
  }, [selectedDate]); // Dependency only on selectedDate

   // Fetch icons based on currently visible items and all available foods
   const triggerIconFetches = useCallback((allFoods: Food[], allEntries: DailyEntry[], currentDate: string) => {
    const relevantFoodNames = new Set<string>();

    // Add names from the current day's entries
    const currentOriginalEntry = allEntries.find((entry) => entry.date === currentDate);
    if (currentOriginalEntry) {
        currentOriginalEntry.items.forEach((item) => {
            if (item.food?.name) {
                relevantFoodNames.add(item.food.name);
            }
        });
    }

    // Add names from all available foods (for the modal) - optional optimization: only fetch if modal opens?
    // allFoods.forEach((f) => relevantFoodNames.add(f.name));

    console.log(`DailyEntryScreen: Triggering icon fetches for ${relevantFoodNames.size} unique food names.`);
    relevantFoodNames.forEach((foodName) => {
      if (foodIcons[foodName] === undefined) { // Only fetch if status is unknown
        setFoodIcons(prevIcons => ({ ...prevIcons, [foodName]: undefined })); // Mark as loading
        getFoodIconUrl(foodName)
          .then((iconUrl) => {
            setFoodIcons((prevIcons) => ({ ...prevIcons, [foodName]: iconUrl }));
          })
          .catch((error) => {
            console.warn(`Icon fetch failed for ${foodName} in background:`, error);
            setFoodIcons((prevIcons) => ({ ...prevIcons, [foodName]: null })); // Mark as failed/no icon
          });
      }
    });
  }, [foodIcons]); // Depend on foodIcons to know which ones are already fetched/fetching

  useFocusEffect(
    useCallback(() => {
      loadData();
      return () => {
        console.log("DailyEntryScreen: Unfocused.");
        setSearch("");
        setIsOverlayVisible(false);
        setEditIndex(null);
      };
    }, [loadData]) // Depend on loadData callback
  );

  // --- List and Index Management ---
  const currentEntryItems = useMemo(() => {
    const entry = dailyEntries.find((e) => e.date === selectedDate);
    // Display most recent first
    return entry ? [...entry.items].reverse() : [];
  }, [dailyEntries, selectedDate]);

  const getOriginalIndex = useCallback((reversedIndex: number): number => {
    const entry = dailyEntries.find((e) => e.date === selectedDate);
    if (!entry || reversedIndex < 0 || reversedIndex >= entry.items.length) {
      console.error(`getOriginalIndex: Invalid reversedIndex ${reversedIndex} for entry length ${entry?.items?.length}`);
      return -1;
    }
    return entry.items.length - 1 - reversedIndex;
  }, [dailyEntries, selectedDate]);

  // --- State Update Helper ---
  const updateAndSaveEntries = useCallback(async (updatedEntries: DailyEntry[]) => {
    setIsSaving(true);
    const entryForSelectedDate = updatedEntries.find((e) => e.date === selectedDate);
    console.log(`DailyEntryScreen: updateAndSaveEntries called. Saving ${updatedEntries.length} total entries.`);
    console.log(`Entry for ${selectedDate} contains ${entryForSelectedDate?.items?.length ?? 0} items.`);
    setDailyEntries(updatedEntries); // Update UI state immediately
    try {
      await saveDailyEntries(updatedEntries);
      console.log("DailyEntryScreen: Successfully saved updated entries to storage.");
    } catch (error) {
      console.error("DailyEntryScreen: Failed to save updated entries to storage:", error);
      Alert.alert("Save Error", "Could not save changes. Please try again.");
      // Consider reverting state here if save fails critically
      // loadData(); // Or reload data to ensure consistency
    } finally {
      setIsSaving(false);
    }
  }, [selectedDate]); // Added selectedDate dependency

  // --- Add/Update/Remove Entry Handlers ---
  const handleSingleEntryAction = useCallback(async () => {
    if (isSaving) return;
    if (!selectedFood || !selectedFood.id) {
      Alert.alert("Food Not Selected", "Please select a valid food item.");
      return;
    }
    const trimmedGrams = grams.trim();
    if (!isValidNumberInput(trimmedGrams) || parseFloat(trimmedGrams) <= 0) {
      Alert.alert("Invalid Amount", "Please enter a valid positive number for grams.");
      return;
    }

    const numericGrams = parseFloat(trimmedGrams);
    const entryItem: DailyEntryItem = {
      food: selectedFood,
      grams: numericGrams,
    };

    const isEditMode = editIndex !== null;
    console.log(`handleSingleEntryAction: Mode=${isEditMode ? 'Edit' : 'Add'}, Food=${selectedFood.name}, Grams=${numericGrams}, ReversedIndex=${editIndex}`);

    const existingEntryIndex = dailyEntries.findIndex((entry) => entry.date === selectedDate);
    let updatedEntries: DailyEntry[];

    if (existingEntryIndex > -1) {
      const existingEntry = dailyEntries[existingEntryIndex];
      let updatedItems;
      if (isEditMode) {
        const originalEditIndex = getOriginalIndex(editIndex!);
        if (originalEditIndex === -1) {
          console.error("DailyEntryScreen: Error updating entry via modal - Could not find original index.");
          Alert.alert("Update Error", "An internal error occurred while trying to update the entry.");
          setIsOverlayVisible(false);
          setIsSaving(false);
          return;
        }
        console.log(`Updating item at original index ${originalEditIndex}`);
        updatedItems = existingEntry.items.map((item, index) =>
          index === originalEditIndex ? entryItem : item
        );
      } else {
        console.log("Adding new single item to existing date entry.");
        // Add to the beginning of the original array before reversing
        updatedItems = [entryItem, ...(existingEntry.items ?? [])];
      }
      const updatedEntry = { ...existingEntry, items: updatedItems };
      updatedEntries = dailyEntries.map((entry, index) =>
        index === existingEntryIndex ? updatedEntry : entry
      );
    } else {
      if (isEditMode) {
        console.error("DailyEntryScreen: Error - Trying to edit an entry for a date that doesn't exist.");
        Alert.alert("Update Error", "Cannot edit an entry for a day with no previous entries.");
         setIsOverlayVisible(false);
         setIsSaving(false);
         return;
      }
      console.log("Creating new date entry with the first item.");
      const newDailyEntry: DailyEntry = { date: selectedDate, items: [entryItem] };
      updatedEntries = [...dailyEntries, newDailyEntry];
      updatedEntries.sort((a, b) => a.date.localeCompare(b.date)); // Keep entries sorted by date
    }

    await updateAndSaveEntries(updatedEntries);

    // Trigger icon fetch if needed for the added/edited food
    if (foodIcons[selectedFood.name] === undefined) {
      triggerIconFetches([selectedFood], [], selectedDate);
    }

    setSelectedFood(null);
    setGrams("");
    setEditIndex(null);
    setIsOverlayVisible(false);
    setSearch("");
    Toast.show({
        type: "success",
        text1: `Entry ${isEditMode ? 'updated' : 'added'}`,
        position: "bottom",
        visibilityTime: 2000,
      });

  }, [
    selectedFood, grams, editIndex, dailyEntries, selectedDate, isSaving,
    getOriginalIndex, updateAndSaveEntries, foodIcons, triggerIconFetches
  ]);

  const handleAddMultipleEntries = useCallback(
    async (entriesToAdd: { food: Food; grams: number }[]) => {
      if (isSaving) return;
      console.log(`DailyEntryScreen: handleAddMultipleEntries START - Received ${entriesToAdd.length} items for ${selectedDate}`);
      try {
        if (!entriesToAdd || entriesToAdd.length === 0) {
             console.warn("handleAddMultipleEntries called with no items.");
             return;
        }
        const newItems: DailyEntryItem[] = entriesToAdd.map((entry) => ({
          food: entry.food,
          grams: entry.grams,
        }));
        console.log(`DailyEntryScreen: Mapped to ${newItems.length} DailyEntryItems.`);

        const existingEntryIndex = dailyEntries.findIndex((entry) => entry.date === selectedDate);
        let updatedEntries: DailyEntry[];

        if (existingEntryIndex > -1) {
          console.log(`DailyEntryScreen: Appending ${newItems.length} items to existing entry for ${selectedDate}.`);
          const existingEntry = dailyEntries[existingEntryIndex];
          // Add new items to the beginning of the original array
          const updatedItems = [...newItems, ...(existingEntry.items ?? [])];
          const updatedEntry = { ...existingEntry, items: updatedItems };
          updatedEntries = dailyEntries.map((entry, index) =>
            index === existingEntryIndex ? updatedEntry : entry
          );
        } else {
          console.log(`DailyEntryScreen: Creating new entry for ${selectedDate} with ${newItems.length} items.`);
          const newDailyEntry: DailyEntry = { date: selectedDate, items: newItems };
          updatedEntries = [...dailyEntries, newDailyEntry];
          updatedEntries.sort((a, b) => a.date.localeCompare(b.date));
        }

        await updateAndSaveEntries(updatedEntries);
        console.log("DailyEntryScreen: updateAndSaveEntries completed for multiple items.");

        const foodsToFetchIconsFor = newItems.map((item) => item.food);
        triggerIconFetches(foodsToFetchIconsFor, [], selectedDate);

        Toast.show({
          type: "success",
          text1: `${entriesToAdd.length} item(s) added`,
          text2: `to ${formatDateReadable(parseISO(selectedDate))}`,
          position: "bottom",
          visibilityTime: 3000,
        });

        setIsOverlayVisible(false);
        setSelectedFood(null);
        setGrams("");
        setEditIndex(null);
        setSearch("");

      } catch (error) {
        console.error("DailyEntryScreen: Error in handleAddMultipleEntries:", error);
        Alert.alert(
          "Quick Add Error",
          `Failed to add items. ${error instanceof Error ? error.message : "Please try again."}`
        );
        setIsOverlayVisible(false); // Ensure modal closes on error
      }
    },
    [dailyEntries, selectedDate, isSaving, updateAndSaveEntries, triggerIconFetches] // Added triggerIconFetches
  );

  const handleSelectFood = (item: Food | null) => {
     console.log("Modal selecting food:", item?.name ?? 'null');
    setSelectedFood(item);
     if (item && editIndex === null) { // Clear grams only when selecting for ADD
          setGrams('');
     }
  };

  const handleRemoveEntry = useCallback(async (reversedIndex: number) => {
    if (isSaving) return;
    const originalIndex = getOriginalIndex(reversedIndex);
    if (originalIndex === -1) {
         console.error(`handleRemoveEntry: Invalid reversedIndex ${reversedIndex}`);
         return;
    }

    const currentEntry = dailyEntries.find((e) => e.date === selectedDate);
    if (!currentEntry || originalIndex >= currentEntry.items.length) {
        console.error(`handleRemoveEntry: Cannot find entry or item at original index ${originalIndex}`);
        return;
    }

    const itemToRemove = currentEntry.items[originalIndex];
    console.log(`Attempting to remove item at original index ${originalIndex}: ${itemToRemove.food.name}`);

    const updatedItems = currentEntry.items.filter((_, i) => i !== originalIndex);
    let finalEntries: DailyEntry[];
    if (updatedItems.length === 0) {
         console.log(`Removing last item for date ${selectedDate}, entry will be removed.`);
         finalEntries = dailyEntries.filter((entry) => entry.date !== selectedDate);
    } else {
         const updatedEntry = { ...currentEntry, items: updatedItems };
         finalEntries = dailyEntries.map((entry) =>
            entry.date === selectedDate ? updatedEntry : entry
         );
    }

    await updateAndSaveEntries(finalEntries);

    Toast.show({
      type: "info",
      text1: `${itemToRemove.food.name} removed`,
      text2: "Tap here to undo",
      position: "bottom",
      bottomOffset: 80, // Adjust if needed based on FAB/navbar
      visibilityTime: 4000,
      onPress: () => handleUndoRemoveEntry(itemToRemove, selectedDate, originalIndex),
    });

  }, [dailyEntries, selectedDate, isSaving, getOriginalIndex, updateAndSaveEntries]);

  const handleUndoRemoveEntry = useCallback(async (
    itemToRestore: DailyEntryItem,
    entryDate: string,
    originalIndex: number
  ) => {
    if (isSaving) return;
    console.log(`Undoing removal of ${itemToRestore.food.name} at original index ${originalIndex} on ${entryDate}`);

    const existingEntryIndex = dailyEntries.findIndex((e) => e.date === entryDate);
    let updatedEntries;

    if (existingEntryIndex > -1) {
        const entryToUpdate = dailyEntries[existingEntryIndex];
        const updatedItems = [...entryToUpdate.items];
        // Insert back at the original position
        updatedItems.splice(originalIndex, 0, itemToRestore);
        const restoredEntry = { ...entryToUpdate, items: updatedItems };
        updatedEntries = dailyEntries.map((entry, index) =>
            index === existingEntryIndex ? restoredEntry : entry
        );
        console.log(`Item inserted back into existing entry at index ${originalIndex}.`);
    } else {
        // If the whole entry was removed, re-create it
        console.log(`Creating new entry for date ${entryDate} as it was removed.`);
        const newEntry: DailyEntry = { date: entryDate, items: [itemToRestore] };
        updatedEntries = [...dailyEntries, newEntry];
        updatedEntries.sort((a, b) => a.date.localeCompare(b.date)); // Keep sorted
    }

    await updateAndSaveEntries(updatedEntries);
    Toast.hide(); // Hide the undo toast
    Toast.show({
      type: "success",
      text1: "Entry restored!",
      visibilityTime: 1500,
      position: "bottom",
    });
  }, [dailyEntries, isSaving, updateAndSaveEntries]);

  const updateSearch = (search: string) => setSearch(search);

  // --- Modal Toggle Logic ---
  const toggleOverlay = useCallback((
    itemToEdit: DailyEntryItem | null = null,
    reversedIndex: number | null = null
  ) => {
    if (isSaving) {
        console.warn("Attempted to toggle modal while saving.");
        return;
    }

    // Clear general modal state first
    setSelectedFood(null);
    setGrams("");
    setEditIndex(null);
    setSearch("");

    if (itemToEdit && reversedIndex !== null) {
      // --- Setup for MODAL EDIT ---
      console.log(`Opening modal to edit item '${itemToEdit.food.name}' at reversed index ${reversedIndex}`);
      setSelectedFood(itemToEdit.food);
      setGrams(String(itemToEdit.grams));
      setEditIndex(reversedIndex); // Store REVERSED index for modal context
      setIsOverlayVisible(true);
    } else {
      // --- Setup for ADD or Closing ---
      setIsOverlayVisible((current) => !current);
    }
  }, [isSaving]); // Added isSaving dependency

  // Explicit handler for swipe-edit action
  const handleEditEntryViaModal = (item: DailyEntryItem, reversedIndex: number) => {
    toggleOverlay(item, reversedIndex);
  };

  // --- Date Navigation Handlers ---
  const handleDateChange = useCallback((event: DateTimePickerEvent, selectedDateValue?: Date) => {
    const isAndroidDismiss = Platform.OS === "android" && event.type === "dismissed";
    setShowDatePicker(Platform.OS === "ios"); // Keep iOS picker open until done

    if (!isAndroidDismiss && event.type === "set" && selectedDateValue) {
        if (isValid(selectedDateValue)) {
             const formattedDate = formatISO(selectedDateValue, { representation: "date" });
            if (formattedDate !== selectedDate) {
                 console.log(`Date changed via picker to: ${formattedDate}`);
                 setSelectedDate(formattedDate);
                 setEditIndex(null); // Cancel modal edit if date changes
            }
        } else {
            console.warn("Date picker returned invalid date:", selectedDateValue);
            Alert.alert("Invalid Date", "The selected date is not valid.");
        }
    }
     if (Platform.OS === "android") { // Always close Android picker after action/dismiss
         setShowDatePicker(false);
     }
  }, [selectedDate]); // Depend only on selectedDate

  const handlePreviousDay = useCallback(() => {
    try {
        const currentDateObj = parseISO(selectedDate);
        if (!isValid(currentDateObj)) {
             console.error("Error parsing current selected date:", selectedDate);
             return;
        }
        const newDate = subDays(currentDateObj, 1);
        const newDateString = formatISO(newDate, { representation: "date" });
        console.log(`Navigating to previous day: ${newDateString}`);
        setSelectedDate(newDateString);
        setEditIndex(null);
    } catch (e) {
      console.error("Error calculating previous day:", selectedDate, e);
    }
  }, [selectedDate]);

  const handleNextDay = useCallback(() => {
    try {
       const currentDateObj = parseISO(selectedDate);
        if (!isValid(currentDateObj)) {
             console.error("Error parsing current selected date:", selectedDate);
             return;
        }
        const newDate = addDays(currentDateObj, 1);
         const newDateString = formatISO(newDate, { representation: "date" });
        console.log(`Navigating to next day: ${newDateString}`);
        setSelectedDate(newDateString);
        setEditIndex(null);
    } catch (e) {
      console.error("Error calculating next day:", selectedDate, e);
    }
  }, [selectedDate]);

  // --- Totals Calculation ---
  const calculateTotals = useMemo(() => {
    const currentOriginalEntry = dailyEntries.find((entry) => entry.date === selectedDate);
    let totals = { totalCalories: 0, totalProtein: 0, totalCarbs: 0, totalFat: 0 };

    if (currentOriginalEntry) {
      currentOriginalEntry.items.forEach((item) => {
        // Check for valid food object and numeric macros/grams
        if (item.food && typeof item.food.calories === 'number' &&
            typeof item.food.protein === 'number' &&
            typeof item.food.carbs === 'number' &&
            typeof item.food.fat === 'number' &&
            typeof item.grams === 'number' && item.grams > 0) {
                const factor = item.grams / 100;
                totals.totalCalories += item.food.calories * factor;
                totals.totalProtein += item.food.protein * factor;
                totals.totalCarbs += item.food.carbs * factor;
                totals.totalFat += item.food.fat * factor;
        } else {
            console.warn("Skipping item in total calculation due to missing/invalid data:", item);
        }
      });
    }
    // Round totals for display
    return {
      totalCalories: Math.round(totals.totalCalories),
      totalProtein: Math.round(totals.totalProtein),
      totalCarbs: Math.round(totals.totalCarbs),
      totalFat: Math.round(totals.totalFat),
    };
  }, [dailyEntries, selectedDate]);

   // --- Render Item Component (Memoized, Styled for consistency) ---
   const RenderItem = React.memo(({ item, reversedIndex }: { item: DailyEntryItem, reversedIndex: number }) => {
        const [iconLoadError, setIconLoadError] = useState(false);
        const iconStatus = foodIcons[item.food.name]; // Check status using name
        const isLoadingIcon = iconStatus === undefined;

        const handleImageError = useCallback(() => {
            console.warn(`Image component failed to load icon for ${item.food.name}: ${iconStatus}`);
            setIconLoadError(true);
            // Explicitly update state in cache to null if Image fails
            if (foodIcons[item.food.name] !== null) {
                setFoodIcons(prev => ({ ...prev, [item.food.name]: null }));
            }
        }, [item.food.name, iconStatus]); // Depend on iconStatus

        // Reset error state if the URL changes (e.g., during refresh)
        useEffect(() => {
            setIconLoadError(false);
        }, [iconStatus]);

        const renderListItemIcon = () => {
             if (isLoadingIcon) {
                 // Consistent Loading Placeholder
                 return (
                    <View style={[styles.foodIcon, styles.iconPlaceholder]}>
                        <ActivityIndicator size="small" color={theme.colors.grey3} />
                    </View>
                 );
             } else if (iconStatus && !iconLoadError) {
                 // Display Image
                 return <Image source={{ uri: iconStatus }} style={styles.foodIconImage} onError={handleImageError} resizeMode="contain" />;
             } else {
                 // Consistent Default/Error Placeholder
                 return (
                     <View style={[styles.foodIcon, styles.iconPlaceholder]}>
                         <RNEIcon
                             name="fast-food-outline" // Default icon consistent with FoodListScreen
                             type="ionicon"
                             size={20}
                             color={theme.colors.grey3}
                         />
                     </View>
                 );
             }
        };

        return (
            <ListItem.Swipeable
                bottomDivider
                leftContent={(reset) => (
                    <Button
                        title="Edit"
                        onPress={() => {
                            if (!isSaving) {
                                handleEditEntryViaModal(item, reversedIndex); // Use modal edit
                                reset();
                            }
                        }}
                        icon={{ name: "edit", color: theme.colors.white }}
                        buttonStyle={styles.swipeButtonEdit} // Consistent style
                        titleStyle={styles.swipeButtonTitle}
                        disabled={isSaving}
                    />
                )}
                rightContent={(reset) => (
                    <Button
                        title="Delete"
                        onPress={() => {
                            if (!isSaving) {
                                handleRemoveEntry(reversedIndex);
                                reset();
                            }
                        }}
                        icon={{ name: "delete", color: theme.colors.white }}
                        buttonStyle={styles.swipeButtonDelete} // Consistent style
                        titleStyle={styles.swipeButtonTitle}
                        disabled={isSaving}
                    />
                )}
                containerStyle={styles.listItemContainer} // Use consistent list item style
            >
                {renderListItemIcon()}

                <ListItem.Content>
                    <ListItem.Title style={styles.listItemTitle}>
                        {item.food.name}
                    </ListItem.Title>
                     {/* Display Grams and Calculated Calories */}
                    <ListItem.Subtitle style={styles.listItemSubtitle}>
                        {`${item.grams}g  ${Math.round((item.food.calories / 100) * item.grams)} kcal`}
                    </ListItem.Subtitle>
                </ListItem.Content>
                {/* Chevron indicates interactibility (swipe) */}
                <ListItem.Chevron color={theme.colors.grey3} />
            </ListItem.Swipeable>
        );
   });

  // --- Main Render ---
  return (
    <SafeAreaView style={styles.container} edges={["top", "left", "right"]}>
      {/* Date Navigation Header */}
      <View style={styles.dateNavigation}>
        <Button
          type="clear"
          onPress={handlePreviousDay}
          icon={<RNEIcon name="chevron-back-outline" type="ionicon" color={theme.colors.primary} size={28} />} // Use Primary color
          buttonStyle={styles.navButton}
          disabled={isSaving || isLoadingData}
        />
        <TouchableOpacity onPress={() => !isSaving && !isLoadingData && setShowDatePicker(true)} disabled={isSaving || isLoadingData}>
          <Text h4 h4Style={styles.dateText}>
             {formatDateReadable(parseISO(selectedDate))}
          </Text>
        </TouchableOpacity>
        <Button
          type="clear"
          onPress={handleNextDay}
          icon={<RNEIcon name="chevron-forward-outline" type="ionicon" color={theme.colors.primary} size={28} />} // Use Primary color
          buttonStyle={styles.navButton}
          disabled={isSaving || isLoadingData}
        />
      </View>

      {/* Date Picker */}
      {showDatePicker && (
        <DateTimePicker
          value={parseISO(selectedDate)}
          mode="date"
          display={Platform.OS === "ios" ? "spinner" : "default"}
          onChange={handleDateChange}
          // maximumDate={new Date()} // Consider if future dates should be disallowed
        />
      )}

       {/* Progress Section - Added padding */}
      <View style={styles.progressContainer}>
            <DailyProgress
                calories={calculateTotals.totalCalories}
                protein={calculateTotals.totalProtein}
                carbs={calculateTotals.totalCarbs}
                fat={calculateTotals.totalFat}
                goals={dailyGoals}
            />
      </View>

      <Divider style={styles.divider} />

      {/* Saving Indicator */}
      {isSaving && (
          <View style={styles.savingIndicator}>
              <ActivityIndicator size="small" color={theme.colors.primary} />
              <Text style={styles.savingText}>Saving...</Text>
          </View>
      )}

      {/* Section Title */}
      <Text style={styles.sectionTitle}>
        Today's Entries
      </Text>

      {/* Entries List */}
      {isLoadingData ? (
         <View style={styles.centeredLoader}>
            <ActivityIndicator size="large" color={theme.colors.primary} />
            <Text style={styles.loadingText}>Loading Entries...</Text>
          </View>
      ) : (
        <FlatList
            data={currentEntryItems}
            keyExtractor={(item, index) => `entry-${item?.food?.id ?? 'unknown'}-${getOriginalIndex(index)}-${item?.grams ?? index}`}
            renderItem={({ item, index }) => <RenderItem item={item} reversedIndex={index} />}
            ListEmptyComponent={
                <View style={styles.emptyListContainer}>
                    <RNEIcon name="reader-outline" type="ionicon" size={50} color={theme.colors.grey3} />
                    <Text style={styles.emptyListText}>No entries recorded for this day.</Text>
                    <Text style={styles.emptyListSubText}>Tap the '+' button to add your first meal.</Text>
                </View>
            }
            initialNumToRender={10}
            maxToRenderPerBatch={5}
            windowSize={11}
            contentContainerStyle={styles.listContentContainer} // Handles paddingBottom for FAB
            keyboardShouldPersistTaps="handled" // Good for modals
        />
      )}

      {/* FAB */}
      <FAB
        icon={<RNEIcon name="add" color="white" />}
        color={theme.colors.primary}
        onPress={() => !isSaving && toggleOverlay()} // Open Add modal
        placement="right"
        size="large"
        style={styles.fab}
        disabled={isSaving || isLoadingData} // Disable while saving/loading
      />

      {/* Add/Edit Modal */}
      <AddEntryModal
        isVisible={isOverlayVisible}
        toggleOverlay={toggleOverlay}
        selectedFood={selectedFood}
        grams={grams}
        setGrams={setGrams}
        foods={foods} // Pass available foods
        handleAddEntry={handleSingleEntryAction}
        handleAddMultipleEntries={handleAddMultipleEntries}
        handleSelectFood={handleSelectFood}
        search={search}
        updateSearch={updateSearch}
        isEditMode={editIndex !== null} // Correctly pass edit mode status
        initialGrams={editIndex !== null ? grams : undefined} // Pass grams only if editing
      />
    </SafeAreaView>
  );
};

// --- Styles ---
const useStyles = makeStyles((theme) => ({
    container: {
        flex: 1,
        backgroundColor: theme.colors.background,
    },
    dateNavigation: {
        flexDirection: "row",
        alignItems: "center",
        justifyContent: "space-between",
        paddingVertical: 10, // Increased padding
        paddingHorizontal: 10, // Balanced padding
        backgroundColor: theme.colors.background, // Ensure background consistency
        // Optional: add subtle shadow or border if needed
        // borderBottomWidth: StyleSheet.hairlineWidth,
        // borderBottomColor: theme.colors.divider,
    },
    navButton: {
        paddingHorizontal: 8,
    },
    dateText: {
        fontSize: 18,
        fontWeight: "bold",
        color: theme.colors.text,
        textAlign: 'center',
        paddingVertical: 5, // Maintain touchability
    },
    progressContainer: { // Added container for padding
        paddingHorizontal: 15,
        paddingTop: 10, // Add space above progress bars
    },
    // Consistent Icon Styles (Adopted from FoodItem/FoodListScreen)
     foodIcon: { // Container style for placeholder/loading icon
       width: 40,
       height: 40,
       marginRight: 15, // Consistent spacing
       borderRadius: 8, // Consistent shape
       alignItems: 'center',
       justifyContent: 'center',
   },
   foodIconImage: { // Specific style for the Image component itself
       width: 40,
       height: 40,
       marginRight: 15,
       borderRadius: 8, // Consistent shape
   },
   iconPlaceholder: {
      backgroundColor: theme.colors.grey5, // Consistent placeholder background
   },
    // Consistent List Item Styles
    listItemContainer: {
        backgroundColor: theme.colors.background,
        paddingVertical: 12,
        paddingHorizontal: 15,
        borderBottomColor: theme.colors.divider,
    },
    listItemTitle: {
        color: theme.colors.text,
        fontWeight: "600", // Slightly bolder than default
        fontSize: 16,
        marginBottom: 3, // Space between title and subtitle
    },
    listItemSubtitle: {
        color: theme.colors.grey1,
        fontSize: 14,
    },
    divider: {
        marginVertical: 0, // Remove vertical margin, use padding on sections
        height: StyleSheet.hairlineWidth, // Thinner divider
        backgroundColor: theme.colors.divider,
    },
    sectionTitle: { // Consistent Section Title Style
        marginTop: 15,
        marginBottom: 10,
        paddingHorizontal: 15,
        fontWeight: 'bold', // Bold title
        fontSize: 18,
        color: theme.colors.text, // Use main text color
    },
    fab: {
        position: 'absolute',
        margin: 16,
        right: 10,
        bottom: 10,
    },
    emptyListContainer: { // Consistent Empty State Style
        flex: 1,
        alignItems: 'center',
        justifyContent: 'center',
        padding: 30,
        marginTop: 50, // Add some space from top elements
    },
    emptyListText: {
        fontSize: 17,
        color: theme.colors.grey2,
        textAlign: 'center',
        marginTop: 15,
    },
    emptyListSubText: {
        fontSize: 14,
        color: theme.colors.grey3,
        textAlign: 'center',
        marginTop: 8,
    },
    // Consistent Swipe Button Styles
    swipeButtonEdit: {
        minHeight: "100%",
        backgroundColor: theme.colors.warning, // Use theme color
        justifyContent: 'center',
        alignItems: 'flex-start',
        paddingLeft: 20,
    },
    swipeButtonDelete: {
        minHeight: "100%",
        backgroundColor: theme.colors.error, // Use theme color
        justifyContent: 'center',
        alignItems: 'flex-end',
        paddingRight: 20,
    },
    swipeButtonTitle: {
        color: theme.colors.white,
        fontWeight: 'bold',
        fontSize: 15,
    },
    // --- Loader and Saving Styles ---
    centeredLoader: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      paddingBottom: 50, // Avoid overlap with potential header/FAB
    },
    loadingText: {
        marginTop: 10,
        color: theme.colors.grey2,
        fontSize: 16,
    },
    savingIndicator: {
      flexDirection: 'row',
      alignItems: 'center',
      justifyContent: 'center',
      paddingVertical: 5, // Increased padding
      backgroundColor: theme.colors.grey5, // Subtle background indication
    },
    savingText: {
        marginLeft: 8,
        color: theme.colors.primary,
        fontSize: 14,
        fontStyle: 'italic',
    },
    // --- List Content Container Style ---
    listContentContainer: {
        paddingBottom: 80, // Ensure space below list for FAB
    }
}));

export default DailyEntryScreen;
---------- END DailyEntryScreen.tsx ----------


---------- FoodListScreen.tsx ----------
// src/screens/FoodListScreen.tsx
import React, { useState, useEffect, useCallback, useMemo, useRef } from "react";
import { View, FlatList, Alert, Platform, ActivityIndicator, StyleSheet } from "react-native";
import {
    createFood,
    getFoods,
    updateFood,
    deleteFood,
} from "../services/foodService";
import { Food } from "../types/food";
import { isNotEmpty } from "../utils/validationUtils"; // Removed unused isValidNumberInput
import FoodItem from "../components/FoodItem";
import { Button, SearchBar, useTheme, makeStyles, Text, Icon as RNEIcon } from "@rneui/themed"; // Renamed import
import { FAB } from "@rneui/base";
import { SafeAreaView } from "react-native-safe-area-context";
import AddFoodModal from "../components/AddFoodModal";
import Toast from "react-native-toast-message";
import { useFocusEffect } from "@react-navigation/native";
import { getFoodIconUrl } from "../utils/iconUtils";

interface FoodListScreenProps {
    onFoodChange?: () => void;
}

const FoodListScreen: React.FC<FoodListScreenProps> = ({ onFoodChange }) => {
    const [foods, setFoods] = useState<Food[]>([]);
    // State: key=food.name, value=undefined(loading), null(failed/no_icon), string(url)
    const [foodIcons, setFoodIcons] = useState<{ [foodName: string]: string | null | undefined }>({});
    const [isLoading, setIsLoading] = useState(true);
    const [isOverlayVisible, setIsOverlayVisible] = useState(false);
    const [search, setSearch] = useState("");
    const [newFood, setNewFood] = useState<Omit<Food, "id">>({
        name: "", calories: 0, protein: 0, carbs: 0, fat: 0,
    });
    const [editFood, setEditFood] = useState<Food | null>(null);
    const [errors, setErrors] = useState<{ [key: string]: string }>({});
    const [isSaving, setIsSaving] = useState(false);

    const { theme } = useTheme();
    const styles = useStyles();
    const flatListRef = useRef<FlatList>(null);

    // --- Data Loading and Icon Fetching ---
    const loadFoodData = useCallback(async () => {
        console.log("FoodListScreen: Loading food data...");
        setIsLoading(true);
        setFoodIcons({}); // Clear icons on reload
        try {
            const loadedFoods = await getFoods();
            loadedFoods.sort((a, b) => a.name.localeCompare(b.name)); // Sort by name
            setFoods(loadedFoods);
            console.log(`FoodListScreen: Loaded ${loadedFoods.length} foods.`);
            // Trigger icon fetches for the loaded foods
            fetchIconsForFoods(loadedFoods);
        } catch (error) {
            console.error("FoodListScreen: Error loading food data:", error);
            Alert.alert("Error", "Failed to load food list.");
            setFoods([]);
        } finally {
            setIsLoading(false);
        }
    }, []); // No dependencies, runs on focus/mount

    // Fetch icons only for the specified list of foods
    const fetchIconsForFoods = useCallback(async (foodsToFetch: Food[]) => {
        if (!foodsToFetch || foodsToFetch.length === 0) return;
        console.log(`FoodListScreen: Fetching icons for ${foodsToFetch.length} visible foods.`);

        const iconUpdates: { [key: string]: string | null } = {};
        const promises = foodsToFetch.map(async (food) => {
            const foodName = food.name;
            // Only fetch if status is unknown (undefined)
            if (foodIcons[foodName] === undefined) {
                 setFoodIcons(prev => ({ ...prev, [foodName]: undefined })); // Mark as loading immediately
                 try {
                    const iconUrl = await getFoodIconUrl(foodName);
                    iconUpdates[foodName] = iconUrl;
                } catch (error) {
                    console.warn(`Icon fetch failed for ${foodName}:`, error);
                    iconUpdates[foodName] = null; // Store null on error
                }
            }
        });

        await Promise.all(promises);

        if (Object.keys(iconUpdates).length > 0) {
            setFoodIcons(prevIcons => ({ ...prevIcons, ...iconUpdates }));
            console.log(`FoodListScreen: Updated icons state for ${Object.keys(iconUpdates).length} food names.`);
        }

    }, [foodIcons]); // Depend on foodIcons to know fetch status

    useFocusEffect(
        useCallback(() => {
            loadFoodData();
            return () => {
                 console.log("FoodListScreen: Unfocused.");
                 setSearch(""); // Clear search on blur
                 setIsOverlayVisible(false); // Ensure modal is closed
            };
        }, [loadFoodData])
    );

    // --- Validation ---
    const validateFood = (food: Omit<Food, "id"> | Food): { [key: string]: string } | null => {
        const newErrors: { [key: string]: string } = {};
        // Check if name is provided and not just whitespace
        if (!isNotEmpty(food.name)) newErrors.name = "Name is required";
        // Ensure macros are non-negative numbers
        if (isNaN(food.calories) || food.calories < 0) newErrors.calories = "Must be a non-negative number";
        if (isNaN(food.protein) || food.protein < 0) newErrors.protein = "Must be a non-negative number";
        if (isNaN(food.carbs) || food.carbs < 0) newErrors.carbs = "Must be a non-negative number";
        if (isNaN(food.fat) || food.fat < 0) newErrors.fat = "Must be a non-negative number";
        return Object.keys(newErrors).length === 0 ? null : newErrors;
    };

    // --- CRUD Operations ---
    const handleCreateFood = async () => {
        const trimmedFood = { ...newFood, name: newFood.name.trim() };
        const validationErrors = validateFood(trimmedFood);
        if (validationErrors) {
            setErrors(validationErrors);
            Toast.show({ type: 'error', text1: 'Please fix errors', position: 'bottom' });
            return;
        }
        setErrors({});
        setIsSaving(true);
        try {
            console.log("FoodListScreen: Creating food:", trimmedFood);
            const createdFood = await createFood(trimmedFood);
            console.log("FoodListScreen: Food created successfully:", createdFood);

            // Add and re-sort
            const updatedFoods = [...foods, createdFood].sort((a, b) => a.name.localeCompare(b.name));
            setFoods(updatedFoods);

             // Fetch icon for the new food immediately
             fetchIconsForFoods([createdFood]); // Fetch just for the new one

            setNewFood({ name: "", calories: 0, protein: 0, carbs: 0, fat: 0 }); // Reset form
            setIsOverlayVisible(false);
            onFoodChange?.(); // Notify parent/navigator if needed
            Toast.show({ type: 'success', text1: `${createdFood.name} added`, position: 'bottom' });

        } catch (error: any) {
            console.error("FoodListScreen: Error creating food:", error);
            Alert.alert("Error", error.message || "Failed to create food.");
        } finally {
            setIsSaving(false);
        }
    };

    const handleUpdateFood = async () => {
        if (!editFood) return;
        const trimmedFood = { ...editFood, name: editFood.name.trim() };
        const validationErrors = validateFood(trimmedFood);
        if (validationErrors) {
            setErrors(validationErrors);
            Toast.show({ type: 'error', text1: 'Please fix errors', position: 'bottom' });
            return;
        }
        setErrors({});
        setIsSaving(true);
        try {
            console.log("FoodListScreen: Updating food:", trimmedFood);
            const updated = await updateFood(trimmedFood);
            console.log("FoodListScreen: Food updated successfully:", updated);

            const originalFood = foods.find(f => f.id === updated.id); // Find original for name comparison
            const updatedFoods = foods.map((f) => (f.id === updated.id ? updated : f))
                                      .sort((a, b) => a.name.localeCompare(b.name)); // Update and re-sort
            setFoods(updatedFoods);

             // If name changed, trigger icon refetch for the new name
            if (originalFood && originalFood.name.toLowerCase() !== updated.name.toLowerCase()) {
                 console.log(`Food name changed from "${originalFood.name}" to "${updated.name}", refetching icon.`);
                 fetchIconsForFoods([updated]);
                 // Optionally remove old icon state if name was key: delete newIcons[originalFood.name];
            }

            setEditFood(null); // Clear edit state
            setIsOverlayVisible(false);
            onFoodChange?.();
            Toast.show({ type: 'success', text1: `${updated.name} updated`, position: 'bottom' });
        } catch (error: any) {
            console.error("FoodListScreen: Error updating food:", error);
            Alert.alert("Error", error.message || "Failed to update food.");
        } finally {
            setIsSaving(false);
        }
    };

     const handleDeleteFood = async (foodId: string) => {
        const foodToDelete = foods.find((f) => f.id === foodId);
        if (!foodToDelete) return;

        // Optimistic UI update: Remove immediately
        setFoods(foods.filter((f) => f.id !== foodId));

        try {
            console.log("FoodListScreen: Deleting food:", foodToDelete.name, foodId);
            await deleteFood(foodId);
            console.log("FoodListScreen: Food deleted successfully from storage.");
            // Success toast is handled by the callback from FoodItem
            onFoodChange?.();

            // Remove icon from cache if needed (using name as key)
            setFoodIcons(prev => {
                const newIcons = {...prev};
                delete newIcons[foodToDelete.name];
                return newIcons;
            });

        } catch (error) {
            console.error("FoodListScreen: Error deleting food:", error);
            // Revert UI change on error
            setFoods((prevFoods) => [...prevFoods, foodToDelete].sort((a,b) => a.name.localeCompare(b.name)));
            Alert.alert("Delete Error", "Failed to delete food from storage. Restored item.");
        }
    };

    // Handles the UI restoration after optimistic delete
    const handleUndoDeleteFood = useCallback((food: Food) => {
        console.log("FoodListScreen: Undoing delete for:", food.name, food.id);
        // Add back and re-sort
        const restoredFoods = [...foods, food].sort((a, b) => a.name.localeCompare(b.name));
        setFoods(restoredFoods);
        Toast.hide(); // Hide the undo toast
        // Note: This doesn't re-add to backend, assumes delete failed or user changed mind before persistence
        onFoodChange?.();
        Toast.show({ type: 'success', text1: `${food.name} restored`, position: 'bottom', visibilityTime: 2000 });

        // Re-fetch icon if it was removed from cache
        if (foodIcons[food.name] === undefined) {
            fetchIconsForFoods([food]);
        }
    }, [foods, onFoodChange, foodIcons, fetchIconsForFoods]); // Add dependencies

    // --- Modal and Input Handling ---
    const toggleOverlay = (foodToEdit?: Food) => {
        if (isSaving) return;
        if (foodToEdit) {
            console.log("FoodListScreen: Opening modal to edit:", foodToEdit.name);
            setEditFood({ ...foodToEdit }); // Set as edit target
            setNewFood({ name: "", calories: 0, protein: 0, carbs: 0, fat: 0 }); // Clear add form
        } else {
             console.log("FoodListScreen: Opening modal to add new food.");
            setEditFood(null); // Clear edit target
            setNewFood({ name: "", calories: 0, protein: 0, carbs: 0, fat: 0 }); // Clear add form
        }
        setErrors({}); // Clear errors on modal open
        setIsOverlayVisible(!isOverlayVisible);
    };

    const updateSearch = (search: string) => setSearch(search);

    // Filter foods based on search query
    const filteredFoods = useMemo(() => {
        return foods.filter((food) =>
            food.name.toLowerCase().includes(search.toLowerCase())
        );
    }, [foods, search]);

    // Handle input changes in the Add/Edit modal
    const handleInputChange = useCallback((
        key: keyof Omit<Food, "id">,
        value: string,
        isEdit: boolean
    ) => {
        const numericKeys: (keyof Omit<Food, "id">)[] = ['calories', 'protein', 'carbs', 'fat'];
        let processedValue: string | number = value;

        // Clean numeric inputs, allow empty string or just "." temporarily
        if (numericKeys.includes(key)) {
            if (value === "" || value === ".") {
                 processedValue = value; // Keep as is for intermediate state
            } else {
                // Allow only numbers and one decimal point
                const cleaned = value.replace(/[^0-9.]/g, "").replace(/(\..*)\./g, "$1");
                // Only update if it's a valid partial number or empty
                if (cleaned === "" || !isNaN(parseFloat(cleaned))) {
                     processedValue = cleaned;
                } else {
                    return; // Do not update state if cleaning results in invalid format
                }
            }
        }

        // Determine the final value to store (0 for empty/invalid numerics, string for name)
        const updateState = (prevState: any) => {
             let finalValue: string | number;
             if (numericKeys.includes(key)) {
                  // Store number 0 if empty or just ".", otherwise parse the valid numeric string
                  if (processedValue === "" || processedValue === ".") {
                      finalValue = 0;
                  } else {
                      finalValue = parseFloat(processedValue as string);
                  }
             } else {
                finalValue = processedValue; // Use the string value for name
             }
             return { ...prevState, [key]: finalValue };
        };

        // Update the correct state object (editFood or newFood)
        if (isEdit) {
            setEditFood(updateState);
        } else {
            setNewFood(updateState);
        }
    }, []);

    // --- Render ---
    if (isLoading) {
        return (
            <SafeAreaView style={styles.centeredLoader}>
                <ActivityIndicator size="large" color={theme.colors.primary} />
                <Text style={styles.loadingText}>Loading Foods...</Text>
            </SafeAreaView>
        );
    }

    return (
        <SafeAreaView style={styles.container} edges={['top', 'left', 'right']}>
            <SearchBar
                placeholder="Search Your Food Library..." // More descriptive placeholder
                onChangeText={updateSearch}
                value={search}
                platform={Platform.OS === "ios" ? "ios" : "android"}
                containerStyle={styles.searchBarContainer}
                inputContainerStyle={styles.searchBarInputContainer}
                inputStyle={styles.searchInputStyle}
                onClear={() => setSearch('')} // Clear button action
                showCancel={Platform.OS === 'ios'} // iOS convention
            />
            <FlatList
                ref={flatListRef}
                data={filteredFoods}
                keyExtractor={(item) => item.id}
                renderItem={({ item }) => (
                    <FoodItem
                        food={item}
                        onEdit={toggleOverlay}
                        onDelete={handleDeleteFood} // Pass delete handler
                        onUndoDelete={handleUndoDeleteFood} // Pass undo handler
                        foodIconUrl={foodIcons[item.name]} // Pass icon state using food NAME
                    />
                )}
                ListEmptyComponent={
                    <View style={styles.emptyListContainer}>
                        <RNEIcon name="nutrition-outline" type="ionicon" size={50} color={theme.colors.grey3} />
                        <Text style={styles.emptyListText}>
                            {search ? `No foods found matching "${search}"` : "Your food library is empty."}
                        </Text>
                        {!search && <Text style={styles.emptyListSubText}>Tap '+' to add your first food item!</Text>}
                    </View>
                }
                contentContainerStyle={filteredFoods.length === 0 ? styles.listContentContainerEmpty : styles.listContentContainer}
                initialNumToRender={15}
                maxToRenderPerBatch={10}
                windowSize={21}
                keyboardShouldPersistTaps="handled" // Important for search bar interaction
            />

            {/* Saving Indicator Overlay (Optional, more prominent) */}
            {/* {isSaving && (
                <View style={styles.savingOverlay}>
                    <ActivityIndicator size="large" color={theme.colors.white} />
                    <Text style={styles.savingOverlayText}>Saving...</Text>
                </View>
            )} */}

            <FAB
                icon={<RNEIcon name="add" color={theme.colors.white} />} // Use white icon for contrast
                color={theme.colors.primary}
                onPress={() => !isSaving && toggleOverlay()} // Prevent opening modal while saving
                placement="right"
                size="large"
                style={styles.fab}
                disabled={isSaving} // Disable FAB during save
            />

            <AddFoodModal
                isVisible={isOverlayVisible}
                toggleOverlay={() => !isSaving && setIsOverlayVisible(false)}
                newFood={newFood}
                editFood={editFood}
                errors={errors}
                handleInputChange={handleInputChange}
                handleCreateFood={handleCreateFood}
                handleUpdateFood={handleUpdateFood}
                validateFood={validateFood}
                setErrors={setErrors}
            />
        </SafeAreaView>
    );
};

// --- Styles ---
const useStyles = makeStyles((theme) => ({
    container: {
        flex: 1,
        backgroundColor: theme.colors.background,
    },
    centeredLoader: { // Centered style for initial loading
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: theme.colors.background, // Ensure background matches
    },
    loadingText: {
        marginTop: 15,
        color: theme.colors.grey1,
        fontSize: 16,
    },
    emptyListContainer: { // Consistent Empty State Style
        flex: 1,
        alignItems: 'center',
        justifyContent: 'center',
        padding: 30,
        marginTop: 50,
    },
    emptyListText: {
        fontSize: 17, // Slightly larger text
        color: theme.colors.grey2,
        textAlign: 'center',
        marginTop: 15,
    },
    emptyListSubText: {
        fontSize: 14,
        color: theme.colors.grey3,
        textAlign: 'center',
        marginTop: 8,
    },
    searchBarContainer: { // Improved Search Bar Style
        backgroundColor: theme.colors.background,
        borderBottomColor: theme.colors.divider, // Use divider color
        borderTopColor: theme.colors.background, // Match background
        borderBottomWidth: StyleSheet.hairlineWidth,
        paddingHorizontal: 10, // Adjust padding
        paddingVertical: 8,
        marginBottom: 0, // Remove margin if list items handle spacing
    },
    searchBarInputContainer: { // Style for the input field itself
        backgroundColor: theme.colors.searchBg || theme.colors.grey5, // Use specific theme color or fallback
        height: 40,
        borderRadius: 20, // Make it round
    },
    searchInputStyle: {
        color: theme.colors.text,
        fontSize: 15,
    },
    listContentContainer: { // Add padding at the bottom for FAB
        paddingBottom: 80,
    },
    listContentContainerEmpty: { // Ensure empty component can take up space
        flexGrow: 1,
        justifyContent: 'center',
    },
    fab: { // Standard FAB styling
        position: 'absolute',
        margin: 16,
        right: 10,
        bottom: 10,
    },
    // Optional Saving Overlay Styles
    // savingOverlay: {
    //     ...StyleSheet.absoluteFillObject, // Cover the whole screen
    //     backgroundColor: 'rgba(0, 0, 0, 0.4)', // Semi-transparent background
    //     justifyContent: 'center',
    //     alignItems: 'center',
    //     zIndex: 10, // Ensure it's on top
    // },
    // savingOverlayText: {
    //     color: theme.colors.white,
    //     marginTop: 10,
    //     fontSize: 16,
    // },
}));

export default FoodListScreen;
---------- END FoodListScreen.tsx ----------


---------- SettingsScreen.tsx ----------
// src/screens/SettingsScreen.tsx
import React, { useState, useEffect, useCallback } from "react";
import { View, ScrollView, Alert, StyleSheet, ActivityIndicator } from "react-native";
import { Text, makeStyles, Button, Icon, ListItem, useTheme } from "@rneui/themed"; // Import ListItem
import DailyGoalsInput from "../components/DailyGoalsInput";
import DataManagementButtons from "../components/DataManagementButtons";
import ThemeSwitch from "../components/ThemeSwitch";
import StatisticsChart from "../components/StatisticsChart";
import { loadSettings, saveSettings, loadDailyEntries } from "../services/storageService";
import { Settings, Statistics, MacroType, MacroData } from "../types/settings";
import { parseISO, isValid } from "date-fns";
import { DailyEntry } from "../types/dailyEntry";
import { useFocusEffect } from "@react-navigation/native";
import { clearIconCache } from "../utils/iconUtils";
import Toast from "react-native-toast-message";
// Import backend service functions
import { getUserStatus, addCoinsToUser, UserStatus, BackendError } from "../services/backendService";

interface SettingsScreenProps {
  onThemeChange: (theme: "light" | "dark" | "system") => void;
}

const SettingsScreen: React.FC<SettingsScreenProps> = ({ onThemeChange }) => {
  // Initial default state - will be overwritten by loadSettings
  const [settings, setSettings] = useState<Settings>({
    theme: "system",
    dailyGoals: { calories: 0, protein: 0, carbs: 0, fat: 0 },
    settingsHistory: [],
  });

  const [statistics, setStatistics] = useState<Statistics>({
    calories: [], protein: [], carbs: [], fat: [],
  });
  const [chartUpdateKey, setChartUpdateKey] = useState(0);
  const [isClearingCache, setIsClearingCache] = useState(false);
  // State for user coins
  const [userCoins, setUserCoins] = useState<number | null>(null);
  const [isLoadingCoins, setIsLoadingCoins] = useState(false);
  const [isAddingCoins, setIsAddingCoins] = useState(false);

  const { theme } = useTheme();
  const styles = useStyles();

  // --- Statistics Calculation (No change needed here) ---
  const getStatisticsData = useCallback((
    dailyEntries: DailyEntry[],
    macro: MacroType,
    currentGoals: { [key in MacroType]: number }
   ): MacroData[][] => {
    const intakeData: MacroData[] = [];
    const goalData: MacroData[] = [];

    dailyEntries.forEach((entry) => {
       try {
            const entryDate = parseISO(entry.date);
            if (!isValid(entryDate)) {
                console.warn(`Skipping entry with invalid date: ${entry.date}`);
                return;
            }

            const entryTimestamp = entryDate.getTime();
            let intakeValue = 0;

            if (entry.items && Array.isArray(entry.items)) {
                intakeValue = entry.items.reduce((total, item) => {
                    if (item.food && typeof item.food[macro] === 'number' && typeof item.grams === 'number' && item.grams > 0) {
                        return total + (item.food[macro] / 100) * item.grams;
                    }
                    return total;
                }, 0);
            }

            const goalValue = currentGoals[macro] ?? 0;

            intakeData.push({ x: entryTimestamp, y: Math.round(intakeValue) });

            if (macro === "calories") {
                goalData.push({ x: entryTimestamp, y: Math.round(goalValue) });
            }
        } catch (parseError) {
             console.error(`Error processing entry for date ${entry.date}:`, parseError);
        }
    });

    intakeData.sort((a, b) => a.x - b.x);
    if (macro === "calories") {
        goalData.sort((a, b) => a.x - b.x);
        return [intakeData, goalData];
    } else {
        return [intakeData];
    }
  }, []);

  // --- Update Statistics State ---
  // Modified: Accepts goals as argument, removed settings.dailyGoals dependency
  const updateStatistics = useCallback(async (currentGoals: { [key in MacroType]: number }) => {
    console.log("SettingsScreen: Updating statistics...");
    try {
        const loadedEntries = await loadDailyEntries();
        // Use the passed currentGoals
        const updatedStats: Statistics = {
            calories: getStatisticsData(loadedEntries, "calories", currentGoals),
            protein: getStatisticsData(loadedEntries, "protein", currentGoals),
            carbs: getStatisticsData(loadedEntries, "carbs", currentGoals),
            fat: getStatisticsData(loadedEntries, "fat", currentGoals),
        };

        setStatistics(updatedStats);
        setChartUpdateKey((prevKey) => prevKey + 1); // Trigger chart re-render
        console.log("SettingsScreen: Statistics updated.");
    } catch (error) {
         console.error("SettingsScreen: Failed to update statistics:", error);
    }
    // Dependency only on the calculation function now
  }, [getStatisticsData]);

  // --- Fetch User Status ---
  const fetchUserStatus = useCallback(async () => {
    setIsLoadingCoins(true);
    try {
        console.log("SettingsScreen: Fetching user status...");
        const status = await getUserStatus();
        setUserCoins(status.coins);
        console.log(`SettingsScreen: User status fetched. Coins: ${status.coins}`);
    } catch (error) {
        console.error("SettingsScreen: Failed to fetch user status:", error);
        setUserCoins(null); // Indicate error state
        // Optionally show a toast or alert
         Toast.show({
           type: 'error',
           text1: 'Could not load coin balance',
           text2: error instanceof BackendError ? error.message : 'Please check connection.',
           position: 'bottom',
         });
    } finally {
        setIsLoadingCoins(false);
    }
  }, []);


  // --- Load Data on Focus ---
  // Modified: Loads settings, sets state, then calls updateStatistics and fetchUserStatus
  useFocusEffect(
    useCallback(() => {
      let isActive = true; // Prevent state updates if component is unmounted quickly
      console.log("SettingsScreen: Focused. Loading settings, user status, and statistics.");

      const loadAndProcessData = async () => {
        try {
          // Load settings first
          const loadedSettings = await loadSettings();
          if (!isActive) return; // Check flag before state update
          setSettings(loadedSettings); // Update settings state

          // Fetch user status (coins)
          await fetchUserStatus(); // Fetch coins

          // Now update statistics using the just-loaded goals
          // Pass the goals directly to avoid dependency loop
          updateStatistics(loadedSettings.dailyGoals);

        } catch (error) {
           if (isActive) {
                console.error("SettingsScreen: Error during focus effect data load:", error);
                // Handle error appropriately, e.g., show an alert
                 Alert.alert("Load Error", "Failed to load settings or statistics data.");
           }
        }
      };

      loadAndProcessData();

      return () => {
        isActive = false; // Set flag on unmount/blur
        console.log("SettingsScreen: Unfocused.");
      };
      // Dependencies are now only on the stable updateStatistics and fetchUserStatus callbacks
    }, [updateStatistics, fetchUserStatus])
  );


  // --- Handle Goal Changes ---
  // Modified: Uses functional state update and passes new goals directly to updateStatistics
  const handleGoalChange = useCallback(async (goalType: MacroType, value: string) => {
    const numericValue = parseFloat(value) || 0;

    // Use functional update for settings to get the latest state reliably
    let latestSettings: Settings | null = null;
    setSettings((prevSettings) => {
      const updatedGoals = { ...prevSettings.dailyGoals, [goalType]: numericValue };
      const updatedSettings: Settings = { ...prevSettings, dailyGoals: updatedGoals };
      latestSettings = updatedSettings; // Store the updated object

      // Trigger save and stats update in the background
      (async () => {
          if (!latestSettings) return; // Should always be set, but good practice
        try {
          await saveSettings(latestSettings);
          console.log("Settings saved successfully after goal change.");
          // Update statistics immediately with the new goals
          updateStatistics(latestSettings.dailyGoals);
        } catch (error) {
          console.error("Failed to save settings or update stats after goal change:", error);
          Alert.alert("Save Error", "Could not save goal changes.");
          // Optional: Revert UI state if save/update fails critically?
          // E.g., reload settings: setSettings(await loadSettings());
        }
      })();

      return updatedSettings; // Return updated state immediately for UI responsiveness
    });
  }, [updateStatistics]); // Dependency is only on the stable updateStatistics callback


  // --- Handle Data Management Button Trigger ---
  // Modified: Reloads settings AND passes the new goals to updateStatistics, AND refetches user status
  const handleDataOperation = useCallback(async () => {
    console.log("SettingsScreen: Data operation triggered. Reloading settings, user status, and statistics.");
    try {
        const reloadedSettings = await loadSettings();
        setSettings(reloadedSettings); // Update settings state
        updateStatistics(reloadedSettings.dailyGoals); // Update stats with new goals
        fetchUserStatus(); // Refetch user status
        // Trigger theme change if it was altered by import
        onThemeChange(reloadedSettings.theme);
        Toast.show({ type: 'info', text1: 'Data reloaded.', position: 'bottom'});
    } catch (error) {
        console.error("Error reloading data after operation:", error);
        Alert.alert("Reload Error", "Failed to reload data after operation.");
    }
  }, [updateStatistics, onThemeChange, fetchUserStatus]);

  // --- Handle Icon Cache Clearing (No change needed) ---
   const handleClearIconCache = useCallback(async () => {
      console.log("SettingsScreen: Clearing icon cache...");
      setIsClearingCache(true);
      try {
          await clearIconCache();
          Toast.show({
              type: 'success',
              text1: 'Food Icon Cache Cleared',
              text2: 'Icons will refresh when viewed.',
              position: 'bottom'
          });
          console.log("SettingsScreen: Icon cache cleared successfully.");
      } catch (error) {
           console.error("SettingsScreen: Failed to clear icon cache:", error);
           Toast.show({
              type: 'error',
              text1: 'Failed to Clear Cache',
              text2: error instanceof Error ? error.message : 'An unknown error occurred.',
              position: 'bottom'
           });
      } finally {
          setIsClearingCache(false);
      }
   }, []);

    // --- Handle Add Coins Button ---
    const handleAddTestCoins = useCallback(async () => {
        setIsAddingCoins(true);
        try {
            const amountToAdd = 10;
            console.log(`SettingsScreen: Attempting to add ${amountToAdd} coins...`);
            const updatedStatus = await addCoinsToUser(amountToAdd);
            setUserCoins(updatedStatus.coins); // Update displayed coins
            console.log(`SettingsScreen: Coins added successfully. New balance: ${updatedStatus.coins}`);
            Toast.show({
                type: 'success',
                text1: `${amountToAdd} Coins Added!`,
                text2: `New balance: ${updatedStatus.coins}`,
                position: 'bottom'
            });
        } catch (error) {
            console.error("SettingsScreen: Failed to add coins:", error);
             Toast.show({
                type: 'error',
                text1: 'Failed to Add Coins',
                text2: error instanceof BackendError ? error.message : 'Please try again.',
                position: 'bottom'
             });
        } finally {
            setIsAddingCoins(false);
        }
    }, []);

  // --- Render ---
  return (
    <ScrollView style={styles.container} contentContainerStyle={styles.scrollContentContainer}>
      <Text h3 style={styles.sectionTitle}>Account</Text>
        <ListItem bottomDivider containerStyle={styles.listItem}>
            {/* Changed Icon */}
            <Icon name="database" type="material-community" color={theme.colors.warning} />
            <ListItem.Content>
                <ListItem.Title style={styles.listItemTitle}>Coin Balance</ListItem.Title>
            </ListItem.Content>
            {isLoadingCoins ? (
                 <ActivityIndicator size="small" color={theme.colors.primary} />
             ) : (
                 <Text style={styles.coinValue}>{userCoins !== null ? userCoins : 'N/A'}</Text>
             )}
        </ListItem>
        {/* REMOVE OR PROTECT THIS BUTTON IN PRODUCTION */}
        <Button
            title="Add 10 Coins (Test)"
            onPress={handleAddTestCoins}
            buttonStyle={[styles.button, { backgroundColor: theme.colors.success, marginTop: 10 }]}
            icon={<Icon name="plus-circle-outline" type="material-community" color="white" size={20} style={{ marginRight: 8 }} />}
            loading={isAddingCoins}
            disabled={isAddingCoins || isLoadingCoins}
        />
        <Text style={styles.testButtonWarning}>
             Note: The "Add Coins" button is for testing/development only and should be removed or secured for production releases.
        </Text>


      <Text h3 style={styles.sectionTitle}>General</Text>
      {/* Pass settings.theme which is updated by useFocusEffect */}
      <ThemeSwitch currentTheme={settings.theme} onToggle={onThemeChange} />

      <Text h3 style={styles.sectionTitle}>Daily Goals</Text>
      <View style={styles.inputGroup}>
        {/* Pass settings.dailyGoals which is updated by useFocusEffect & handleGoalChange */}
        <DailyGoalsInput dailyGoals={settings.dailyGoals} onGoalChange={handleGoalChange} />
      </View>

       <Text h3 style={styles.sectionTitle}>Cache Management</Text>
       <View style={styles.buttonGroup}>
            <Button
                title="Refresh Food Icons"
                onPress={handleClearIconCache}
                buttonStyle={[styles.button, { backgroundColor: theme.colors.secondary }]}
                icon={<Icon name="refresh-outline" type="ionicon" color="white" size={20} style={{ marginRight: 8 }} />}
                loading={isClearingCache}
                disabled={isClearingCache}
            />
       </View>


      <Text h3 style={styles.sectionTitle}>Statistics</Text>
      <View style={styles.chartContainer}>
        {/* Statistics and key are updated by updateStatistics */}
        <StatisticsChart statistics={statistics} key={chartUpdateKey} />
      </View>


      <Text h3 style={styles.sectionTitle}>Data Management</Text>
      <View style={styles.buttonGroup}>
        <DataManagementButtons onDataOperation={handleDataOperation} />
      </View>
    </ScrollView>
  );
};

// Styles (adjusted from original)
const useStyles = makeStyles((theme) => ({
  container: {
    flex: 1,
    backgroundColor: theme.colors.background,
  },
  scrollContentContainer: {
     padding: 15,
     paddingBottom: 40,
  },
  sectionTitle: {
    color: theme.colors.text,
    marginTop: 25,
    marginBottom: 15,
    paddingLeft: 5,
    borderLeftWidth: 3,
    borderLeftColor: theme.colors.primary,
  },
  inputGroup: {
     marginBottom: 10,
     paddingHorizontal: 5,
  },
   buttonGroup: {
      marginBottom: 10,
      paddingHorizontal: 5,
   },
  button: {
    marginBottom: 10,
    borderRadius: 8,
  },
  chartContainer: {
    minHeight: 300,
    height: 'auto',
    marginBottom: 20,
  },
  // Styles for Coin Display
  listItem: {
    backgroundColor: theme.colors.background,
    paddingVertical: 15, // Add some padding
  },
  listItemTitle: {
    color: theme.colors.text,
    fontWeight: '500',
  },
  coinValue: {
    color: theme.colors.primary,
    fontWeight: 'bold',
    fontSize: 16,
  },
  testButtonWarning: {
    fontSize: 12,
    color: theme.colors.grey3,
    fontStyle: 'italic',
    textAlign: 'center',
    marginTop: 0,
    marginBottom: 15,
    marginHorizontal: 10,
  },
}));

export default SettingsScreen;
---------- END SettingsScreen.tsx ----------


---------- backendService.ts ----------
// src/services/backendService.ts
// ---------- backendService.ts (Improved Error Handling and Logging) ----------
import Constants from 'expo-constants';
import { getClientId } from './clientIDService';
import { EstimatedFoodItem, Macros, MacrosWithFoodName } from '../types/macros';
import { Platform } from 'react-native'; // For logging platform info

// --- Configuration ---
const getBackendUrl = (): string => {
    // Prefer environment variable set during build (e.g., EXPO_PUBLIC_BACKEND_URL)
    const envUrl = process.env.EXPO_PUBLIC_BACKEND_URL;
    if (envUrl) {
        console.log("Using Backend URL from EXPO_PUBLIC_BACKEND_URL:", envUrl);
        return envUrl.endsWith('/api/v1') ? envUrl : `${envUrl.replace(/\/$/, '')}/api/v1`;
    }

    // Fallback to expoConfig (less ideal for production secrets)
    const configUrl = Constants.expoConfig?.extra?.env?.BACKEND_URL;
    if (configUrl) {
        console.warn("Using Backend URL from app.json extra.env. Consider using build-time environment variables (EXPO_PUBLIC_*) for production.");
        return configUrl.endsWith('/api/v1') ? configUrl : `${configUrl.replace(/\/$/, '')}/api/v1`;
    }

    // Final fallback for local development (clearly indicate this)
    console.error("BACKEND_URL not found in environment variables or app.json extra.env. Using default DEVELOPMENT URL. THIS IS NOT FOR PRODUCTION.");
    // Replace with your actual development backend IP/hostname
    const DEV_URL = 'http://192.168.1.15:8000'; // Or your machine's local IP
    return `${DEV_URL}/api/v1`;
};

const BASE_URL = getBackendUrl();
console.log(`Backend Service Initialized. Base URL: ${BASE_URL}`);


// --- Interfaces ---
interface GramsResponse {
    grams: number;
}

interface IconResponse {
    icon_url: string | null;
}

export interface UserStatus {
    client_id: string;
    coins: number;
}

interface BackendErrorDetail {
    // Matches FastAPI validation error structure
    loc?: (string | number)[];
    msg?: string;
    type?: string;
}

interface BackendErrorResponse {
    detail?: string | BackendErrorDetail[]; // Can be string or validation error list
}


// --- Custom Error Class ---
export class BackendError extends Error {
    status: number;
    detail?: string | BackendErrorDetail[]; // Can be string or parsed validation errors
    requestId?: string | null; // Optional request ID from response header

    constructor(message: string, status: number, detail?: string | BackendErrorDetail[], requestId?: string | null) {
        super(message);
        this.name = 'BackendError';
        this.status = status;
        this.detail = detail;
        this.requestId = requestId;
    }
}

// --- API Call Helper ---
async function fetchBackend<T>(
    endpoint: string,
    options: RequestInit = {}
): Promise<T> {
    const cleanEndpoint = endpoint.startsWith('/') ? endpoint : `/${endpoint}`;
    const url = `${BASE_URL}${cleanEndpoint}`;
    const method = options.method || 'GET';
    let response: Response | null = null; // Define response outside try block
    let requestId: string | null = null; // For logging correlation

    console.log(`[API Request] ${method} ${url} - Starting`);

    const defaultHeaders: HeadersInit = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        // Add platform info for backend logging/debugging
        'X-Platform': Platform.OS,
        // 'X-App-Version': Constants.expoConfig?.version || 'unknown', // Example app version
    };

    const clientId = await getClientId();
    const authHeaders: HeadersInit = { 'X-Client-ID': clientId };

    const config: RequestInit = {
        ...options,
        headers: {
            ...defaultHeaders,
            ...authHeaders,
            ...options.headers,
        },
        // Consider adding a timeout (if not using default)
        // signal: AbortSignal.timeout(30000), // Example 30 second timeout
    };

     // Log request body structure carefully (avoid logging full sensitive data)
     if (config.body && typeof config.body === 'string') {
          try {
              const bodyObj = JSON.parse(config.body);
              const bodyKeys = Object.keys(bodyObj);
              const bodyPreview = bodyKeys.length > 0 ? `{ keys: [${bodyKeys.join(', ')}] }` : '{}';
              console.log(`[API Request] ${method} ${url} - Body Preview: ${bodyPreview}`);
              // DEBUG only: Log snippet of body value for specific fields if safe
              // if (bodyObj.food_name) console.debug(`[API Request] Body food_name: ${String(bodyObj.food_name).substring(0, 50)}`);
              // if (bodyObj.image_base64) console.debug(`[API Request] Body image_base64: (length ${bodyObj.image_base64.length})`);
          } catch {
              console.log(`[API Request] ${method} ${url} - Body: (non-JSON or failed parse)`);
          }
     }


    try {
        response = await fetch(url, config);
        requestId = response.headers.get("X-Request-ID"); // Get request ID from response
        const status = response.status;
        const contentType = response.headers.get("content-type");

        console.log(`[API Response] ${method} ${url} - Status: ${status}, Content-Type: ${contentType}, RequestID: ${requestId || 'N/A'}`);

        // Handle No Content success case
        if (status === 204) {
             console.log(`[API Response] ${method} ${url} - Success (204 No Content)`);
             return null as T; // Or appropriate value for T if null isn't expected
        }

        // Attempt to parse JSON, otherwise get text
        let responseBody: any;
        let isJson = false;
        try {
            if (contentType && contentType.includes("application/json")) {
                responseBody = await response.json();
                isJson = true;
            } else {
                responseBody = await response.text(); // Read as text for non-JSON
                console.log(`[API Response] ${method} ${url} - Received Text: ${responseBody.substring(0, 200)}...`);
            }
        } catch (parseError) {
            // Handle cases where parsing fails (e.g., empty body, malformed JSON)
            console.error(`[API Error] ${method} ${url} - Failed to parse response body (Status: ${status}):`, parseError);
             // Use raw text if available and parsing failed
            const rawText = await response.text().catch(() => '(Could not get raw text)');
            if (!response.ok) {
                throw new BackendError(`Backend request failed (Status ${status}), failed to parse response.`, status, rawText, requestId);
            } else {
                // If response was OK but parsing failed, this might be an issue
                console.warn(`[API Warning] ${method} ${url} - Status ${status} OK, but failed to parse response body.`);
                 // Depending on T, might return null or throw
                 return null as T;
            }
        }

        // Check if the response status indicates failure
        if (!response.ok) {
            let errorMessage = `Backend request failed (Status ${status})`;
            let errorDetail: string | BackendErrorDetail[] | undefined = undefined;

            if (isJson && responseBody) {
                 const errorData = responseBody as BackendErrorResponse;
                 if (typeof errorData.detail === 'string') {
                    errorMessage = errorData.detail; // Use backend's string detail
                    errorDetail = errorMessage;
                 } else if (Array.isArray(errorData.detail)) {
                     // Handle validation errors
                     errorMessage = "Validation failed. Please check your input.";
                     errorDetail = errorData.detail; // Keep the array of details
                     console.warn(`[API Validation Error] ${method} ${url} - Details:`, JSON.stringify(errorDetail));
                 } else {
                      // Fallback if detail is missing or not string/array
                      errorMessage = `Backend error (Status ${status}), unexpected detail format.`;
                      errorDetail = JSON.stringify(responseBody); // Stringify the whole body as detail
                 }
            } else if (!isJson) {
                 // Use the text response as detail if it wasn't JSON
                 errorMessage = `Backend request failed (Status ${status}). Server response: ${responseBody.substring(0, 100)}...`;
                 errorDetail = responseBody;
            }

            // Specific handling for common error codes
            if (status === 401) errorMessage = "Authentication failed. Please log in again.";
            if (status === 403) errorMessage = "Permission denied.";
            if (status === 404) errorMessage = "Resource not found.";
            if (status === 429) errorMessage = "Too many requests. Please try again later.";
            if (status === 402) errorMessage = "Insufficient coins for this action."; // Specific message for 402

            console.error(`[API Error] ${method} ${url} - Status: ${status}, Message: "${errorMessage}", Detail:`, errorDetail);
            throw new BackendError(errorMessage, status, errorDetail, requestId);
        }

        // Success case
        console.log(`[API Response] ${method} ${url} - Success (Status: ${status})`);
        // DEBUG only: Log successful response body snippet
        // if (isJson) console.debug(`[API Response] Body: ${JSON.stringify(responseBody).substring(0, 200)}...`);
        return responseBody as T;

    } catch (error) {
        // Log request ID if available
        const logRequestId = requestId ? ` (RequestID: ${requestId})` : '';

        if (error instanceof BackendError) {
            // Already logged in the block above
            throw error; // Re-throw known backend errors
        }

        // Handle network errors, timeouts, etc.
        console.error(`[API Network Error] ${method} ${url}${logRequestId} - Error:`, error);
        let networkErrorMessage = `Failed to communicate with the backend.`;
         if (error instanceof Error) {
             if (error.name === 'AbortError' || error.message.includes('timed out')) {
                 networkErrorMessage = 'The request timed out. Please try again.';
             } else if (error.message.includes('Network request failed')) {
                 networkErrorMessage += ' Please check your network connection.';
             } else {
                 networkErrorMessage += ` Details: ${error.message}`;
             }
         } else {
             networkErrorMessage += ' An unknown network error occurred.';
         }
        // Use status 0 or a custom code (e.g., 599) for client-side network errors
        throw new BackendError(networkErrorMessage, 0, networkErrorMessage, requestId);
    }
}

// --- Service Functions (Endpoints remain the same) ---

export const getUserStatus = async (): Promise<UserStatus> => {
    const clientId = await getClientId();
    // Ensure clientId is valid UUID format before sending? Maybe not necessary if backend handles it.
    return fetchBackend<UserStatus>(`/users/status/${clientId}`);
};

export const getMacrosForRecipe = async (foodName: string, ingredients: string): Promise<Macros> => {
    const body = { food_name: foodName, ingredients };
    return fetchBackend<Macros>('/ai/macros_recipe', {
        method: 'POST',
        body: JSON.stringify(body),
    });
};

export const getMacrosForImageSingle = async (image_base64: string, mime_type: string): Promise<MacrosWithFoodName> => {
    const body = { image_base64, mime_type };
    return fetchBackend<MacrosWithFoodName>('/ai/macros_image_single', {
        method: 'POST',
        body: JSON.stringify(body),
    });
};

export const getMacrosForImageMultiple = async (image_base64: string, mime_type: string): Promise<EstimatedFoodItem[]> => {
    const body = { image_base64, mime_type };
    return fetchBackend<EstimatedFoodItem[]>('/ai/macros_image_multiple', {
        method: 'POST',
        body: JSON.stringify(body),
    });
};

export const estimateGramsNaturalLanguage = async (foodName: string, quantityDescription: string): Promise<number> => {
    const body = { food_name: foodName, quantity_description: quantityDescription };
    const response = await fetchBackend<GramsResponse>('/ai/grams_natural_language', {
        method: 'POST',
        body: JSON.stringify(body),
    });
    // Handle potential null response from fetchBackend if server returned 204 or non-JSON OK
    if (response === null || typeof response.grams !== 'number') {
        console.error("Received unexpected null or invalid response format while estimating grams.");
        throw new BackendError("Failed to get grams estimation due to unexpected response.", 500, "Invalid response format");
    }
    return response.grams;
};

export const getFoodIcon = async (foodName: string, locale: string = 'en'): Promise<string | null> => {
    const encodedFoodName = encodeURIComponent(foodName);
    const encodedLocale = encodeURIComponent(locale);
    try {
        // Expecting IconResponse = { icon_url: string | null }
        const response = await fetchBackend<IconResponse>(`/icons/food?food_name=${encodedFoodName}&locale=${encodedLocale}`);
        // Handle null response from fetchBackend (e.g., 204 No Content)
        if (response === null) {
            // console.log(`Received null response for icon ${foodName}, treating as not found.`);
            return null;
        }
        return response.icon_url; // Can be string or null as intended by backend
    } catch (error) {
        if (error instanceof BackendError && error.status === 404) {
             console.log(`Icon not found for ${foodName} (404).`);
             return null;
        }
        // Log other errors but return null to calling function
        console.error(`Failed to get icon for ${foodName} via backend service:`, error);
         return null;
    }
};

export const addCoinsToUser = async (amount: number): Promise<UserStatus> => {
    const clientId = await getClientId();
    const body = { amount };
    if (amount <= 0) {
        // Basic client-side validation
        throw new BackendError("Amount to add must be positive.", 400, "Amount must be positive.");
    }
    return fetchBackend<UserStatus>(`/users/add_coins/${clientId}`, {
        method: 'POST',
        body: JSON.stringify(body),
    });
};

---------- END backendService.ts ----------


---------- clientIDService.ts ----------
// src/services/clientIDService.ts
import AsyncStorage from '@react-native-async-storage/async-storage';
import uuid from 'react-native-uuid';

const CLIENT_ID_KEY = '@MacroTracker:clientId';
let currentClientId: string | null = null; // In-memory cache

export const getClientId = async (): Promise<string> => {
  if (currentClientId) {
    return currentClientId;
  }

  try {
    let clientId = await AsyncStorage.getItem(CLIENT_ID_KEY);
    if (!clientId) {
      clientId = uuid.v4() as string;
      console.log('Generated new client ID:', clientId);
      await AsyncStorage.setItem(CLIENT_ID_KEY, clientId);
    } else {
      console.log('Retrieved existing client ID:', clientId);
    }
    currentClientId = clientId;
    return clientId;
  } catch (error) {
    console.error('Error handling client ID:', error);
    // Fallback or throw error depending on desired behavior
    // For now, generating a temporary one if storage fails
    return uuid.v4() as string;
  }
};

// Optional: Function to clear ID for testing
export const clearClientId = async (): Promise<void> => {
    currentClientId = null;
    try {
        await AsyncStorage.removeItem(CLIENT_ID_KEY);
        console.log('Client ID cleared.');
    } catch (error) {
        console.error('Error clearing client ID:', error);
    }
};
---------- END clientIDService.ts ----------


---------- foodService.ts ----------
// services/foodService.ts
import { Food } from '../types/food';
import { saveFoods, loadFoods } from './storageService';
import 'react-native-get-random-values';
import { v4 as uuidv4 } from 'uuid';

export const createFood = async (foodData: Omit<Food, 'id'>): Promise<Food> => {
  const newFood: Food = {
    id: uuidv4(),
    ...foodData,
  };
  const foods = await loadFoods();
  foods.push(newFood);
  await saveFoods(foods);
  return newFood;
};

export const getFoods = async (): Promise<Food[]> => {
  return loadFoods();
};

export const updateFood = async (updatedFood: Food): Promise<Food> => {
  const foods = await loadFoods();
  const index = foods.findIndex((f) => f.id === updatedFood.id);
  if (index === -1) {
    throw new Error('Food not found'); // Throw an error if not found
  }
  foods[index] = updatedFood;
  await saveFoods(foods);
  return updatedFood;
};

export const deleteFood = async (foodId: string): Promise<void> => {
  const foods = await loadFoods();
  const filteredFoods = foods.filter((f) => f.id !== foodId);
  await saveFoods(filteredFoods);
};
---------- END foodService.ts ----------


---------- storageService.ts ----------
// services/storageService.ts (Modified for Timestamps)
import AsyncStorage from '@react-native-async-storage/async-storage';
import { DailyEntry } from '../types/dailyEntry';
import { Food } from '../types/food';
import { Settings } from '../types/settings';
import { formatISO, parseISO } from 'date-fns';


const DAILY_ENTRIES_KEY = 'dailyEntries';
const FOODS_KEY = 'foods';
const SETTINGS_KEY = 'settings';
const RECENT_FOODS = 'recentFoods';


export const saveDailyEntries = async (entries: DailyEntry[]): Promise<void> => {
  try {
    await AsyncStorage.setItem(DAILY_ENTRIES_KEY, JSON.stringify(entries));
  } catch (error) {
    console.error('Error saving daily entries:', error);
    throw error;
  }
};

export const loadDailyEntries = async (): Promise<DailyEntry[]> => {
  try {
    const entriesJson = await AsyncStorage.getItem(DAILY_ENTRIES_KEY);
    return entriesJson ? JSON.parse(entriesJson) : [];
  } catch (error) {
    console.error('Error loading daily entries:', error);
    return [];
  }
};

export const saveFoods = async (foods: Food[]): Promise<void> => {
  try {
    await AsyncStorage.setItem(FOODS_KEY, JSON.stringify(foods));
  } catch (error) {
    console.error('Error saving foods:', error);
    throw error; // Re-throw the error
  }
};

export const loadFoods = async (): Promise<Food[]> => {
  try {
    const foodsJson = await AsyncStorage.getItem(FOODS_KEY);
    return foodsJson ? JSON.parse(foodsJson) : [];
  } catch (error) {
    console.error('Error loading foods:', error);
    return []; // Return an empty array on error
  }
};



export const saveSettings = async (settings: Settings): Promise<void> => {
  try {
    await AsyncStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
  } catch (error) {
    console.error('Error saving settings:', error);
    throw error;
  }
};

export const loadSettings = async (): Promise<Settings> => {
  try {
    const settingsJson = await AsyncStorage.getItem(SETTINGS_KEY);
    const loadedSettings = settingsJson ? JSON.parse(settingsJson) : {};

    // Apply defaults and ensure structure
    const defaultSettings: Settings = {
      theme: 'system',
      dailyGoals: { calories: 2000, protein: 50, carbs: 200, fat: 70 },
      settingsHistory: [] // Ensure settingsHistory exists
    };


    return {
      ...defaultSettings, // Start with defaults
        ...loadedSettings, // Override with loaded values
        dailyGoals: {
          ...defaultSettings.dailyGoals,  //ensure no fields missing from daily goals
            ...(loadedSettings.dailyGoals || {}) // And override *those* with any loaded dailyGoals
        }
    }

  } catch (error: any) {
    console.error('Error loading settings:', error);

    // *** KEY CHANGE: Handle "Row too big" error ***
    if (error.message.includes('Row too big')) {
      console.warn('Detected oversized settings data. Clearing settings.');
      try {
        await AsyncStorage.removeItem(SETTINGS_KEY); // Clear the oversized data
      } catch (clearError) {
        console.error('Error clearing oversized settings:', clearError);
        // You might want to handle this more gracefully, e.g., by showing an error to the user.
      }
    }

    // Return defaults if loading fails (or after clearing)
    return {
      theme: 'system',
      dailyGoals: { calories: 2000, protein: 50, carbs: 200, fat: 70 },
      settingsHistory: [] // Ensure settingsHistory exists in default
    };
  }
};

export const clearAllData = async (): Promise<void> => {
  try {
    await AsyncStorage.clear();
  } catch (error) {
    console.error('Error clearing data:', error);
    throw error;
  }
};

// Function to save recent foods
export const saveRecentFoods = async (foods: Food[]) => {
    try {
        await AsyncStorage.setItem(RECENT_FOODS, JSON.stringify(foods));
    } catch (error) {
        console.error('Error saving recent foods:', error);
        throw error; // Important: Re-throw the error so calling code knows it failed
    }
};

// Function to load recent foods
export const loadRecentFoods = async (): Promise<Food[]> => {
    try {
        const foods = await AsyncStorage.getItem(RECENT_FOODS);
        return foods ? JSON.parse(foods) : [];
    } catch (error) {
        console.error('Error loading recent foods:', error);
        return []; // Return empty array on error, don't throw
    }
};
---------- END storageService.ts ----------


---------- dailyEntry.ts ----------
// types/dailyEntry.ts (Modified)
import { Food } from "./food";

export interface DailyEntryItem {
  food: Food;
  grams: number;
}

export interface DailyEntry {
  date: string; // YYYY-MM-DD format
  items: DailyEntryItem[];
  goals?: {  // Optional goals
    calories?: number;
    protein?: number;
    carbs?: number;
    fat?: number;
  };
}

export interface FoodItem { //No changes here.
    id: string;
    name: string;
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
  }
---------- END dailyEntry.ts ----------


---------- food.ts ----------
// types/food.ts
export interface Food {
  id: string;
  name: string;
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
  // category: string;  // REMOVED
}
---------- END food.ts ----------


---------- macros.ts ----------
// src/types/macros.ts

// Basic macro structure
export interface Macros {
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
  }
  
  // Macros structure including the identified food name
  export interface MacrosWithFoodName extends Macros {
    foodName: string;
  }
  
  /**
   * Represents a single food item estimated from an image,
   * including its name, estimated weight, and macros per 100g.
   * Matches the structure expected/returned by the backend service.
   */
  export interface EstimatedFoodItem {
    foodName: string;
    estimatedWeightGrams: number;
    calories_per_100g: number;
    protein_per_100g: number;
    carbs_per_100g: number;
    fat_per_100g: number;
  }
---------- END macros.ts ----------


---------- openRouterTypes.ts ----------
// src/utils/types.ts

// =====================================
// Consolidated OpenRouter Type Definitions
// =====================================

// --- Content Parts (for multi-modal input like images) ---
export type OpenRouterContentPart =
  | { type: "text"; text: string }
  | { type: "image_url"; image_url: { url: string; detail?: "low" | "high" | "auto" } };

// --- Message Structure ---
// Allows content to be a simple string OR an array of content parts for vision models
export interface OpenRouterMessage {
  role: "user" | "assistant" | "system";
  content: string | OpenRouterContentPart[]; // Consolidated definition
  name?: string; // Optional name field
}

// --- Choice Structure (within the response) ---
// This structure aligns with standard Chat Completion APIs (like OpenAI/OpenRouter)
export interface OpenRouterChatChoice {
  index: number;
  message: OpenRouterMessage; // Contains the actual message content and role
  logprobs?: any | null; // Optional log probabilities (use a specific type if known)
  finish_reason: string | null; // Can be null sometimes
  // text?: string; // Usually the content is inside message.content, keep optional if some models return it differently
}

// --- API Usage Information ---
export interface OpenRouterUsage {
  prompt_tokens: number;
  completion_tokens: number;
  total_tokens: number;
}

// --- Main Chat Completion Response Structure ---
// Consolidates the fields from both previous declarations
export interface OpenRouterChatCompletionResponse {
  id: string;
  object: string; // Typically "chat.completion"
  created: number; // Timestamp
  model: string; // Model used
  choices: OpenRouterChatChoice[]; // Array of choices using the defined structure
  usage?: OpenRouterUsage; // Usage information is often optional
  // Add any other relevant fields you might encounter from OpenRouter
  // system_fingerprint?: string; // Example optional field
}


// =====================================
// Removed Redundant/Conflicting Declarations:
// =====================================

/*
// REMOVED - Duplicate/Outdated OpenRouterMessage
export interface OpenRouterMessage {
  role: "user" | "assistant" | "system"; // Add system role
  content: string;
}

// REMOVED - Less standard choice structure (often message.content is used instead of top-level text)
export interface OpenRouterChoice {
  text: any; // 'any' is vague, content is usually in message
  message: OpenRouterMessage; // This duplicates content info if 'text' is also present
  finish_reason?: string;
  index?: number;
}

// REMOVED - Duplicate/Simpler OpenRouterChatCompletionResponse
export interface OpenRouterChatCompletionResponse {
  choices: OpenRouterChoice[]; // Used the less standard choice type
  id?: string;
  created?: number;
  model?: string;
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}
*/
---------- END openRouterTypes.ts ----------


---------- settings.ts ----------
// types/settings.ts (Modified)
export const macros = ["calories", "protein", "carbs", "fat"] as const;
export type MacroType = (typeof macros)[number];

export interface MacroData {
  x: number; // Timestamp
  y: number; // Macro value
}

export interface Statistics {
  calories: MacroData[][];
  protein: MacroData[][];
  carbs: MacroData[][];
  fat: MacroData[][];
}

export interface Settings {
  theme: "light" | "dark" | "system";
  dailyGoals: {
    [key in MacroType]: number;
  };
  settingsHistory?: { date: number; dailyGoals: { [key in MacroType]: number } }[]; // CHANGED: Store timestamp
}

export interface SettingsScreenProps {
  onThemeChange: (theme: "light" | "dark" | "system") => void;
}
---------- END settings.ts ----------


---------- dateUtils.ts ----------
// utils/dateUtils.ts (Corrected type for formatDateReadable)
import { format, parseISO, formatISO, isValid } from 'date-fns';

/**
 * Formats a Date object, timestamp (number), or ISO date string (YYYY-MM-DD)
 * into a standard YYYY-MM-DD string representation.
 * Returns an empty string if the input is invalid.
 * @param dateInput - The date to format (Date object, timestamp number, or 'YYYY-MM-DD' string).
 * @returns The formatted date string 'YYYY-MM-DD' or empty string on error.
 */
export const formatDateISO = (dateInput: number | string | Date): string => {
    try {
        let dateObj: Date;
        if (dateInput instanceof Date) {
            dateObj = dateInput;
        } else if (typeof dateInput === 'string') {
            // Assume 'YYYY-MM-DD' format if string
            dateObj = parseISO(dateInput);
        } else if (typeof dateInput === 'number') {
            // Assume timestamp if number
            dateObj = new Date(dateInput);
        } else {
            throw new Error("Invalid input type");
        }

        if (!isValid(dateObj)) {
             throw new Error("Invalid date value");
        }
        return formatISO(dateObj, { representation: 'date' });
    } catch (error) {
        console.error("Error in formatDateISO:", error, "Input:", dateInput);
        return ""; // Return empty string on error
    }
};


/**
 * Formats a Date object, timestamp (number), or ISO date string (YYYY-MM-DD)
 * into a human-readable format (e.g., "MMMM dd, yyyy").
 * Returns 'Invalid Date' if the input is invalid.
 * @param dateInput - The date to format (Date object, timestamp number, or 'YYYY-MM-DD' string).
 * @returns The formatted readable date string or 'Invalid Date' on error.
 */
export const formatDateReadable = (dateInput: number | string | Date): string => {
    try {
        let dateObj: Date;
        if (dateInput instanceof Date) {
            dateObj = dateInput;
        } else if (typeof dateInput === 'string') {
            // Assume 'YYYY-MM-DD' format if string
            dateObj = parseISO(dateInput);
        } else if (typeof dateInput === 'number') {
             // Assume timestamp if number
            dateObj = new Date(dateInput);
        } else {
             throw new Error("Invalid input type");
        }

        if (!isValid(dateObj)) {
            throw new Error("Invalid date value");
        }
        return format(dateObj, 'MMMM dd, yyyy'); // Example format
    } catch (error) {
         console.error("Error in formatDateReadable:", error, "Input:", dateInput);
         return 'Invalid Date'; // Return indicator string on error
    }
};

/**
 * Gets today's date as a standard YYYY-MM-DD string.
 * @returns Today's date in 'YYYY-MM-DD' format.
 */
export const getTodayDateString = (): string => {
  // formatISO handles Date object correctly
  return formatISO(new Date(), { representation: 'date' });
};
---------- END dateUtils.ts ----------


---------- iconUtils.ts ----------
// src/utils/iconUtils.ts
// Import necessary modules
import AsyncStorage from '@react-native-async-storage/async-storage';
import { getFoodIcon } from '../services/backendService'; // Import backend service

// Define the cache entry type (URL only, no expiry handled here)
type CacheEntry = {
  url: string | null;
};

// In-memory cache for fast access
const memoryCache = new Map<string, CacheEntry>();

// Prefix for AsyncStorage keys (keeping versioning)
const STORAGE_KEY_PREFIX = 'foodIconCacheBE_v1_'; // BE = Backend

// --- Main Exported Function ---

/**
 * Gets the icon URL for a food item.
 * Checks memory cache, then AsyncStorage, then calls the backend service.
 * Caches the result (including null for failures/not found).
 *
 * @param foodName The name of the food item.
 * @param locale The desired locale for the icon search (defaults to 'en').
 * @returns A Promise resolving to the icon URL (string) or null if not found or an error occurred.
 */
export const getFoodIconUrl = async (foodName: string, locale: string = 'en'): Promise<string | null> => {
  if (!foodName || foodName.trim() === '') {
      console.warn("getFoodIconUrl called with empty foodName.");
      return null;
  }

  const cacheKey = `${locale}_${foodName.toLowerCase().trim()}`;

  // 1. Check Memory Cache
  const memoryEntry = memoryCache.get(cacheKey);
  if (memoryEntry !== undefined) { // Check existence, not just truthiness (null is valid cached value)
    // console.log(`Icon Cache HIT (Memory): ${cacheKey} -> ${memoryEntry.url}`);
    return memoryEntry.url;
  }

  // 2. Check AsyncStorage
  const storageKey = STORAGE_KEY_PREFIX + cacheKey;
  try {
    const storedValue = await AsyncStorage.getItem(storageKey);
    if (storedValue !== null) {
      const parsed: CacheEntry = JSON.parse(storedValue);
      // console.log(`Icon Cache HIT (Storage): ${cacheKey} -> ${parsed.url}`);
      memoryCache.set(cacheKey, parsed); // Update memory cache
      return parsed.url;
    }
  } catch (error) {
    console.error(`Error reading icon cache from AsyncStorage for key ${storageKey}:`, error);
    // Continue to fetch if storage read fails
  }

  // 3. Fetch from Backend API
  // console.log(`Icon Cache MISS / Fetching Backend API: ${cacheKey}`);
  let iconUrl: string | null = null;
  try {
      // Call the backend service function - it handles its own errors and returns null on failure
      iconUrl = await getFoodIcon(foodName, locale);
      // console.log(`Backend returned icon URL for ${foodName}: ${iconUrl}`);

  } catch (error) {
      // This catch block might be redundant if getFoodIcon handles all errors,
      // but kept as a safeguard against unexpected issues in the service call itself.
      console.error(`Unexpected error calling getFoodIcon service for ${foodName}:`, error);
      iconUrl = null; // Ensure null is cached on unexpected error during service call
  }

  // 4. Cache the final result (even nulls) from backend
  const newCacheEntry: CacheEntry = { url: iconUrl };
  memoryCache.set(cacheKey, newCacheEntry); // Cache in memory
  try {
    // Cache in AsyncStorage
    await AsyncStorage.setItem(storageKey, JSON.stringify(newCacheEntry));
  } catch (error) {
    console.error(`Error saving icon cache to AsyncStorage for key ${storageKey}:`, error);
  }

  return iconUrl;
};

// --- Cache Management (Optional but recommended) ---

export const clearIconCache = async () => {
    memoryCache.clear();
    try {
        const keys = await AsyncStorage.getAllKeys();
        const cacheKeys = keys.filter(key => key.startsWith(STORAGE_KEY_PREFIX));
        if (cacheKeys.length > 0) {
             await AsyncStorage.multiRemove(cacheKeys);
             console.log(`Cleared ${cacheKeys.length} items from AsyncStorage icon cache (Backend Version).`);
        }
    } catch (error) {
        console.error("Error clearing backend icon cache from AsyncStorage:", error);
    }
};

export const logMemoryCacheSize = () => {
    console.log(`In-memory icon cache size: ${memoryCache.size}`);
};
---------- END iconUtils.ts ----------


---------- macros.ts ----------
// src/utils/macros.ts
import * as FileSystem from 'expo-file-system';
// import MimeTypes from 'react-native-mime-types'; // Optional: for more robust MIME type detection
import {
    getMacrosForRecipe,
    getMacrosForImageSingle,
    getMacrosForImageMultiple,
    BackendError // Re-export for components if needed
} from '../services/backendService';
import { Alert } from 'react-native';
import { Macros, MacrosWithFoodName, EstimatedFoodItem } from '../types/macros';
import { ImagePickerAsset } from 'expo-image-picker';

// --- Helper function to determine MIME type (more robust) ---
function determineMimeType(asset: {
    uri: string;
    mimeType?: string | null;
    fileName?: string | null;
    // Removed 'type' as it's less reliable than mimeType or extension
}): string {
    // 1. Prioritize asset.mimeType if available (most reliable)
    if (asset.mimeType && asset.mimeType.includes('/')) { // Basic validation
        console.log(`Using provided MIME type: ${asset.mimeType}`);
        return asset.mimeType;
    }

    // 2. Optional: Use react-native-mime-types if installed
    // const validFileNameForLookup = asset.fileName ?? undefined;
    // if (validFileNameForLookup) {
    //     const lookedUpMime = MimeTypes.lookup(validFileNameForLookup);
    //     if (lookedUpMime) {
    //         console.log(`Looked up MIME type using filename: ${lookedUpMime}`);
    //         return lookedUpMime;
    //     }
    // }

    // 3. Infer from URI extension (fallback)
    const uriParts = asset.uri.split('.');
    const extension = uriParts.pop()?.toLowerCase();
    console.log(`Inferring MIME type from extension: .${extension}`);
    switch (extension) {
        case 'jpg':
        case 'jpeg':
            return 'image/jpeg';
        case 'png':
            return 'image/png';
        case 'gif':
            return 'image/gif';
        case 'webp':
            return 'image/webp';
        case 'bmp':
            return 'image/bmp';
        // Add other image types if necessary
        default:
            // 4. Final fallback (e.g., if no extension or unknown)
            console.warn(`Could not determine specific MIME type for URI: ${asset.uri}. Defaulting to image/jpeg.`);
            return 'image/jpeg'; // Default to common type
    }
}


// --- Utility function to convert a file URI to base64 (Error Handling) ---
export async function getBase64FromUri(uri: string): Promise<string> {
    try {
        const base64 = await FileSystem.readAsStringAsync(uri, {
            encoding: FileSystem.EncodingType.Base64,
        });
        return base64;
    } catch (error: any) {
        console.error(`Failed to read file as base64: ${uri}`, error);
        // Provide a more specific error message
        throw new Error(`Failed to read image file: ${error.message || 'Unknown error'}`);
    }
}


// --- Service Interaction Functions (with better error handling context) ---

// Get macros from recipe text
export async function getMacrosFromText(
    foodName: string,
    ingredients: string
): Promise<Macros> {
    try {
        console.log(`Requesting macros for recipe: "${foodName}"`);
        const macros = await getMacrosForRecipe(foodName, ingredients);
        console.log(`Received macros for recipe: "${foodName}"`);
        return macros;
    } catch (error) {
        // Log with context before Alert/re-throw
        console.error(`Error getting macros for recipe "${foodName}":`, error);
        const message = error instanceof BackendError
            ? error.message
            : `Failed to get macros for recipe: ${error instanceof Error ? error.message : String(error)}`;
        Alert.alert("AI Error (Recipe)", message);
        throw error;
    }
}

// Get macros for a single food item from an image asset
export async function getMacrosForImageFile(asset: ImagePickerAsset): Promise<MacrosWithFoodName> {
    let base64File: string;
    try {
        base64File = await getBase64FromUri(asset.uri);
    } catch (err) {
        Alert.alert("Image Read Error", err instanceof Error ? err.message : "Failed to read image file.");
        throw err;
    }

    const mimeType = determineMimeType(asset);
    console.log(`Requesting single food analysis. MIME: ${mimeType}, Asset URI: ${asset.uri}`);

    try {
        const result = await getMacrosForImageSingle(base64File, mimeType);
        console.log(`Received single food analysis: ${result.foodName}`);
        return result;
    } catch (error) {
        console.error(`Error getting single food macros for image ${asset.uri}:`, error);
        const message = error instanceof BackendError
            ? error.message
            : `Image analysis failed: ${error instanceof Error ? error.message : String(error)}`;
        Alert.alert("Analysis Failed (Single Item)", message);
        throw error;
    }
}

// Get multiple estimated food items from an image asset
export async function getMultipleFoodsFromImage(asset: ImagePickerAsset): Promise<EstimatedFoodItem[]> {
    console.log(`Starting getMultipleFoodsFromImage for asset URI: ${asset.uri}`);
    let base64File: string;
    try {
        base64File = await getBase64FromUri(asset.uri);
        console.log("Converted multi-food image to base64.");
    } catch (err) {
         Alert.alert("Image Read Error", err instanceof Error ? err.message : "Failed to read image file.");
         throw err;
    }

    const mimeType = determineMimeType(asset);
    console.log(`Requesting multi-food analysis. MIME: ${mimeType}, Asset URI: ${asset.uri}`);

    try {
        console.log("Calling backendService.getMacrosForImageMultiple...");
        const results = await getMacrosForImageMultiple(base64File, mimeType);
        console.log(`Received ${results.length} estimated items from backend.`);
        return results;
    } catch (error) {
        console.error(`Error getting multiple food macros for image ${asset.uri}:`, error);
         const message = error instanceof BackendError
            ? error.message
            : `Could not analyze image: ${error instanceof Error ? error.message : String(error)}`;
        Alert.alert("Quick Add Failed (Multi-Item)", message);
        throw error;
    }
}

// Re-export types and potentially BackendError if components need it directly
export { BackendError, EstimatedFoodItem, Macros, MacrosWithFoodName };
---------- END macros.ts ----------


---------- units.ts ----------
// src/utils/units.ts
import { Alert } from 'react-native';
import { estimateGramsNaturalLanguage, BackendError } from '../services/backendService';

/**
 * Estimates the weight in grams based on a natural language description and food item, using the backend service.
 * @param foodName The name of the food item (e.g., "Apple").
 * @param quantityDescription The natural language description (e.g., "2 small", "1 cup chopped").
 * @returns A promise that resolves with the estimated weight in grams (number).
 */
export async function getGramsFromNaturalLanguage(
    foodName: string,
    quantityDescription: string
): Promise<number> {
    try {
        const grams = await estimateGramsNaturalLanguage(foodName, quantityDescription);
        return grams; // Backend service already rounds
    } catch (error) {
        console.error("Error getting grams estimation from backend:", error);
        const message = error instanceof BackendError
            ? error.message
            : `Could not estimate grams: ${error instanceof Error ? error.message : String(error)}`;
        Alert.alert("AI Estimation Failed", message);
        throw error; // Re-throw error
    }
}
---------- END units.ts ----------


---------- validationUtils.ts ----------
// utils/validationUtils.ts

export const isValidNumberInput = (value: string): boolean => {
    return /^[0-9]*(\.[0-9]*)?$/.test(value) && !isNaN(parseFloat(value));
  };
  
  export const isNotEmpty = (value: string): boolean => {
    return value.trim() !== '';
  };
---------- END validationUtils.ts ----------


---------- tsconfig.json ----------
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true

  }
}
---------- END tsconfig.json ----------

