.gitignore
app.json
App.tsx
assets/
  adaptive-icon.png
  favicon.png
  icon.png
  splash-icon.png
components/
  ConfirmationModal.tsx
  DailyProgress.tsx
  FoodItem.tsx
index.ts
navigation/
  AppNavigator.tsx
package.json
projectToFile.js
screens/
  DailyEntryScreen.tsx
  FoodListScreen.tsx
  SettingsScreen.tsx
services/
  foodService.ts
  storageService.ts
tsconfig.json
types/
  dailyEntry.ts
  food.ts
utils/
  dateUtils.ts
  validationUtils.ts

---------- .gitignore ----------
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

---------- END .gitignore ----------


---------- app.json ----------
{
  "expo": {
    "name": "MacroTracker",
    "slug": "MacroTracker",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "automatic",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "assetBundlePatterns": ["**/*"],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.yourcompany.macrotracker"
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "package": "com.yourcompany.macrotracker"
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      [
        "expo-document-picker",
        {
          "appleTeamId": "YOUR_TEAM_ID"
        }
      ]
    ]
  }
}

---------- END app.json ----------


---------- App.tsx ----------
// App.tsx
import 'react-native-get-random-values'; // <-- MUST BE FIRST
import React, { useState, useEffect } from 'react';
import AppNavigator from './navigation/AppNavigator';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { ThemeProvider, createTheme } from '@rneui/themed';
import { loadSettings, saveSettings, Settings } from './services/storageService';
import { useColorScheme } from 'react-native';
import { NavigationContainer, DefaultTheme, DarkTheme } from '@react-navigation/native';
import { Colors } from '@rneui/base';

// Module augmentation to extend the Colors interface
declare module '@rneui/themed' {
  export interface Colors {
    text: string; // Add custom color properties here
  }
}

interface MyTheme {
  mode: 'light' | 'dark';
  colors: Colors; // Use the augmented Colors interface
}

const lightTheme: MyTheme = {
  mode: 'light',
  colors: {
    primary: '#007bff',
    background: '#ffffff',
    grey5: '#f2f2f2',
    white: '#ffffff',
    grey4: '#cccccc',
    success: '#28a745',
    black: '#000000',
    text: '#000000', // Set text color for light theme
    secondary: '', // Required by rneui
    warning: '', // Required by rneui
    error: '', // Required by rneui
    disabled: '', // Required by rneui
    divider: '', // Required by rneui
    platform: {
      ios: {
        primary: '',
        secondary: '',
        grey: '',
        searchBg: '',
        success: '',
        error: '',
        warning: '',
      },
      android: {
        primary: '',
        secondary: '',
        grey: '',
        searchBg: '',
        success: '',
        error: '',
        warning: '',
      },
      web: {
        primary: '',
        secondary: '',
        grey: '',
        searchBg: '',
        success: '',
        error: '',
        warning: '',
      },
      default: {
        primary: '',
        secondary: '',
        grey: '',
        searchBg: '',
        success: '',
        error: '',
        warning: '',
      },
    },
    grey0: '',
    grey1: '',
    grey2: '',
    grey3: '',
    greyOutline: '',
    searchBg: ''
  },
};

const darkTheme: MyTheme = {
  mode: 'dark',
  colors: {
    primary: '#007bff',
    background: '#121212',
    grey5: '#2c2c2c',
    white: '#ffffff',
    grey4: '#333333',
    success: '#28a745',
    black: '#000000',
    text: '#ffffff', // Set text color for dark theme
    secondary: '', // Required by rneui
    warning: '', // Required by rneui
    error: '', // Required by rneui
    disabled: '', // Required by rneui
    divider: '', // Required by rneui
    platform: {
      ios: {
        primary: '',
        secondary: '',
        grey: '',
        searchBg: '',
        success: '',
        error: '',
        warning: '',
      },
      android: {
        primary: '',
        secondary: '',
        grey: '',
        searchBg: '',
        success: '',
        error: '',
        warning: '',
      },
      web: {
        primary: '',
        secondary: '',
        grey: '',
        searchBg: '',
        success: '',
        error: '',
        warning: '',
      },
      default: {
        primary: '',
        secondary: '',
        grey: '',
        searchBg: '',
        success: '',
        error: '',
        warning: '',
      },
    },
    grey0: '',
    grey1: '',
    grey2: '',
    grey3: '',
    greyOutline: '',
    searchBg: ''
  },
};

const App = () => {
  const [themeMode, setThemeMode] = useState<'light' | 'dark' | 'system'>('system');
  const [currentTheme, setCurrentTheme] = useState<MyTheme>(lightTheme); // Initialize with light theme
  const colorScheme = useColorScheme();

  // Load settings and set theme
  useEffect(() => {
    const loadInitialSettings = async () => {
      const settings = await loadSettings();
      const initialThemeMode = settings.theme || 'system'; //default to system
      setThemeMode(initialThemeMode);

      updateTheme(initialThemeMode);
    };
    loadInitialSettings();
  }, []);

  const updateTheme = (newThemeMode: 'light' | 'dark' | 'system') => {
    const isDark = newThemeMode === 'system' ? colorScheme === 'dark' : newThemeMode === 'dark';
    setCurrentTheme(isDark ? darkTheme : lightTheme);
  };

  // Update theme when themeMode changes.  This is crucial for live updates.
  useEffect(() => {
    updateTheme(themeMode);
  }, [themeMode, colorScheme]); // colorScheme is needed for "system" theme

  const handleThemeChange = async (newTheme: 'light' | 'dark' | 'system') => {
    setThemeMode(newTheme);
    await saveSettings({ theme: newTheme }); // Save the new theme.
  };

  const navigationDarkTheme = {
    ...DarkTheme,
    colors: {
      ...DarkTheme.colors,
      primary: currentTheme.colors.primary,
      background: currentTheme.colors.background,
      card: currentTheme.colors.grey5,
      text: currentTheme.colors.text,
      border: currentTheme.colors.grey4,
      notification: currentTheme.colors.success,
    },
  };

  const navigationLightTheme = {
    ...DefaultTheme,
    colors: {
      ...DefaultTheme.colors,
      primary: currentTheme.colors.primary,
      background: currentTheme.colors.background,
      card: currentTheme.colors.white,
      text: currentTheme.colors.text,
      border: currentTheme.colors.grey4,
      notification: currentTheme.colors.success,
    },
  };

  return (
    <ThemeProvider theme={createTheme(currentTheme)}>
      <SafeAreaProvider>
        <NavigationContainer
          theme={currentTheme.mode === 'dark' ? navigationDarkTheme : navigationLightTheme}
        >
          <AppNavigator onThemeChange={handleThemeChange} />
        </NavigationContainer>
      </SafeAreaProvider>
    </ThemeProvider>
  );
};

export default App;
---------- END App.tsx ----------


---------- adaptive-icon.png ----------
(Image file - content not included)
---------- END adaptive-icon.png ----------


---------- favicon.png ----------
(Image file - content not included)
---------- END favicon.png ----------


---------- icon.png ----------
(Image file - content not included)
---------- END icon.png ----------


---------- splash-icon.png ----------
(Image file - content not included)
---------- END splash-icon.png ----------


---------- ConfirmationModal.tsx ----------
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Overlay, Button, Input, Text } from '@rneui/themed';

interface ConfirmationModalProps {
    isVisible: boolean;
    onCancel: () => void;
    onConfirm: () => void;
    confirmationText: string;
    setConfirmationText: (text: string) => void;
}
const ConfirmationModal: React.FC<ConfirmationModalProps> = ({ isVisible, onCancel, onConfirm, confirmationText, setConfirmationText }) => {


    return (
        <Overlay isVisible={isVisible} onBackdropPress={onCancel}>
            <View style={styles.container}>
                <Text style={styles.text}>Type "CLEAR DATA" to confirm:</Text>
                <Input
                    placeholder="Enter confirmation text"
                    value={confirmationText}
                    onChangeText={setConfirmationText}
                />
                <View style={styles.buttonContainer}>
                    <Button title="Cancel" onPress={onCancel} type="outline" buttonStyle={styles.button}/>
                    <Button title="Confirm" onPress={onConfirm} color="error" buttonStyle={styles.button}/>
                </View>
            </View>
        </Overlay>
    );
};
const styles = StyleSheet.create({
    container: {
        padding: 20,
        width: 300,
    },
    text: {
        marginBottom: 10
    },
    buttonContainer: {
        flexDirection: 'row',
        justifyContent: 'space-around',
        marginTop: 20,
    },
    button: {
        width: 100
    }
});

export default ConfirmationModal;
---------- END ConfirmationModal.tsx ----------


---------- DailyProgress.tsx ----------
// components/DailyProgress.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, useTheme } from '@rneui/themed';

interface DailyProgressProps {
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
  goals: {
    calories?: number;
    protein?: number;
    carbs?: number;
    fat?: number;
  };
}

const DailyProgress: React.FC<DailyProgressProps> = ({ calories, protein, carbs, fat, goals }) => {
  const { theme } = useTheme();

  const calorieProgress = goals.calories ? Math.min(calories / goals.calories, 1) : 0;
  const proteinProgress = goals.protein ? Math.min(protein / goals.protein, 1) : 0;
  const carbsProgress = goals.carbs ? Math.min(carbs / goals.carbs, 1) : 0;
  const fatProgress = goals.fat ? Math.min(fat / goals.fat, 1) : 0;

  return (
    <View style={styles.container}>
      <View style={styles.macroContainer}>
        <Text style={styles.macroLabel}>Calories: {Math.round(calories)} / {goals.calories || 0}</Text>
        <View style={[styles.progressBar, { width: `${calorieProgress * 100}%`, backgroundColor: theme.colors.primary }]} />
      </View>
      <View style={styles.macroContainer}>
        <Text style={styles.macroLabel}>Protein: {Math.round(protein)}g / {goals.protein || 0}g</Text>
        <View style={[styles.progressBar, { width: `${proteinProgress * 100}%`, backgroundColor: 'green' }]} />
      </View>
      <View style={styles.macroContainer}>
        <Text style={styles.macroLabel}>Carbs: {Math.round(carbs)}g / {goals.carbs || 0}g</Text>
        <View style={[styles.progressBar, { width: `${carbsProgress * 100}%`, backgroundColor: 'orange' }]} />
      </View>
      <View style={styles.macroContainer}>
        <Text style={styles.macroLabel}>Fat: {Math.round(fat)}g / {goals.fat || 0}g</Text>
        <View style={[styles.progressBar, { width: `${fatProgress * 100}%`, backgroundColor: 'blue' }]} />
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: 20,
  },
  macroContainer: {
    marginBottom: 10,
  },
  macroLabel: {
    marginBottom: 5,
  },
  progressBar: {
    height: 10,
    borderRadius: 5,
  },
});

export default DailyProgress;
---------- END DailyProgress.tsx ----------


---------- FoodItem.tsx ----------
// components/FoodItem.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Food } from '../types/food';
import { ListItem, Icon, Text, Button } from '@rneui/themed';

interface FoodItemProps {
  food: Food;
  onEdit: (food: Food) => void;
  onDelete: (foodId: string) => void;
}

const FoodItem: React.FC<FoodItemProps> = ({ food, onEdit, onDelete }) => {
  return (
    <ListItem.Swipeable
      bottomDivider
      leftContent={(reset) => (
          <Button
              title="Edit"
              onPress={() => {onEdit(food); reset()}}
              icon={{ name: 'edit', color: 'white' }}
              buttonStyle={{ minHeight: '100%', backgroundColor: 'orange' }}
          />
      )}
      rightContent={(reset) => (
        <Button
          title="Delete"
          onPress={() => {onDelete(food.id); reset()}}
          icon={{ name: 'delete', color: 'white' }}
          buttonStyle={{ minHeight: '100%', backgroundColor: 'red' }}
        />
      )}
    >
        <ListItem.Content>
            <ListItem.Title>{food.name}</ListItem.Title>
            <ListItem.Subtitle>
                {`Calories: ${food.calories}, Protein: ${food.protein}, Carbs: ${food.carbs}, Fat: ${food.fat}`}
            </ListItem.Subtitle>
        </ListItem.Content>
        <ListItem.Chevron />
    </ListItem.Swipeable>
  );
};

export default FoodItem;
---------- END FoodItem.tsx ----------


---------- index.ts ----------
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);

---------- END index.ts ----------


---------- AppNavigator.tsx ----------
// navigation/AppNavigator.tsx
import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { useTheme, Icon } from '@rneui/themed'; // Import useTheme
import DailyEntryScreen from '../screens/DailyEntryScreen';
import FoodListScreen from '../screens/FoodListScreen';
import SettingsScreen from '../screens/SettingsScreen';


const Tab = createBottomTabNavigator();

interface AppNavigatorProps {
    onThemeChange: (theme: 'light' | 'dark' | 'system') => void;
}

const AppNavigator: React.FC<AppNavigatorProps> = ({ onThemeChange }) => {
    const { theme } = useTheme(); // Use the theme

    return (
        <Tab.Navigator
            screenOptions={({ route }) => ({
                tabBarIcon: ({ focused, color, size }) => {
                    let iconName = '';
                    let type = '';

                    if (route.name === 'Daily Entry') {
                        iconName = 'calendar';
                        type = 'ionicon'
                    } else if (route.name === 'Foods') {
                        iconName = 'fastfood';
                        type = 'material'
                    } else if (route.name === 'Settings') {
                        iconName = 'settings';
                        type = 'ionicon'
                    }

                    return <Icon name={iconName} type={type} size={size} color={color} />;
                },
                tabBarActiveTintColor: theme.colors.primary,
                tabBarInactiveTintColor: 'gray',
                headerShown: false,
                tabBarStyle: {
                    backgroundColor: theme.colors.background
                }

            })}
        >
            <Tab.Screen name="Daily Entry" component={DailyEntryScreen} />
            <Tab.Screen name="Foods" component={FoodListScreen} />
            <Tab.Screen name="Settings" component={() => <SettingsScreen onThemeChange={onThemeChange} />} />
        </Tab.Navigator>
    );
};

export default AppNavigator;
---------- END AppNavigator.tsx ----------


---------- package.json ----------
{
  "name": "macrotracker",
  "license": "0BSD",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@react-native-async-storage/async-storage": "^2.1.2",
    "@react-native-community/datetimepicker": "8.2.0",
    "@react-navigation/bottom-tabs": "^7.3.1",
    "@react-navigation/native": "^7.0.17",
    "@rneui/base": "^4.0.0-rc.7",
    "@rneui/themed": "^4.0.0-rc.8",
    "@types/d3-scale": "^4.0.9",
    "d3-scale": "^4.0.2",
    "date-fns": "^4.1.0",
    "expo": "~52.0.40",
    "expo-document-picker": "^13.0.3",
    "expo-file-system": "^18.0.12",
    "expo-status-bar": "~2.0.1",
    "react": "18.3.1",
    "react-native": "0.76.7",
    "react-native-get-random-values": "^1.11.0",
    "react-native-reanimated": "~3.16.1",
    "react-native-safe-area-context": "^4.14.1",
    "react-native-screens": "^4.9.2",
    "react-native-svg": "^15.11.2",
    "react-native-svg-charts": "^5.4.0",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/react": "~18.3.12",
    "@types/react-native": "^0.73.0",
    "@types/react-native-svg-charts": "^5.0.16",
    "@types/uuid": "^10.0.0",
    "typescript": "^5.3.3",
    "victory": "^37.3.6"
  },
  "private": true
}

---------- END package.json ----------


---------- projectToFile.js ----------
const fs = require('fs');
const path = require('path');

async function generateProjectStructureAndContent(projectRoot, outputFile) {
    const excludedDirs = ['node_modules', '.git', '.expo', 'android', 'ios', '__tests__', 'dist', 'build', '.vscode'];
    const excludedFiles = ['.DS_Store', 'package-lock.json', 'yarn.lock', 'bun.lockb', 'metro.config.js', 'babel.config.js'];
    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.webp', '.ico']; // Add more if needed

    let fileStructureTree = '';  // For the initial tree structure
    let fileContents = '';      // For the file contents

    async function traverseDirectory(dir, indent = '') {
        const entries = await fs.promises.readdir(dir, { withFileTypes: true });

        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);

            if (excludedDirs.includes(entry.name)) {
                continue;
            }

            if (entry.isDirectory()) {
                fileStructureTree += `${indent}${entry.name}/\n`;
                await traverseDirectory(fullPath, indent + '  ');
            } else if (entry.isFile()) {
                if (excludedFiles.includes(entry.name)) {
                    continue;
                }
                fileStructureTree += `${indent}${entry.name}\n`;
                const fileExtension = path.extname(entry.name).toLowerCase();

                if (!imageExtensions.includes(fileExtension)) {
                    fileContents += `\n---------- ${entry.name} ----------\n`;
                    try {
                        const fileContent = await fs.promises.readFile(fullPath, 'utf-8');
                        fileContents += `${fileContent}\n`;
                    } catch (readError) {
                        fileContents += `ERROR READING FILE: ${readError.message}\n`;
                    }
                    fileContents += `---------- END ${entry.name} ----------\n\n`;
                } else {
                     fileContents += `\n---------- ${entry.name} ----------\n`;
                     fileContents += `(Image file - content not included)\n`;
                     fileContents += `---------- END ${entry.name} ----------\n\n`;
                }
            }
        }
    }

    try {
        await traverseDirectory(projectRoot);
        const fullOutput = fileStructureTree + fileContents;

        await fs.promises.writeFile(outputFile, fullOutput);
        console.log(`Project structure and content written to ${outputFile}`);

    } catch (error) {
        console.error('An error occurred:', error);
        process.exit(1);
    }
}

// --- Main execution ---

const projectRoot = process.cwd(); // Use the current working directory
const outputFile = 'project_structure.txt';

// Check if the projectRoot exists.
fs.stat(projectRoot, (err, stats) => {
    if (err) {
        console.error(`Error: Project root directory "${projectRoot}" not found or not accessible.`);
        process.exit(1);
    }

    if (!stats.isDirectory()) {
        console.error(`Error: "${projectRoot}" is not a directory.`);
        process.exit(1);
    }

    generateProjectStructureAndContent(projectRoot, outputFile);
});
---------- END projectToFile.js ----------


---------- DailyEntryScreen.tsx ----------
// screens/DailyEntryScreen.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { View, FlatList, Alert, StyleSheet, ScrollView, Platform } from 'react-native';
import { DailyEntry, DailyEntryItem } from '../types/dailyEntry';
import { Food } from '../types/food';
import { getFoods } from '../services/foodService';
import { saveDailyEntries, loadDailyEntries, loadSettings } from '../services/storageService';
import { formatDate, formatDateReadable, getTodayDateString } from '../utils/dateUtils';
import { isValidNumberInput } from '../utils/validationUtils';
import DailyProgress from '../components/DailyProgress';
import { Button, Input, Text, ListItem, FAB, Overlay, SearchBar, makeStyles, useTheme, Divider } from '@rneui/themed';
import DateTimePicker from '@react-native-community/datetimepicker';
import { addDays, subDays, parseISO } from 'date-fns';
//Correct Import
import { Icon as RNEIcon } from "@rneui/base";


interface DailyGoals {
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
}

const DailyEntryScreen: React.FC = () => {
    const [dailyEntries, setDailyEntries] = useState<DailyEntry[]>([]);
    const [selectedDate, setSelectedDate] = useState<string>(getTodayDateString());
    const [foods, setFoods] = useState<Food[]>([]);
    const [selectedFood, setSelectedFood] = useState<Food | null>(null);
    const [grams, setGrams] = useState('');
    const [isOverlayVisible, setIsOverlayVisible] = useState(false);
    const [search, setSearch] = useState('');
    const [showDatePicker, setShowDatePicker] = useState(false);
    const [dailyGoals, setDailyGoals] = useState<DailyGoals>({  // Add type annotation
        calories: 2000,
        protein: 50,
        carbs: 200,
        fat: 70
    });

    const { theme } = useTheme();
    const styles = useStyles();


    const loadData = useCallback(async () => {
        const loadedFoods = await getFoods();
        const loadedEntries = await loadDailyEntries();
        const loadedSettings = await loadSettings();

        // Merge loaded settings with defaults.  Crucial for fixing the error.
        if (loadedSettings.dailyGoals) {
            setDailyGoals(prevGoals => ({
                ...prevGoals,  // Start with the current/default goals
                ...loadedSettings.dailyGoals  // Override with any values from loadedSettings
            }));
        }

        setFoods(loadedFoods);
        setDailyEntries(loadedEntries);
    }, []);

    useEffect(() => {
        loadData();
    }, [loadData]);

    const getCurrentEntry = (): DailyEntry => {
        return (
            dailyEntries.find((entry) => entry.date === selectedDate) || {
                date: selectedDate,
                items: [],
            }
        );
    };

    const handleAddEntry = async () => {
        if (!selectedFood || !isValidNumberInput(grams)) {
            Alert.alert('Invalid Input', 'Please select a food and enter a valid weight.');
            return;
        }

        const newEntryItem: DailyEntryItem = {
            food: selectedFood,
            grams: parseFloat(grams),
        };

        const currentEntry = getCurrentEntry();
        const updatedItems = [...currentEntry.items, newEntryItem];
        const updatedEntry: DailyEntry = { ...currentEntry, items: updatedItems };

        const updatedEntries = dailyEntries.filter((entry) => entry.date !== selectedDate);
        updatedEntries.push(updatedEntry);

        try {
            await saveDailyEntries(updatedEntries);
            setDailyEntries(updatedEntries);
            setSelectedFood(null);
            setGrams('');
            setIsOverlayVisible(false);
        } catch (error) {
            Alert.alert('Error', 'Failed to add entry.');
        }
    };

    const handleRemoveEntry = async (index: number) => {
        const currentEntry = getCurrentEntry();
        const updatedItems = currentEntry.items.filter((_, i) => i !== index);
        const updatedEntry: DailyEntry = { ...currentEntry, items: updatedItems };

        const updatedEntries = dailyEntries.filter((entry) => entry.date !== selectedDate);
        if (updatedItems.length > 0) { // Only add back if there are items
            updatedEntries.push(updatedEntry);
        }

        try {
            await saveDailyEntries(updatedEntries);
            setDailyEntries(updatedEntries);
        } catch (error) {
            Alert.alert('Error', 'Failed to remove entry.');
        }
    };

    const toggleOverlay = () => {
        setIsOverlayVisible(!isOverlayVisible);
    };

    const updateSearch = (search: string) => {
        setSearch(search);
    };

    const filteredFoods = foods.filter((food) => {
        return food.name.toLowerCase().includes(search.toLowerCase());
    });

    const handleDateChange = (event: any, selectedDateVal?: Date) => {

        const currentDate = selectedDateVal || new Date();

        setShowDatePicker(false);

        if (event.type === "set") {
            setSelectedDate(formatDate(currentDate));
        }
    };
    const handlePreviousDay = () => {
        setSelectedDate(formatDate(subDays(parseISO(selectedDate), 1)));
    };

    const handleNextDay = () => {
        setSelectedDate(formatDate(addDays(parseISO(selectedDate), 1)));
    };

    const calculateTotals = () => {
        const currentEntry = getCurrentEntry();
        let totalCalories = 0;
        let totalProtein = 0;
        let totalCarbs = 0;
        let totalFat = 0;

        currentEntry.items.forEach((item) => {
            totalCalories += (item.food.calories / 100) * item.grams;
            totalProtein += (item.food.protein / 100) * item.grams;
            totalCarbs += (item.food.carbs / 100) * item.grams;
            totalFat += (item.food.fat / 100) * item.grams;
        });

        return { totalCalories, totalProtein, totalCarbs, totalFat };
    };
    const { totalCalories, totalProtein, totalCarbs, totalFat } = calculateTotals();

    return (
        <View style={styles.container}>
            <View style={styles.dateNavigation}>
                <Button type="clear" onPress={handlePreviousDay} icon={<RNEIcon name="arrow-back" type="ionicon" color={theme.colors.text} />} />
                <Text style={styles.dateText} onPress={() => setShowDatePicker(true)}>{formatDateReadable(selectedDate)}</Text>
                <Button type="clear" onPress={handleNextDay} icon={<RNEIcon name="arrow-forward" type="ionicon" color={theme.colors.text} />} />
            </View>
            {showDatePicker && (
                <DateTimePicker
                    value={parseISO(selectedDate)}
                    mode="date"
                    is24Hour={true}
                    display="default"
                    onChange={handleDateChange}
                />
            )}
            <DailyProgress
                calories={totalCalories}
                protein={totalProtein}
                carbs={totalCarbs}
                fat={totalFat}
                goals={dailyGoals}
            />
            <Divider style={{ marginVertical: 10 }} />
            <Text h4 style={{color: theme.colors.text}}>Entries:</Text>
            <FlatList
                data={getCurrentEntry().items}
                keyExtractor={(_, index) => index.toString()}
                renderItem={({ item, index }) => (
                    <ListItem bottomDivider containerStyle={{backgroundColor: theme.colors.background}}>
                        <ListItem.Content>
                            <ListItem.Title style={{color: theme.colors.text}}>{item.food.name}</ListItem.Title>
                            <ListItem.Subtitle style={{color: theme.colors.text}}>{`${item.grams}g`}</ListItem.Subtitle>
                        </ListItem.Content>
                        <Button type="clear" onPress={() => handleRemoveEntry(index)} icon={<RNEIcon name="trash" type="ionicon" color="red" />} />
                    </ListItem>
                )}
            />

            <FAB
                icon={<RNEIcon name="add" color="white" />}
                color={theme.colors.primary}
                onPress={toggleOverlay}
                placement="right"
                title="Add" // Add button text to pass accessibility test
            />


            <Overlay isVisible={isOverlayVisible} onBackdropPress={toggleOverlay} fullScreen={false} overlayStyle={{backgroundColor: theme.colors.background}}>
                <View style={{ flex: 1, padding: 10 }}>
                    <Text h4 style={{ marginBottom: 10, color: theme.colors.text }}>Add Entry</Text>
                    <SearchBar
                        placeholder="Search Foods..."
                        onChangeText={updateSearch}
                        value={search}
                        platform={Platform.OS === 'ios' ? 'ios' : 'android'} // Use Platform.OS
                        containerStyle={{backgroundColor: theme.colors.background}}
                        inputContainerStyle={{backgroundColor: theme.colors.grey5}}
                    />
                    <FlatList
                        data={filteredFoods}
                        keyExtractor={(item) => item.id}
                        renderItem={({ item }) => (
                            <ListItem bottomDivider onPress={() => { setSelectedFood(item); setSearch('') }} containerStyle={{backgroundColor: theme.colors.background}}>
                                <ListItem.Content>
                                    <ListItem.Title style={{color: theme.colors.text}}>{item.name}</ListItem.Title>
                                </ListItem.Content>
                            </ListItem>
                        )}
                    />

                    <Input
                        placeholder="Grams"
                        keyboardType="numeric"
                        value={grams}
                        onChangeText={setGrams}
                        style={{color: theme.colors.text}}
                        inputContainerStyle={{borderBottomColor: theme.colors.text}}
                    />
                    <Button title="Add Entry" onPress={handleAddEntry} disabled={!selectedFood} />
                </View>
            </Overlay>
        </View>
    );
};
const useStyles = makeStyles((theme) => ({
    container: {
        flex: 1,
        padding: 10,
        backgroundColor: theme.colors.background,
    },
    dateNavigation: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
        marginBottom: 10,
    },
    dateText: {
        fontSize: 18,
        fontWeight: 'bold',
        color: theme.colors.text
    },
}));

export default DailyEntryScreen;
---------- END DailyEntryScreen.tsx ----------


---------- FoodListScreen.tsx ----------
// screens/FoodListScreen.tsx

import React, { useState, useEffect } from 'react'; // Removed useCallback
import { View, FlatList, StyleSheet, Alert, TextInput, ScrollView, Platform } from 'react-native';
import { createFood, getFoods, updateFood, deleteFood } from '../services/foodService';
import { Food } from '../types/food';
import { isValidNumberInput, isNotEmpty } from '../utils/validationUtils';
import FoodItem from '../components/FoodItem';
import { Button, Input, Text, ListItem, FAB, Overlay, SearchBar, useTheme, makeStyles } from '@rneui/themed';
import { formatDate } from '../utils/dateUtils';

const FoodListScreen: React.FC = () => {
  const [foods, setFoods] = useState<Food[]>([]);
  const [isOverlayVisible, setIsOverlayVisible] = useState(false);
  const [search, setSearch] = useState('');
  const [newFood, setNewFood] = useState<Omit<Food, 'id'>>({
    name: '',
    calories: 0,
    protein: 0,
    carbs: 0,
    fat: 0,
  });
  const [editFood, setEditFood] = useState<Food | null>(null);
  const { theme } = useTheme();
  const styles = useStyles();

  const loadFoodData = async () => { // Removed useCallback
    const loadedFoods = await getFoods();
    setFoods(loadedFoods);
  };

  useEffect(() => {
    loadFoodData();
  }, []); // Removed loadFoodData dependency

  const handleCreateFood = async () => {
    if (!isNotEmpty(newFood.name) || !isValidNumberInput(String(newFood.calories)) || !isValidNumberInput(String(newFood.protein)) || !isValidNumberInput(String(newFood.carbs)) || !isValidNumberInput(String(newFood.fat))) {
      Alert.alert('Invalid Input', 'Please enter valid food data.');
      return;
    }

    try {
      const createdFood = await createFood(newFood);
      setFoods([...foods, createdFood]);
      setNewFood({ name: '', calories: 0, protein: 0, carbs: 0, fat: 0 });
      setIsOverlayVisible(false);
    } catch (error) {
      Alert.alert('Error', 'Failed to create food.');
    }
  };

  const handleUpdateFood = async () => {
    if (!editFood || !isNotEmpty(editFood.name) || !isValidNumberInput(String(editFood.calories)) || !isValidNumberInput(String(editFood.protein)) || !isValidNumberInput(String(editFood.carbs)) || !isValidNumberInput(String(editFood.fat))) {
      Alert.alert('Invalid Input', 'Please enter valid food data.');
      return;
    }

    try {
      const updated = await updateFood(editFood);
      setFoods(foods.map(f => f.id === updated.id ? updated : f));
      setEditFood(null);
      setIsOverlayVisible(false);
    } catch (error) {
      Alert.alert('Error', 'Failed to update food.');
    }
  };

  const handleDeleteFood = async (foodId: string) => {
    try {
      await deleteFood(foodId);
      setFoods(foods.filter((f) => f.id !== foodId));
    } catch (error) {
      Alert.alert('Error', 'Failed to delete food.');
    }
  };

  const toggleOverlay = (food?: Food) => {
    if (food) {
      setEditFood(food);
    } else {
      setNewFood({ name: '', calories: 0, protein: 0, carbs: 0, fat: 0 });
    }

    setIsOverlayVisible(!isOverlayVisible);
  };

  const updateSearch = (search: string) => {
    setSearch(search);
  };

  const filteredFoods = foods.filter((food) => {
    return food.name.toLowerCase().includes(search.toLowerCase());
  });

  return (
    <View style={styles.container}>
      <SearchBar
        placeholder="Search Foods..."
        onChangeText={updateSearch}
        value={search}
        platform={Platform.select({ ios: 'ios', android: 'android', default: 'default' })} // Use Platform.select
        containerStyle={{backgroundColor: theme.colors.background}}
        inputContainerStyle={{backgroundColor: theme.colors.grey5}}
      />
      <FlatList
        data={filteredFoods}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <FoodItem food={item} onEdit={toggleOverlay} onDelete={handleDeleteFood} />
        )}
      />

      <FAB
        icon={{ name: 'add', color: 'white' }}
        color={theme.colors.primary}
        onPress={() => toggleOverlay()}
        placement="right"
        title='Add'
      />

      <Overlay isVisible={isOverlayVisible} onBackdropPress={() => toggleOverlay()} overlayStyle={{backgroundColor: theme.colors.background}}>
        <ScrollView>
          <Text h4 style={{ marginBottom: 10, color: theme.colors.text }}>{editFood ? 'Edit Food' : 'Add New Food'}</Text>
          <Input
            placeholder="Food Name"
            value={editFood ? editFood.name : newFood.name}
            onChangeText={(text) => editFood ? setEditFood({ ...editFood, name: text }) : setNewFood({ ...newFood, name: text })}
            style={{color: theme.colors.text}}
            inputContainerStyle={{borderBottomColor: theme.colors.text}}
          />
          <Input
            placeholder="Calories (per 100g)"
            keyboardType="numeric"
            value={editFood ? String(editFood.calories) : String(newFood.calories)}
            onChangeText={(text) => editFood ? setEditFood({ ...editFood, calories: parseFloat(text) || 0 }) : setNewFood({ ...newFood, calories: parseFloat(text) || 0 })}
            style={{color: theme.colors.text}}
            inputContainerStyle={{borderBottomColor: theme.colors.text}}
          />
          <Input
            placeholder="Protein (per 100g)"
            keyboardType="numeric"
            value={editFood ? String(editFood.protein) : String(newFood.protein)}
            onChangeText={(text) => editFood ? setEditFood({ ...editFood, protein: parseFloat(text) || 0 }) : setNewFood({ ...newFood, protein: parseFloat(text) || 0 })}
            style={{color: theme.colors.text}}
            inputContainerStyle={{borderBottomColor: theme.colors.text}}
          />
          <Input
            placeholder="Carbs (per 100g)"
            keyboardType="numeric"
            value={editFood ? String(editFood.carbs) : String(newFood.carbs)}
            onChangeText={(text) => editFood ? setEditFood({ ...editFood, carbs: parseFloat(text) || 0 }) : setNewFood({ ...newFood, carbs: parseFloat(text) || 0 })}
            style={{color: theme.colors.text}}
            inputContainerStyle={{borderBottomColor: theme.colors.text}}

          />
          <Input
            placeholder="Fat (per 100g)"
            keyboardType="numeric"
            value={editFood ? String(editFood.fat) : String(newFood.fat)}
            onChangeText={(text) => editFood ? setEditFood({ ...editFood, fat: parseFloat(text) || 0 }) : setNewFood({ ...newFood, fat: parseFloat(text) || 0 })}
            style={{color: theme.colors.text}}
            inputContainerStyle={{borderBottomColor: theme.colors.text}}
          />
          <Button title={editFood ? "Update Food" : "Add Food"} onPress={editFood ? handleUpdateFood : handleCreateFood} />
        </ScrollView>
      </Overlay>
    </View>
  );
};
const useStyles = makeStyles((theme) => ({
  container: {
    flex: 1,
    backgroundColor: theme.colors.background,
  }
}));
export default FoodListScreen;
---------- END FoodListScreen.tsx ----------


---------- SettingsScreen.tsx ----------
// screens/SettingsScreen.tsx
import React, { useState, useEffect, useCallback } from "react";
import { View, Alert, ScrollView } from "react-native";
import {
  saveSettings,
  loadSettings,
  Settings,
  clearAllData,
  loadDailyEntries,
} from "../services/storageService";
import {
  Button,
  ListItem,
  Text,
  Switch,
  Input,
  makeStyles,
  useTheme,
} from "@rneui/themed";
import * as DocumentPicker from "expo-document-picker";
import * as FileSystem from "expo-file-system";
import { formatDate } from "../utils/dateUtils";
import ConfirmationModal from "../components/ConfirmationModal";
import { DailyEntry } from "../types/dailyEntry";
import { LineChart, Grid, YAxis, XAxis } from "react-native-svg-charts";
import { scaleTime } from "d3-scale";
import { parseISO } from "date-fns";

const macros = ["calories", "protein", "carbs", "fat"] as const;
type MacroType = (typeof macros)[number];

interface MacroData {
  x: number; // Change: x is now a number (timestamp)
  y: number;
}

interface Statistics {
  calories: MacroData[];
  protein: MacroData[];
  carbs: MacroData[];
  fat: MacroData[];
}

interface SettingsScreenProps {
  onThemeChange: (theme: 'light' | 'dark' | 'system') => void;
}

const SettingsScreen: React.FC<SettingsScreenProps> = ({ onThemeChange }) => {
  const [settings, setSettings] = useState<Settings>({
    theme: "system",
    dailyGoals: {
      calories: 2000, // Provide default values
      protein: 50,
      carbs: 200,
      fat: 70,
    },
  });
  const [isConfirmationVisible, setIsConfirmationVisible] = useState(false);
  const [confirmationText, setConfirmationText] = useState("");
  const [statistics, setStatistics] = useState<Statistics>({
    calories: [],
    protein: [],
    carbs: [],
    fat: [],
  });

  const { theme } = useTheme();
  const styles = useStyles();

  const loadInitialSettings = useCallback(async () => {
    const loadedSettings = await loadSettings();
    // Ensure dailyGoals is initialized, even if loadedSettings is null/undefined
    setSettings(prevSettings => ({
      ...prevSettings, // Keep existing settings (like theme)
      ...loadedSettings, // Overwrite with loaded settings
      dailyGoals: {
        // Ensure dailyGoals exists and merge defaults
        ...prevSettings.dailyGoals, // Start with default/previous
        ...(loadedSettings?.dailyGoals || {}), // Overlay with loaded, if exist
      },
    }));
  }, []);

  useEffect(() => {
    loadInitialSettings();
  }, [loadInitialSettings]);

  //This is now handled by the parent component App.tsx
  // const handleThemeChange = async (newTheme: "light" | "dark" | "system") => {
  //   const updatedSettings: Settings = { ...settings, theme: newTheme }; //Type assertion
  //   setSettings(updatedSettings);
  //   await saveSettings(updatedSettings);
  // };

  const handleGoalChange = async (goalType: MacroType, value: string) => {
    const numericValue = parseFloat(value) || 0;
    const updatedGoals = { ...settings.dailyGoals, [goalType]: numericValue };

    // Use functional update to correctly merge with previous state
    setSettings(prevSettings => {
      const updatedSettings: Settings = { ...prevSettings, dailyGoals: updatedGoals };
      saveSettings(updatedSettings); // Save on every change
      return updatedSettings;
    });
  };

  const handleExportData = async () => {
    try {
      const dailyEntries = await loadDailyEntries();
      const csvData = [
        ["Date", "Food Name", "Grams", "Calories", "Protein", "Carbs", "Fat"],
        ...dailyEntries.flatMap((entry) =>
          entry.items.map((item) => [
            entry.date,
            item.food.name,
            item.grams,
            item.food.calories,
            item.food.protein,
            item.food.carbs,
            item.food.fat,
          ]),
        ),
      ];
      const csvString = csvData.map((row) => row.join(",")).join("\n");
      const fileUri =
        FileSystem.documentDirectory +
        `macro_data_${formatDate(new Date())}.csv`;
      await FileSystem.writeAsStringAsync(fileUri, csvString, {
        encoding: FileSystem.EncodingType.UTF8,
      });
      Alert.alert("Export Successful", `Data exported to ${fileUri}`);
    } catch (error) {
      console.error(error);
      Alert.alert("Export Failed", "An error occurred while exporting data.");
    }
  };

  const handleImportData = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: "*/*",
        copyToCacheDirectory: true,
      });
      if (!result.canceled && result.assets?.length > 0) {
        const fileUri = result.assets[0].uri;
        const fileContent = await FileSystem.readAsStringAsync(fileUri, {
          encoding: FileSystem.EncodingType.UTF8,
        });
        console.log("Imported File Content:", fileContent);

        const lines = fileContent.trim().split("\n");
        const headers = lines[0].split(",");
        const data = lines.slice(1).map((line) => {
          const values = line.split(",");
          return headers.reduce((obj: any, header, index) => {
            obj[header.trim()] = values[index]?.trim();
            return obj;
          }, {});
        });

        console.log("Parsed Data:", data);
        Alert.alert(
          "Import Successful",
          "Data imported (parsing complete). Storage implementation pending."
        );
      } else {
        Alert.alert("Import Failed", "No file selected");
      }
    } catch (error: any) {
      console.error("Import Error:", error);
      Alert.alert(
        "Import Failed",
        error.message || "An unknown error occurred."
      );
    }
  };

  const handleClearData = () => setIsConfirmationVisible(true);

  const confirmClearData = async () => {
    if (confirmationText === "CLEAR DATA") {
      try {
        await clearAllData();
        Alert.alert("Data Cleared", "All data has been cleared.");
        setConfirmationText("");
        setIsConfirmationVisible(false);
        await loadInitialSettings(); // Reload initial settings after clearing
      } catch (error) {
        Alert.alert("Error", "Failed to clear data.");
      }
    } else {
      Alert.alert("Error", "Incorrect confirmation text.");
    }
  };

  const getStatisticsData = (dailyEntries: DailyEntry[], macro: MacroType) => {
    return dailyEntries
      .map((entry) => ({
        x: parseISO(entry.date).getTime(), // Get timestamp
        y: entry.items.reduce(
          (total, item) => total + (item.food[macro] / 100) * item.grams,
          0
        ),
      }))
      .sort((a, b) => a.x - b.x); // Sort by timestamp
  };

  useEffect(() => {
    const loadStatistics = async () => {
      const loadedEntries = await loadDailyEntries();
      setStatistics({
        calories: getStatisticsData(loadedEntries, "calories"),
        protein: getStatisticsData(loadedEntries, "protein"),
        carbs: getStatisticsData(loadedEntries, "carbs"),
        fat: getStatisticsData(loadedEntries, "fat"),
      });
    };
    loadStatistics();
  }, []);

  return (
    <ScrollView style={styles.container}>
      <Text h3 style={{ ...styles.sectionTitle, color: theme.colors.text }}>
        General
      </Text>
      <ListItem bottomDivider containerStyle={{backgroundColor: theme.colors.background}}>
        <ListItem.Content>
          <ListItem.Title style={{ color: theme.colors.text }}>Dark Mode</ListItem.Title>
        </ListItem.Content>
        <Switch
          value={settings.theme === "dark"}
          onValueChange={() =>
            onThemeChange(settings.theme === "dark" ? "light" : "dark")
          }
        />
      </ListItem>

      <Text h3 style={{ ...styles.sectionTitle, color: theme.colors.text }}>
        Daily Goals
      </Text>
      {macros.map((macro) => (
        <Input
          key={macro}
          label={`${macro.charAt(0).toUpperCase() + macro.slice(1)} Goal`}
          keyboardType="numeric"
          value={settings.dailyGoals?.[macro]?.toString() || ""}
          onChangeText={(value) => handleGoalChange(macro, value)}
          style={{color: theme.colors.text}}
          inputContainerStyle={{borderBottomColor: theme.colors.text}}
          labelStyle={{color: theme.colors.text}}
        />
      ))}

      <Text h3 style={{ ...styles.sectionTitle, color: theme.colors.text }}>
        Statistics
      </Text>
      {macros.map((macro) => {
        const data = statistics[macro];
        const dates = data.map((item) => item.x);
        const values = data.map((item) => item.y);

        // Calculate domain for x-axis (dates), converting timestamps to numbers.
        const xDomain = [
          Number(Math.min(...dates)),
          Number(Math.max(...dates)),
        ];

        return (
          <View key={macro} style={styles.chartContainer}>
            <Text h4 style={{ textAlign: "center", color: theme.colors.text }}>
              {macro.charAt(0).toUpperCase() + macro.slice(1)}
            </Text>
            <View style={{ height: 200, flexDirection: "row" }}>
              <YAxis
                data={values}
                contentInset={{ top: 20, bottom: 20 }}
                svg={{
                  fill: theme.colors.text,
                  fontSize: 10,
                }}
                numberOfTicks={10}
                formatLabel={(value: number) => `${value}`}
              />
              <View style={{ flex: 1, marginLeft: 10 }}>
                <LineChart
                  style={{ flex: 1 }}
                  data={values}
                  gridMin={Math.min(...values)}
                  gridMax={Math.max(...values)}
                  contentInset={{ top: 20, bottom: 20 }}
                  svg={{ stroke: theme.colors.primary }}
                >
                  <Grid />
                </LineChart>
                <XAxis
                  style={{ marginHorizontal: -10, height: 30 }}
                  data={data}
                  scale={scaleTime}
                  formatLabel={(value: number, index: number) =>
                    formatDate(new Date(value))
                  } // Create Date from timestamp
                  contentInset={{ left: 10, right: 10 }}
                  svg={{
                    fontSize: 10,
                    fill: theme.colors.text,
                    rotation: -45,
                    originY: 30,
                    y: 5,
                  }} // Rotate labels
                />
              </View>
            </View>
          </View>
        );
      })}

      <Text h3 style={{ ...styles.sectionTitle, color: theme.colors.text }}>
        Data Management
      </Text>
      <Button
        title="Export Data"
        onPress={handleExportData}
        buttonStyle={{ marginBottom: 10, backgroundColor: theme.colors.primary }}
      />
      <Button
        title="Import Data"
        onPress={handleImportData}
        buttonStyle={{ marginBottom: 10, backgroundColor: theme.colors.primary }}
      />
      <Button title="Clear All Data" onPress={handleClearData} color="error" />

      <ConfirmationModal
        isVisible={isConfirmationVisible}
        onCancel={() => setIsConfirmationVisible(false)}
        onConfirm={confirmClearData}
        confirmationText={confirmationText}
        setConfirmationText={setConfirmationText}
      />
    </ScrollView>
  );
};

const useStyles = makeStyles((theme) => ({
  container: {
    flex: 1,
    padding: 10,
    backgroundColor: theme.colors.background,
  },
  sectionTitle: {
    marginTop: 20,
    marginBottom: 10,
  },
  chartContainer: {
    marginBottom: 20,
  },
}));

export default SettingsScreen;
---------- END SettingsScreen.tsx ----------


---------- foodService.ts ----------
// services/foodService.ts
import { Food } from '../types/food';
import { saveFoods, loadFoods } from './storageService';
import 'react-native-get-random-values';
import { v4 as uuidv4 } from 'uuid';

export const createFood = async (foodData: Omit<Food, 'id'>): Promise<Food> => {
  const newFood: Food = {
    id: uuidv4(),
    ...foodData,
  };
  const foods = await loadFoods();
  foods.push(newFood);
  await saveFoods(foods);
  return newFood;
};

export const getFoods = async (): Promise<Food[]> => {
  return loadFoods();
};

export const updateFood = async (updatedFood: Food): Promise<Food> => {
  const foods = await loadFoods();
  const index = foods.findIndex((f) => f.id === updatedFood.id);
  if (index === -1) {
    throw new Error('Food not found');
  }
  foods[index] = updatedFood;
  await saveFoods(foods);
  return updatedFood;
};

export const deleteFood = async (foodId: string): Promise<void> => {
  const foods = await loadFoods();
  const filteredFoods = foods.filter((f) => f.id !== foodId);
  await saveFoods(filteredFoods);
};
---------- END foodService.ts ----------


---------- storageService.ts ----------
// services/storageService.ts
import AsyncStorage from '@react-native-async-storage/async-storage';
import { DailyEntry } from '../types/dailyEntry';
import { Food } from '../types/food';

const DAILY_ENTRIES_KEY = 'dailyEntries';
const FOODS_KEY = 'foods';
const SETTINGS_KEY = 'settings';

export const saveDailyEntries = async (entries: DailyEntry[]): Promise<void> => {
  try {
    await AsyncStorage.setItem(DAILY_ENTRIES_KEY, JSON.stringify(entries));
  } catch (error) {
    console.error('Error saving daily entries:', error);
    throw error; // Re-throw to handle upstream
  }
};

export const loadDailyEntries = async (): Promise<DailyEntry[]> => {
  try {
    const entriesJson = await AsyncStorage.getItem(DAILY_ENTRIES_KEY);
    return entriesJson ? JSON.parse(entriesJson) : [];
  } catch (error) {
    console.error('Error loading daily entries:', error);
    return []; // Return empty array on error
  }
};

export const saveFoods = async (foods: Food[]): Promise<void> => {
  try {
    await AsyncStorage.setItem(FOODS_KEY, JSON.stringify(foods));
  } catch (error) {
    console.error('Error saving foods:', error);
    throw error;
  }
};

export const loadFoods = async (): Promise<Food[]> => {
  try {
    const foodsJson = await AsyncStorage.getItem(FOODS_KEY);
    return foodsJson ? JSON.parse(foodsJson) : [];
  } catch (error) {
    console.error('Error loading foods:', error);
    return [];
  }
};

// Settings (example: theme)
export interface Settings {
  theme: 'light' | 'dark' | 'system';
  dailyGoals?: {  // Optional goals
    calories?: number;
    protein?: number;
    carbs?: number;
    fat?: number;
  };
}

export const saveSettings = async (settings: Settings): Promise<void> => {
  try {
    await AsyncStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
  } catch (error) {
    console.error('Error saving settings:', error);
    throw error;
  }
};

export const loadSettings = async (): Promise<Settings> => {
  try {
    const settingsJson = await AsyncStorage.getItem(SETTINGS_KEY);
    return settingsJson ? JSON.parse(settingsJson) : { theme: 'system' }; // Default settings
  } catch (error) {
    console.error('Error loading settings:', error);
    return { theme: 'system' };
  }
};

export const clearAllData = async (): Promise<void> => {
  try {
    await AsyncStorage.clear();
  } catch (error) {
    console.error('Error clearing data:', error);
    throw error;
  }
};
---------- END storageService.ts ----------


---------- tsconfig.json ----------
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true

  }
}
---------- END tsconfig.json ----------


---------- dailyEntry.ts ----------
// types/dailyEntry.ts
import { Food } from "./food";

export interface DailyEntryItem {
  food: Food;
  grams: number;
}

export interface DailyEntry {
  date: string; // YYYY-MM-DD format
  items: DailyEntryItem[];
  goals?: {  // Optional goals
    calories?: number;
    protein?: number;
    carbs?: number;
    fat?: number;
  };
}
---------- END dailyEntry.ts ----------


---------- food.ts ----------
// types/food.ts
export interface Food {
    id: string;
    name: string;
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
  }
---------- END food.ts ----------


---------- dateUtils.ts ----------
// utils/dateUtils.ts
import { format, parseISO } from 'date-fns';

export const formatDate = (date: Date | string): string => {
  if (typeof date === 'string') {
    date = parseISO(date);
  }
  return format(date, 'yyyy-MM-dd');
};

export const formatDateReadable = (date: Date | string): string => {
    if (typeof date === 'string') {
        date = parseISO(date);
    }
    return format(date, 'MMMM dd, yyyy');
}

export const getTodayDateString = (): string => {
  return formatDate(new Date());
};
---------- END dateUtils.ts ----------


---------- validationUtils.ts ----------
// utils/validationUtils.ts

export const isValidNumberInput = (value: string): boolean => {
    return /^[0-9]*(\.[0-9]*)?$/.test(value) && !isNaN(parseFloat(value));
  };
  
  export const isNotEmpty = (value: string): boolean => {
    return value.trim() !== '';
  };
---------- END validationUtils.ts ----------

