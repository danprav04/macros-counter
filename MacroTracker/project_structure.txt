.gitignore
app.json
App.tsx
assets/
  adaptive-icon.png
  favicon.png
  icon.png
  splash.png
eas.json
index.ts
package.json
projectToFile.js
src/
  components/
    AddEntryModal.tsx
    AddFoodModal.tsx
    ConfirmationModal.tsx
    DailyGoalsInput.tsx
    DailyProgress.tsx
    DataManagementButtons.tsx
    FoodItem.tsx
    StatisticsChart.tsx
    ThemeSwitch.tsx
  navigation/
    AppNavigator.tsx
  screens/
    DailyEntryScreen.tsx
    FoodListScreen.tsx
    SettingsScreen.tsx
  services/
    backendService.ts
    clientIDService.ts
    foodService.ts
    storageService.ts
  types/
    dailyEntry.ts
    food.ts
    macros.ts
    openRouterTypes.ts
    settings.ts
  utils/
    dateUtils.ts
    iconUtils.ts
    macros.ts
    units.ts
    validationUtils.ts
tsconfig.json

---------- .gitignore ----------
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

---------- END .gitignore ----------


---------- app.json ----------

{
  "expo": {
    "name": "MacroTracker",
    "slug": "MacroTracker",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "automatic", 
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#000000"
    },
    "androidStatusBar": {
      "backgroundColor": "#000000",
      "translucent": false,
      "barStyle": "light-content"
    },
    "assetBundlePatterns": [
      "**/*"
    ],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.yourcompany.macrotracker",
      "infoPlist": { 
        "UIStatusBarStyle": "UIStatusBarStyleAutomatic" 
      }
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "package": "com.yourcompany.macrotracker",
      "userInterfaceStyle": "automatic", 
      "statusBar": { 
        "backgroundColor": "#00000000",  
        "translucent": true,             
        "barStyle": "auto"
      }
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      [
        "expo-document-picker",
        {
          "appleTeamId": "YOUR_TEAM_ID"
        }
      ]
    ],
    "extra": {
      "eas": {
        "projectId": "25ac2bcf-78a3-4f2c-a635-4fcaae7b93f1"
      }
    }
  }
}
---------- END app.json ----------


---------- App.tsx ----------
// App.tsx
// App.tsx (Initialize Client ID)
import "react-native-get-random-values"; // MUST BE FIRST
import Toast from "react-native-toast-message";
import React, { useState, useEffect } from "react";
import AppNavigator from "./src/navigation/AppNavigator";
import { SafeAreaProvider, SafeAreaView } from "react-native-safe-area-context";
import { ThemeProvider, createTheme } from "@rneui/themed";
import { loadSettings, saveSettings } from "./src/services/storageService";
import {
  useColorScheme,
  AppState,
  AppStateStatus,
  Platform,
} from "react-native";
import {
  NavigationContainer,
  DefaultTheme,
  DarkTheme,
} from "@react-navigation/native";
import { Colors } from "@rneui/base";
import { Settings } from "./src/types/settings";
import { LogBox, View, Text } from "react-native"; //Import view for debug
import { StatusBar } from "expo-status-bar"; // changed import
import { getClientId } from "./src/services/clientIDService"; // Import client ID service

LogBox.ignoreLogs(["Function components cannot be given refs"]);

declare module "@rneui/themed" {
  export interface Colors {
    text: string;
    card: string; // Added for better card styling
    successLight: string; // Lighter success color
  }
}

interface MyTheme {
  mode: "light" | "dark";
  colors: Colors;
}

const lightTheme: MyTheme = {
  mode: "light",
  colors: {
    primary: "#2e86de",
    secondary: "#6c757d",
    background: "#f8f9fa",
    grey5: "#e9ecef",
    white: "#ffffff",
    grey4: "#ced4da",
    success: "#28a745",
    successLight: "#d4edda",
    black: "#000000",
    text: "#212529",
    card: "#ffffff",
    error: "#dc3545",
    warning: "#ffc107",
    disabled: "#6c757d",
    divider: "#ced4da",
    platform: {
      ios: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      android: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      web: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      default: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
    },
    grey0: "#f8f9fa",
    grey1: "#e9ecef",
    grey2: "#dee2e6",
    grey3: "#ced4da",
    greyOutline: "#adb5bd",
    searchBg: "#ffffff",
  },
};

const darkTheme: MyTheme = {
  mode: "dark",
  colors: {
    primary: "#2e86de",
    secondary: "#adb5bd",
    background: "#121212",
    grey5: "#2c2c2c",
    white: "#ffffff",
    grey4: "#343a40",
    success: "#28a745",
    successLight: "#1f5139",
    black: "#000000",
    text: "#f8f9fa",
    card: "#1e1e1e",
    error: "#dc3545",
    warning: "#ffc107",
    disabled: "#6c757d",
    divider: "#343a40",
    platform: {
      ios: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      android: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      web: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      default: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
    },
    grey0: "#212529",
    grey1: "#2c2c2c",
    grey2: "#343a40",
    grey3: "#495057",
    greyOutline: "#6c757d",
    searchBg: "#1e1e1e",
  },
};

const App = () => {
  const [themeMode, setThemeMode] = useState<"light" | "dark" | "system">(
    "system"
  );
  const [loadedSettings, setLoadedSettings] = useState<Settings | null>(null);
  const colorScheme = useColorScheme();
  const [appState, setAppState] = useState(AppState.currentState);
  const [themeCheck, setThemeCheck] = useState(0);
  const [isClientIdReady, setIsClientIdReady] = useState(false); // Track client ID readiness

  // Initialize Client ID and Load initial settings
  useEffect(() => {
    const initializeApp = async () => {
      try {
          // Ensure Client ID is ready before loading other data
          await getClientId(); // This generates/retrieves and caches the ID
          setIsClientIdReady(true);
          console.log('Client ID is ready.');

          // Load settings after client ID is confirmed
          const settings = await loadSettings();
          setThemeMode(settings.theme);
          setLoadedSettings(settings);
          console.log('Settings loaded.');
      } catch (error) {
            console.error("Initialization Error:", error);
            // Handle error, maybe show an error screen
      }
    };
    initializeApp();
  }, []); // Run only once on mount

  // AppState Listener
  useEffect(() => {
    const handleAppStateChange = (nextAppState: AppStateStatus) => {
      setAppState(nextAppState);
    };

    const subscription = AppState.addEventListener(
      "change",
      handleAppStateChange
    );

    return () => {
      subscription.remove();
    };
  }, []); // No appState dependency needed here

  const updateTheme = (newThemeMode: "light" | "dark" | "system") => {
    const isDark =
      newThemeMode === "system"
        ? colorScheme === "dark"
        : newThemeMode === "dark";
    return isDark ? darkTheme : lightTheme;
  };

  const handleThemeChange = async (newTheme: "light" | "dark" | "system") => {
    setThemeMode(newTheme);
    if (loadedSettings) {
      const updatedSettings: Settings = {
        ...loadedSettings,
        theme: newTheme,
      };
      await saveSettings(updatedSettings);
      setLoadedSettings(updatedSettings);
    }
    setThemeCheck((t) => t + 1);
  };

  const currentTheme = updateTheme(themeMode);

  const navigationTheme = {
    dark: {
      ...DarkTheme,
      colors: {
        ...DarkTheme.colors,
        primary: currentTheme.colors.primary,
        background: currentTheme.colors.background,
        card: currentTheme.colors.card,
        text: currentTheme.colors.text,
        border: currentTheme.colors.divider,
        notification: currentTheme.colors.successLight,
      },
    },
    light: {
      ...DefaultTheme,
      colors: {
        ...DefaultTheme.colors,
        primary: currentTheme.colors.primary,
        background: currentTheme.colors.background,
        card: currentTheme.colors.card,
        text: currentTheme.colors.text,
        border: currentTheme.colors.divider,
        notification: currentTheme.colors.success,
      },
    },
  };

  const statusBarTheme = themeMode === "system" ? colorScheme : themeMode;
  const backgroundColor = currentTheme.colors.background;

  // Show loading or placeholder until client ID is ready
  if (!isClientIdReady) {
      return (
          <SafeAreaView style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: backgroundColor }}>
              <Text style={{ color: currentTheme.colors.text }}>Initializing...</Text>
              {/* Optionally add an ActivityIndicator */}
          </SafeAreaView>
      );
  }

  return (
    <ThemeProvider theme={createTheme(currentTheme)}>
      <SafeAreaView style={{ flex: 1, backgroundColor: backgroundColor }}>
        <StatusBar
          style={statusBarTheme === "dark" ? "light" : "dark"}
          backgroundColor={backgroundColor}
          translucent={false}
        />
        <NavigationContainer
          theme={
            currentTheme.mode === "dark"
              ? navigationTheme.dark
              : navigationTheme.light
          }
        >
          <AppNavigator onThemeChange={handleThemeChange} />
        </NavigationContainer>
        <Toast />
      </SafeAreaView>
    </ThemeProvider>
  );
};

export default App;
---------- END App.tsx ----------


---------- adaptive-icon.png ----------
(Image file - content not included)
---------- END adaptive-icon.png ----------


---------- favicon.png ----------
(Image file - content not included)
---------- END favicon.png ----------


---------- icon.png ----------
(Image file - content not included)
---------- END icon.png ----------


---------- splash.png ----------
(Image file - content not included)
---------- END splash.png ----------


---------- eas.json ----------
{
  "cli": {
    "version": ">= 13.4.1",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal"
    },
    "preview": {
      "android": {
        "buildType": "apk"
      }
    },
    "production": {
      "autoIncrement": true
    }
  },
  "submit": {
    "production": {}
  }
}

---------- END eas.json ----------


---------- index.ts ----------
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);

---------- END index.ts ----------


---------- package.json ----------
{
  "name": "macrotracker",
  "license": "0BSD",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@react-native-async-storage/async-storage": "^2.1.2",
    "@react-native-community/datetimepicker": "8.2.0",
    "@react-navigation/bottom-tabs": "^7.3.1",
    "@react-navigation/native": "^7.0.17",
    "@rneui/base": "^4.0.0-rc.7",
    "@rneui/themed": "^4.0.0-rc.8",
    "@types/d3-scale": "^4.0.9",
    "d3-scale": "^4.0.2",
    "date-fns": "^4.1.0",
    "expo": "~52.0.40",
    "expo-document-picker": "^13.0.3",
    "expo-file-system": "^18.0.12",
    "expo-image-picker": "^16.0.6",
    "expo-sharing": "~13.0.1",
    "expo-status-bar": "~2.0.1",
    "react": "18.3.1",
    "react-native": "0.76.7",
    "react-native-config": "^1.5.5",
    "react-native-get-random-values": "^1.11.0",
    "react-native-mime-types": "^2.5.0",
    "react-native-reanimated": "~3.16.1",
    "react-native-safe-area-context": "^4.14.1",
    "react-native-screens": "^4.9.2",
    "react-native-svg": "^15.11.2",
    "react-native-toast-message": "^2.2.1",
    "react-native-uuid": "^2.0.3",
    "react-native-webview": "^13.13.4",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/react": "~18.3.12",
    "@types/react-native": "^0.73.0",
    "@types/react-native-svg-charts": "^5.0.16",
    "@types/uuid": "^10.0.0",
    "typescript": "^5.3.3",
    "victory": "^37.3.6"
  },
  "private": true
}

---------- END package.json ----------


---------- projectToFile.js ----------
const fs = require('fs');
const path = require('path');

async function generateProjectStructureAndContent(projectRoot, outputFile) {
    const excludedDirs = ['node_modules', '.git', '.expo', 'android', 'ios', '__tests__', 'dist', 'build', '.vscode'];
    const excludedFiles = ['.DS_Store', 'package-lock.json', 'yarn.lock', 'bun.lockb', 'metro.config.js', 'babel.config.js'];
    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.webp', '.ico']; // Add more if needed

    let fileStructureTree = '';  // For the initial tree structure
    let fileContents = '';      // For the file contents

    async function traverseDirectory(dir, indent = '') {
        const entries = await fs.promises.readdir(dir, { withFileTypes: true });

        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);

            if (excludedDirs.includes(entry.name)) {
                continue;
            }

            if (entry.isDirectory()) {
                fileStructureTree += `${indent}${entry.name}/\n`;
                await traverseDirectory(fullPath, indent + '  ');
            } else if (entry.isFile()) {
                if (excludedFiles.includes(entry.name)) {
                    continue;
                }
                fileStructureTree += `${indent}${entry.name}\n`;
                const fileExtension = path.extname(entry.name).toLowerCase();

                if (!imageExtensions.includes(fileExtension)) {
                    fileContents += `\n---------- ${entry.name} ----------\n`;
                    try {
                        const fileContent = await fs.promises.readFile(fullPath, 'utf-8');
                        fileContents += `${fileContent}\n`;
                    } catch (readError) {
                        fileContents += `ERROR READING FILE: ${readError.message}\n`;
                    }
                    fileContents += `---------- END ${entry.name} ----------\n\n`;
                } else {
                     fileContents += `\n---------- ${entry.name} ----------\n`;
                     fileContents += `(Image file - content not included)\n`;
                     fileContents += `---------- END ${entry.name} ----------\n\n`;
                }
            }
        }
    }

    try {
        await traverseDirectory(projectRoot);
        const fullOutput = fileStructureTree + fileContents;

        await fs.promises.writeFile(outputFile, fullOutput);
        console.log(`Project structure and content written to ${outputFile}`);

    } catch (error) {
        console.error('An error occurred:', error);
        process.exit(1);
    }
}

// --- Main execution ---

const projectRoot = process.cwd(); // Use the current working directory
const outputFile = 'project_structure.txt';

// Check if the projectRoot exists.
fs.stat(projectRoot, (err, stats) => {
    if (err) {
        console.error(`Error: Project root directory "${projectRoot}" not found or not accessible.`);
        process.exit(1);
    }

    if (!stats.isDirectory()) {
        console.error(`Error: "${projectRoot}" is not a directory.`);
        process.exit(1);
    }

    generateProjectStructureAndContent(projectRoot, outputFile);
});
---------- END projectToFile.js ----------


---------- AddEntryModal.tsx ----------
// src/components/AddEntryModal.tsx
// ---------- AddEntryModal.tsx (Integrate Backend, Handle Errors) ----------
import React, {
  useEffect,
  useState,
  useMemo,
  useCallback,
  useRef,
} from "react";
import {
  View,
  FlatList,
  KeyboardAvoidingView,
  Platform,
  TouchableOpacity,
  ScrollView,
  Dimensions,
  Image,
  StyleSheet,
  ActivityIndicator,
  Alert,
  Pressable,
} from "react-native";
import {
  Button,
  Input,
  Text,
  ListItem,
  Overlay,
  SearchBar,
  makeStyles,
  useTheme,
  Icon,
  ButtonGroup,
  CheckBox,
} from "@rneui/themed";
import { Food } from "../types/food";
import { isValidNumberInput } from "../utils/validationUtils";
import { loadRecentFoods, saveRecentFoods } from "../services/storageService";
import { getFoodIconUrl } from "../utils/iconUtils"; // Frontend icon cache remains
import { getGramsFromNaturalLanguage } from "../utils/units"; // Uses backend now
import Toast from "react-native-toast-message";
import * as ImagePicker from "expo-image-picker";
// Import types and backend function for multi-image add
import { EstimatedFoodItem, getMultipleFoodsFromImage, getBase64FromUri } from "../utils/macros";
import { v4 as uuidv4 } from "uuid";
import { BackendError } from "../services/backendService"; // Import custom error type


interface AddEntryModalProps {
  isVisible: boolean;
  toggleOverlay: () => void;
  selectedFood: Food | null;
  grams: string;
  setGrams: (grams: string) => void;
  handleAddEntry: () => void;
  handleAddMultipleEntries: (entries: { food: Food; grams: number }[]) => void;
  foods: Food[];
  handleSelectFood: (item: Food | null) => void;
  updateSearch: (search: string) => void;
  search: string;
  isEditMode: boolean;
  initialGrams?: string;
}

const KEYBOARD_VERTICAL_OFFSET = Platform.OS === "ios" ? 80 : 0;

type UnitMode = "grams" | "auto";
type ModalMode = "normal" | "quickAddSelect";

const AddEntryModal: React.FC<AddEntryModalProps> = ({
  isVisible,
  toggleOverlay,
  selectedFood,
  grams,
  setGrams,
  handleAddEntry,
  handleAddMultipleEntries,
  foods,
  handleSelectFood,
  updateSearch,
  search,
  isEditMode,
  initialGrams,
}) => {
  const { theme } = useTheme();
  const styles = useStyles();
  const [recentFoods, setRecentFoods] = useState<Food[]>([]);
  const MAX_RECENT_FOODS = 5;
  const [foodIcons, setFoodIcons] = useState<{
    [foodName: string]: string | null;
  }>({});

  const [unitMode, setUnitMode] = useState<UnitMode>("grams");
  const [autoInput, setAutoInput] = useState("");
  const [isAiLoading, setIsAiLoading] = useState(false); // For natural language grams

  // --- Quick Add State ---
  const [modalMode, setModalMode] = useState<ModalMode>("normal");
  const [quickAddLoading, setQuickAddLoading] = useState(false); // For image analysis
  const [quickAddItems, setQuickAddItems] = useState<EstimatedFoodItem[]>([]);
  const [selectedQuickAddIndices, setSelectedQuickAddIndices] = useState<
    Set<number>
  >(new Set());
  const [editingQuickAddItemIndex, setEditingQuickAddItemIndex] = useState<
    number | null
  >(null);
  const [editedFoodName, setEditedFoodName] = useState<string>("");
  const [editedGrams, setEditedGrams] = useState<string>("");
  // --- End Quick Add State ---

  const screenWidth = Dimensions.get("window").width;
  const isInitiallyVisible = useRef(false);

  const filteredFoods = useMemo(() => {
    if (!search) return [];
    return foods.filter((food) =>
      food.name.toLowerCase().includes(search.toLowerCase())
    );
  }, [foods, search]);

  // Effect to handle state resets on visibility change and mode switches
  useEffect(() => {
    if (!isVisible) {
      handleSelectFood(null);
      setGrams("");
      updateSearch("");
      setUnitMode("grams");
      setAutoInput("");
      setIsAiLoading(false);
      setModalMode("normal");
      setQuickAddItems([]);
      setSelectedQuickAddIndices(new Set());
      setQuickAddLoading(false);
      setEditingQuickAddItemIndex(null);
      setEditedFoodName("");
      setEditedGrams("");
      isInitiallyVisible.current = false;
    } else {
      if (
        !isInitiallyVisible.current &&
        !quickAddLoading &&
        modalMode !== "quickAddSelect"
      ) {
        setModalMode("normal");
      }
      isInitiallyVisible.current = true;

      if (!isAiLoading && !quickAddLoading) {
        setAutoInput("");
      }

      let targetGrams = grams;
      let targetUnitMode = unitMode;

      if (
        isEditMode &&
        selectedFood &&
        initialGrams &&
        modalMode === "normal"
      ) {
        targetGrams = initialGrams;
        targetUnitMode = "grams";
        if (unitMode === "auto") {
            setAutoInput("");
        }
      } else if (!isEditMode && selectedFood && modalMode === "normal") {
        targetUnitMode = "grams";
      } else if (!selectedFood && modalMode === "normal") {
        targetGrams = "";
        targetUnitMode = "grams";
      }

      if (grams !== targetGrams) {
        setGrams(targetGrams);
      }
      if (unitMode !== targetUnitMode && !isAiLoading && !quickAddLoading) {
        setUnitMode(targetUnitMode);
      }

      if (isEditMode) {
          setModalMode("normal");
          setQuickAddItems([]);
          setSelectedQuickAddIndices(new Set());
          setEditingQuickAddItemIndex(null);
          setEditedFoodName("");
          setEditedGrams("");
      }
    }
  }, [
    isVisible, isEditMode, selectedFood, initialGrams, quickAddLoading, modalMode,
    handleSelectFood, updateSearch, setGrams, unitMode, grams,
  ]);

  // Load recent foods when modal becomes visible in normal mode
  useEffect(() => {
    const loadRecents = async () => {
      const loadedRecentFoods = await loadRecentFoods();
      setRecentFoods(loadedRecentFoods);
    };
    if (isVisible && modalMode === "normal") {
      loadRecents();
    }
  }, [isVisible, modalMode]);

  // Load icons for visible foods (using frontend cache/backend service)
  useEffect(() => {
    const loadIcons = async () => {
      const iconsToLoad: { [foodName: string]: Promise<string | null> } = {};
      const relevantFoods = search ? filteredFoods : recentFoods;
      const uniqueFoodsMap = new Map(
        relevantFoods.map((food) => [food.id ?? food.name, food]) // Use ID if available, fallback name
      );

      let shouldUpdateState = false;
      for (const food of uniqueFoodsMap.values()) {
        if (foodIcons[food.name] === undefined) { // Only initiate fetch if status is unknown
            // No need to await here, let it run in background
            getFoodIconUrl(food.name)
              .then(iconUrl => {
                   // Update state specifically for this food when promise resolves
                   setFoodIcons(prevIcons => ({ ...prevIcons, [food.name]: iconUrl }));
              })
              .catch(error => {
                   console.warn(`Icon fetch failed for ${food.name}:`, error);
                   // Still update state to mark as failed (null)
                   setFoodIcons(prevIcons => ({ ...prevIcons, [food.name]: null }));
              });
              // Mark that an update *will* happen, even if async
              shouldUpdateState = true;
        }
      }
       // No need to call setFoodIcons here, it's handled in the .then/.catch callbacks
       // if (shouldUpdateState) {
       //     // State updates happen asynchronously now
       // }
    };

    if (
      isVisible &&
      modalMode === "normal" &&
      (foods.length > 0 || recentFoods.length > 0)
    ) {
      loadIcons();
    }
  }, [isVisible, modalMode, search, filteredFoods, recentFoods, foods]); // Keep dependencies

  const addToRecentFoods = async (food: Food) => {
    if (!food || !food.id) {
      console.warn("Attempted to add invalid food to recents:", food);
      return;
    }
    if (recentFoods.length > 0 && recentFoods[0].id === food.id) return;
    const updatedRecentFoods = recentFoods.filter(
      (recentFood) => recentFood.id !== food.id
    );
    updatedRecentFoods.unshift(food);
    const trimmedRecentFoods = updatedRecentFoods.slice(0, MAX_RECENT_FOODS);
    setRecentFoods(trimmedRecentFoods);
    await saveRecentFoods(trimmedRecentFoods);
  };

  const servingSizeSuggestions = useMemo(() => {
    if (!selectedFood) return [];
    return [
      { label: "50g", value: "50" },
      { label: "100g", value: "100" },
      { label: "150g", value: "150" },
      { label: "200g", value: "200" },
    ];
  }, [selectedFood]);

  // Uses backend service
  const handleEstimateGrams = async () => {
    if (!selectedFood || !autoInput.trim()) {
      Alert.alert(
        "Input Missing",
        "Please select a food and enter a quantity description (e.g., '1 cup', '2 medium')."
      );
      return;
    }
    setIsAiLoading(true);
    try {
      // Call the refactored utility function (which calls backend service)
      const estimatedGrams = await getGramsFromNaturalLanguage(
        selectedFood.name,
        autoInput
      );
      const roundedGrams = String(Math.round(estimatedGrams));
      setGrams(roundedGrams);
      setUnitMode("grams"); // Switch back to grams mode
      Toast.show({
        type: "success",
        text1: "Grams Estimated",
        text2: `Estimated ${roundedGrams}g for ${selectedFood.name}`,
        position: "bottom",
        visibilityTime: 3000,
      });
    } catch (error: any) {
      // Error Alert is handled within getGramsFromNaturalLanguage using BackendError check
      console.error("AI Gram Estimation Error (Modal Level):", error);
      // No need for duplicate Alert here if backendService/utils handle it
      // Alert.alert(
      //   "AI Estimation Failed",
      //   error.message || "Could not estimate grams. Please enter manually."
      // );
    } finally {
      setIsAiLoading(false);
    }
  };

  const handleAddOrUpdateSingleEntry = async () => {
    if (!selectedFood) {
      Alert.alert("Food Not Selected", "Please select a food item.");
      return;
    }
    const numericGrams = parseFloat(grams);
    if (!isValidNumberInput(grams) || numericGrams <= 0) {
      Alert.alert(
        "Invalid Amount",
        "Please enter a valid positive number for grams."
      );
      return;
    }
    if (isAiLoading || quickAddLoading) return;
    handleAddEntry(); // Call parent function to update DailyEntryScreen state
    await addToRecentFoods(selectedFood);
  };

  const handleInternalSelectFood = (item: Food | null) => {
    if (selectedFood?.id === item?.id) return;
    handleSelectFood(item);
    if (item && (!isEditMode || !initialGrams)) {
      setGrams("");
      setUnitMode("grams");
      setAutoInput("");
    } else if (!item) {
      setGrams("");
      setUnitMode("grams");
      setAutoInput("");
    }
  };

  // --- Quick Add Functions ---

  const handleQuickAddImage = async () => {
    if (isEditMode) {
        console.warn("Attempted to initiate Quick Add while in Edit Mode.");
        return;
    }
    if (editingQuickAddItemIndex !== null) {
      Alert.alert(
        "Finish Editing",
        "Please save or cancel the current edit before adding a new image."
      );
      return;
    }
    Alert.alert(
      "Quick Add from Image",
      "Identify multiple foods from a single image.",
      [
        { text: "Cancel", style: "cancel" },
        { text: "Camera", onPress: () => pickImageAndAnalyze("camera") },
        { text: "Gallery", onPress: () => pickImageAndAnalyze("gallery") },
      ]
    );
  };

  // Uses backend service
  const pickImageAndAnalyze = async (source: "camera" | "gallery") => {
    if (isEditMode) return;

    let permissionResult;
    let pickerResult: ImagePicker.ImagePickerResult;

    setQuickAddLoading(true);
    setQuickAddItems([]);
    setSelectedQuickAddIndices(new Set());
    setEditingQuickAddItemIndex(null);

    try {
      if (source === "camera") {
        permissionResult = await ImagePicker.requestCameraPermissionsAsync();
        if (!permissionResult.granted) {
          Alert.alert("Permission Required", "Camera access needed.");
          setQuickAddLoading(false);
          return;
        }
        pickerResult = await ImagePicker.launchCameraAsync({ quality: 0.6 });
      } else {
        permissionResult =
          await ImagePicker.requestMediaLibraryPermissionsAsync();
        if (!permissionResult.granted) {
          Alert.alert("Permission Required", "Gallery access needed.");
          setQuickAddLoading(false);
          return;
        }
        pickerResult = await ImagePicker.launchImageLibraryAsync({
          mediaTypes: ImagePicker.MediaTypeOptions.Images, // Correct type
          quality: 0.6,
        });
      }

      if (pickerResult.canceled) {
        console.log("Image selection/capture cancelled for Quick Add.");
        setQuickAddLoading(false);
        return;
      }

      if (pickerResult.assets && pickerResult.assets.length > 0) {
        const asset = pickerResult.assets[0];
        // Call the refactored utility function (which calls backend service)
        const results = await getMultipleFoodsFromImage(asset); // Pass the asset directly

        if (results.length === 0) {
          Alert.alert(
            "No Foods Found",
            "The AI couldn't identify any food items in the image. Try again or add manually."
          );
          setQuickAddItems([]);
          setModalMode("normal");
        } else {
          setQuickAddItems(results);
          setSelectedQuickAddIndices(new Set(results.map((_, i) => i)));
          setModalMode("quickAddSelect");
          handleSelectFood(null);
          setGrams("");
          updateSearch("");
          setUnitMode("grams");
          setAutoInput("");
        }
      } else {
        console.log("No assets selected or returned for Quick Add.");
        Alert.alert("Error", "Could not select image.");
        setModalMode("normal");
      }
    } catch (error: any) {
       // Alert handling is now done within getMultipleFoodsFromImage
       console.error("Error during Quick Add image process (Modal Level):", error);
       setModalMode("normal"); // Go back to normal mode on error
       setQuickAddItems([]);
       setSelectedQuickAddIndices(new Set());
       setEditingQuickAddItemIndex(null);
       // No need for duplicate Alert here if backendService/utils handle it
       // Alert.alert(
       //   "Quick Add Failed",
       //   `Could not analyze the image. ${error.message || "Please try again."}`
       // );
    } finally {
      // Use timeout to ensure loading state hides after modal transition completes
      setTimeout(() => setQuickAddLoading(false), 100);
    }
  };

  const handleToggleQuickAddItem = (index: number) => {
    if (editingQuickAddItemIndex !== null) return;

    setSelectedQuickAddIndices((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(index)) {
        newSet.delete(index);
      } else {
        newSet.add(index);
      }
      return newSet;
    });
  };

  const handleEditQuickAddItem = (index: number) => {
    if (editingQuickAddItemIndex !== null) {
      Alert.alert(
        "Finish Editing",
        "Please save or cancel the current edit first."
      );
      return;
    }
    const item = quickAddItems[index];
    setEditingQuickAddItemIndex(index);
    setEditedFoodName(item.foodName);
    setEditedGrams(String(Math.round(item.estimatedWeightGrams)));
    setSelectedQuickAddIndices((prev) => {
      const newSet = new Set(prev);
      newSet.delete(index);
      return newSet;
    });
  };

  const handleSaveQuickAddItemEdit = () => {
    if (editingQuickAddItemIndex === null) return;

    const trimmedName = editedFoodName.trim();
    if (!trimmedName) {
      Alert.alert("Invalid Name", "Food name cannot be empty.");
      return;
    }

    const numericGrams = parseFloat(editedGrams);
    if (!isValidNumberInput(editedGrams) || numericGrams <= 0) {
      Alert.alert(
        "Invalid Grams",
        "Please enter a valid positive number for grams."
      );
      return;
    }
    const roundedGrams = Math.round(numericGrams);

    const updatedItems = quickAddItems.map((item, index) => {
      if (index === editingQuickAddItemIndex) {
        return {
          ...item,
          foodName: trimmedName,
          estimatedWeightGrams: roundedGrams,
        };
      }
      return item;
    });

    setQuickAddItems(updatedItems);
    setEditingQuickAddItemIndex(null);
    setEditedFoodName("");
    setEditedGrams("");
    setSelectedQuickAddIndices((prev) => {
        const newSet = new Set(prev);
        // Use the original index that was stored in editingQuickAddItemIndex
        if (editingQuickAddItemIndex !== null) {
            newSet.add(editingQuickAddItemIndex);
        }
        return newSet;
      });
  };

  const handleCancelQuickAddItemEdit = () => {
    setEditingQuickAddItemIndex(null);
    setEditedFoodName("");
    setEditedGrams("");
     // Optionally re-select if needed, based on desired UX
  };

  const handleConfirmQuickAdd = () => {
    if (isEditMode) {
        console.warn("Attempted Quick Add confirmation while in Edit Mode.");
        return;
    }
    try {
      console.log("AddEntryModal: handleConfirmQuickAdd triggered.");

      if (editingQuickAddItemIndex !== null) {
        Alert.alert(
          "Finish Editing",
          "Please save or cancel your edit before adding items."
        );
        return;
      }

      if (selectedQuickAddIndices.size === 0) {
        Alert.alert(
          "No Items Selected",
          "Please select or edit at least one item to add."
        );
        return;
      }

      const entriesToAdd = Array.from(selectedQuickAddIndices).map((index) => {
        const item = quickAddItems[index];
        // Create a temporary Food object consistent with Food type
        const quickFood: Food = {
          id: uuidv4(), // Generate unique ID for this specific entry instance
          name: item.foodName,
          calories: Math.round(item.calories_per_100g),
          protein: Math.round(item.protein_per_100g),
          carbs: Math.round(item.carbs_per_100g),
          fat: Math.round(item.fat_per_100g),
        };
        const entryGrams = Math.max(1, Math.round(item.estimatedWeightGrams));
        return { food: quickFood, grams: entryGrams };
      });

      console.log(
        "AddEntryModal: Prepared entriesToAdd:",
        JSON.stringify(entriesToAdd, null, 2)
      );

      handleAddMultipleEntries(entriesToAdd); // Pass to parent
      // toggleOverlay(); // Let parent handle closing after state update
    } catch (error) {
      console.error(
        "AddEntryModal: Error in handleConfirmQuickAdd:",
        error
      );
      Alert.alert(
        "Error",
        "A problem occurred while preparing items to add."
      );
    }
  };

  // --- End Quick Add Functions ---

  const isActionDisabled =
    isAiLoading || quickAddLoading || editingQuickAddItemIndex !== null;

  const isAddButtonDisabled =
    modalMode !== "normal" ||
    !selectedFood ||
    !isValidNumberInput(grams) ||
    parseFloat(grams) <= 0 ||
    isActionDisabled;
  const isAiButtonDisabled = // For natural language grams
    modalMode !== "normal" ||
    !selectedFood ||
    !autoInput.trim() ||
    isActionDisabled;
  const isQuickAddConfirmDisabled = // For multi-image add
    isEditMode ||
    modalMode !== "quickAddSelect" ||
    selectedQuickAddIndices.size === 0 ||
    isActionDisabled;
  const isQuickAddImageButtonDisabled = isEditMode || isActionDisabled;

  const combinedOverlayStyle = StyleSheet.flatten([
    styles.overlayStyle,
    { backgroundColor: theme.colors.background },
  ]);

  useEffect(() => {
    // Removed console logs for brevity
  }, [
    isVisible, modalMode, quickAddItems, selectedQuickAddIndices,
    isActionDisabled, isQuickAddConfirmDisabled, editingQuickAddItemIndex,
    isEditMode, selectedFood, grams, unitMode, search, isAddButtonDisabled,
  ]);

  const handleQuickAddGramsChange = (text: string) => {
    const cleanedText = text.replace(/[^0-9.]/g, "").replace(/(\..*)\./g, "$1");
    setEditedGrams(cleanedText);
  };

  return (
    <Overlay
      isVisible={isVisible}
      onBackdropPress={!isActionDisabled ? toggleOverlay : undefined}
      animationType="slide"
      overlayStyle={styles.overlayContainer}
    >
      <KeyboardAvoidingView
        behavior={Platform.OS === "ios" ? "padding" : "height"}
        style={styles.keyboardAvoidingView}
        keyboardVerticalOffset={KEYBOARD_VERTICAL_OFFSET}
      >
        <View style={combinedOverlayStyle}>
          {/* Header */}
          <View style={styles.header}>
            <TouchableOpacity
              onPress={!isActionDisabled ? toggleOverlay : undefined}
              style={styles.closeIconTouchable}
              disabled={isActionDisabled}
            >
              <Icon
                name="close"
                type="material"
                size={28}
                color={
                  isActionDisabled ? theme.colors.grey3 : theme.colors.text
                }
              />
            </TouchableOpacity>

            <Text
              h4
              h4Style={[
                styles.overlayTitle,
                isEditMode && modalMode === "normal" && styles.editModeTitle,
              ]}
              numberOfLines={1}
              ellipsizeMode="tail"
            >
              {modalMode === "quickAddSelect"
                ? editingQuickAddItemIndex !== null
                  ? "Edit Item"
                  : "Select Items to Add"
                : isEditMode
                ? "Edit Entry"
                : "Add Entry"}
            </Text>

            {/* Conditional Header Actions */}
            {modalMode === "normal" && (
              <>
                {!isEditMode && (
                  <TouchableOpacity
                    onPress={handleQuickAddImage}
                    disabled={isQuickAddImageButtonDisabled}
                    style={styles.headerIcon}
                  >
                    {quickAddLoading ? ( // Use quickAddLoading for image analysis
                      <ActivityIndicator
                        size="small"
                        color={theme.colors.primary}
                      />
                    ) : (
                      <Icon
                        name="camera-burst"
                        type="material-community"
                        size={26}
                        color={
                          isQuickAddImageButtonDisabled
                            ? theme.colors.grey3
                            : theme.colors.primary
                        }
                      />
                    )}
                  </TouchableOpacity>
                )}
                <Button
                  title={isEditMode ? "Update" : "Add"}
                  onPress={handleAddOrUpdateSingleEntry}
                  disabled={isAddButtonDisabled}
                  buttonStyle={[
                    styles.addButton,
                    isEditMode && styles.updateButton,
                  ]}
                  titleStyle={styles.buttonTitle}
                />
              </>
            )}
            {modalMode === "quickAddSelect" && !isEditMode && (
              editingQuickAddItemIndex === null && (
                <Button
                  title={`Add ${selectedQuickAddIndices.size}`}
                  onPress={handleConfirmQuickAdd}
                  disabled={isQuickAddConfirmDisabled}
                  buttonStyle={[
                    styles.addButton,
                    { backgroundColor: theme.colors.success },
                  ]}
                  titleStyle={styles.buttonTitle}
                />
              )
            )}
          </View>

          {/* Unified Loading Indicator */}
          {(isAiLoading || quickAddLoading) && (
            <View style={styles.loadingContainer}>
              <ActivityIndicator size="large" color={theme.colors.primary} />
              <Text style={styles.loadingText}>
                {quickAddLoading ? "Analyzing Image..." : "Estimating Grams..."}
              </Text>
            </View>
          )}

          {/* --- Conditional Content (Normal Mode) --- */}
          {!isActionDisabled && modalMode === "normal" && (
            <>
              {/* Search Bar */}
              <SearchBar
                placeholder="Search Foods..."
                onChangeText={updateSearch}
                value={search}
                platform={Platform.OS === "ios" ? "ios" : "android"}
                containerStyle={styles.searchBarContainer}
                inputContainerStyle={styles.searchBarInputContainer}
                inputStyle={styles.searchInputStyle}
                onCancel={() => updateSearch("")}
              />

              {/* Recent Foods */}
              {!search && recentFoods.length > 0 && (
                <View style={styles.recentFoodsSection}>
                  <Text style={styles.sectionTitle}>Recent</Text>
                  <FlatList
                    data={recentFoods}
                    keyExtractor={(item) => `recent-${item.id}`}
                    horizontal
                    showsHorizontalScrollIndicator={false}
                    contentContainerStyle={styles.recentFoodsContainer}
                    renderItem={({ item }) => (
                      <TouchableOpacity
                        style={[
                          styles.recentFoodItem,
                          screenWidth < 350 && styles.smallRecentFoodItem,
                          selectedFood?.id === item.id &&
                            styles.selectedRecentFoodItem,
                        ]}
                        onPress={() => handleInternalSelectFood(item)}
                      >
                        {/* Icon Logic (remains using local cache state) */}
                         {foodIcons[item.name] !== undefined ? (
                              foodIcons[item.name] ? (
                              <Image
                                  source={{ uri: foodIcons[item.name] as string }}
                                  style={styles.foodIconSmall}
                                  onError={() =>
                                  setFoodIcons((prev) => ({
                                      ...prev,
                                      [item.name]: null, // Mark as failed if Image component fails
                                  }))
                                  }
                              />
                              ) : (
                              // Icon fetch failed or returned null
                              <View
                                  style={[
                                  styles.foodIconSmall,
                                  styles.iconPlaceholderSmall,
                                  ]}
                              >
                                  <Icon
                                  name="fastfood" type="material" size={12}
                                  color={theme.colors.grey2}
                                  />
                              </View>
                              )
                          ) : (
                              // Icon fetch is in progress
                              <ActivityIndicator
                              size="small" color={theme.colors.grey3}
                              style={styles.foodIconSmall}
                              />
                          )}
                        <Text
                          style={[
                            styles.recentFoodText,
                            screenWidth < 350 && styles.smallRecentFoodText,
                          ]}
                          numberOfLines={1}
                          ellipsizeMode="tail"
                        >
                          {item.name}
                        </Text>
                      </TouchableOpacity>
                    )}
                  />
                </View>
              )}

              {/* Food Search Results List */}
              {search && (
                <FlatList
                  data={filteredFoods}
                  keyExtractor={(item) => `search-${item.id}`}
                  renderItem={({ item }) => (
                    <TouchableOpacity
                      onPress={() => handleInternalSelectFood(item)}
                    >
                      <ListItem
                        bottomDivider
                        containerStyle={[
                          styles.listItemContainer,
                          selectedFood?.id === item.id &&
                            styles.selectedListItem,
                        ]}
                      >
                         {/* Icon Logic (remains using local cache state) */}
                         {foodIcons[item.name] !== undefined ? (
                              foodIcons[item.name] ? (
                              <Image
                                  source={{ uri: foodIcons[item.name] as string }}
                                  style={styles.foodIcon} // Use regular size icon style
                                  onError={() =>
                                  setFoodIcons((prev) => ({
                                      ...prev,
                                      [item.name]: null,
                                  }))
                                  }
                              />
                              ) : (
                              <View style={styles.defaultIconContainer}>
                                  <Icon
                                  name="restaurant" type="material" size={18}
                                  color={theme.colors.grey3}
                                  />
                              </View>
                              )
                          ) : (
                              <ActivityIndicator
                              size="small" color={theme.colors.grey3}
                              style={styles.foodIcon} // Use regular size icon style
                              />
                          )}
                        <ListItem.Content>
                          <ListItem.Title style={styles.listItemTitle}>
                            {item.name}
                          </ListItem.Title>
                        </ListItem.Content>
                        {selectedFood?.id === item.id && (
                          <Icon
                            name="checkmark-circle"
                            type="ionicon"
                            color={theme.colors.primary}
                            size={24}
                          />
                        )}
                      </ListItem>
                    </TouchableOpacity>
                  )}
                  style={styles.foodList}
                  ListEmptyComponent={
                    <Text style={styles.noFoodsText}>
                      No foods found matching "{search}".
                    </Text>
                  }
                  initialNumToRender={10}
                  maxToRenderPerBatch={10}
                  windowSize={5}
                  keyboardShouldPersistTaps="handled"
                />
              )}

              {/* Amount Input Section */}
              {selectedFood && (
                <View style={styles.amountSection}>
                  <View style={styles.unitSelectorContainer}>
                    <Text style={styles.inputLabel}>Amount</Text>
                    <ButtonGroup
                      buttons={["Grams", "Auto (AI)"]}
                      selectedIndex={unitMode === "grams" ? 0 : 1}
                      onPress={(index) =>
                        setUnitMode(index === 0 ? "grams" : "auto")
                      }
                      containerStyle={styles.buttonGroupContainer}
                      selectedButtonStyle={{
                        backgroundColor: theme.colors.primary,
                      }}
                      textStyle={styles.buttonGroupText}
                      selectedTextStyle={{ color: theme.colors.white }}
                      disabled={isEditMode && [1]}
                      disabledStyle={{ backgroundColor: theme.colors.grey5 }}
                      disabledTextStyle={{ color: theme.colors.grey3 }}
                    />
                  </View>

                  {unitMode === "grams" && (
                    <>
                      {!isEditMode && servingSizeSuggestions.length > 0 && (
                        <View style={styles.servingSizeRow}>
                          <Text style={styles.servingSizeLabel}>
                            Quick Add:
                          </Text>
                          <ScrollView
                            horizontal
                            showsHorizontalScrollIndicator={false}
                            contentContainerStyle={styles.servingSizeContainer}
                          >
                            {servingSizeSuggestions.map((suggestion) => (
                              <TouchableOpacity
                                key={suggestion.label}
                                style={styles.servingSizeButton}
                                onPress={() => setGrams(suggestion.value)}
                              >
                                <Text style={styles.servingSizeButtonTitle}>
                                  {suggestion.label}
                                </Text>
                              </TouchableOpacity>
                            ))}
                          </ScrollView>
                        </View>
                      )}
                      <Input
                        placeholder={isEditMode ? "Update grams" : "Enter exact grams (e.g., 150)"}
                        keyboardType="numeric"
                        value={grams}
                        onChangeText={(text) => {
                          const cleanedText = text
                            .replace(/[^0-9.]/g, "")
                            .replace(/(\..*)\./g, "$1");
                          setGrams(cleanedText);
                        }}
                        inputStyle={styles.gramInputStyle}
                        inputContainerStyle={styles.gramInputContainerStyle}
                        errorMessage={
                          !isValidNumberInput(grams) &&
                          grams !== "" &&
                          grams !== "."
                            ? "Enter a valid number"
                            : ""
                        }
                        errorStyle={{ color: theme.colors.error }}
                        rightIcon={<Text style={styles.unitText}> g</Text>}
                        containerStyle={{ paddingHorizontal: 0 }}
                        key={`grams-input-${selectedFood?.id}`}
                        autoFocus={!search && !isEditMode}
                      />
                    </>
                  )}

                  {/* AI Grams Estimation Input */}
                  {unitMode === "auto" && !isEditMode && (
                    <View style={styles.autoInputRow}>
                      <Input
                        placeholder="Describe quantity (e.g., 1 cup cooked)"
                        value={autoInput}
                        onChangeText={setAutoInput}
                        inputStyle={[
                          styles.gramInputStyle,
                          styles.autoInputField,
                        ]}
                        inputContainerStyle={styles.gramInputContainerStyle}
                        containerStyle={styles.autoInputContainer}
                        multiline={false}
                        onSubmitEditing={handleEstimateGrams}
                        key={`auto-input-${selectedFood?.id}`}
                        autoFocus={true}
                      />
                      <Button
                        onPress={handleEstimateGrams}
                        disabled={isAiButtonDisabled} // Use specific disable state
                        loading={isAiLoading} // Use specific loading state
                        buttonStyle={styles.aiButton}
                        icon={
                          isAiLoading ? ( // Use specific loading state
                            <ActivityIndicator
                              size="small"
                              color={theme.colors.white}
                            />
                          ) : (
                            <Icon
                              name="calculator-variant"
                              type="material-community"
                              size={20}
                              color={theme.colors.white}
                            />
                          )
                        }
                      />
                    </View>
                  )}
                </View>
              )}
            </>
          )}

          {/* --- Conditional Content (Quick Add Selection Mode) --- */}
          {!isEditMode && modalMode === "quickAddSelect" && (
            <>
              <View style={styles.quickAddHeader}>
                <Text style={styles.sectionTitle}>
                  {editingQuickAddItemIndex !== null
                    ? "Editing Item Details"
                    : "Select Items from Image"}
                </Text>
                {editingQuickAddItemIndex === null && (
                  <Button
                    type="clear"
                    title="Back"
                    onPress={() => {
                      setModalMode("normal");
                      setQuickAddItems([]);
                      setSelectedQuickAddIndices(new Set());
                      setEditingQuickAddItemIndex(null);
                    }}
                    titleStyle={{
                      color: theme.colors.primary,
                      fontSize: 14,
                    }}
                    icon={
                      <Icon
                        name="arrow-back"
                        type="ionicon"
                        size={18}
                        color={theme.colors.primary}
                      />
                    }
                    disabled={quickAddLoading}
                  />
                )}
              </View>
              <FlatList
                data={quickAddItems}
                keyExtractor={(item, index) =>
                  `quickadd-${index}-${item.foodName}-${item.estimatedWeightGrams}`
                }
                renderItem={({ item, index }) => {
                  const isSelected = selectedQuickAddIndices.has(index);
                  const isEditingThisItem =
                    editingQuickAddItemIndex === index;
                  const isAnyItemEditing = editingQuickAddItemIndex !== null;
                  const estimatedCalories = Math.round(
                    (item.calories_per_100g / 100) * item.estimatedWeightGrams
                  );

                  return (
                    <Pressable
                      onPress={() =>
                        !isEditingThisItem && handleToggleQuickAddItem(index)
                      }
                      disabled={isAnyItemEditing && !isEditingThisItem}
                    >
                      <ListItem
                        bottomDivider
                        containerStyle={[
                          styles.quickAddItemContainer,
                          isEditingThisItem && styles.quickAddItemEditing,
                          isSelected && styles.quickAddItemSelected,
                          isAnyItemEditing &&
                            !isEditingThisItem && { opacity: 0.6 },
                        ]}
                      >
                        {isEditingThisItem ? (
                          <View style={styles.quickAddEditView}>
                            <Input
                              value={editedFoodName}
                              onChangeText={setEditedFoodName}
                              placeholder="Food Name"
                              inputContainerStyle={
                                styles.quickEditInputContainer
                              }
                              inputStyle={styles.quickEditInput}
                              containerStyle={styles.quickEditNameContainer}
                              autoFocus
                            />
                            <View style={styles.quickEditGramsRow}>
                              <Input
                                value={editedGrams}
                                onChangeText={handleQuickAddGramsChange}
                                placeholder="Grams"
                                keyboardType="numeric"
                                inputContainerStyle={
                                  styles.quickEditInputContainer
                                }
                                inputStyle={styles.quickEditInput}
                                containerStyle={
                                  styles.quickEditGramsContainer
                                }
                                rightIcon={
                                  <Text style={styles.quickEditUnitText}>
                                    g
                                  </Text>
                                }
                              />
                              <TouchableOpacity
                                onPress={handleSaveQuickAddItemEdit}
                                style={styles.quickEditButton}
                              >
                                <Icon
                                  name="checkmark"
                                  type="ionicon"
                                  color={theme.colors.success}
                                  size={26}
                                />
                              </TouchableOpacity>
                              <TouchableOpacity
                                onPress={handleCancelQuickAddItemEdit}
                                style={styles.quickEditButton}
                              >
                                <Icon
                                  name="close-circle-outline"
                                  type="ionicon"
                                  color={theme.colors.error}
                                  size={26}
                                />
                              </TouchableOpacity>
                            </View>
                          </View>
                        ) : (
                          <>
                            <CheckBox
                              checked={isSelected}
                              onPress={() => handleToggleQuickAddItem(index)}
                              containerStyle={styles.quickAddCheckbox}
                              checkedColor={theme.colors.primary}
                              disabled={isAnyItemEditing}
                            />
                            <ListItem.Content>
                              <ListItem.Title style={styles.quickAddItemTitle}>
                                {item.foodName}
                              </ListItem.Title>
                              <ListItem.Subtitle
                                style={styles.quickAddItemSubtitle}
                              >
                                {`Est: ${Math.round(
                                  item.estimatedWeightGrams
                                )}g  ~${estimatedCalories} kcal`}
                              </ListItem.Subtitle>
                            </ListItem.Content>
                            {!isAnyItemEditing && (
                              <TouchableOpacity
                                onPress={() => handleEditQuickAddItem(index)}
                                style={styles.quickEditIconButton}
                              >
                                <Icon
                                  name="pencil"
                                  type="material-community"
                                  size={20}
                                  color={theme.colors.grey1}
                                />
                              </TouchableOpacity>
                            )}
                          </>
                        )}
                      </ListItem>
                    </Pressable>
                  );
                }}
                ListEmptyComponent={
                  <View style={styles.emptyListContainer}>
                    <Text style={styles.emptyListText}>
                      {quickAddLoading ? "Analyzing..." : "No identifiable foods found."}
                    </Text>
                  </View>
                }
                style={styles.quickAddList}
                extraData={{ selectedQuickAddIndices, editingQuickAddItemIndex }}
                keyboardShouldPersistTaps="handled"
              />
            </>
          )}

          <View style={{ height: 20 }} />
        </View>
      </KeyboardAvoidingView>
      <Toast />
    </Overlay>
  );
};

// --- Styles (Keep existing styles, ensure they are up-to-date) ---
const useStyles = makeStyles((theme) => ({
  overlayContainer: {
    backgroundColor: "transparent", width: "90%", maxWidth: 500, padding: 0,
    borderRadius: 15, shadowColor: "#000", shadowOffset: { width: 0, height: 3 },
    shadowOpacity: 0.2, shadowRadius: 5, elevation: 6, overflow: "hidden",
  },
  overlayStyle: {
    width: "100%", borderRadius: 15, padding: 15, paddingBottom: 0,
    maxHeight: Dimensions.get("window").height * 0.85,
  },
  keyboardAvoidingView: { width: "100%" },
  header: {
    flexDirection: "row", justifyContent: "space-between", alignItems: "center",
    marginBottom: 15, paddingHorizontal: 5,
  },
  closeIconTouchable: { padding: 5, zIndex: 1 },
  overlayTitle: {
    color: theme.colors.text, fontWeight: "bold", fontSize: 20, textAlign: "center",
    flex: 1, marginHorizontal: 5,
  },
  editModeTitle: { color: theme.colors.warning },
  headerIcon: { padding: 5, marginHorizontal: 5, zIndex: 1 },
  addButton: {
    borderRadius: 20, paddingHorizontal: 15, paddingVertical: 8, minWidth: 70,
    marginLeft: 5, backgroundColor: theme.colors.primary, zIndex: 1,
  },
  updateButton: { backgroundColor: theme.colors.warning },
  buttonTitle: { color: theme.colors.white, fontWeight: "600", fontSize: 15 },
  searchBarContainer: {
    backgroundColor: "transparent", borderBottomColor: "transparent", borderTopColor: "transparent",
    paddingHorizontal: 0, marginBottom: 10,
  },
  searchBarInputContainer: {
    borderRadius: 25, backgroundColor: theme.colors.searchBg || theme.colors.grey5, height: 40,
  },
  searchInputStyle: { color: theme.colors.text, fontSize: 15 },
  recentFoodsSection: { marginBottom: 15 },
  sectionTitle: {
    fontWeight: "600", marginBottom: 8, color: theme.colors.text, fontSize: 14,
    marginLeft: 5, textTransform: "uppercase",
  },
  recentFoodsContainer: { paddingHorizontal: 5, paddingVertical: 2 },
  recentFoodItem: {
    paddingHorizontal: 10, paddingVertical: 6, borderRadius: 16,
    backgroundColor: theme.colors.grey5, marginRight: 8, flexDirection: "row",
    alignItems: "center", borderWidth: 1.5, borderColor: "transparent",
  },
  selectedRecentFoodItem: { borderColor: theme.colors.primary },
  smallRecentFoodItem: { paddingHorizontal: 8, paddingVertical: 5 },
  foodIconSmall: {
    width: 20, height: 20, marginRight: 6, borderRadius: 10, resizeMode: "contain",
    alignItems: "center", justifyContent: "center", backgroundColor: theme.colors.grey4,
  },
  iconPlaceholderSmall: {
    backgroundColor: theme.colors.grey4, alignItems: "center", justifyContent: "center",
  },
  recentFoodText: { color: theme.colors.text, fontSize: 13, maxWidth: 80 },
  smallRecentFoodText: { fontSize: 12, maxWidth: 70 },
  foodList: {
    maxHeight: Dimensions.get("window").height * 0.3, minHeight: 60, flexGrow: 0, marginBottom: 15,
  },
  listItemContainer: {
    backgroundColor: "transparent", paddingVertical: 8, paddingHorizontal: 5,
    borderBottomColor: theme.colors.divider,
  },
  selectedListItem: { backgroundColor: theme.colors.grey5, borderRadius: 8 },
  defaultIconContainer: { // Style for placeholder when icon fetch fails
      width: 35, height: 35, marginRight: 12, borderRadius: 17.5,
      backgroundColor: theme.colors.grey5, alignItems: "center", justifyContent: "center",
  },
  foodIcon: { // Style for successfully loaded icons in the list
      width: 35, height: 35, marginRight: 12, borderRadius: 17.5, resizeMode: "contain",
      backgroundColor: theme.colors.grey5, // Background for loading/activity indicator
      alignItems: "center", justifyContent: "center",
  },
  listItemTitle: { color: theme.colors.text, fontSize: 16, fontWeight: "500" },
  noFoodsText: {
    color: theme.colors.grey2, fontStyle: "italic", textAlign: "center",
    marginTop: 20, marginBottom: 10, paddingHorizontal: 10,
  },
  amountSection: {
    marginTop: 10, borderTopWidth: 1, borderTopColor: theme.colors.divider, paddingTop: 15,
  },
  unitSelectorContainer: {
    flexDirection: "row", alignItems: "center", justifyContent: "space-between",
    marginBottom: 15, paddingHorizontal: 5,
  },
  inputLabel: {
    fontWeight: "600", color: theme.colors.grey1, fontSize: 14, marginRight: 10,
    textTransform: "uppercase",
  },
  buttonGroupContainer: {
    flex: 0.7, maxWidth: 220, height: 35, borderRadius: 8,
    backgroundColor: theme.colors.background,
  },
  buttonGroupText: { fontSize: 14, color: theme.colors.text },
  servingSizeRow: {
    flexDirection: "row", alignItems: "center", marginBottom: 12, paddingHorizontal: 5,
  },
  servingSizeLabel: { color: theme.colors.grey2, fontSize: 13, marginRight: 8 },
  servingSizeContainer: { flexGrow: 0 },
  servingSizeButton: {
    backgroundColor: theme.colors.grey4, borderRadius: 15, marginRight: 8,
    paddingHorizontal: 12, paddingVertical: 5, justifyContent: "center",
    alignItems: "center", height: 30,
  },
  servingSizeButtonTitle: { color: theme.colors.text, fontSize: 13 },
  gramInputStyle: { color: theme.colors.text, fontSize: 16, paddingVertical: 8, height: 40, },
  gramInputContainerStyle: { borderBottomColor: theme.colors.grey3, paddingHorizontal: 5, },
  unitText: { color: theme.colors.grey2, fontSize: 15, fontWeight: "500", paddingRight: 5, },
  autoInputRow: { flexDirection: "row", alignItems: "center" },
  autoInputContainer: { flex: 1, paddingHorizontal: 0, marginRight: 10 },
  autoInputField: { height: 40 },
  aiButton: {
    backgroundColor: theme.colors.secondary, borderRadius: 20, width: 40, height: 40,
    padding: 0, justifyContent: "center", alignItems: "center",
  },
  loadingContainer: { // Unified loading overlay
    position: "absolute", top: 0, left: 0, right: 0, bottom: 0,
    backgroundColor: "rgba(0, 0, 0, 0.1)", alignItems: "center", justifyContent: "center",
    zIndex: 10, borderRadius: 15,
  },
  loadingText: { marginTop: 10, color: theme.colors.text, fontSize: 16, fontWeight: "500", },
  quickAddHeader: {
    flexDirection: "row", justifyContent: "space-between", alignItems: "center",
    marginBottom: 10, paddingHorizontal: 5, borderBottomWidth: 1,
    borderBottomColor: theme.colors.divider, paddingBottom: 8,
  },
  quickAddList: { maxHeight: Dimensions.get("window").height * 0.5, flexGrow: 0, marginBottom: 10, },
  quickAddItemContainer: {
    paddingVertical: 6, paddingHorizontal: 5, backgroundColor: theme.colors.background,
    borderBottomColor: theme.colors.divider, flexDirection: "row", alignItems: "center",
  },
  quickAddItemSelected: { backgroundColor: theme.colors.successLight || '#d4edda' },
  quickAddItemEditing: { backgroundColor: theme.colors.grey5, paddingVertical: 8, },
  quickAddCheckbox: { padding: 0, margin: 0, marginRight: 10, backgroundColor: "transparent", borderWidth: 0, },
  quickAddItemTitle: { fontWeight: "bold", color: theme.colors.text, fontSize: 16, },
  quickAddItemSubtitle: { color: theme.colors.grey1, fontSize: 13, marginTop: 2, },
  quickEditIconButton: { padding: 8, marginLeft: 8, },
  quickAddEditView: { flex: 1, paddingLeft: 10, },
  quickEditInputContainer: { borderBottomWidth: 1, borderBottomColor: theme.colors.primary, height: 35, paddingHorizontal: 0, },
  quickEditInput: { fontSize: 15, color: theme.colors.text, paddingVertical: 0, },
  quickEditNameContainer: { paddingHorizontal: 0, marginBottom: 5, },
  quickEditGramsRow: { flexDirection: "row", alignItems: "center", },
  quickEditGramsContainer: { flex: 1, paddingHorizontal: 0, },
  quickEditUnitText: { color: theme.colors.grey2, fontSize: 14, fontWeight: "500", },
  quickEditButton: { paddingLeft: 10, paddingVertical: 5, },
  emptyListContainer: { alignItems: "center", paddingVertical: 30, paddingHorizontal: 15, },
  emptyListText: { color: theme.colors.grey2, fontSize: 16, textAlign: "center", },
  emptyListSubText: { fontSize: 14, color: theme.colors.grey3, textAlign: "center", marginTop: 5, },
}));


export default AddEntryModal;
---------- END AddEntryModal.tsx ----------


---------- AddFoodModal.tsx ----------
// src/components/AddFoodModal.tsx
// components/AddFoodModal.tsx (Integrate Backend, Handle Errors)
import React, { useState, useEffect } from "react";
import {
  View,
  KeyboardAvoidingView,
  Platform,
  ActivityIndicator,
  Alert,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
} from "react-native";
import {
  Button,
  Input,
  Text,
  Overlay,
  makeStyles,
  useTheme,
  Icon,
} from "@rneui/themed";
import { Food } from "../types/food";
import { MaterialCommunityIcons } from "@expo/vector-icons";
import Toast from "react-native-toast-message";
// Import backend service functions and error type
import {
    getMacrosFromText, // Renamed utility function using backend
    getMacrosForImageFile, // Utility function using backend
    getBase64FromUri, // Keep utility
    BackendError
} from "../utils/macros";
import * as ImagePicker from "expo-image-picker";
import { ImagePickerAsset, ImagePickerResult } from 'expo-image-picker';
import { isValidNumberInput, isNotEmpty } from "../utils/validationUtils";

interface AddFoodModalProps {
  isVisible: boolean;
  toggleOverlay: () => void;
  newFood: Omit<Food, "id">;
  editFood: Food | null;
  errors: { [key: string]: string };
  handleInputChange: (
    key: keyof Omit<Food, "id">,
    value: string,
    isEdit: boolean
  ) => void;
  handleCreateFood: () => void; // Still used to update local list state
  handleUpdateFood: () => void; // Still used to update local list state
  validateFood: (food: Omit<Food, "id">) => { [key: string]: string } | null;
  setErrors: React.Dispatch<React.SetStateAction<{ [key: string]: string }>>;
}

const KEYBOARD_VERTICAL_OFFSET = Platform.OS === "ios" ? 60 : 0;

const AddFoodModal: React.FC<AddFoodModalProps> = ({
  isVisible,
  toggleOverlay,
  newFood,
  editFood,
  errors,
  handleInputChange,
  handleCreateFood,
  handleUpdateFood,
  validateFood,
  setErrors,
}) => {
  const { theme } = useTheme();
  const styles = useStyles();
  const [loading, setLoading] = useState(false); // For save/update button
  const [apiLoading, setApiLoading] = useState(false); // General API loading (may not be needed)
  const [mode, setMode] = useState<"normal" | "ingredients">("normal");
  const [ingredients, setIngredients] = useState("");
  const [aiButtonLoading, setAiButtonLoading] = useState(false); // For ingredient text AI
  const [imageLoading, setImageLoading] = useState(false); // For image analysis AI

  useEffect(() => {
    if (isVisible) {
      setErrors({});
      setMode("normal");
      setIngredients("");
      setAiButtonLoading(false);
      setImageLoading(false);
      setLoading(false);
    }
  }, [isVisible, setErrors]);

  const getValue = (key: keyof Omit<Food, "id">) => {
    const value = (editFood && editFood[key]) ?? newFood[key] ?? "";
    if (!editFood && typeof value === 'number' && value === 0 && key !== 'name') {
        return "";
    }
    if (editFood && typeof value === 'number' && value === 0 && key !== 'name') {
        return "0";
    }
    return String(value);
  };

  // Handles local state update and triggers parent save/update
  const handleCreateOrUpdate = async (isUpdate: boolean) => {
    setLoading(true);
    const foodData = isUpdate ? editFood : newFood;
    if (!foodData) {
        setLoading(false);
        return;
    }

     const dataToValidate: Omit<Food, "id"> = {
        ...foodData,
        name: String(foodData.name).trim(),
        calories: parseFloat(getValue("calories")) || 0,
        protein: parseFloat(getValue("protein")) || 0,
        carbs: parseFloat(getValue("carbs")) || 0,
        fat: parseFloat(getValue("fat")) || 0,
    };

    const validationErrors = validateFood(dataToValidate);

    if (validationErrors) {
      setErrors(validationErrors);
      setLoading(false);
      Toast.show({
        type: "error", text1: "Please fix the errors", position: 'bottom',
      });
      return;
    }
    setErrors({});

    try {
      // Call the parent function which handles storage/state update
      if (isUpdate) {
          await handleUpdateFood();
      } else {
          await handleCreateFood();
      }

      Toast.show({
        type: "success",
        text1: `Food ${isUpdate ? "Updated" : "Created"} Successfully!`,
        position: 'bottom',
      });
      toggleOverlay(); // Close modal on success
    } catch (error: any) {
        // Errors during storage save (handled by parent) might show alerts
        // This catch block is more for unexpected issues during the call
      console.error(`Error during ${isUpdate ? 'update' : 'create'} food handler:`, error);
      Alert.alert(
        "Error",
        error.message || `Failed to ${isUpdate ? "update" : "create"} food.`
      );
    } finally {
      setLoading(false);
    }
  };

  // Uses backend service for recipe text analysis
  const handleAiButtonClick = async () => {
    const foodName = getValue("name");
    if (!foodName && mode === 'ingredients') {
      Alert.alert("Missing Name", "Please enter a food name first.");
      return;
    }

    if (mode === "normal") {
      setMode("ingredients");
      handleInputChange("calories", "", !!editFood);
      handleInputChange("protein", "", !!editFood);
      handleInputChange("carbs", "", !!editFood);
      handleInputChange("fat", "", !!editFood);
    } else if (mode === "ingredients") {
      const currentFoodName = getValue("name");
      if (!currentFoodName) {
        Alert.alert("Missing Name", "Please enter a food name before calculating macros.");
        return;
      }

      setAiButtonLoading(true);
      try {
        // Call the refactored utility function (uses backend)
        const macros = await getMacrosFromText(currentFoodName, ingredients);

        handleInputChange("calories", String(Math.round(macros.calories)), !!editFood);
        handleInputChange("protein", String(Math.round(macros.protein)), !!editFood);
        handleInputChange("carbs", String(Math.round(macros.carbs)), !!editFood);
        handleInputChange("fat", String(Math.round(macros.fat)), !!editFood);

        setMode("normal");
        Toast.show({ type: 'info', text1: 'Macros estimated from text.', position: 'bottom' });
      } catch (error) {
         // Alert is handled within getMacrosFromText utility now
         console.error("AI Macro fetch error (recipe - modal):", error);
         // Optional: Additional handling specific to this modal if needed
      } finally {
        setAiButtonLoading(false);
      }
    }
  };

  // Uses backend service for image analysis
  const handleGetImageAndAnalyze = async () => {

    const processImage = async (pickerResult: ImagePickerResult) => {
        if (pickerResult.canceled) {
            console.log("Image selection/capture cancelled");
            setImageLoading(false); // Stop loading if cancelled
            return;
        }

        if (pickerResult.assets && pickerResult.assets.length > 0) {
            const asset = pickerResult.assets[0];
            console.log("Image acquired:", asset.uri);
            setImageLoading(true); // Loading starts before backend call

            try {
                 // Call the refactored utility function (uses backend)
                 const result = await getMacrosForImageFile(asset); // Pass asset directly

                // Update form fields with results
                handleInputChange("name", result.foodName, !!editFood);
                handleInputChange("calories", String(Math.round(result.calories)), !!editFood);
                handleInputChange("protein", String(Math.round(result.protein)), !!editFood);
                handleInputChange("carbs", String(Math.round(result.carbs)), !!editFood);
                handleInputChange("fat", String(Math.round(result.fat)), !!editFood);

                setMode("normal");
                setIngredients("");

                Toast.show({
                    type: 'success',
                    text1: 'Food Identified!',
                    text2: `Identified as ${result.foodName}. Macros estimated.`,
                    position: 'bottom',
                });

            } catch (analysisError) {
                // Alert is handled within getMacrosForImageFile utility now
                console.error("Error during image analysis (modal):", analysisError);
                 // Optional: Specific modal handling if needed
            } finally {
                 setTimeout(() => setImageLoading(false), 100); // Stop loading
            }
        } else {
            console.log("No assets selected or returned.");
            setImageLoading(false); // Stop loading if no assets
        }
    };

    Alert.alert(
      "Get Image",
      "Choose a source for the food image:",
      [
        { text: "Cancel", style: "cancel", onPress: () => setImageLoading(false) }, // Ensure loading stops
        {
          text: "Camera",
          onPress: async () => {
            setImageLoading(true); // Indicate loading
            try {
                const permissionResult = await ImagePicker.requestCameraPermissionsAsync();
                if (!permissionResult.granted) {
                    Alert.alert("Permission Required", "Camera access is needed.");
                    setImageLoading(false); return;
                }
                const cameraResult = await ImagePicker.launchCameraAsync({ quality: 0.6 });
                await processImage(cameraResult);
            } catch (error) {
                console.error("Error launching camera:", error);
                Alert.alert("Camera Error", "Could not open the camera.");
                setImageLoading(false); // Stop loading on error
            }
          },
        },
        {
          text: "Gallery",
          onPress: async () => {
            setImageLoading(true); // Indicate loading
            try {
                const permissionResult = await ImagePicker.requestMediaLibraryPermissionsAsync();
                if (!permissionResult.granted) {
                    Alert.alert("Permission Required", "Gallery access needed.");
                    setImageLoading(false); return;
                }
                const libraryResult = await ImagePicker.launchImageLibraryAsync({
                    mediaTypes: ImagePicker.MediaTypeOptions.Images, quality: 0.6,
                });
                await processImage(libraryResult);
            } catch (error) {
                console.error("Error launching image library:", error);
                Alert.alert("Gallery Error", "Could not open the image library.");
                 setImageLoading(false); // Stop loading on error
            }
          },
        },
      ],
      { cancelable: true, onDismiss: () => setImageLoading(false) } // Stop loading if dismissed
    );
  };

    const combinedOverlayStyle = StyleSheet.flatten([
        styles.overlayStyle,
        { backgroundColor: theme.colors.background }
    ]);

    const isAnyLoading = loading || aiButtonLoading || imageLoading; // Combined loading state

  return (
    <Overlay
      isVisible={isVisible}
      onBackdropPress={!isAnyLoading ? toggleOverlay : undefined} // Prevent closing while loading
      animationType="fade"
      overlayStyle={styles.overlayContainer}
    >
      <KeyboardAvoidingView
        behavior={Platform.OS === "ios" ? "padding" : "height"}
        style={styles.keyboardAvoidingView}
        keyboardVerticalOffset={KEYBOARD_VERTICAL_OFFSET}
      >
        <View style={combinedOverlayStyle}>
          <View style={styles.header}>
            <Text h4 style={styles.overlayTitle}>
              {editFood ? "Edit Food" : "Add New Food"}
            </Text>
            <Button
              title={editFood ? "Update" : "Add"}
              onPress={() => handleCreateOrUpdate(!!editFood)}
              buttonStyle={[
                styles.button,
                { backgroundColor: editFood ? theme.colors.warning : theme.colors.primary },
              ]}
              titleStyle={{ color: theme.colors.white, fontWeight: "600" }}
              loading={loading} // Only show loading for the save/update action itself
              disabled={isAnyLoading} // Disable if any operation is running
              containerStyle={styles.buttonContainer}
            />
            <Icon
              name="close"
              type="material"
              size={28}
              color={theme.colors.text}
              onPress={!isAnyLoading ? toggleOverlay : undefined} // Disable close when loading
              containerStyle={styles.closeIcon}
              disabled={isAnyLoading}
              disabledStyle={{ backgroundColor: 'transparent' }}
            />
          </View>

          <ScrollView keyboardShouldPersistTaps="handled">
             {/* Food Name Input with Image Icon */}
            <View style={styles.inputRow}>
                <Input
                    label="Food Name"
                    labelStyle={{ color: theme.colors.text }}
                    value={getValue("name")}
                    onChangeText={(text) => handleInputChange("name", text, !!editFood)}
                    errorMessage={errors.name}
                    inputContainerStyle={[styles.inputContainerStyle, styles.inputContainerFlex]}
                    inputStyle={styles.inputStyle}
                    containerStyle={{ flex: 1 }}
                    leftIcon={
                        <MaterialCommunityIcons
                        name="food-apple" size={24}
                        color={errors.name ? theme.colors.error : theme.colors.grey1}
                        />
                    }
                    disabled={isAnyLoading} // Disable input while loading
                />
                {/* Image Picker/Camera Icon Button */}
                <TouchableOpacity
                    onPress={handleGetImageAndAnalyze}
                    disabled={isAnyLoading} // Disable while loading
                    style={styles.iconButtonContainer}
                 >
                    {imageLoading ? ( // Use specific loading state for this button
                        <ActivityIndicator size="small" color={theme.colors.primary} />
                    ) : (
                        <Icon
                            name="camera-enhance-outline"
                            type="material-community" size={28}
                            color={isAnyLoading ? theme.colors.grey3 : theme.colors.primary} // Dim icon when disabled
                        />
                    )}
                </TouchableOpacity>
            </View>

            {/* Macro Inputs or Ingredient Input */}
            {mode === "normal" && (
              <>
                <Input
                  label="Calories (per 100g)" labelStyle={{ color: theme.colors.text }}
                  keyboardType="numeric" value={getValue("calories")}
                  onChangeText={(text) => handleInputChange("calories", text.replace(/[^0-9.]/g, "").replace(/(\..*)\./g, "$1"), !!editFood)}
                  errorMessage={errors.calories} inputContainerStyle={styles.inputContainerStyle}
                  inputStyle={styles.inputStyle}
                  leftIcon={<MaterialCommunityIcons name="fire" size={24} color={errors.calories ? theme.colors.error : theme.colors.grey1}/>}
                  disabled={isAnyLoading}
                />
                <Input
                  label="Protein (per 100g)" labelStyle={{ color: theme.colors.text }}
                  keyboardType="numeric" value={getValue("protein")}
                  onChangeText={(text) => handleInputChange("protein", text.replace(/[^0-9.]/g, "").replace(/(\..*)\./g, "$1"), !!editFood)}
                  errorMessage={errors.protein} inputContainerStyle={styles.inputContainerStyle}
                  inputStyle={styles.inputStyle}
                  leftIcon={<MaterialCommunityIcons name="food-drumstick" size={24} color={errors.protein ? theme.colors.error : theme.colors.grey1}/>}
                   disabled={isAnyLoading}
               />
                <Input
                  label="Carbs (per 100g)" labelStyle={{ color: theme.colors.text }}
                  keyboardType="numeric" value={getValue("carbs")}
                  onChangeText={(text) => handleInputChange("carbs", text.replace(/[^0-9.]/g, "").replace(/(\..*)\./g, "$1"), !!editFood)}
                  errorMessage={errors.carbs} inputContainerStyle={styles.inputContainerStyle}
                  inputStyle={styles.inputStyle}
                  leftIcon={<MaterialCommunityIcons name="bread-slice" size={24} color={errors.carbs ? theme.colors.error : theme.colors.grey1}/>}
                   disabled={isAnyLoading}
               />
                <Input
                  label="Fat (per 100g)" labelStyle={{ color: theme.colors.text }}
                  keyboardType="numeric" value={getValue("fat")}
                  onChangeText={(text) => handleInputChange("fat", text.replace(/[^0-9.]/g, "").replace(/(\..*)\./g, "$1"), !!editFood)}
                  errorMessage={errors.fat} inputContainerStyle={styles.inputContainerStyle}
                  inputStyle={styles.inputStyle}
                  leftIcon={<MaterialCommunityIcons name="oil" size={24} color={errors.fat ? theme.colors.error : theme.colors.grey1}/>}
                   disabled={isAnyLoading}
               />
              </>
            )}

            {mode === "ingredients" && (
              <>
                <View style={styles.backButtonContainer}>
                  <Icon name="arrow-left" type="material-community" size={24} color={theme.colors.primary}
                    onPress={() => !isAnyLoading && setMode("normal")} // Prevent switching during AI call
                    disabled={isAnyLoading} containerStyle={styles.backIcon}
                  />
                  <Text style={[styles.backButtonText, isAnyLoading && styles.disabledText]} onPress={() => !isAnyLoading && setMode("normal")}>
                      Back to Manual Input
                  </Text>
                </View>
                <Input
                  label="Ingredients (Optional)" labelStyle={{ color: theme.colors.text }}
                  value={ingredients} onChangeText={setIngredients} multiline={true}
                  numberOfLines={4} inputContainerStyle={[styles.inputContainerStyle, styles.multilineInputContainer]}
                  inputStyle={[styles.inputStyle, styles.multilineInput]}
                  placeholder="e.g.\n100g Chicken Breast\n50g Rice\n1 tbsp Olive Oil"
                  placeholderTextColor={theme.colors.grey3}
                  leftIcon={<MaterialCommunityIcons name="format-list-bulleted" size={24} color={theme.colors.grey1} style={styles.multilineIcon}/>}
                  disabled={isAnyLoading}
                />
              </>
            )}

            {/* AI (Text) Button */}
            <Button
              title={mode === "normal" ? "Calculate with AI (Recipe/Text)" : ingredients ? "Get Macros from Ingredients" : "Get Macros from Name Only"}
              onPress={handleAiButtonClick}
              buttonStyle={[styles.button, styles.aiButton, { backgroundColor: theme.colors.secondary }]}
              titleStyle={[styles.aiButtonTitle, { color: theme.colors.white }]}
              loading={aiButtonLoading} // Use specific loading state
              disabled={isAnyLoading} // Disable while any op runs
              icon={mode === "normal" ? <MaterialCommunityIcons name="text-box-search-outline" size={18} color={theme.colors.white} style={{ marginRight: 8 }}/> : undefined}
              containerStyle={[styles.buttonContainer, { marginTop: 15 }]}
            />

            {/* Barcode Placeholder */}
            <View style={styles.futureInputContainer}>
              <Text style={styles.futureInputLabel}>
                Barcode Input (Coming Soon)
              </Text>
            </View>
          </ScrollView>
        </View>
      </KeyboardAvoidingView>
      {/* General API Loading Overlay (Optional) */}
      {/* {apiLoading && (
        <View style={styles.loadingOverlay}>
          <ActivityIndicator size="large" color={theme.colors.primary} />
        </View>
      )} */}
    </Overlay>
  );
};

// --- Styles (Keep existing styles) ---
const useStyles = makeStyles((theme) => ({
    overlayContainer: {
        backgroundColor: 'transparent', width: '90%', maxWidth: 500, padding: 0, borderRadius: 15,
        shadowColor: "#000", shadowOffset: { width: 0, height: 2, }, shadowOpacity: 0.25,
        shadowRadius: 3.84, elevation: 5, overflow: 'hidden',
    },
    overlayStyle: {
        width: '100%', borderRadius: 15, padding: 20, paddingBottom: 30, maxHeight: '90%',
    },
    keyboardAvoidingView: { width: "100%", },
    header: {
        flexDirection: "row", justifyContent: "space-between", alignItems: "center",
        marginBottom: 20, paddingBottom: 10, borderBottomWidth: 1, borderBottomColor: theme.colors.divider,
    },
    overlayTitle: { color: theme.colors.text, fontWeight: "bold", fontSize: 20, flexShrink: 1, marginRight: 10, },
    closeIcon: { padding: 5, marginLeft: 10, },
    inputRow: { flexDirection: 'row', alignItems: 'flex-end', marginBottom: 5, },
    inputContainerFlex: { flex: 1, marginRight: 10, marginBottom: 0, },
    iconButtonContainer: {
        height: 40, width: 40, justifyContent: 'center', alignItems: 'center', marginBottom: 10,
    },
    inputContainerStyle: { borderBottomWidth: 1, borderBottomColor: theme.colors.grey4, marginBottom: 5, paddingBottom: 2, },
    inputStyle: { color: theme.colors.text, marginLeft: 10, fontSize: 16, },
    multilineInputContainer: {
        borderWidth: 1, borderColor: theme.colors.grey4, borderRadius: 8, paddingVertical: 8,
        paddingHorizontal: 5, marginBottom: 10, borderBottomWidth: 1, borderBottomColor: theme.colors.grey4,
    },
    multilineInput: { marginLeft: 5, textAlignVertical: 'top', minHeight: 80, fontSize: 16, color: theme.colors.text, },
    multilineIcon: { marginTop: 8, marginRight: 5, },
    futureInputContainer: {
        backgroundColor: theme.colors.grey5, padding: 15, borderRadius: 10,
        marginTop: 20, marginBottom: 10, alignItems: "center",
    },
    futureInputLabel: { color: theme.colors.grey2, fontStyle: "italic", },
    buttonContainer: { },
    button: { borderRadius: 8, paddingHorizontal: 15, paddingVertical: 10, },
    aiButton: { paddingVertical: 12, },
    aiButtonTitle: { fontWeight: "600", fontSize: 15, textAlign: 'center', },
    loadingOverlay: {
        position: "absolute", top: 0, left: 0, right: 0, bottom: 0, backgroundColor: "rgba(0, 0, 0, 0.5)",
        justifyContent: "center", alignItems: "center", zIndex: 10, borderRadius: 15,
    },
    backButtonContainer: { flexDirection: "row", alignItems: "center", marginBottom: 15, marginTop: 5, },
    backIcon: { marginRight: 5, padding: 5, },
    backButtonText: { color: theme.colors.primary, fontSize: 16, fontWeight: '500', },
    disabledText: { color: theme.colors.grey3, }
}));


export default AddFoodModal;
---------- END AddFoodModal.tsx ----------


---------- ConfirmationModal.tsx ----------
// components/ConfirmationModal.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Overlay, Button, Input, Text, useTheme } from '@rneui/themed';

interface ConfirmationModalProps {
  isVisible: boolean;
  onCancel: () => void;
  onConfirm: () => void;
  confirmationText: string;
  setConfirmationText: (text: string) => void;
  title?: string; // Optional title
  message?: string;  //Optional message
}

const ConfirmationModal: React.FC<ConfirmationModalProps> = ({
  isVisible,
  onCancel,
  onConfirm,
  confirmationText,
  setConfirmationText,
  title = "Confirm Action", //default title
  message = "Are you sure you want to perform this action?"
}) => {
  const { theme } = useTheme();

  return (
    <Overlay
      isVisible={isVisible}
      onBackdropPress={onCancel}
      overlayStyle={styles.overlay}
      backdropStyle={styles.backdrop} // Add the backdropStyle
    >
      <View style={[styles.container, {backgroundColor: theme.colors.background}]}>
        <Text style={[styles.title, {color: theme.colors.text}]}>{title}</Text>
        <Text style={[styles.message, {color: theme.colors.text}]}>{message}</Text>
        <Input
          placeholder="Enter confirmation text"
          placeholderTextColor={theme.colors.text}
          value={confirmationText}
          onChangeText={setConfirmationText}
          containerStyle={styles.inputContainer}
          inputStyle={{ color: theme.colors.text }}
          inputContainerStyle={{borderBottomColor: theme.colors.text}}
        />
        <View style={styles.buttonContainer}>
          <Button title="Cancel" onPress={onCancel} type="outline" buttonStyle={styles.button} />
          <Button
            title="Confirm"
            onPress={onConfirm}
            color="error"
            buttonStyle={styles.button}
            disabled={confirmationText === ""}  //Disable when empty
          />
        </View>
      </View>
    </Overlay>
  );
};

const styles = StyleSheet.create({
    overlay: {
        borderRadius: 10,
        width: '80%', // Responsive width
        padding: 6,
        backgroundColor: 'rgba(200, 200, 200, 0.5)'
    },
  container: {
    padding: 20,
    borderRadius: 7,
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 10,
    textAlign: 'center', //center align
  },
  message: {
    marginBottom: 15,
    textAlign: 'center'
  },
  inputContainer: {
    marginBottom: 20,
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
  },
  button: {
    width: 100,
    padding: 10,
  },
  backdrop: {  // Add styles for the backdrop
    backgroundColor: 'rgba(0, 0, 0, 0.5)', // Semi-transparent black
  },
});

export default ConfirmationModal;
---------- END ConfirmationModal.tsx ----------


---------- DailyGoalsInput.tsx ----------
// components/DailyGoalsInput.tsx
import React from "react";
import { Input, Text } from "@rneui/themed";
import { MacroType } from "../types/settings";
import { useTheme } from "@rneui/themed";


interface DailyGoalsInputProps {
    dailyGoals: { [key in MacroType]: number };
    onGoalChange: (goalType: MacroType, value: string) => void;
}

const DailyGoalsInput: React.FC<DailyGoalsInputProps> = ({
  dailyGoals,
  onGoalChange,
}) => {

    const { theme } = useTheme();

  return (
    <>
      {["calories", "protein", "carbs", "fat"].map((macro) => (
        <Input
          key={macro}
          label={<Text style={{ color: theme.colors.text }}>{`${macro.charAt(0).toUpperCase() + macro.slice(1)} Goal`}</Text>} // Wrap label in <Text>
          keyboardType="numeric"
          value={dailyGoals?.[macro as MacroType]?.toString() || ""}
          onChangeText={(value) => onGoalChange(macro as MacroType, value)}
          style={{ color: theme.colors.text }}
          inputContainerStyle={{ borderBottomColor: theme.colors.text }}
          labelStyle={{ color: theme.colors.text }}
        />
      ))}
    </>
  );
};

export default DailyGoalsInput;
---------- END DailyGoalsInput.tsx ----------


---------- DailyProgress.tsx ----------
// components/DailyProgress.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, useTheme } from '@rneui/themed';

interface DailyProgressProps {
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
  goals: {
    calories?: number;
    protein?: number;
    carbs?: number;
    fat?: number;
  };
}

const DailyProgress: React.FC<DailyProgressProps> = ({
  calories,
  protein,
  carbs,
  fat,
  goals,
}) => {
  const { theme } = useTheme();

  const calculateProgress = (current: number, goal?: number) => {
    if (!goal || goal <= 0) return 0; // Avoid division by zero and handle undefined goals
    return Math.min(current / goal, 1); // Cap at 100%
  };

  const renderProgressBar = (label: string, current: number, goal: number | undefined, color: string) => {
      const progress = calculateProgress(current, goal);
      return (
          <View style={styles.macroContainer} key={label}>
              <View style={styles.labelContainer}>
                    <Text style={[styles.macroLabel, {color: theme.colors.text}]}>{label}:</Text>
                    <Text style={[styles.macroValue, {color: theme.colors.text}]}>
                        {`${Math.round(current)} / ${goal || 0}`}
                    </Text>
              </View>
              <View style={styles.progressBarContainer}>
                  <View style={[styles.progressBar, { width: `${progress * 100}%`, backgroundColor: color }]} />
              </View>
          </View>
      )
  }


  return (
    <View style={styles.container}>
        {renderProgressBar('Calories', calories, goals.calories, theme.colors.primary)}
        {renderProgressBar('Protein', protein, goals.protein, 'green')}
        {renderProgressBar('Carbs', carbs, goals.carbs, 'orange')}
        {renderProgressBar('Fat', fat, goals.fat, 'blue')}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: 20,
    padding: 10,
    borderRadius: 8, // Rounded corners for the container
    //backgroundColor: '#f0f0f0', // Light background for contrast Removed for theme consistency
  },
  macroContainer: {
    marginBottom: 10,
  },
  labelContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 5,
  },
  macroLabel: {
    fontWeight: 'bold',
  },
  macroValue: {},
  progressBarContainer: {
      backgroundColor: '#e0e0e0', //Light grey for track
      borderRadius: 5,
      height: 10
  },
  progressBar: {
    height: 10,
    borderRadius: 5,
  },
});

export default DailyProgress;
---------- END DailyProgress.tsx ----------


---------- DataManagementButtons.tsx ----------
// components/DataManagementButtons.tsx (Modified callback)

import React, { useState } from "react";
import { Alert, Platform } from "react-native"; // Import Platform
import { Button } from "@rneui/themed";
import * as DocumentPicker from "expo-document-picker";
import * as FileSystem from "expo-file-system";
import * as Sharing from 'expo-sharing'; // Import Sharing
import { formatDate } from "../utils/dateUtils";
import {
  clearAllData,
  loadDailyEntries,
  saveDailyEntries,
  loadFoods,
  saveFoods,
  loadSettings,
  saveSettings
} from "../services/storageService";
import ConfirmationModal from "./ConfirmationModal";
import { DailyEntry } from "../types/dailyEntry";
import { Food } from "../types/food";
import { Settings } from "../types/settings";
import { useTheme } from "@rneui/themed";


interface DataManagementButtonsProps {
  onDataOperation: () => void; // Changed prop name
}

const DataManagementButtons: React.FC<DataManagementButtonsProps> = ({
    onDataOperation
}) => {
  const [isConfirmationVisible, setIsConfirmationVisible] = useState(false);
  const [confirmationText, setConfirmationText] = useState("");
  const { theme } = useTheme();

  const handleExportData = async () => {
    try {
      const dailyEntries = await loadDailyEntries();
      const foods = await loadFoods();
      const settings = await loadSettings();

      const exportData = {
        dailyEntries,
        foods,
        settings
      };

      const exportDataString = JSON.stringify(exportData);
      const formattedDate = formatDate(new Date()).replace(/\//g, '-'); // Replace slashes
      const fileName = `macro_data_${formattedDate}.json`;
      const fileUri = FileSystem.documentDirectory + fileName;

      await FileSystem.writeAsStringAsync(fileUri, exportDataString, {
        encoding: FileSystem.EncodingType.UTF8,
      });

      // Use expo-sharing to share the file
      if (!(await Sharing.isAvailableAsync())) {
        Alert.alert('Sharing is not available on your platform');
        return;
      }

      await Sharing.shareAsync(fileUri);
      onDataOperation(); // Trigger reload after export

    } catch (error: any) {
      console.error(error);
      Alert.alert(
        "Export Failed",
        error.message || "An error occurred while exporting data."
      );
    }
  };

  const handleImportData = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: ["application/json"], // Only accept JSON files
      });

      if (result.assets && result.assets.length > 0) {
        const file = result.assets[0];

        // Check file extension
        if (!file.name?.toLowerCase().endsWith(".json")) {
          Alert.alert("Invalid File", "Please select a JSON file.");
          return;
        }

        const fileContent = await FileSystem.readAsStringAsync(file.uri, {
          encoding: FileSystem.EncodingType.UTF8,
        });


        try {
          const importedData = JSON.parse(fileContent);

          // Basic structure validation:
          if (
            !importedData.hasOwnProperty("dailyEntries") ||
            !importedData.hasOwnProperty("foods") ||
            !importedData.hasOwnProperty("settings")
          ) {
            Alert.alert(
              "Import Failed",
              "The imported file is missing required data (dailyEntries, foods, or settings)."
            );
            return;
          }


          await saveDailyEntries(importedData.dailyEntries);
          await saveFoods(importedData.foods);
          await saveSettings(importedData.settings)
          Alert.alert("Import Successful", "Data imported and saved.");
          onDataOperation(); //trigger reload

        } catch (parseError) {
          Alert.alert(
            "Import Failed",
            "The imported file is not valid JSON."
          );
          return;
        }


      } else {
        // Explicitly check for cancelled
        if (result.canceled) {
          // User cancelled, do nothing
        } else {
          Alert.alert("Import Failed", "Invalid file selected.");
        }
      }
    } catch (error: any) {
      console.error("Import Error:", error);
      Alert.alert(
        "Import Failed",
        error.message || "An unknown error occurred."
      );
    }
  };

  const handleClearData = () => setIsConfirmationVisible(true);

  const confirmClearData = async () => {
    if (confirmationText === "CLEAR DATA") {
      try {
        await clearAllData();
        Alert.alert("Data Cleared", "All data has been cleared.");
        onDataOperation(); // Trigger reload after clearing
      } catch (error) {
        Alert.alert("Error", "Failed to clear data.");
      } finally {
        setConfirmationText("");
        setIsConfirmationVisible(false);
      }
    } else {
      Alert.alert("Error", "Incorrect confirmation text.");
    }
  };

  return (
    <>
      <Button
        title="Export Data"
        onPress={handleExportData}
        buttonStyle={{ marginBottom: 10, backgroundColor: theme.colors.primary }}
      />
      <Button
        title="Import Data"
        onPress={handleImportData}
        buttonStyle={{ marginBottom: 10, backgroundColor: theme.colors.primary }}
      />
      <Button
        title="Clear All Data"
        onPress={handleClearData}
        color="error"
        buttonStyle={{ marginBottom: 10 }}
      />

      <ConfirmationModal
        isVisible={isConfirmationVisible}
        onCancel={() => setIsConfirmationVisible(false)}
        onConfirm={confirmClearData}
        confirmationText={confirmationText}
        setConfirmationText={setConfirmationText}
        title="Clear All Data?"
        message="This action cannot be undone. Confirmation Text: CLEAR DATA"
      />
    </>
  );
};

export default DataManagementButtons;
---------- END DataManagementButtons.tsx ----------


---------- FoodItem.tsx ----------
// FoodItem.tsx (Corrected with forwardRef and Icon Handling)
import React, { forwardRef } from "react"; // Import forwardRef
import { StyleSheet, View, Image } from "react-native"; // Import View and Image
import { ListItem, Icon, useTheme, Button } from "@rneui/themed";
import { Food } from "../types/food";
import Toast from "react-native-toast-message";

interface FoodItemProps {
  food: Food;
  onEdit: (food: Food) => void;
  onDelete: (foodId: string) => void;
  onUndoDelete: (food: Food) => void;
  foodIconUrl: string | null; // Add foodIconUrl prop
}

// Use forwardRef to receive the ref from the parent
const FoodItem = forwardRef<any, FoodItemProps>(
  ({ food, onEdit, onDelete, onUndoDelete, foodIconUrl }, ref) => {
    const { theme } = useTheme();

    const handleDelete = () => {
      onDelete(food.id);
      Toast.show({
        type: "success",
        text1: `${food.name} deleted`,
        text2: "Tap to undo",
        position: "bottom",
        bottomOffset: 80,
        onPress: () => onUndoDelete(food), // Call undo function
        visibilityTime: 3000, // Show for 3 seconds
      });
    };

    return (
      // Attach the received ref to ListItem.Swipeable
      <ListItem.Swipeable
        ref={ref} // Pass the forwarded ref here!
        bottomDivider
        leftContent={(reset) => (
          <Button
            title="Edit"
            onPress={() => {
              onEdit(food);
              reset();
            }}
            icon={{ name: "edit", color: "white" }}
            buttonStyle={styles.swipeButtonEdit}
          />
        )}
        rightContent={(reset) => (
          <Button
            title="Delete"
            onPress={handleDelete} // Call handleDelete
            icon={{ name: "delete", color: "white" }}
            buttonStyle={styles.swipeButtonDelete}
          />
        )}
        containerStyle={[
          styles.listItemContainer,
          { backgroundColor: theme.colors.background },
        ]}
      >
        {/* Use Image component if foodIconUrl exists, otherwise use default Icon */}
        {foodIconUrl ? (
          <Image source={{ uri: foodIconUrl }} style={styles.foodIcon} />
        ) : (
          <Icon
            name="fast-food-outline"
            type="ionicon"
            color={theme.colors.text}
          />
        )}
        <ListItem.Content>
          <ListItem.Title style={[styles.title, { color: theme.colors.text }]}>
            {food.name}
          </ListItem.Title>
          <ListItem.Subtitle style={{ color: theme.colors.text }}>
            {`Cal: ${food.calories}, P: ${food.protein}g, C: ${food.carbs}g, F: ${food.fat}g`}
          </ListItem.Subtitle>
        </ListItem.Content>
        <ListItem.Chevron />
      </ListItem.Swipeable>
    );
  }
);

const styles = StyleSheet.create({
  listItemContainer: {
    paddingVertical: 15,
    borderRadius: 0,
    marginVertical: 0,
  },
  title: {
    fontWeight: "bold",
    fontSize: 16,
  },
  swipeButtonEdit: {
    minHeight: "100%",
    backgroundColor: "orange",
  },
  swipeButtonDelete: {
    minHeight: "100%",
    backgroundColor: "red",
  },
  foodIcon: {
    width: 30,
    height: 30,
    marginRight: 10,
    borderRadius: 15,
    resizeMode: "stretch", // Or 'cover', or 'stretch', see below
  },
});

export default FoodItem;

---------- END FoodItem.tsx ----------


---------- StatisticsChart.tsx ----------
// components/StatisticsChart.tsx (Modified)
import React from "react";
import { View, StyleSheet } from "react-native";
import { WebView } from "react-native-webview";
import { Statistics, MacroType, macros } from "../types/settings"; // Import types
import { useTheme } from "@rneui/themed";


interface StatisticsChartProps {
  statistics: Statistics;
}

const StatisticsChart: React.FC<StatisticsChartProps> = ({ statistics }) => {

  const { theme } = useTheme();

  const generateChartHTML = () => {
    const chartData = macros.reduce((acc, macro) => {
      // Prepare data for each macro, including goal if applicable
      acc[macro] = statistics[macro].map((series) =>
        series.map((item) => [item.x / 1000, item.y])
      );
      return acc;
    }, {} as { [key in MacroType]: number[][][] });

    const textColor = theme.colors.text;
    const gridColor = theme.colors.grey5; // Lighter grid
    const axisColor = theme.colors.grey3; // Slightly darker axis
    const fontFamily = "Helvetica, Arial, sans-serif";

    // Define color palette for the lines, using theme colors if possible
    const lineColors = {
      calories: theme.colors.primary,
      protein: theme.colors.success,
      carbs: theme.colors.warning,
      fat: theme.colors.error,
    };


    // Re-enabled caching, but *only* cache the HTML itself, not the data.  The data is now dynamic.
    return `
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>Macro Charts</title>
            <style>
            body { font-family: ${fontFamily}; margin: 0; padding: 0; background-color: ${theme.colors.background}; color: ${textColor};}
                .chart-container { width: 95%; height: 250px; margin: 10px auto; }
            </style>
            <link rel="stylesheet" href="https://unpkg.com/uplot@1.6.27/dist/uPlot.min.css">
            <script src="https://unpkg.com/uplot@1.6.27/dist/uPlot.iife.min.js"></script>
        </head>
        <body>
            ${macros
      .map((macro) => {
        const isCalories = macro === "calories";
        const seriesCount = isCalories ? 2 : 1; // Two series for calories (intake, goal)

        const seriesConfig = isCalories
          ? `[
                      {},
                      {
                        stroke: "${lineColors[macro] || theme.colors.primary}",
                        width: 2,
                        label: "Intake",
                        points: { show: false }
                      },
                      {
                        stroke: "red",
                        width: 1,
                        dash: [5, 5],
                        label: "Goal",
                        points: { show: false }
                      }
                    ]`
          : `[
                      {},
                      {
                        stroke: "${lineColors[macro] || theme.colors.primary}",
                        width: 2,
                        label: "${macro.charAt(0).toUpperCase() + macro.slice(1)}",
                        points: { show: false }
                      }
                    ]`;


        const uPlotData =
          seriesCount === 2
            ? `[data[0].map(d => d[0]), data[0].map(d => d[1]), data[1].map(d => d[1])]`
            : `[data[0].map(d => d[0]), data[0].map(d => d[1])]`;



        return `
                <div id="${macro}-chart" class="chart-container"></div>
                <script>
                    const data = ${JSON.stringify(chartData[macro])};
                    const opts = {
                        title: "${macro.charAt(0).toUpperCase() + macro.slice(1)}",
                        width: window.innerWidth * 0.95,
                        height: 250,
                        scales: {
                            x: { time: true },
                            y: { },
                        },
                        axes: [
                            {
                                stroke: "${textColor}",
                                font: "14px ${fontFamily}",
                            grid: {
                                    stroke: "${gridColor}",
                                    width: 1
                                },
                                ticks: {
                                    stroke: "${gridColor}",
                                    width: 1
                                }
                            },
                            {
                                stroke: "${textColor}",
                                font: "14px ${fontFamily}",
                                grid: {
                                    stroke: "${gridColor}",
                                    width: 1
                                },
                                ticks: {
                                    stroke: "${gridColor}",
                                    width: 1
                                }
                            }
                        ],
                        series: ${seriesConfig},
                        cursor: {
                            drag: { setScale: false },
                            points: {
                                size: 6,
                                fill: (self, i) => self.series[i]._stroke,
                                stroke: (self, i) => self.series[i]._stroke,
                            }
                        },
                        ${isCalories ? `
                        hooks: {
                            draw: [
                                (u) => {
                                   const ctx = u.ctx;
                                    u.series.forEach((series, seriesIdx) => {
                                      if (seriesIdx === 1) {
                                        const intakeData = data[0];
                                        const goalData = data[1];

                                        ctx.beginPath();
                                        ctx.fillStyle = "rgba(255, 0, 0, 0.3)"; // Semi-transparent red

                                        for (let i = 0; i < intakeData.length; i++) {
                                          const intakeY = intakeData[i][1];
                                          const goalY = goalData[i][1];
                                          const x = u.valToPos(intakeData[i][0], "x", true);
                                          
                                           // Check if intake exceeds the goal
                                            if(intakeY > goalY){
                                                const intakeYPos = u.valToPos(intakeY, 'y', true);
                                                const goalYPos = u.valToPos(goalY, 'y', true);
                                               
                                                //if this is the first point or last point, move to x, other wise line to x
                                                if(i === 0){
                                                   ctx.moveTo(x, intakeYPos);
                                                }else{
                                                  ctx.lineTo(x, intakeYPos);
                                                }
                                            }
                                        }
                                        //go back along the goal data
                                         for (let i = intakeData.length-1; i >= 0; i--) {
                                            const intakeY = intakeData[i][1];
                                            const goalY = goalData[i][1];
                                             const x = u.valToPos(intakeData[i][0], "x", true);
                                               // Check if intake exceeds the goal
                                            if(intakeY > goalY){
                                                 const goalYPos = u.valToPos(goalY, 'y', true);
                                                ctx.lineTo(x, goalYPos);
                                            }
                                         }

                                        ctx.closePath();
                                        ctx.fill();
                                        }

                                    });

                                }
                            ]
                        }
                        ` : ''}
                    };
                    new uPlot(opts, ${uPlotData}, document.getElementById('${macro}-chart'));
                </script>
            `;
      })
      .join("")}
        </body>
        </html>
        `;

  };

  return (
    <View style={styles.webViewContainer}>
      <WebView
        originWhitelist={["*"]}
        source={{ html: generateChartHTML() }}
        style={styles.webView}
        scalesPageToFit={false}
        scrollEnabled={false}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  webViewContainer: {
    height: 'auto',
    width: "100%",
    marginTop: 10,
  },
  webView: {
    height: 340, // Explicit height, adjust as needed.
  },
});

export default StatisticsChart;
---------- END StatisticsChart.tsx ----------


---------- ThemeSwitch.tsx ----------
// components/ThemeSwitch.tsx (Corrected)
import React from "react";
import { ListItem, Switch } from "@rneui/themed";
import { useTheme } from "@rneui/themed";

interface ThemeSwitchProps {
  currentTheme: 'light' | 'dark' | 'system'; // Use theme string
  onToggle: (theme: 'light' | 'dark' | 'system') => void; // Pass the theme string
}

const ThemeSwitch: React.FC<ThemeSwitchProps> = ({ currentTheme, onToggle }) => {
  const { theme } = useTheme();

  return (
    <ListItem
      bottomDivider
      containerStyle={{ backgroundColor: theme.colors.background }}
    >
      <ListItem.Content>
        <ListItem.Title style={{ color: theme.colors.text }}>
          Dark Mode
        </ListItem.Title>
      </ListItem.Content>
      <Switch
        value={currentTheme === 'dark'} // Correctly reflect theme
        onValueChange={(newValue) => {
          onToggle(newValue ? 'dark' : 'light'); // Toggle between 'light' and 'dark'
        }}
      />
    </ListItem>
  );
};

export default ThemeSwitch;
---------- END ThemeSwitch.tsx ----------


---------- AppNavigator.tsx ----------
// navigation/AppNavigator.tsx
import React, { useState, useCallback } from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { Icon, useTheme } from '@rneui/themed';
import DailyEntryScreen from '../screens/DailyEntryScreen';
import FoodListScreen from '../screens/FoodListScreen';
import SettingsScreen from '../screens/SettingsScreen';

const Tab = createBottomTabNavigator();

interface AppNavigatorProps {
  onThemeChange: (theme: 'light' | 'dark' | 'system') => void;
}

const AppNavigator: React.FC<AppNavigatorProps> = ({ onThemeChange }) => {
  const { theme } = useTheme();
  const [foodListRefresh, setFoodListRefresh] = useState(false);

  const handleFoodChange = useCallback(() => {
    setFoodListRefresh(prev => !prev); // Toggle the state to trigger refresh
  }, []);

  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        tabBarIcon: ({ focused, color, size }) => {
          let iconName: string = '';
          let type: string = '';

          if (route.name === 'Daily Entry') {
            iconName = focused ? 'calendar' : 'calendar-outline';
            type = 'ionicon';
          } else if (route.name === 'Foods') {
            iconName = focused ? 'fast-food' : 'fast-food-outline';
            type = 'ionicon'; // Consistent icon set
          } else if (route.name === 'Settings') {
            iconName = focused ? 'settings' : 'settings-outline';
            type = 'ionicon';
          }

          return <Icon name={iconName} type={type} size={size} color={color} />;
        },
        tabBarActiveTintColor: theme.colors.primary,
        tabBarInactiveTintColor: theme.colors.secondary, // Use secondary color
        headerShown: false,
        tabBarStyle: {
          backgroundColor: theme.colors.background,
          borderTopColor: theme.colors.divider, // Add a subtle border
        },
        tabBarLabelStyle: {
          fontWeight: 'bold', // Make labels more prominent
        }
      })}
    >
      <Tab.Screen name="Daily Entry">
        {() => <DailyEntryScreen key={foodListRefresh ? 'refresh' : 'normal'} />}
      </Tab.Screen>
      <Tab.Screen name="Foods">
        {() => <FoodListScreen onFoodChange={handleFoodChange} />}
      </Tab.Screen>
      <Tab.Screen name="Settings">
        {() => <SettingsScreen onThemeChange={onThemeChange} onDataOperation={function (): void {
          throw new Error('Function not implemented.');
        } } />}
      </Tab.Screen>
    </Tab.Navigator>
  );
};

export default AppNavigator;
---------- END AppNavigator.tsx ----------


---------- DailyEntryScreen.tsx ----------
// src/screens/DailyEntryScreen.tsx
// src/screens/DailyEntryScreen.tsx (Update icon fetching)
import React, { useState, useEffect, useCallback, useMemo } from "react";
import {
  View,
  FlatList,
  Alert,
  Platform,
  Image,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
} from "react-native";
import { DailyEntry, DailyEntryItem } from "../types/dailyEntry";
import { Food } from "../types/food";
import { getFoods } from "../services/foodService";
import {
  saveDailyEntries,
  loadDailyEntries,
  loadSettings,
} from "../services/storageService";
import { formatDateReadable, getTodayDateString } from "../utils/dateUtils";
import { isValidNumberInput } from "../utils/validationUtils";
import DailyProgress from "../components/DailyProgress";
import {
  Button,
  Text,
  ListItem,
  FAB,
  makeStyles,
  useTheme,
  Divider,
  Input,
} from "@rneui/themed";
import DateTimePicker from "@react-native-community/datetimepicker";
import { addDays, subDays, parseISO, formatISO } from "date-fns";
import { Icon } from "@rneui/base";
import { SafeAreaView } from "react-native-safe-area-context";
import AddEntryModal from "../components/AddEntryModal";
import "react-native-get-random-values";
import Toast from "react-native-toast-message";
import { useFocusEffect } from "@react-navigation/native";
import { getFoodIconUrl } from "../utils/iconUtils"; // Uses backend service now, but keeps local cache

// Interface for daily goals structure
interface DailyGoals {
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
}

const DailyEntryScreen: React.FC = () => {
  // State variables (most remain the same)
  const [dailyEntries, setDailyEntries] = useState<DailyEntry[]>([]);
  const [selectedDate, setSelectedDate] = useState<string>(
    getTodayDateString()
  );
  const [foods, setFoods] = useState<Food[]>([]);
  const [selectedFood, setSelectedFood] = useState<Food | null>(null);
  const [grams, setGrams] = useState("");
  const [isOverlayVisible, setIsOverlayVisible] = useState(false);
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [dailyGoals, setDailyGoals] = useState<DailyGoals>({
    calories: 2000,
    protein: 50,
    carbs: 200,
    fat: 70,
  });
  const [editingIndex, setEditingIndex] = useState<number | null>(null); // Inline edit original index
  const [tempGrams, setTempGrams] = useState(""); // Inline edit temp grams
  const [search, setSearch] = useState("");
  const [editIndex, setEditIndex] = useState<number | null>(null); // Modal edit reversed index
  const [foodIcons, setFoodIcons] = useState<{
    [foodName: string]: string | null | undefined;
  }>({}); // Cache state: undefined=not_checked, null=failed/no_icon, string=url

  const { theme } = useTheme();
  const styles = useStyles();

  // --- Data Loading and Icon Fetching ---

  const loadData = useCallback(async () => {
    try {
      const [loadedFoods, loadedEntries, loadedSettings] = await Promise.all([
        getFoods(),
        loadDailyEntries(),
        loadSettings(),
      ]);

      if (loadedSettings.dailyGoals) {
        setDailyGoals(loadedSettings.dailyGoals);
      }

      setFoods(loadedFoods);
      setDailyEntries(loadedEntries);

      // Trigger Icon Fetching for relevant foods (current day + all known)
      triggerIconFetches(loadedFoods, loadedEntries, selectedDate);
    } catch (error) {
      console.error("Error loading data:", error);
      Alert.alert("Error", "Failed to load necessary data.");
      setFoods([]);
      setDailyEntries([]);
    }
  }, [selectedDate]); // Re-run if selectedDate changes

  // Function to trigger icon fetches without blocking
  const triggerIconFetches = useCallback(
    (allFoods: Food[], allEntries: DailyEntry[], currentDate: string) => {
      const relevantFoodNames = new Set<string>();
      allFoods.forEach((f) => relevantFoodNames.add(f.name));
      const currentOriginalEntry = allEntries.find(
        (entry) => entry.date === currentDate
      );
      if (currentOriginalEntry) {
        currentOriginalEntry.items.forEach((item) =>
          relevantFoodNames.add(item.food.name)
        );
      }

      console.log(
        `Triggering icon fetches for ${relevantFoodNames.size} unique food names.`
      );

      relevantFoodNames.forEach((foodName) => {
        // Check if icon status is unknown (undefined) before fetching
        if (foodIcons[foodName] === undefined) {
          // Mark as loading immediately (optional visual cue could use this)
          // setFoodIcons(prev => ({ ...prev, [foodName]: undefined })); // Keep as undefined while loading

          // Fetch async, update state individually on resolve/reject
          getFoodIconUrl(foodName)
            .then((iconUrl) => {
              setFoodIcons((prevIcons) => ({
                ...prevIcons,
                [foodName]: iconUrl,
              })); // Store URL or null
            })
            .catch((error) => {
              console.warn(
                `Icon fetch failed for ${foodName} in background:`,
                error
              );
              // Ensure state reflects failure
              setFoodIcons((prevIcons) => ({ ...prevIcons, [foodName]: null }));
            });
        }
      });
    },
    [foodIcons]
  ); // Depend on foodIcons state to avoid re-fetching known icons

  // Load data when the screen comes into focus or selectedDate changes
  useFocusEffect(
    useCallback(() => {
      loadData(); // Will also trigger icon fetches
      return () => {
        // Cleanup
        setSearch("");
        setIsOverlayVisible(false);
        setEditingIndex(null);
        setTempGrams("");
      };
    }, [loadData]) // loadData dependency includes selectedDate
  );

  // --- List and Index Management ---
  const currentEntryItems = useMemo(() => {
    const entry = dailyEntries.find((e) => e.date === selectedDate);
    return entry ? [...entry.items].reverse() : [];
  }, [dailyEntries, selectedDate]);

  const getOriginalIndex = useCallback(
    (reversedIndex: number): number => {
      const entry = dailyEntries.find((e) => e.date === selectedDate);
      if (!entry || reversedIndex < 0 || reversedIndex >= entry.items.length) {
        return -1;
      }
      return entry.items.length - 1 - reversedIndex;
    },
    [dailyEntries, selectedDate]
  );

  // --- State Update Helper ---
  const updateAndSaveEntries = useCallback(
    async (updatedEntries: DailyEntry[]) => {
      const entryForSelectedDate = updatedEntries.find(
        (e) => e.date === selectedDate
      );
      console.log(
        `DailyEntryScreen: updateAndSaveEntries. Saving ${
          updatedEntries.length
        } total entries. Entry for ${selectedDate} contains ${
          entryForSelectedDate?.items?.length ?? 0
        } items.`
      );
      setDailyEntries(updatedEntries);
      try {
        await saveDailyEntries(updatedEntries);
      } catch (error) {
        console.error(
          "DailyEntryScreen: Failed to save updated entries:",
          error
        );
        Alert.alert("Save Error", "Could not save changes.");
        // Optionally revert state or reload data
      }
    },
    [selectedDate]
  ); // Depend on selectedDate? Maybe not needed here if only structure matters.

  // --- Inline Editing Handlers ---
  const handleStartEditing = (reversedIndex: number) => {
    const originalIndex = getOriginalIndex(reversedIndex);
    if (originalIndex === -1) return;
    const currentEntry = dailyEntries.find((e) => e.date === selectedDate);
    if (!currentEntry) return;
    setEditingIndex(originalIndex);
    setTempGrams(String(currentEntry.items[originalIndex].grams));
  };

  const handleSaveInlineEdit = useCallback(async () => {
    if (editingIndex === null) return;

    const trimmedGrams = tempGrams.trim();
    if (!isValidNumberInput(trimmedGrams) || parseFloat(trimmedGrams) <= 0) {
      Alert.alert(
        "Invalid Input",
        "Please enter a valid, positive number for grams."
      );
      return;
    }
    const newGramsValue = parseFloat(trimmedGrams);

    const updatedEntries = dailyEntries.map((entry) => {
      if (entry.date === selectedDate) {
        const updatedItems = entry.items.map((item, index) => {
          if (index === editingIndex) {
            return { ...item, grams: newGramsValue };
          }
          return item;
        });
        return { ...entry, items: updatedItems };
      }
      return entry;
    });

    await updateAndSaveEntries(updatedEntries);
    setEditingIndex(null);
    setTempGrams("");
  }, [
    editingIndex,
    tempGrams,
    dailyEntries,
    selectedDate,
    updateAndSaveEntries,
  ]);

  const handleCancelInlineEdit = () => {
    setEditingIndex(null);
    setTempGrams("");
  };
  // --- End Inline Editing ---

  // --- Add/Update/Remove Entry Handlers ---
  const handleSingleEntryAction = useCallback(async () => {
    if (!selectedFood || !selectedFood.id) {
      Alert.alert("Food Not Selected", "Please select a valid food item.");
      return;
    }
    const trimmedGrams = grams.trim();
    if (!isValidNumberInput(trimmedGrams) || parseFloat(trimmedGrams) <= 0) {
      Alert.alert(
        "Invalid Amount",
        "Please enter a valid positive number for grams."
      );
      return;
    }
    const numericGrams = parseFloat(trimmedGrams);
    const entryItem: DailyEntryItem = {
      food: selectedFood,
      grams: numericGrams,
    };

    const existingEntryIndex = dailyEntries.findIndex(
      (entry) => entry.date === selectedDate
    );
    let updatedEntries: DailyEntry[];

    if (existingEntryIndex > -1) {
      const existingEntry = dailyEntries[existingEntryIndex];
      let updatedItems;
      if (editIndex !== null) {
        // Modal Edit Mode
        const originalEditIndex = getOriginalIndex(editIndex);
        if (originalEditIndex === -1) {
          console.error("Error updating entry: Could not find original index.");
          setIsOverlayVisible(false);
          return;
        }
        updatedItems = existingEntry.items.map((item, index) =>
          index === originalEditIndex ? entryItem : item
        );
      } else {
        // Adding new single item
        updatedItems = [...existingEntry.items, entryItem];
      }
      const updatedEntry = { ...existingEntry, items: updatedItems };
      updatedEntries = dailyEntries.map((entry) =>
        entry.date === selectedDate ? updatedEntry : entry
      );
    } else {
      // New entry for the date
      const newDailyEntry: DailyEntry = {
        date: selectedDate,
        items: [entryItem],
      };
      updatedEntries = [...dailyEntries, newDailyEntry];
      updatedEntries.sort((a, b) => a.date.localeCompare(b.date));
    }

    await updateAndSaveEntries(updatedEntries);

    // Trigger icon fetch for the added/edited food if needed
    if (foodIcons[selectedFood.name] === undefined) {
      triggerIconFetches([selectedFood], [], selectedDate); // Pass only the relevant food
    }

    setSelectedFood(null);
    setGrams("");
    setEditIndex(null);
    setIsOverlayVisible(false);
    setSearch("");
  }, [
    selectedFood,
    grams,
    editIndex,
    dailyEntries,
    selectedDate,
    getOriginalIndex,
    updateAndSaveEntries,
    foodIcons,
    triggerIconFetches,
  ]);

  // --- NEW: Handle Adding Multiple Entries ---
  const handleAddMultipleEntries = useCallback(
    async (entriesToAdd: { food: Food; grams: number }[]) => {
      console.log(
        "DailyEntryScreen: handleAddMultipleEntries START - Received:",
        entriesToAdd.length,
        "items"
      );
      try {
        if (!entriesToAdd || entriesToAdd.length === 0) return;

        const newItems: DailyEntryItem[] = entriesToAdd.map((entry) => ({
          food: entry.food, // Contains unique ID generated in modal
          grams: entry.grams,
        }));
        console.log(
          `DailyEntryScreen: Mapped to ${newItems.length} DailyEntryItems for ${selectedDate}`
        );

        const existingEntryIndex = dailyEntries.findIndex(
          (entry) => entry.date === selectedDate
        );
        let updatedEntries: DailyEntry[];

        if (existingEntryIndex > -1) {
          console.log(
            `DailyEntryScreen: Appending to existing entry for ${selectedDate}.`
          );
          const existingEntry = dailyEntries[existingEntryIndex];
          const updatedItems = [...existingEntry.items, ...newItems];
          const updatedEntry = { ...existingEntry, items: updatedItems };
          updatedEntries = dailyEntries.map((entry, index) =>
            index === existingEntryIndex ? updatedEntry : entry
          );
        } else {
          console.log(
            `DailyEntryScreen: Creating new entry for ${selectedDate}.`
          );
          const newDailyEntry: DailyEntry = {
            date: selectedDate,
            items: newItems,
          };
          updatedEntries = [...dailyEntries, newDailyEntry];
          updatedEntries.sort((a, b) => a.date.localeCompare(b.date));
        }

        await updateAndSaveEntries(updatedEntries);
        console.log("DailyEntryScreen: updateAndSaveEntries completed.");

        // Trigger icon fetches for the newly added foods
        const foodsToFetchIconsFor = newItems.map((item) => item.food);
        triggerIconFetches(foodsToFetchIconsFor, [], selectedDate);

        Toast.show({
          type: "success",
          text1: `${entriesToAdd.length} item(s) added to ${formatDateReadable(
            selectedDate
          )}`,
          position: "bottom",
          visibilityTime: 3000,
        });

        // Close the modal AFTER state update and save
        setIsOverlayVisible(false);
        setSelectedFood(null);
        setGrams("");
        setEditIndex(null);
        setSearch("");
      } catch (error) {
        console.error(
          "!!!!! CRITICAL ERROR inside handleAddMultipleEntries !!!!!",
          error
        );
        Alert.alert(
          "Quick Add Error",
          `Failed to process items. Error: ${
            error instanceof Error ? error.message : String(error)
          }`
        );
        // Close modal even on error? Or leave it open? Let's close it.
        setIsOverlayVisible(false);
      }
    },
    [dailyEntries, selectedDate, updateAndSaveEntries, triggerIconFetches]
  );
  // --- End NEW FUNCTION ---

  const handleSelectFood = (item: Food | null) => {
    setSelectedFood(item);
  };

  const handleRemoveEntry = useCallback(
    async (reversedIndex: number) => {
      const originalIndex = getOriginalIndex(reversedIndex);
      if (originalIndex === -1) return;

      const currentEntry = dailyEntries.find((e) => e.date === selectedDate);
      if (!currentEntry || originalIndex >= currentEntry.items.length) return;

      const itemToRemove = currentEntry.items[originalIndex];
      const updatedItems = currentEntry.items.filter(
        (_, i) => i !== originalIndex
      );
      let finalEntries: DailyEntry[];

      if (updatedItems.length === 0) {
        finalEntries = dailyEntries.filter(
          (entry) => entry.date !== selectedDate
        );
      } else {
        const updatedEntry = { ...currentEntry, items: updatedItems };
        finalEntries = dailyEntries.map((entry) =>
          entry.date === selectedDate ? updatedEntry : entry
        );
      }

      await updateAndSaveEntries(finalEntries);

      Toast.show({
        type: "info",
        text1: `${itemToRemove.food.name} deleted`,
        text2: "Tap here to undo",
        position: "bottom",
        bottomOffset: 80,
        visibilityTime: 4000,
        onPress: () =>
          handleUndoRemoveEntry(itemToRemove, selectedDate, originalIndex),
      });
    },
    [dailyEntries, selectedDate, getOriginalIndex, updateAndSaveEntries]
  ); // Added handleUndoRemoveEntry dependency

  const handleUndoRemoveEntry = useCallback(
    async (
      itemToRestore: DailyEntryItem,
      entryDate: string,
      originalIndex: number
    ) => {
      console.log(
        `Undoing removal of ${itemToRestore.food.name} at index ${originalIndex} on ${entryDate}`
      );
      const existingEntryIndex = dailyEntries.findIndex(
        (e) => e.date === entryDate
      );
      let updatedEntries;

      if (existingEntryIndex > -1) {
        const entryToUpdate = dailyEntries[existingEntryIndex];
        const updatedItems = [...entryToUpdate.items];
        updatedItems.splice(originalIndex, 0, itemToRestore);
        const restoredEntry = { ...entryToUpdate, items: updatedItems };
        updatedEntries = dailyEntries.map((entry, index) =>
          index === existingEntryIndex ? restoredEntry : entry
        );
      } else {
        const newEntry: DailyEntry = {
          date: entryDate,
          items: [itemToRestore],
        };
        updatedEntries = [...dailyEntries, newEntry];
        updatedEntries.sort((a, b) => a.date.localeCompare(b.date));
      }

      await updateAndSaveEntries(updatedEntries);
      Toast.hide();
      Toast.show({
        type: "success",
        text1: "Entry restored!",
        visibilityTime: 1500,
        position: "bottom",
      });
    },
    [dailyEntries, updateAndSaveEntries]
  ); // Ensure dependencies are correct

  const updateSearch = (search: string) => setSearch(search);

  // --- Modal Toggle Logic ---
  const toggleOverlay = useCallback(
    (
      itemToEdit: DailyEntryItem | null = null,
      reversedIndex: number | null = null
    ) => {
      if (itemToEdit && reversedIndex !== null) {
        // Setup for MODAL EDIT
        console.log(
          `Opening modal to edit item at reversed index ${reversedIndex}`
        );
        setSelectedFood(itemToEdit.food);
        setGrams(String(itemToEdit.grams));
        setEditIndex(reversedIndex);
        setIsOverlayVisible(true);
      } else {
        // Setup for ADD or Closing
        console.log("Toggling modal for Add or Closing.");
        setSelectedFood(null);
        setGrams("");
        setEditIndex(null);
        setSearch(""); // Clear search on close/add open
        setIsOverlayVisible((current) => !current); // Toggle visibility
      }
    },
    []
  ); // No dependencies needed if it only manipulates state

  const handleEditEntryViaModal = (
    item: DailyEntryItem,
    reversedIndex: number
  ) => {
    toggleOverlay(item, reversedIndex);
  };
  // --- End Modal Toggle ---

  // --- Date Navigation Handlers ---
  const handleDateChange = useCallback(
    (event: any, selectedDateValue?: Date) => {
      const isAndroidDismiss =
        Platform.OS === "android" && event.type === "dismissed";
      setShowDatePicker(Platform.OS === "ios");

      if (!isAndroidDismiss && event.type === "set" && selectedDateValue) {
        const formattedDate = formatISO(selectedDateValue, {
          representation: "date",
        });
        if (formattedDate !== selectedDate) {
          console.log(`Date changed to: ${formattedDate}`);
          setSelectedDate(formattedDate); // This will trigger useFocusEffect -> loadData -> triggerIconFetches
          setEditingIndex(null); // Cancel inline edit when changing date
          setTempGrams("");
        }
      } else if (Platform.OS === "android") {
        setShowDatePicker(false);
      }
    },
    [selectedDate]
  ); // Depend on selectedDate to compare

  const handlePreviousDay = useCallback(() => {
    try {
      const currentDate = parseISO(selectedDate);
      const newDate = subDays(currentDate, 1);
      setSelectedDate(formatISO(newDate, { representation: "date" }));
      setEditingIndex(null);
      setTempGrams(""); // Cancel inline edit
    } catch (e) {
      console.error("Error parsing date:", selectedDate, e);
    }
  }, [selectedDate]);

  const handleNextDay = useCallback(() => {
    try {
      const currentDate = parseISO(selectedDate);
      const newDate = addDays(currentDate, 1);
      setSelectedDate(formatISO(newDate, { representation: "date" }));
      setEditingIndex(null);
      setTempGrams(""); // Cancel inline edit
    } catch (e) {
      console.error("Error parsing date:", selectedDate, e);
    }
  }, [selectedDate]);
  // --- End Date Navigation ---

  // --- Totals Calculation ---
  const calculateTotals = useMemo(() => {
    const currentOriginalEntry = dailyEntries.find(
      (entry) => entry.date === selectedDate
    );
    let totals = {
      totalCalories: 0,
      totalProtein: 0,
      totalCarbs: 0,
      totalFat: 0,
    };

    if (currentOriginalEntry) {
      currentOriginalEntry.items.forEach((item) => {
        if (item.food) {
          // Ensure food object exists
          totals.totalCalories += (item.food.calories / 100) * item.grams || 0;
          totals.totalProtein += (item.food.protein / 100) * item.grams || 0;
          totals.totalCarbs += (item.food.carbs / 100) * item.grams || 0;
          totals.totalFat += (item.food.fat / 100) * item.grams || 0;
        }
      });
    }

    // Round totals at the end
    return {
      totalCalories: Math.round(totals.totalCalories),
      totalProtein: Math.round(totals.totalProtein),
      totalCarbs: Math.round(totals.totalCarbs),
      totalFat: Math.round(totals.totalFat),
    };
  }, [dailyEntries, selectedDate]);

  // --- Render ---
  return (
    <SafeAreaView style={styles.container} edges={["top", "left", "right"]}>
      {/* Date Navigation Header */}
      <View style={styles.dateNavigation}>
        <Button
          type="clear"
          onPress={handlePreviousDay}
          icon={
            <Icon
              name="chevron-back-outline"
              type="ionicon"
              color={theme.colors.text}
              size={28}
            />
          }
          buttonStyle={styles.navButton}
        />
        <TouchableOpacity onPress={() => setShowDatePicker(true)}>
          <Text h4 style={styles.dateText}>
            {" "}
            {formatDateReadable(selectedDate)}{" "}
          </Text>
        </TouchableOpacity>
        <Button
          type="clear"
          onPress={handleNextDay}
          icon={
            <Icon
              name="chevron-forward-outline"
              type="ionicon"
              color={theme.colors.text}
              size={28}
            />
          }
          buttonStyle={styles.navButton}
        />
      </View>

      {/* Date Picker */}
      {showDatePicker && (
        <DateTimePicker
          value={parseISO(selectedDate)}
          mode="date"
          display={Platform.OS === "ios" ? "spinner" : "default"}
          onChange={handleDateChange}
          // maximumDate={new Date()} // Optional constraint
        />
      )}

      {/* Progress Bars */}
      <DailyProgress
        calories={calculateTotals.totalCalories}
        protein={calculateTotals.totalProtein}
        carbs={calculateTotals.totalCarbs}
        fat={calculateTotals.totalFat}
        goals={dailyGoals}
      />
      <Divider style={styles.divider} />

      <Text h4 style={[styles.sectionTitle, { color: theme.colors.text }]}>
        {" "}
        Today's Entries{" "}
      </Text>

      {/* Entries List */}
      <FlatList
        data={currentEntryItems}
        keyExtractor={(item, index) =>
          `entry-${item.food.id}-${index}-${item.grams}`
        } // Use food.id
        renderItem={({ item, index: reversedIndex }) => {
          const originalIndex = getOriginalIndex(reversedIndex);
          const isInlineEditing = editingIndex === originalIndex;
          const iconStatus = foodIcons[item.food.name]; // undefined, null, or string URL
          const isLoadingIcon = iconStatus === undefined;

          return (
            <ListItem.Swipeable
              bottomDivider
              leftContent={(reset) => (
                <Button
                  title="Edit"
                  onPress={() => {
                    handleEditEntryViaModal(item, reversedIndex);
                    reset();
                  }}
                  icon={{ name: "edit", color: "white" }}
                  buttonStyle={{
                    minHeight: "100%",
                    backgroundColor: theme.colors.warning,
                  }}
                />
              )}
              rightContent={(reset) => (
                <Button
                  title="Delete"
                  onPress={() => {
                    handleRemoveEntry(reversedIndex);
                    reset();
                  }}
                  icon={{ name: "delete", color: "white" }}
                  buttonStyle={{
                    minHeight: "100%",
                    backgroundColor: theme.colors.error,
                  }}
                />
              )}
              containerStyle={{ backgroundColor: theme.colors.background }}
            >
              {/* Icon Rendering Logic */}
              {isLoadingIcon ? (
                <ActivityIndicator
                  size="small"
                  color={theme.colors.grey3}
                  style={styles.foodIcon}
                />
              ) : iconStatus ? ( // Check if iconStatus is a non-empty string (URL)
                <Image
                  source={{ uri: iconStatus }}
                  style={styles.foodIcon}
                  onError={() => {
                    // Handle Image component specific load error
                    console.warn(
                      `Image component failed to load: ${iconStatus}`
                    );
                    setFoodIcons((prev) => ({
                      ...prev,
                      [item.food.name]: null,
                    })); // Mark as null on error
                  }}
                />
              ) : (
                // Icon fetch failed or no icon found (iconStatus is null)
                <Icon
                  name="restaurant-outline"
                  type="ionicon"
                  color={theme.colors.grey3}
                  containerStyle={styles.defaultIconContainer}
                />
              )}

              {/* Content: Title and Subtitle/Inline Edit */}
              <ListItem.Content>
                <ListItem.Title style={styles.listItemTitle}>
                  {" "}
                  {item.food.name}{" "}
                </ListItem.Title>
                {isInlineEditing ? (
                  <View style={styles.inlineEditContainer}>
                    <Input
                      value={tempGrams}
                      onChangeText={setTempGrams}
                      keyboardType="numeric"
                      containerStyle={styles.inlineInputContainer}
                      inputContainerStyle={styles.inlineInputInnerContainer}
                      inputStyle={styles.inlineInput}
                      autoFocus
                      selectTextOnFocus
                      maxLength={6}
                      onSubmitEditing={handleSaveInlineEdit} // Use callback directly
                      // onBlur={handleSaveInlineEdit} // Consider if needed
                    />
                    <Text style={styles.inlineInputSuffix}>g</Text>
                    <Button
                      type="clear"
                      onPress={handleSaveInlineEdit}
                      icon={
                        <Icon
                          name="checkmark-circle"
                          type="ionicon"
                          color={theme.colors.success}
                          size={24}
                        />
                      }
                      containerStyle={styles.inlineButtonContainer}
                    />
                    <Button
                      type="clear"
                      onPress={handleCancelInlineEdit}
                      icon={
                        <Icon
                          name="close-circle"
                          type="ionicon"
                          color={theme.colors.error}
                          size={24}
                        />
                      }
                      containerStyle={styles.inlineButtonContainer}
                    />
                  </View>
                ) : (
                  <ListItem.Subtitle
                    style={styles.listItemSubtitle}
                    onPress={() => handleStartEditing(reversedIndex)}
                  >
                    {`${item.grams}g  ${Math.round(
                      (item.food.calories / 100) * item.grams
                    )} kcal`}
                  </ListItem.Subtitle>
                )}
              </ListItem.Content>
              {!isInlineEditing && (
                <ListItem.Chevron color={theme.colors.grey3} />
              )}
            </ListItem.Swipeable>
          );
        }}
        ListEmptyComponent={
          <View style={styles.emptyListContainer}>
            <Icon
              name="leaf-outline"
              type="ionicon"
              size={40}
              color={theme.colors.grey3}
            />
            <Text style={styles.emptyListText}>
              No entries for this day yet.
            </Text>
            <Text style={styles.emptyListSubText}>
              Tap the '+' button to add food.
            </Text>
          </View>
        }
        initialNumToRender={10}
        maxToRenderPerBatch={5}
        windowSize={11}
      />

      {/* FAB */}
      <FAB
        icon={<Icon name="add" color="white" />}
        color={theme.colors.primary}
        onPress={() => toggleOverlay()} // Pass no args for 'add' mode
        placement="right"
        size="large"
        style={styles.fab}
      />

      {/* Add/Edit Modal */}
      <AddEntryModal
        isVisible={isOverlayVisible}
        toggleOverlay={toggleOverlay}
        selectedFood={selectedFood}
        grams={grams}
        setGrams={setGrams}
        foods={foods} // Pass local food list for search
        handleAddEntry={handleSingleEntryAction} // Use callback
        handleAddMultipleEntries={handleAddMultipleEntries} // Use callback
        handleSelectFood={handleSelectFood}
        search={search}
        updateSearch={updateSearch}
        isEditMode={editIndex !== null} // Pass boolean for modal edit mode
        // initialGrams removed
      />
    </SafeAreaView>
  );
};

// Styles definition using makeStyles (Keep existing styles)
const useStyles = makeStyles((theme) => ({
  container: { flex: 1, backgroundColor: theme.colors.background },
  dateNavigation: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    paddingVertical: 8,
    paddingHorizontal: 5,
    borderBottomWidth: 1,
    borderBottomColor: theme.colors.divider,
  },
  navButton: { paddingHorizontal: 8 },
  dateText: {
    fontSize: 18,
    fontWeight: "bold",
    color: theme.colors.text,
    textAlign: "center",
    paddingVertical: 5,
  },
  foodIcon: {
    // Covers loading indicator, image, and container size
    width: 40,
    height: 40,
    marginRight: 15,
    borderRadius: 20,
    resizeMode: "contain",
    backgroundColor: theme.colors.grey5,
    alignItems: "center",
    justifyContent: "center",
    overflow: "hidden",
  },
  defaultIconContainer: {
    // Used when iconStatus is null
    width: 40,
    height: 40,
    marginRight: 15,
    borderRadius: 20,
    backgroundColor: theme.colors.grey5,
    alignItems: "center",
    justifyContent: "center",
  },
  listItemTitle: { color: theme.colors.text, fontWeight: "bold", fontSize: 16 },
  listItemSubtitle: { color: theme.colors.grey1, fontSize: 14, marginTop: 3 },
  divider: { marginVertical: 10 },
  sectionTitle: {
    marginTop: 15,
    marginBottom: 8,
    paddingHorizontal: 15,
    fontWeight: "600",
    fontSize: 18,
    color: theme.colors.grey1,
  },
  fab: { position: "absolute", margin: 16, right: 10, bottom: 10 },
  emptyListContainer: {
    flex: 1,
    alignItems: "center",
    justifyContent: "center",
    marginTop: 50,
    paddingHorizontal: 30,
  },
  emptyListText: {
    fontSize: 17,
    color: theme.colors.grey2,
    textAlign: "center",
    marginTop: 10,
  },
  emptyListSubText: {
    fontSize: 14,
    color: theme.colors.grey3,
    textAlign: "center",
    marginTop: 8,
  },
  inlineEditContainer: {
    flexDirection: "row",
    alignItems: "center",
    marginTop: 5,
    width: "100%",
  },
  inlineInputContainer: { width: 80, height: 38, paddingHorizontal: 0 },
  inlineInputInnerContainer: {
    borderBottomWidth: 1,
    borderColor: theme.colors.primary,
    paddingHorizontal: 6,
    height: "100%",
    paddingVertical: 0,
    justifyContent: "center",
  },
  inlineInput: {
    fontSize: 14,
    color: theme.colors.text,
    textAlign: "right",
    paddingVertical: 0,
  },
  inlineInputSuffix: {
    fontSize: 14,
    color: theme.colors.grey1,
    marginLeft: 4,
    marginRight: 10,
  },
  inlineButtonContainer: {
    padding: 0,
    marginLeft: 0,
    minWidth: 30,
    justifyContent: "center",
    alignItems: "center",
  },
}));

export default DailyEntryScreen;

---------- END DailyEntryScreen.tsx ----------


---------- FoodListScreen.tsx ----------
// FoodListScreen.tsx (Corrected)

import React, { useState, useEffect, useCallback } from "react";
import { View, FlatList, Alert, Platform, Image } from "react-native";
import {
    createFood,
    getFoods,
    updateFood,
    deleteFood,
} from "../services/foodService";
import { Food } from "../types/food";
import { isValidNumberInput, isNotEmpty } from "../utils/validationUtils";
import FoodItem from "../components/FoodItem";
import { Button, SearchBar, useTheme, makeStyles } from "@rneui/themed";
import { FAB } from "@rneui/base";
import { SafeAreaView } from "react-native-safe-area-context";
import AddFoodModal from "../components/AddFoodModal";
import Toast from "react-native-toast-message";
import { useFocusEffect } from "@react-navigation/native";
import { Icon } from "@rneui/base";
import { getFoodIconUrl } from "./../utils/iconUtils";

interface FoodListScreenProps {
    onFoodChange?: () => void;
}

const FoodListScreen: React.FC<FoodListScreenProps> = ({ onFoodChange }) => {
    const [foods, setFoods] = useState<Food[]>([]);
    const [foodIcons, setFoodIcons] = useState<{ [foodName: string]: string | null }>({});
    const [isOverlayVisible, setIsOverlayVisible] = useState(false);
    const [search, setSearch] = useState("");
    const [newFood, setNewFood] = useState<Omit<Food, "id">>({
        name: "",
        calories: 0,
        protein: 0,
        carbs: 0,
        fat: 0,
    });
    const [editFood, setEditFood] = useState<Food | null>(null);
    const [errors, setErrors] = useState<{ [key: string]: string }>({});
    const { theme } = useTheme();
    const styles = useStyles();

    const loadFoodData = useCallback(async () => {
        const loadedFoods = await getFoods();
        setFoods(loadedFoods);
    }, []);

    useFocusEffect(
        useCallback(() => {
            loadFoodData();
        }, [loadFoodData])
    );
    useEffect(() => {
        const loadIcons = async () => {
            const icons: { [foodName: string]: string | null } = {};
            for (const food of foods) {
                const iconUrl = await getFoodIconUrl(food.name);
                icons[food.name] = iconUrl;
            }
            setFoodIcons(icons);
        };

        loadIcons();
    }, [foods]);

    const validateFood = (food: Omit<Food, "id">) => {
        const newErrors: { [key: string]: string } = {};
        if (!isNotEmpty(food.name)) newErrors.name = "Name is required";
        if (!isValidNumberInput(String(food.calories)))
            newErrors.calories = "Invalid input";
        if (!isValidNumberInput(String(food.protein)))
            newErrors.protein = "Invalid input";
        if (!isValidNumberInput(String(food.carbs)))
            newErrors.carbs = "Invalid input";
        if (!isValidNumberInput(String(food.fat)))
            newErrors.fat = "Invalid input";

        return Object.keys(newErrors).length === 0 ? null : newErrors;
    };

    const handleCreateFood = async () => {
        const validationErrors = validateFood(newFood);
        if (validationErrors) {
            setErrors(validationErrors);
            return;
        }
        setErrors({});
        try {
            const createdFood = await createFood(newFood);
            setFoods([...foods, createdFood]);
            setNewFood({
                name: "",
                calories: 0,
                protein: 0,
                carbs: 0,
                fat: 0,
            });
            setIsOverlayVisible(false);
            onFoodChange && onFoodChange();
        } catch (error: any) {
            Alert.alert("Error", error.message || "Failed to create food.");
        }
    };

    const handleUpdateFood = async () => {
        if (!editFood) return;
        const validationErrors = validateFood(editFood);
        if (validationErrors) {
            setErrors(validationErrors);
            return;
        }
        setErrors({});
        try {
            const updated = await updateFood(editFood);
            setFoods(foods.map((f) => (f.id === updated.id ? updated : f)));
            setEditFood(null);
            setIsOverlayVisible(false);
            onFoodChange && onFoodChange();
        } catch (error: any) {
            Alert.alert("Error", error.message || "Failed to update food.");
        }
    };

    const handleDeleteFood = async (foodId: string) => {
        const foodToDelete = foods.find((f) => f.id === foodId);
        if (!foodToDelete) return;
        setFoods(foods.filter((f) => f.id !== foodId));

        try {
            await deleteFood(foodId);
            Toast.show({
                type: "success",
                text1: `${foodToDelete.name} deleted`,
                text2: "Tap to undo",
                position: "bottom",
                bottomOffset: 80,
                onPress: () => handleUndoDeleteFood(foodToDelete),
                visibilityTime: 3000,
            });
            onFoodChange && onFoodChange();
        } catch (error) {
            setFoods((prevFoods) => [...prevFoods, foodToDelete]);
            Alert.alert("Error", "Failed to delete food.");
        }
    };

    const handleUndoDeleteFood = (food: Food) => {
        setFoods((prevFoods) => [...prevFoods, food]);
        Toast.hide();
        onFoodChange && onFoodChange();
    };

    const toggleOverlay = (food?: Food) => {
        if (food) {
            setEditFood(food);
        } else {
            setEditFood(null);
            setNewFood({
                name: "",
                calories: 0,
                protein: 0,
                carbs: 0,
                fat: 0,
            });
        }
        setErrors({});
        setIsOverlayVisible(!isOverlayVisible);
    };

    const updateSearch = (search: string) => setSearch(search);

    const filteredFoods = foods.filter((food) =>
        food.name.toLowerCase().includes(search.toLowerCase())
    );

   const handleInputChange = (
        key: keyof Omit<Food, "id">,
        value: string,
        isEdit: boolean
    ) => {
        if (isEdit) {
            setEditFood((prevEditFood) => {
                if (!prevEditFood) return null; // Or some default empty Food object
                return {
                    ...prevEditFood,
                    [key]: key === "name" ? value : value === "" ? 0 : parseFloat(value),
                };
            });
        } else {
            setNewFood((prevNewFood) => ({
                ...prevNewFood,
                [key]: key === "name" ? value : value === "" ? 0 : parseFloat(value),
            }));
        }
    };

    return (
        <SafeAreaView style={styles.container}>
            <SearchBar
                placeholder="Search Foods..."
                onChangeText={updateSearch}
                value={search}
                platform={Platform.OS === "ios" ? "ios" : "android"}
                containerStyle={styles.searchBarContainer}
                inputContainerStyle={[
                    styles.searchBarInputContainer,
                    { backgroundColor: theme.colors.grey5 },
                ]}
                inputStyle={{ color: theme.colors.text }}
            />
            <FlatList
                data={filteredFoods}
                keyExtractor={(item) => item.id}
                renderItem={({ item }) => (
                    <FoodItem
                        food={item}
                        onEdit={toggleOverlay}
                        onDelete={handleDeleteFood}
                        onUndoDelete={handleUndoDeleteFood}
                        foodIconUrl={foodIcons[item.name]}
                    />
                )}
            />

            <FAB
                icon={{ name: "add", color: "white" }}
                color={theme.colors.primary}
                onPress={() => toggleOverlay()}
                placement="right"
                title=""
                style={{ marginBottom: 10, marginRight: 8 }}
            />

            <AddFoodModal
                isVisible={isOverlayVisible}
                toggleOverlay={toggleOverlay}
                newFood={newFood}
                editFood={editFood}
                errors={errors}
                handleInputChange={handleInputChange}
                handleCreateFood={handleCreateFood}
                handleUpdateFood={handleUpdateFood}
                validateFood={validateFood}
                setErrors={setErrors}
            />
        </SafeAreaView>
    );
};

const useStyles = makeStyles((theme) => ({
    container: {
        flex: 1,
        backgroundColor: theme.colors.background,
    },
    searchBarContainer: {
        backgroundColor: "transparent",
        borderBottomColor: "transparent",
        borderTopColor: "transparent",
        marginBottom: 10,
        padding: 0,
    },
    searchBarInputContainer: {
        borderRadius: 10,
    },
      foodIcon: {
      width: 30,
      height: 30,
      marginRight: 10,
      borderRadius: 15,
      resizeMode: "stretch", // Or 'cover', or 'stretch', see below
    },
}));

export default FoodListScreen;
---------- END FoodListScreen.tsx ----------


---------- SettingsScreen.tsx ----------
// SettingsScreen.tsx
import React, { useState, useEffect, useCallback } from "react";
import { View, ScrollView, Alert } from "react-native";
import { Text, makeStyles } from "@rneui/themed";
import DailyGoalsInput from "../components/DailyGoalsInput";
import DataManagementButtons from "../components/DataManagementButtons";
import ThemeSwitch from "../components/ThemeSwitch";
import StatisticsChart from "../components/StatisticsChart";
import { loadSettings, saveSettings, loadDailyEntries } from "../services/storageService";
import { Settings, Statistics, MacroType, MacroData } from "../types/settings";
import { parseISO, isBefore, formatISO } from "date-fns";
import { formatDate, formatDateReadable } from "../utils/dateUtils"; // Use custom formatDate
import { useTheme } from "@rneui/themed";
import { DailyEntry } from "../types/dailyEntry";
import { useFocusEffect } from "@react-navigation/native";

interface SettingsScreenProps {
  onThemeChange: (theme: "light" | "dark" | "system") => void;
  onDataOperation: () => void;
}

const SettingsScreen: React.FC<SettingsScreenProps> = ({ onThemeChange, onDataOperation }) => {
  const [settings, setSettings] = useState<Settings>({
    theme: "system",
    dailyGoals: {
      calories: 2000,
      protein: 50,
      carbs: 200,
      fat: 70,
    },
  });

  const [statistics, setStatistics] = useState<Statistics>({
    calories: [],
    protein: [],
    carbs: [],
    fat: [],
  });
  // Removed settingsHistory
  const [chartUpdateKey, setChartUpdateKey] = useState(0);
  const [dataChangeCounter, setDataChangeCounter] = useState(0);

  const { theme } = useTheme();
  const styles = useStyles();

  const loadInitialSettings = useCallback(async () => {
    const loadedSettings = await loadSettings();

    setSettings((prevSettings) => ({
      ...prevSettings,
      ...loadedSettings,
      dailyGoals: {
        ...prevSettings.dailyGoals,
        ...(loadedSettings?.dailyGoals || {}),
      },
    }));
  }, []);

  useEffect(() => {
    loadInitialSettings();
  }, [loadInitialSettings]);


  const handleGoalChange = useCallback(async (goalType: MacroType, value: string) => {
    const numericValue = parseFloat(value) || 0;

    setSettings((prevSettings) => {
      const updatedGoals = { ...prevSettings.dailyGoals, [goalType]: numericValue };
      const updatedSettings: Settings = {
        ...prevSettings,
        dailyGoals: updatedGoals,
      };

      // Removed settings history update

      (async () => {
        await saveSettings(updatedSettings); // Simplified save
        setChartUpdateKey((prevKey) => prevKey + 1);
      })();

      return updatedSettings;
    });
    }, []); // Removed settingsHistory dependency


    const getStatisticsData = useCallback(
      (
        dailyEntries: DailyEntry[],
        macro: MacroType,
      ): MacroData[][] => { // Return type annotation
        const intakeData: MacroData[] = [];
        const goalData: MacroData[] = []; // For calories goal

          dailyEntries.forEach((entry) => {
              const entryDate = parseISO(entry.date);
            // Use current settings for all entries
            const relevantGoals = settings.dailyGoals;

            const intakeValue = entry.items.reduce(
              (total, item) => total + (item.food[macro] / 100) * item.grams,
              0
            );
            const goalValue = relevantGoals[macro] ?? 0;

            // Add to intake data (for all macros)
            intakeData.push({ x: entryDate.getTime(), y: intakeValue });

            // Add to goal data (only for calories)
            if (macro === "calories") {
              goalData.push({ x: entryDate.getTime(), y: goalValue });
            }
          });

          // Sort both arrays by date
        intakeData.sort((a, b) => a.x - b.x);
          if (macro === "calories") {
              goalData.sort((a,b) => a.x - b.x);
          }

        // Return as an array of arrays
        if (macro === "calories") {
          return [intakeData, goalData]; // Two series: intake and goal
        } else {
          return [intakeData]; // One series: intake only
        }
      },
      [settings.dailyGoals] // Only settings.dailyGoals as dependency
    );


  const updateStatistics = useCallback(async () => {
    const loadedEntries = await loadDailyEntries();

    // Calculate statistics for each macro
    const updatedStats: Statistics = {
      calories: getStatisticsData(loadedEntries, "calories"),
      protein: getStatisticsData(loadedEntries, "protein"),
      carbs: getStatisticsData(loadedEntries, "carbs"),
      fat: getStatisticsData(loadedEntries, "fat"),
    };

    setStatistics(updatedStats);
  }, [getStatisticsData]);

   useFocusEffect(
    useCallback(() => {
      (async () => {
        await loadInitialSettings();
        await updateStatistics();
      })();
    }, [loadInitialSettings, updateStatistics])
  );

  useEffect(() => {
    (async () => {
      if (dataChangeCounter > 0) {
        await updateStatistics();
        setChartUpdateKey((prevKey) => prevKey + 1);
      }
    })();
  }, [dataChangeCounter, updateStatistics]);

  const handleDataOperation = useCallback(() => {
    setDataChangeCounter((prevCounter) => prevCounter + 1);
  }, []);

  return (
    <ScrollView style={styles.container}>
      <Text h3 style={[styles.sectionTitle, { color: theme.colors.text }]}>General</Text>
      <ThemeSwitch currentTheme={settings.theme} onToggle={onThemeChange} />

      <Text h3 style={[styles.sectionTitle, { color: theme.colors.text }]}>Daily Goals</Text>
      <DailyGoalsInput dailyGoals={settings.dailyGoals} onGoalChange={handleGoalChange} />

      <Text h3 style={[styles.sectionTitle, { color: theme.colors.text }]}>Statistics</Text>
      <StatisticsChart statistics={statistics} key={chartUpdateKey} />

      <Text h3 style={[styles.sectionTitle, { color: theme.colors.text }]}>Data Management</Text>
      <DataManagementButtons onDataOperation={handleDataOperation} />
    </ScrollView>
  );
};
const useStyles = makeStyles((theme) => ({
  container: {
    flex: 1,
    padding: 10,
    backgroundColor: theme.colors.background,
  },
  sectionTitle: {
    marginTop: 20,
    marginBottom: 10,
  },
  button: {
    marginBottom: 10,
  },
}));

export default SettingsScreen;

// components/StatisticsChart.tsx (No changes needed here)
// Remains the same as in the previous, corrected version.  The key changes were in SettingsScreen.
---------- END SettingsScreen.tsx ----------


---------- backendService.ts ----------
// src/services/backendService.ts
import { getClientId } from './clientIDService';
// Correctly import types from their new location
import { EstimatedFoodItem, Macros, MacrosWithFoodName } from '../types/macros';

// --- Configuration ---
const BASE_URL = 'http://192.168.1.15:8000/api/v1';

// --- Interfaces ---
interface GramsResponse {
    grams: number;
}

interface IconResponse {
    icon_url: string | null;
}

interface BackendErrorDetail {
    detail?: string | any;
}

// --- Custom Error Class ---
export class BackendError extends Error {
    status: number;
    detail?: string | any;

    constructor(message: string, status: number, detail?: string | any) {
        super(message);
        this.name = 'BackendError';
        this.status = status;
        this.detail = detail;
    }
}

// --- API Call Helper ---
async function fetchBackend<T>(
    endpoint: string,
    options: RequestInit = {}
): Promise<T> {
    const url = `${BASE_URL}${endpoint}`;
    console.log(`Calling Backend: ${options.method || 'GET'} ${url}`);

    const defaultHeaders = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
    };

    const config: RequestInit = {
        ...options,
        headers: {
            ...defaultHeaders,
            ...options.headers,
        },
    };

    try {
        const response = await fetch(url, config);
        const responseBody = await response.json();

        if (!response.ok) {
            console.error(`Backend Error (${response.status}) on ${url}:`, responseBody);
            const detail = (responseBody as BackendErrorDetail)?.detail || 'Unknown backend error';
            let message = `Backend request failed with status ${response.status}`;
            if (response.status === 402) {
                message = 'Insufficient coins.';
            } else if (typeof detail === 'string') {
                message = detail;
            }
            throw new BackendError(message, response.status, detail);
        }

        console.log(`Backend Success (${response.status}) on ${url}`);
        return responseBody as T;

    } catch (error) {
        if (error instanceof BackendError) {
            throw error;
        }
        console.error(`Network or parsing error calling ${url}:`, error);
        throw new Error(`Failed to communicate with the backend: ${error instanceof Error ? error.message : 'Unknown network error'}`);
    }
}

// --- Service Functions ---

export const getUserStatus = async (): Promise<{ client_id: string; coins: number }> => {
    const clientId = await getClientId();
    return fetchBackend<{ client_id: string; coins: number }>(`/users/status/${clientId}`);
};

export const getMacrosForRecipe = async (foodName: string, ingredients: string): Promise<Macros> => {
    const clientId = await getClientId();
    const body = { client_id: clientId, food_name: foodName, ingredients };
    // The backend endpoint returns data matching the Macros interface
    return fetchBackend<Macros>('/ai/macros_recipe', {
        method: 'POST',
        body: JSON.stringify(body),
    });
};

export const getMacrosForImageSingle = async (image_base64: string, mime_type: string): Promise<MacrosWithFoodName> => {
    const clientId = await getClientId();
    const body = { client_id: clientId, image_base64, mime_type };
     // The backend endpoint returns data matching the MacrosWithFoodName interface
    return fetchBackend<MacrosWithFoodName>('/ai/macros_image_single', {
        method: 'POST',
        body: JSON.stringify(body),
    });
};

export const getMacrosForImageMultiple = async (image_base64: string, mime_type: string): Promise<EstimatedFoodItem[]> => {
    const clientId = await getClientId();
    const body = { client_id: clientId, image_base64, mime_type };
    // The backend endpoint returns data matching the EstimatedFoodItem[] interface
    return fetchBackend<EstimatedFoodItem[]>('/ai/macros_image_multiple', {
        method: 'POST',
        body: JSON.stringify(body),
    });
};

export const estimateGramsNaturalLanguage = async (foodName: string, quantityDescription: string): Promise<number> => {
    const clientId = await getClientId();
    const body = { client_id: clientId, food_name: foodName, quantity_description: quantityDescription };
    const response = await fetchBackend<GramsResponse>('/ai/grams_natural_language', {
        method: 'POST',
        body: JSON.stringify(body),
    });
    return response.grams;
};

export const getFoodIcon = async (foodName: string, locale: string = 'en'): Promise<string | null> => {
    const encodedFoodName = encodeURIComponent(foodName);
    const encodedLocale = encodeURIComponent(locale);
    try {
        const response = await fetchBackend<IconResponse>(`/icons/food?food_name=${encodedFoodName}&locale=${encodedLocale}`);
        return response.icon_url;
    } catch (error) {
         console.error(`Failed to get icon for ${foodName}:`, error);
         return null;
    }
};
---------- END backendService.ts ----------


---------- clientIDService.ts ----------
// src/services/clientIDService.ts
import AsyncStorage from '@react-native-async-storage/async-storage';
import uuid from 'react-native-uuid';

const CLIENT_ID_KEY = '@MacroTracker:clientId';
let currentClientId: string | null = null; // In-memory cache

export const getClientId = async (): Promise<string> => {
  if (currentClientId) {
    return currentClientId;
  }

  try {
    let clientId = await AsyncStorage.getItem(CLIENT_ID_KEY);
    if (!clientId) {
      clientId = uuid.v4() as string;
      console.log('Generated new client ID:', clientId);
      await AsyncStorage.setItem(CLIENT_ID_KEY, clientId);
    } else {
      console.log('Retrieved existing client ID:', clientId);
    }
    currentClientId = clientId;
    return clientId;
  } catch (error) {
    console.error('Error handling client ID:', error);
    // Fallback or throw error depending on desired behavior
    // For now, generating a temporary one if storage fails
    return uuid.v4() as string;
  }
};

// Optional: Function to clear ID for testing
export const clearClientId = async (): Promise<void> => {
    currentClientId = null;
    try {
        await AsyncStorage.removeItem(CLIENT_ID_KEY);
        console.log('Client ID cleared.');
    } catch (error) {
        console.error('Error clearing client ID:', error);
    }
};
---------- END clientIDService.ts ----------


---------- foodService.ts ----------
// services/foodService.ts
import { Food } from '../types/food';
import { saveFoods, loadFoods } from './storageService';
import 'react-native-get-random-values';
import { v4 as uuidv4 } from 'uuid';

export const createFood = async (foodData: Omit<Food, 'id'>): Promise<Food> => {
  const newFood: Food = {
    id: uuidv4(),
    ...foodData,
  };
  const foods = await loadFoods();
  foods.push(newFood);
  await saveFoods(foods);
  return newFood;
};

export const getFoods = async (): Promise<Food[]> => {
  return loadFoods();
};

export const updateFood = async (updatedFood: Food): Promise<Food> => {
  const foods = await loadFoods();
  const index = foods.findIndex((f) => f.id === updatedFood.id);
  if (index === -1) {
    throw new Error('Food not found'); // Throw an error if not found
  }
  foods[index] = updatedFood;
  await saveFoods(foods);
  return updatedFood;
};

export const deleteFood = async (foodId: string): Promise<void> => {
  const foods = await loadFoods();
  const filteredFoods = foods.filter((f) => f.id !== foodId);
  await saveFoods(filteredFoods);
};
---------- END foodService.ts ----------


---------- storageService.ts ----------
// services/storageService.ts (Modified for Timestamps)
import AsyncStorage from '@react-native-async-storage/async-storage';
import { DailyEntry } from '../types/dailyEntry';
import { Food } from '../types/food';
import { Settings } from '../types/settings';
import { formatISO, parseISO } from 'date-fns';


const DAILY_ENTRIES_KEY = 'dailyEntries';
const FOODS_KEY = 'foods';
const SETTINGS_KEY = 'settings';
const RECENT_FOODS = 'recentFoods';


export const saveDailyEntries = async (entries: DailyEntry[]): Promise<void> => {
  try {
    await AsyncStorage.setItem(DAILY_ENTRIES_KEY, JSON.stringify(entries));
  } catch (error) {
    console.error('Error saving daily entries:', error);
    throw error;
  }
};

export const loadDailyEntries = async (): Promise<DailyEntry[]> => {
  try {
    const entriesJson = await AsyncStorage.getItem(DAILY_ENTRIES_KEY);
    return entriesJson ? JSON.parse(entriesJson) : [];
  } catch (error) {
    console.error('Error loading daily entries:', error);
    return [];
  }
};

export const saveFoods = async (foods: Food[]): Promise<void> => {
  try {
    await AsyncStorage.setItem(FOODS_KEY, JSON.stringify(foods));
  } catch (error) {
    console.error('Error saving foods:', error);
    throw error; // Re-throw the error
  }
};

export const loadFoods = async (): Promise<Food[]> => {
  try {
    const foodsJson = await AsyncStorage.getItem(FOODS_KEY);
    return foodsJson ? JSON.parse(foodsJson) : [];
  } catch (error) {
    console.error('Error loading foods:', error);
    return []; // Return an empty array on error
  }
};



export const saveSettings = async (settings: Settings): Promise<void> => {
  try {
    await AsyncStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
  } catch (error) {
    console.error('Error saving settings:', error);
    throw error;
  }
};

export const loadSettings = async (): Promise<Settings> => {
  try {
    const settingsJson = await AsyncStorage.getItem(SETTINGS_KEY);
    const loadedSettings = settingsJson ? JSON.parse(settingsJson) : {};

    // Apply defaults and ensure structure
    const defaultSettings: Settings = {
      theme: 'system',
      dailyGoals: { calories: 2000, protein: 50, carbs: 200, fat: 70 },
      settingsHistory: [] // Ensure settingsHistory exists
    };


    return {
      ...defaultSettings, // Start with defaults
        ...loadedSettings, // Override with loaded values
        dailyGoals: {
          ...defaultSettings.dailyGoals,  //ensure no fields missing from daily goals
            ...(loadedSettings.dailyGoals || {}) // And override *those* with any loaded dailyGoals
        }
    }

  } catch (error: any) {
    console.error('Error loading settings:', error);

    // *** KEY CHANGE: Handle "Row too big" error ***
    if (error.message.includes('Row too big')) {
      console.warn('Detected oversized settings data. Clearing settings.');
      try {
        await AsyncStorage.removeItem(SETTINGS_KEY); // Clear the oversized data
      } catch (clearError) {
        console.error('Error clearing oversized settings:', clearError);
        // You might want to handle this more gracefully, e.g., by showing an error to the user.
      }
    }

    // Return defaults if loading fails (or after clearing)
    return {
      theme: 'system',
      dailyGoals: { calories: 2000, protein: 50, carbs: 200, fat: 70 },
      settingsHistory: [] // Ensure settingsHistory exists in default
    };
  }
};

export const clearAllData = async (): Promise<void> => {
  try {
    await AsyncStorage.clear();
  } catch (error) {
    console.error('Error clearing data:', error);
    throw error;
  }
};

// Function to save recent foods
export const saveRecentFoods = async (foods: Food[]) => {
    try {
        await AsyncStorage.setItem(RECENT_FOODS, JSON.stringify(foods));
    } catch (error) {
        console.error('Error saving recent foods:', error);
        throw error; // Important: Re-throw the error so calling code knows it failed
    }
};

// Function to load recent foods
export const loadRecentFoods = async (): Promise<Food[]> => {
    try {
        const foods = await AsyncStorage.getItem(RECENT_FOODS);
        return foods ? JSON.parse(foods) : [];
    } catch (error) {
        console.error('Error loading recent foods:', error);
        return []; // Return empty array on error, don't throw
    }
};
---------- END storageService.ts ----------


---------- dailyEntry.ts ----------
// types/dailyEntry.ts (Modified)
import { Food } from "./food";

export interface DailyEntryItem {
  food: Food;
  grams: number;
}

export interface DailyEntry {
  date: string; // YYYY-MM-DD format
  items: DailyEntryItem[];
  goals?: {  // Optional goals
    calories?: number;
    protein?: number;
    carbs?: number;
    fat?: number;
  };
}

export interface FoodItem { //No changes here.
    id: string;
    name: string;
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
  }
---------- END dailyEntry.ts ----------


---------- food.ts ----------
// types/food.ts
export interface Food {
  id: string;
  name: string;
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
  // category: string;  // REMOVED
}
---------- END food.ts ----------


---------- macros.ts ----------
// src/types/macros.ts

// Basic macro structure
export interface Macros {
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
  }
  
  // Macros structure including the identified food name
  export interface MacrosWithFoodName extends Macros {
    foodName: string;
  }
  
  /**
   * Represents a single food item estimated from an image,
   * including its name, estimated weight, and macros per 100g.
   * Matches the structure expected/returned by the backend service.
   */
  export interface EstimatedFoodItem {
    foodName: string;
    estimatedWeightGrams: number;
    calories_per_100g: number;
    protein_per_100g: number;
    carbs_per_100g: number;
    fat_per_100g: number;
  }
---------- END macros.ts ----------


---------- openRouterTypes.ts ----------
// src/utils/types.ts

// =====================================
// Consolidated OpenRouter Type Definitions
// =====================================

// --- Content Parts (for multi-modal input like images) ---
export type OpenRouterContentPart =
  | { type: "text"; text: string }
  | { type: "image_url"; image_url: { url: string; detail?: "low" | "high" | "auto" } };

// --- Message Structure ---
// Allows content to be a simple string OR an array of content parts for vision models
export interface OpenRouterMessage {
  role: "user" | "assistant" | "system";
  content: string | OpenRouterContentPart[]; // Consolidated definition
  name?: string; // Optional name field
}

// --- Choice Structure (within the response) ---
// This structure aligns with standard Chat Completion APIs (like OpenAI/OpenRouter)
export interface OpenRouterChatChoice {
  index: number;
  message: OpenRouterMessage; // Contains the actual message content and role
  logprobs?: any | null; // Optional log probabilities (use a specific type if known)
  finish_reason: string | null; // Can be null sometimes
  // text?: string; // Usually the content is inside message.content, keep optional if some models return it differently
}

// --- API Usage Information ---
export interface OpenRouterUsage {
  prompt_tokens: number;
  completion_tokens: number;
  total_tokens: number;
}

// --- Main Chat Completion Response Structure ---
// Consolidates the fields from both previous declarations
export interface OpenRouterChatCompletionResponse {
  id: string;
  object: string; // Typically "chat.completion"
  created: number; // Timestamp
  model: string; // Model used
  choices: OpenRouterChatChoice[]; // Array of choices using the defined structure
  usage?: OpenRouterUsage; // Usage information is often optional
  // Add any other relevant fields you might encounter from OpenRouter
  // system_fingerprint?: string; // Example optional field
}


// =====================================
// Removed Redundant/Conflicting Declarations:
// =====================================

/*
// REMOVED - Duplicate/Outdated OpenRouterMessage
export interface OpenRouterMessage {
  role: "user" | "assistant" | "system"; // Add system role
  content: string;
}

// REMOVED - Less standard choice structure (often message.content is used instead of top-level text)
export interface OpenRouterChoice {
  text: any; // 'any' is vague, content is usually in message
  message: OpenRouterMessage; // This duplicates content info if 'text' is also present
  finish_reason?: string;
  index?: number;
}

// REMOVED - Duplicate/Simpler OpenRouterChatCompletionResponse
export interface OpenRouterChatCompletionResponse {
  choices: OpenRouterChoice[]; // Used the less standard choice type
  id?: string;
  created?: number;
  model?: string;
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}
*/
---------- END openRouterTypes.ts ----------


---------- settings.ts ----------
// types/settings.ts (Modified)
export const macros = ["calories", "protein", "carbs", "fat"] as const;
export type MacroType = (typeof macros)[number];

export interface MacroData {
  x: number; // Timestamp
  y: number; // Macro value
}

export interface Statistics {
  calories: MacroData[][];
  protein: MacroData[][];
  carbs: MacroData[][];
  fat: MacroData[][];
}

export interface Settings {
  theme: "light" | "dark" | "system";
  dailyGoals: {
    [key in MacroType]: number;
  };
  settingsHistory?: { date: number; dailyGoals: { [key in MacroType]: number } }[]; // CHANGED: Store timestamp
}

export interface SettingsScreenProps {
  onThemeChange: (theme: "light" | "dark" | "system") => void;
}
---------- END settings.ts ----------


---------- dateUtils.ts ----------
// utils/dateUtils.ts (Modified)
import { format, parseISO, formatISO } from 'date-fns';

// Format a timestamp as YYYY-MM-DD (for display and storage)
export const formatDate = (timestamp: number): string => {
    return formatISO(timestamp, { representation: 'date' });
};

// Format a timestamp as a readable date (for display)
export const formatDateReadable = (timestamp: number | string): string => {
    if (typeof timestamp === 'string') {
        return timestamp; // if it is a string, do nothing.
    }
  return format(timestamp, 'MMMM dd, yyyy');
};

// Get today's date as a timestamp
export const getTodayDateString = (): string => {
  return formatISO(new Date(), { representation: 'date' });
};
---------- END dateUtils.ts ----------


---------- iconUtils.ts ----------
// src/utils/iconUtils.ts
// Import necessary modules
import AsyncStorage from '@react-native-async-storage/async-storage';
import { getFoodIcon, BackendError } from '../services/backendService'; // Import backend service

// Define the cache entry type (URL only, no expiry handled here)
type CacheEntry = {
  url: string | null;
};

// In-memory cache for fast access
const memoryCache = new Map<string, CacheEntry>();

// Prefix for AsyncStorage keys (keeping versioning)
const STORAGE_KEY_PREFIX = 'foodIconCacheBE_v1_'; // BE = Backend

// --- Main Exported Function ---

export const getFoodIconUrl = async (foodName: string, locale: string = 'en'): Promise<string | null> => {
  if (!foodName || foodName.trim() === '') {
      return null;
  }

  const cacheKey = `${locale}_${foodName.toLowerCase().trim()}`;

  // 1. Check Memory Cache
  const memoryEntry = memoryCache.get(cacheKey);
  if (memoryEntry) {
    // console.log(`Icon Cache HIT (Memory): ${cacheKey}`);
    return memoryEntry.url;
  }

  // 2. Check AsyncStorage
  const storageKey = STORAGE_KEY_PREFIX + cacheKey;
  try {
    const storedValue = await AsyncStorage.getItem(storageKey);
    if (storedValue) {
      const parsed: CacheEntry = JSON.parse(storedValue);
      // console.log(`Icon Cache HIT (Storage): ${cacheKey}`);
      memoryCache.set(cacheKey, parsed); // Update memory cache
      return parsed.url;
    }
  } catch (error) {
    console.error('Error reading icon cache from AsyncStorage:', error);
    // Continue to fetch if storage read fails
  }

  // 3. Fetch from Backend API
  console.log(`Icon Cache MISS / Fetching Backend API: ${cacheKey}`);
  let iconUrl: string | null = null;
  try {
      // Call the backend service function
      iconUrl = await getFoodIcon(foodName, locale);
      console.log(`Backend returned icon URL for ${foodName}: ${iconUrl}`);

  } catch (error) {
      // Backend service already logs errors, just handle the outcome
      console.error(`Error fetching icon from backend for ${foodName}:`, error);
      iconUrl = null; // Ensure null is cached on error
      // Do not show Alert here, let the calling component decide UI response
  }


  // 4. Cache the final result (even nulls) from backend
  const newCacheEntry: CacheEntry = { url: iconUrl };
  memoryCache.set(cacheKey, newCacheEntry);
  try {
    await AsyncStorage.setItem(storageKey, JSON.stringify(newCacheEntry));
  } catch (error) {
    console.error('Error saving icon cache to AsyncStorage:', error);
  }

  return iconUrl;
};

// --- Cache Management (Optional but recommended) ---

export const clearIconCache = async () => {
    memoryCache.clear();
    try {
        const keys = await AsyncStorage.getAllKeys();
        const cacheKeys = keys.filter(key => key.startsWith(STORAGE_KEY_PREFIX));
        if (cacheKeys.length > 0) {
             await AsyncStorage.multiRemove(cacheKeys);
             console.log(`Cleared ${cacheKeys.length} items from AsyncStorage icon cache (Backend Version).`);
        }
    } catch (error) {
        console.error("Error clearing backend icon cache from AsyncStorage:", error);
    }
};

export const logMemoryCacheSize = () => {
    console.log(`In-memory icon cache size: ${memoryCache.size}`);
};

// Removed scoring and direct Pixabay fetch logic as it's now in the backend service.
---------- END iconUtils.ts ----------


---------- macros.ts ----------
// src/utils/macros.ts
import * as FileSystem from 'expo-file-system';
import MimeTypes from 'react-native-mime-types';
import {
    getMacrosForRecipe,
    getMacrosForImageSingle,
    getMacrosForImageMultiple,
    BackendError
} from '../services/backendService'; // Import backend service functions
import { Alert } from 'react-native';
// Import types from the new location
import { Macros, MacrosWithFoodName, EstimatedFoodItem } from '../types/macros';

// --- Refactored Functions ---

// Function to get macros from text description (using backend)
export async function getMacrosFromText(
    foodName: string,
    ingredients: string // Changed param name for clarity
): Promise<Macros> {
    try {
        // Backend service already returns the correct Macros type
        const macros = await getMacrosForRecipe(foodName, ingredients);
        return macros;
    } catch (error) {
        console.error("Error fetching macros for recipe from backend:", error);
        const message = error instanceof BackendError
            ? error.message // Use message from BackendError (e.g., "Insufficient coins.")
            : `Failed to get macros for recipe: ${error instanceof Error ? error.message : String(error)}`;
        Alert.alert("AI Error", message); // Show alert to user
        throw error; // Re-throw to allow calling component further handling if needed
    }
}

// Utility function to convert a file URI to base64 (remains the same)
export async function getBase64FromUri(uri: string): Promise<string> {
    try {
        const base64 = await FileSystem.readAsStringAsync(uri, {
            encoding: FileSystem.EncodingType.Base64,
        });
        return base64;
    } catch (error) {
        console.error(`Failed to convert file to base64: ${uri}`, error);
        throw new Error(`Failed to convert file to base64: ${error}`);
    }
}

// Function to get macros for a single food item from an image file (using backend)
// Accepts the specific type structure matching ImagePickerAsset properties needed
export async function getMacrosForImageFile(asset: {
    uri: string;
    fileName?: string | null; // Accept null for fileName
    type?: string;
}): Promise<MacrosWithFoodName> {
    let base64File: string;
    try {
        base64File = await getBase64FromUri(asset.uri);
    } catch (err) {
        Alert.alert("Error", "Failed to read image file.");
        throw err; // Re-throw
    }

    let mimeType = asset.type;
    // Use fileName only if it's not null for lookup
    const validFileName = asset.fileName ?? undefined; // Convert null to undefined for lookup/logging
    if (!mimeType && validFileName) {
        mimeType = MimeTypes.lookup(validFileName) || undefined;
    }
    if (!mimeType) {
        mimeType = 'image/jpeg'; // Default fallback
    }

    try {
        // Backend service already returns the correct MacrosWithFoodName type
        const result = await getMacrosForImageSingle(base64File, mimeType);
        return result;
    } catch (error) {
        console.error("Error fetching single food macros from image from backend:", error);
         const message = error instanceof BackendError
            ? error.message
            : `Analysis failed: ${error instanceof Error ? error.message : String(error)}`;
        Alert.alert("Analysis Failed", message);
        throw error; // Re-throw
    }
}


// Function for Multiple Foods (using backend)
// Accepts the specific type structure matching ImagePickerAsset properties needed
export async function getMultipleFoodsFromImage(asset: {
    uri: string;
    fileName?: string | null; // Accept null for fileName
    type?: string;
}): Promise<EstimatedFoodItem[]> {
    console.log(`Frontend: Starting getMultipleFoodsFromImage for asset URI: ${asset.uri}`);
    let base64File: string;
    try {
        base64File = await getBase64FromUri(asset.uri);
        console.log("Frontend: Successfully converted multi-food image to base64.");
    } catch (err) {
         Alert.alert("Error", "Failed to read image file.");
         throw err;
    }

    let mimeType = asset.type;
    // Use fileName only if it's not null for lookup
    const validFileName = asset.fileName ?? undefined; // Convert null to undefined
    if (!mimeType && validFileName) {
        mimeType = MimeTypes.lookup(validFileName) || undefined;
    }
    if (!mimeType) {
        mimeType = 'image/jpeg'; // Default fallback
    }
    console.log(`Frontend: Determined MIME type (multi-food): ${mimeType}`);

    try {
        console.log("Frontend: Calling backendService.getMacrosForImageMultiple...");
        // Backend service already returns the correct EstimatedFoodItem[] type
        const results = await getMacrosForImageMultiple(base64File, mimeType);
        console.log(`Frontend: Received ${results.length} items from backend.`);
        return results;
    } catch (error) {
        console.error("Frontend: Error calling backend for multiple foods:", error);
         const message = error instanceof BackendError
            ? error.message
            : `Could not analyze image: ${error instanceof Error ? error.message : String(error)}`;
        Alert.alert("Quick Add Failed", message);
        throw error; // Re-throw
    }
}

export { BackendError, EstimatedFoodItem };

---------- END macros.ts ----------


---------- units.ts ----------
// src/utils/units.ts
import { Alert } from 'react-native';
import { estimateGramsNaturalLanguage, BackendError } from '../services/backendService';

/**
 * Estimates the weight in grams based on a natural language description and food item, using the backend service.
 * @param foodName The name of the food item (e.g., "Apple").
 * @param quantityDescription The natural language description (e.g., "2 small", "1 cup chopped").
 * @returns A promise that resolves with the estimated weight in grams (number).
 */
export async function getGramsFromNaturalLanguage(
    foodName: string,
    quantityDescription: string
): Promise<number> {
    try {
        const grams = await estimateGramsNaturalLanguage(foodName, quantityDescription);
        return grams; // Backend service already rounds
    } catch (error) {
        console.error("Error getting grams estimation from backend:", error);
        const message = error instanceof BackendError
            ? error.message
            : `Could not estimate grams: ${error instanceof Error ? error.message : String(error)}`;
        Alert.alert("AI Estimation Failed", message);
        throw error; // Re-throw error
    }
}
---------- END units.ts ----------


---------- validationUtils.ts ----------
// utils/validationUtils.ts

export const isValidNumberInput = (value: string): boolean => {
    return /^[0-9]*(\.[0-9]*)?$/.test(value) && !isNaN(parseFloat(value));
  };
  
  export const isNotEmpty = (value: string): boolean => {
    return value.trim() !== '';
  };
---------- END validationUtils.ts ----------


---------- tsconfig.json ----------
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true

  }
}
---------- END tsconfig.json ----------

