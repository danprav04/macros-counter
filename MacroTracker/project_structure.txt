.gitignore
app.json
App.tsx
assets/
  adaptive-icon.png
  favicon.png
  icon.png
  splash.png
eas.json
index.ts
package.json
projectToFile.js
src/
  components/
    AccountSettings.tsx
    AddEntryModal.tsx
    AddFoodModal.tsx
    ConfirmationModal.tsx
    DailyEntryListItem.tsx
    DailyGoalsInput.tsx
    DailyProgress.tsx
    DataManagementButtons.tsx
    DateNavigator.tsx
    FoodFormFields.tsx
    FoodItem.tsx
    QuickAddList.tsx
    StatisticsChart.tsx
    ThemeSwitch.tsx
  navigation/
    AppNavigator.tsx
  screens/
    DailyEntryScreen.tsx
    FoodListScreen.tsx
    SettingsScreen.tsx
  services/
    backendService.ts
    clientIDService.ts
    foodService.ts
    storageService.ts
  types/
    dailyEntry.ts
    food.ts
    macros.ts
    openRouterTypes.ts
    settings.ts
  utils/
    dateUtils.ts
    iconUtils.ts
    imageUtils.ts
    macros.ts
    units.ts
    validationUtils.ts
tsconfig.json

---------- .gitignore ----------
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

---------- END .gitignore ----------


---------- app.json ----------
{
  "expo": {
    "name": "MacroTracker",
    "slug": "MacroTracker",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "automatic",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#000000"
    },
    "androidStatusBar": {
      "backgroundColor": "#000000",
      "translucent": false,
      "barStyle": "light-content"
    },
    "assetBundlePatterns": [
      "**/*"
    ],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.yourcompany.macrotracker",
      "infoPlist": {
        "UIStatusBarStyle": "UIStatusBarStyleAutomatic",
        "NSCameraUsageDescription": "Allow $(PRODUCT_NAME) to access your camera to take photos of food for macro analysis.",
        "NSPhotoLibraryUsageDescription": "Allow $(PRODUCT_NAME) to access your photos to select food images for macro analysis."
      }
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "package": "com.yourcompany.macrotracker",
      "userInterfaceStyle": "automatic",
      "statusBar": {
        "backgroundColor": "#00000000",
        "translucent": true,
        "barStyle": "auto"
      },
      "permissions": [
        "android.permission.CAMERA",
        "android.permission.READ_EXTERNAL_STORAGE",
        "android.permission.WRITE_EXTERNAL_STORAGE"
      ]
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      [
        "expo-document-picker",
        {
          "appleTeamId": "YOUR_TEAM_ID"
        }
      ],
      [
        "expo-image-picker",
        {
          "photosPermission": "Allow $(PRODUCT_NAME) to access your photos to select food images for macro analysis.",
          "cameraPermission": "Allow $(PRODUCT_NAME) to access your camera to take photos of food for macro analysis."
        }
      ]
    ],
    "extra": {
      "eas": {
        "projectId": "25ac2bcf-78a3-4f2c-a635-4fcaae7b93f1"
      },
      "env": {
         "BACKEND_URL": "https://macros-counter.mooo.com"
      }
    }
  }
}
---------- END app.json ----------


---------- App.tsx ----------
// App.tsx
// App.tsx (Initialize Client ID)
import "react-native-get-random-values"; // MUST BE FIRST
import Toast from "react-native-toast-message";
import React, { useState, useEffect } from "react";
import AppNavigator from "./src/navigation/AppNavigator";
import { SafeAreaProvider, SafeAreaView } from "react-native-safe-area-context";
import { ThemeProvider, createTheme } from "@rneui/themed";
import { loadSettings, saveSettings } from "./src/services/storageService";
import {
  useColorScheme,
  AppState,
  AppStateStatus,
  Platform,
} from "react-native";
import {
  NavigationContainer,
  DefaultTheme,
  DarkTheme,
} from "@react-navigation/native";
import { Colors } from "@rneui/base";
import { Settings } from "./src/types/settings";
import { LogBox, View, Text } from "react-native"; //Import view for debug
import { StatusBar } from "expo-status-bar"; // changed import
import { getClientId } from "./src/services/clientIDService"; // Import client ID service

LogBox.ignoreLogs(["Function components cannot be given refs"]);

declare module "@rneui/themed" {
  export interface Colors {
    text: string;
    card: string; // Added for better card styling
    successLight: string; // Lighter success color
  }
}

interface MyTheme {
  mode: "light" | "dark";
  colors: Colors;
}

const lightTheme: MyTheme = {
  mode: "light",
  colors: {
    primary: "#2e86de",
    secondary: "#6c757d",
    background: "#f8f9fa",
    grey5: "#e9ecef",
    white: "#ffffff",
    grey4: "#ced4da",
    success: "#28a745",
    successLight: "#d4edda",
    black: "#000000",
    text: "#212529",
    card: "#ffffff",
    error: "#dc3545",
    warning: "#ffc107",
    disabled: "#6c757d",
    divider: "#ced4da",
    platform: {
      ios: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      android: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      web: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      default: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
    },
    grey0: "#f8f9fa",
    grey1: "#e9ecef",
    grey2: "#dee2e6",
    grey3: "#ced4da",
    greyOutline: "#adb5bd",
    searchBg: "#ffffff",
  },
};

const darkTheme: MyTheme = {
  mode: "dark",
  colors: {
    primary: "#2e86de",
    secondary: "#adb5bd",
    background: "#121212",
    grey5: "#2c2c2c",
    white: "#ffffff",
    grey4: "#343a40",
    success: "#28a745",
    successLight: "#1f5139",
    black: "#000000",
    text: "#f8f9fa",
    card: "#1e1e1e",
    error: "#dc3545",
    warning: "#ffc107",
    disabled: "#6c757d",
    divider: "#343a40",
    platform: {
      ios: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      android: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      web: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
      default: {
        primary: "",
        secondary: "",
        grey: "",
        searchBg: "",
        success: "",
        error: "",
        warning: "",
      },
    },
    grey0: "#212529",
    grey1: "#2c2c2c",
    grey2: "#343a40",
    grey3: "#495057",
    greyOutline: "#6c757d",
    searchBg: "#1e1e1e",
  },
};

const App = () => {
  const [themeMode, setThemeMode] = useState<"light" | "dark" | "system">(
    "system"
  );
  const [loadedSettings, setLoadedSettings] = useState<Settings | null>(null);
  const colorScheme = useColorScheme();
  const [appState, setAppState] = useState(AppState.currentState);
  const [themeCheck, setThemeCheck] = useState(0);
  const [isClientIdReady, setIsClientIdReady] = useState(false); // Track client ID readiness

  // Initialize Client ID and Load initial settings
  useEffect(() => {
    const initializeApp = async () => {
      try {
          // Ensure Client ID is ready before loading other data
          await getClientId(); // This generates/retrieves and caches the ID
          setIsClientIdReady(true);
          console.log('Client ID is ready.');

          // Load settings after client ID is confirmed
          const settings = await loadSettings();
          setThemeMode(settings.theme);
          setLoadedSettings(settings);
          console.log('Settings loaded.');
      } catch (error) {
            console.error("Initialization Error:", error);
            // Handle error, maybe show an error screen
      }
    };
    initializeApp();
  }, []); // Run only once on mount

  // AppState Listener
  useEffect(() => {
    const handleAppStateChange = (nextAppState: AppStateStatus) => {
      setAppState(nextAppState);
    };

    const subscription = AppState.addEventListener(
      "change",
      handleAppStateChange
    );

    return () => {
      subscription.remove();
    };
  }, []); // No appState dependency needed here

  const updateTheme = (newThemeMode: "light" | "dark" | "system") => {
    const isDark =
      newThemeMode === "system"
        ? colorScheme === "dark"
        : newThemeMode === "dark";
    return isDark ? darkTheme : lightTheme;
  };

  const handleThemeChange = async (newTheme: "light" | "dark" | "system") => {
    setThemeMode(newTheme);
    if (loadedSettings) {
      const updatedSettings: Settings = {
        ...loadedSettings,
        theme: newTheme,
      };
      await saveSettings(updatedSettings);
      setLoadedSettings(updatedSettings);
    }
    setThemeCheck((t) => t + 1);
  };

  const currentTheme = updateTheme(themeMode);

  const navigationTheme = {
    dark: {
      ...DarkTheme,
      colors: {
        ...DarkTheme.colors,
        primary: currentTheme.colors.primary,
        background: currentTheme.colors.background,
        card: currentTheme.colors.card,
        text: currentTheme.colors.text,
        border: currentTheme.colors.divider,
        notification: currentTheme.colors.successLight,
      },
    },
    light: {
      ...DefaultTheme,
      colors: {
        ...DefaultTheme.colors,
        primary: currentTheme.colors.primary,
        background: currentTheme.colors.background,
        card: currentTheme.colors.card,
        text: currentTheme.colors.text,
        border: currentTheme.colors.divider,
        notification: currentTheme.colors.success,
      },
    },
  };

  const statusBarTheme = themeMode === "system" ? colorScheme : themeMode;
  const backgroundColor = currentTheme.colors.background;

  // Show loading or placeholder until client ID is ready
  if (!isClientIdReady) {
      return (
          <SafeAreaView style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: backgroundColor }}>
              <Text style={{ color: currentTheme.colors.text }}>Initializing...</Text>
              {/* Optionally add an ActivityIndicator */}
          </SafeAreaView>
      );
  }

  return (
    <ThemeProvider theme={createTheme(currentTheme)}>
      <SafeAreaView style={{ flex: 1, backgroundColor: backgroundColor }}>
        <StatusBar
          style={statusBarTheme === "dark" ? "light" : "dark"}
          backgroundColor={backgroundColor}
          translucent={false}
        />
        <NavigationContainer
          theme={
            currentTheme.mode === "dark"
              ? navigationTheme.dark
              : navigationTheme.light
          }
        >
          <AppNavigator onThemeChange={handleThemeChange} />
        </NavigationContainer>
        <Toast />
      </SafeAreaView>
    </ThemeProvider>
  );
};

export default App;
---------- END App.tsx ----------


---------- adaptive-icon.png ----------
(Image file - content not included)
---------- END adaptive-icon.png ----------


---------- favicon.png ----------
(Image file - content not included)
---------- END favicon.png ----------


---------- icon.png ----------
(Image file - content not included)
---------- END icon.png ----------


---------- splash.png ----------
(Image file - content not included)
---------- END splash.png ----------


---------- eas.json ----------
{
  "cli": {
    "version": ">= 13.4.1",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal"
    },
    "preview": {
      "android": {
        "buildType": "apk"
      },
      "env": {
        "BACKEND_URL": "https://macros-counter.mooo.com"
      }
    },
    "production": {
      "autoIncrement": true
    }
  },
  "submit": {
    "production": {}
  }
}

---------- END eas.json ----------


---------- index.ts ----------
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);

---------- END index.ts ----------


---------- package.json ----------
{
  "name": "macrotracker",
  "license": "0BSD",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@react-native-async-storage/async-storage": "^2.1.2",
    "@react-native-community/datetimepicker": "8.2.0",
    "@react-navigation/bottom-tabs": "^7.3.1",
    "@react-navigation/native": "^7.0.17",
    "@rneui/base": "^4.0.0-rc.7",
    "@rneui/themed": "^4.0.0-rc.8",
    "@types/d3-scale": "^4.0.9",
    "d3-scale": "^4.0.2",
    "date-fns": "^4.1.0",
    "expo": "~52.0.40",
    "expo-constants": "~16.0.2",
    "expo-document-picker": "^13.0.3",
    "expo-file-system": "^18.0.12",
    "expo-image-manipulator": "~13.0.5",
    "expo-image-picker": "^16.0.6",
    "expo-sharing": "~13.0.1",
    "expo-status-bar": "~2.0.1",
    "react": "18.3.1",
    "react-native": "0.76.7",
    "react-native-config": "^1.5.5",
    "react-native-get-random-values": "^1.11.0",
    "react-native-mime-types": "^2.5.0",
    "react-native-reanimated": "~3.16.1",
    "react-native-safe-area-context": "^4.14.1",
    "react-native-screens": "^4.9.2",
    "react-native-svg": "^15.11.2",
    "react-native-toast-message": "^2.2.1",
    "react-native-uuid": "^2.0.3",
    "react-native-webview": "^13.13.4",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/react": "~18.3.12",
    "@types/react-native": "^0.73.0",
    "@types/react-native-svg-charts": "^5.0.16",
    "@types/uuid": "^10.0.0",
    "typescript": "^5.3.3",
    "victory": "^37.3.6"
  },
  "private": true
}
---------- END package.json ----------


---------- projectToFile.js ----------
const fs = require('fs');
const path = require('path');

async function generateProjectStructureAndContent(projectRoot, outputFile) {
    const excludedDirs = ['node_modules', '.git', '.expo', 'android', 'ios', '__tests__', 'dist', 'build', '.vscode'];
    const excludedFiles = ['.DS_Store', 'package-lock.json', 'yarn.lock', 'bun.lockb', 'metro.config.js', 'babel.config.js'];
    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.webp', '.ico']; // Add more if needed

    let fileStructureTree = '';  // For the initial tree structure
    let fileContents = '';      // For the file contents

    async function traverseDirectory(dir, indent = '') {
        const entries = await fs.promises.readdir(dir, { withFileTypes: true });

        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);

            if (excludedDirs.includes(entry.name)) {
                continue;
            }

            if (entry.isDirectory()) {
                fileStructureTree += `${indent}${entry.name}/\n`;
                await traverseDirectory(fullPath, indent + '  ');
            } else if (entry.isFile()) {
                if (excludedFiles.includes(entry.name)) {
                    continue;
                }
                fileStructureTree += `${indent}${entry.name}\n`;
                const fileExtension = path.extname(entry.name).toLowerCase();

                if (!imageExtensions.includes(fileExtension)) {
                    fileContents += `\n---------- ${entry.name} ----------\n`;
                    try {
                        const fileContent = await fs.promises.readFile(fullPath, 'utf-8');
                        fileContents += `${fileContent}\n`;
                    } catch (readError) {
                        fileContents += `ERROR READING FILE: ${readError.message}\n`;
                    }
                    fileContents += `---------- END ${entry.name} ----------\n\n`;
                } else {
                     fileContents += `\n---------- ${entry.name} ----------\n`;
                     fileContents += `(Image file - content not included)\n`;
                     fileContents += `---------- END ${entry.name} ----------\n\n`;
                }
            }
        }
    }

    try {
        await traverseDirectory(projectRoot);
        const fullOutput = fileStructureTree + fileContents;

        await fs.promises.writeFile(outputFile, fullOutput);
        console.log(`Project structure and content written to ${outputFile}`);

    } catch (error) {
        console.error('An error occurred:', error);
        process.exit(1);
    }
}

// --- Main execution ---

const projectRoot = process.cwd(); // Use the current working directory
const outputFile = 'project_structure.txt';

// Check if the projectRoot exists.
fs.stat(projectRoot, (err, stats) => {
    if (err) {
        console.error(`Error: Project root directory "${projectRoot}" not found or not accessible.`);
        process.exit(1);
    }

    if (!stats.isDirectory()) {
        console.error(`Error: "${projectRoot}" is not a directory.`);
        process.exit(1);
    }

    generateProjectStructureAndContent(projectRoot, outputFile);
});
---------- END projectToFile.js ----------


---------- AccountSettings.tsx ----------
import React from 'react';
import { View, ActivityIndicator } from 'react-native';
import { Text, makeStyles, Button, Icon, ListItem, useTheme } from '@rneui/themed';

interface AccountSettingsProps {
    userCoins: number | null;
    isLoadingCoins: boolean;
    isAddingCoins: boolean;
    onAddTestCoins: () => void;
}

const AccountSettings: React.FC<AccountSettingsProps> = ({
    userCoins,
    isLoadingCoins,
    isAddingCoins,
    onAddTestCoins,
}) => {
    const { theme } = useTheme();
    const styles = useStyles();

    return (
        <View>
            <ListItem bottomDivider containerStyle={styles.listItem}>
                <Icon name="database" type="material-community" color={theme.colors.warning} />
                <ListItem.Content>
                    <ListItem.Title style={styles.listItemTitle}>Coin Balance</ListItem.Title>
                </ListItem.Content>
                {isLoadingCoins ? (
                    <ActivityIndicator size="small" color={theme.colors.primary} />
                ) : (
                    <Text style={styles.coinValue}>{userCoins !== null ? userCoins : 'N/A'}</Text>
                )}
            </ListItem>

            {/* REMOVE OR PROTECT THIS BUTTON IN PRODUCTION */}
            <Button
                title="Add 10 Coins (Test)"
                onPress={onAddTestCoins}
                buttonStyle={[styles.button, { backgroundColor: theme.colors.success, marginTop: 10 }]}
                icon={<Icon name="plus-circle-outline" type="material-community" color="white" size={20} style={{ marginRight: 8 }} />}
                loading={isAddingCoins}
                disabled={isAddingCoins || isLoadingCoins}
            />
            <Text style={styles.testButtonWarning}>
                Note: The "Add Coins" button is for testing/development only and should be removed or secured for production releases.
            </Text>
        </View>
    );
};

const useStyles = makeStyles((theme) => ({
    listItem: {
        backgroundColor: theme.colors.background,
        paddingVertical: 15,
    },
    listItemTitle: {
        color: theme.colors.text,
        fontWeight: '500',
    },
    coinValue: {
        color: theme.colors.primary,
        fontWeight: 'bold',
        fontSize: 16,
    },
    button: {
        marginBottom: 10,
        borderRadius: 8,
    },
    testButtonWarning: {
        fontSize: 12,
        color: theme.colors.grey3,
        fontStyle: 'italic',
        textAlign: 'center',
        marginTop: 0,
        marginBottom: 15,
        marginHorizontal: 10,
    },
}));

export default AccountSettings;
---------- END AccountSettings.tsx ----------


---------- AddEntryModal.tsx ----------
// ---------- src/components/AddEntryModal.tsx ----------
import React, {
  useEffect,
  useState,
  useMemo,
  useCallback,
  useRef,
} from "react";
import {
  View,
  FlatList,
  KeyboardAvoidingView,
  Platform,
  TouchableOpacity,
  ScrollView,
  Dimensions,
  Image,
  StyleSheet,
  ActivityIndicator,
  Alert,
  Keyboard,
} from "react-native";
import {
  Button,
  Input,
  Text,
  ListItem,
  Overlay,
  SearchBar,
  makeStyles,
  useTheme,
  Icon,
  ButtonGroup,
} from "@rneui/themed";
import { Food } from "../types/food";
import { isValidNumberInput } from "../utils/validationUtils";
import { loadRecentFoods, saveRecentFoods } from "../services/storageService";
import { getFoodIconUrl } from "../utils/iconUtils";
import { getGramsFromNaturalLanguage } from "../utils/units";
import Toast from "react-native-toast-message";
import * as ImagePicker from "expo-image-picker";
import {
  EstimatedFoodItem,
  getMultipleFoodsFromImage,
  BackendError,
  determineMimeType,
} from "../utils/macros";
import { compressImageIfNeeded, getBase64FromUri } from "../utils/imageUtils";
import { v4 as uuidv4 } from "uuid";
import QuickAddList from "./QuickAddList"; // Import the extracted component

interface AddEntryModalProps {
  isVisible: boolean;
  toggleOverlay: () => void;
  selectedFood: Food | null;
  grams: string;
  setGrams: (grams: string) => void;
  handleAddEntry: () => void; // Single entry add/update action from parent
  handleAddMultipleEntries: (entries: { food: Food; grams: number }[]) => void; // Multiple entries action
  foods: Food[]; // Full list of available foods
  handleSelectFood: (item: Food | null) => void; // Callback when food is selected in modal
  updateSearch: (search: string) => void; // Callback to update search term
  search: string; // Current search term
  isEditMode: boolean; // True if editing an existing DailyEntryItem
  initialGrams?: string; // The grams value passed IN for editing
}

const KEYBOARD_VERTICAL_OFFSET = Platform.OS === "ios" ? 80 : 0;

type UnitMode = "grams" | "auto";
type ModalMode = "normal" | "quickAddSelect";

// Define types for the items in our main FlatList data structure
type ListItemType =
  | { type: "searchBar"; key: string }
  | { type: "recentFoods"; key: string }
  | { type: "searchResults"; key: string; data: Food } // Individual search result
  | { type: "noResults"; key: string }
  | { type: "amountInput"; key: string }
  | { type: "quickAddHeader"; key: string }
  // REPLACED individual items with the list component
  | { type: "quickAddList"; key: string }
  | { type: "spacer"; key: string; height: number };

const AddEntryModal: React.FC<AddEntryModalProps> = ({
  isVisible,
  toggleOverlay,
  selectedFood,
  grams,
  setGrams,
  handleAddEntry,
  handleAddMultipleEntries,
  foods,
  handleSelectFood,
  updateSearch,
  search,
  isEditMode,
  initialGrams,
}) => {
  const { theme } = useTheme();
  const styles = useStyles();
  const [recentFoods, setRecentFoods] = useState<Food[]>([]);
  const MAX_RECENT_FOODS = 5;
  const [foodIcons, setFoodIcons] = useState<{
    [foodName: string]: string | null | undefined;
  }>({});

  const [unitMode, setUnitMode] = useState<UnitMode>("grams");
  const [autoInput, setAutoInput] = useState("");
  const [isAiLoading, setIsAiLoading] = useState(false); // Loading for natural language grams

  // --- Quick Add State ---
  const [modalMode, setModalMode] = useState<ModalMode>("normal");
  const [quickAddLoading, setQuickAddLoading] = useState(false); // Loading for image analysis AND list display
  const [quickAddItems, setQuickAddItems] = useState<EstimatedFoodItem[]>([]);
  const [selectedQuickAddIndices, setSelectedQuickAddIndices] = useState<
    Set<number>
  >(new Set());
  const [editingQuickAddItemIndex, setEditingQuickAddItemIndex] = useState<
    number | null
  >(null);
  const [editedFoodName, setEditedFoodName] = useState<string>("");
  const [editedGrams, setEditedGrams] = useState<string>("");
  // --- End Quick Add State ---

  const screenWidth = Dimensions.get("window").width;
  const isModalOpening = useRef(false);

  // --- Computed State ---
  const isActionDisabled = isAiLoading || quickAddLoading; // General loading state check

  const filteredFoods = useMemo(() => {
    if (!search) return [];
    return foods.filter((food) =>
      food.name.toLowerCase().includes(search.toLowerCase())
    );
  }, [foods, search]);

  // --- Effects ---

  // Reset state on modal close
  useEffect(() => {
    if (!isVisible) {
      const timer = setTimeout(() => {
        handleSelectFood(null);
        updateSearch("");
        setModalMode("normal");
        setQuickAddItems([]);
        setSelectedQuickAddIndices(new Set());
        setEditingQuickAddItemIndex(null);
        setGrams("");
        setUnitMode("grams");
        setAutoInput("");
        setIsAiLoading(false);
        setQuickAddLoading(false);
        console.log("AddEntryModal state reset on close.");
      }, 150);
      return () => clearTimeout(timer);
    }
  }, [isVisible, handleSelectFood, updateSearch, setGrams]);

  // Handle state initialization/reset when modal opens or mode changes
  useEffect(() => {
    if (isVisible) {
      isModalOpening.current = true;
      const timer = setTimeout(() => {
        isModalOpening.current = false;
      }, 100);

      if (modalMode === "normal") {
        if (isEditMode && selectedFood && initialGrams !== undefined) {
          setGrams(initialGrams);
          setUnitMode("grams");
          setAutoInput("");
        } else if (!isEditMode && !selectedFood) {
          setGrams("");
          setUnitMode("grams");
          setAutoInput("");
        }
        loadRecentFoods().then(setRecentFoods);
      } else if (modalMode === "quickAddSelect") {
        handleSelectFood(null);
        updateSearch("");
        setGrams("");
        setUnitMode("grams");
        setAutoInput("");
      }
      return () => clearTimeout(timer);
    }
  }, [
    isVisible,
    modalMode,
    isEditMode,
    selectedFood,
    initialGrams,
    handleSelectFood,
    updateSearch,
    setGrams,
  ]);

  // Load icons for visible foods
  useEffect(() => {
    if (!isVisible || modalMode !== "normal") return;

    const loadIcons = async () => {
      const relevantFoods = search ? filteredFoods : recentFoods;
      const uniqueFoodsMap = new Map(
        relevantFoods.map((food) => [food.id ?? food.name, food])
      );

      for (const food of uniqueFoodsMap.values()) {
        const foodName = food.name;
        if (foodIcons[foodName] === undefined) {
          setFoodIcons((prevIcons) => ({
            ...prevIcons,
            [foodName]: undefined,
          }));
          getFoodIconUrl(foodName)
            .then((iconUrl) =>
              setFoodIcons((prevIcons) => ({
                ...prevIcons,
                [foodName]: iconUrl,
              }))
            )
            .catch((error) => {
              console.warn(`Icon fetch failed for ${foodName}:`, error);
              setFoodIcons((prevIcons) => ({ ...prevIcons, [foodName]: null }));
            });
        }
      }
    };
    loadIcons();
  }, [isVisible, modalMode, search, filteredFoods, recentFoods, foodIcons]);

  // --- Utility Functions ---
  const addToRecentFoods = useCallback(async (food: Food) => {
    if (!food || !food.id) return;
    setRecentFoods((prevRecent) => {
      if (prevRecent.length > 0 && prevRecent[0].id === food.id)
        return prevRecent;
      const updated = prevRecent.filter((rf) => rf.id !== food.id);
      updated.unshift(food);
      const trimmed = updated.slice(0, MAX_RECENT_FOODS);
      saveRecentFoods(trimmed).catch((err) =>
        console.error("Failed to save recent foods:", err)
      );
      return trimmed;
    });
  }, []);

  const servingSizeSuggestions = useMemo(() => {
    if (!selectedFood) return [];
    return [
      { label: "50g", value: "50" },
      { label: "100g", value: "100" },
      { label: "150g", value: "150" },
      { label: "200g", value: "200" },
    ];
  }, [selectedFood]);

  // --- Action Handlers ---
  const handleEstimateGrams = useCallback(async () => {
    Keyboard.dismiss();
    if (!selectedFood || !autoInput.trim()) {
      Alert.alert(
        "Input Missing",
        "Please select a food and enter a quantity description."
      );
      return;
    }
    if (isAiLoading) return;
    setIsAiLoading(true);
    try {
      const estimatedGrams = await getGramsFromNaturalLanguage(
        selectedFood.name,
        autoInput
      );
      const roundedGrams = String(Math.round(estimatedGrams));
      setGrams(roundedGrams);
      setUnitMode("grams");
      setAutoInput("");
      Toast.show({
        type: "success",
        text1: "Grams Estimated",
        text2: `Estimated ${roundedGrams}g for ${selectedFood.name}`,
        position: "bottom",
      });
    } catch (error: any) {
      console.error("AI Gram Estimation Error (AddEntryModal):", error);
      // Error alert is now handled within getGramsFromNaturalLanguage
    } finally {
      setIsAiLoading(false);
    }
  }, [selectedFood, autoInput, isAiLoading, setGrams]);

  const handleAddOrUpdateSingleEntry = useCallback(async () => {
    Keyboard.dismiss();
    if (!selectedFood) {
      Alert.alert("Food Not Selected", "Please select a food item.");
      return;
    }
    const numericGrams = parseFloat(grams);
    if (!isValidNumberInput(grams) || numericGrams <= 0) {
      Alert.alert(
        "Invalid Amount",
        "Please enter a valid positive number for grams."
      );
      return;
    }
    if (isActionDisabled) return;
    handleAddEntry();
    if (!isEditMode) addToRecentFoods(selectedFood);
  }, [
    selectedFood,
    grams,
    isActionDisabled,
    isEditMode,
    handleAddEntry,
    addToRecentFoods,
  ]);

  const handleInternalSelectFood = useCallback(
    (item: Food | null) => {
      handleSelectFood(item);
      updateSearch("");
      Keyboard.dismiss();
      if (!isEditMode && item?.id !== selectedFood?.id) {
        setGrams("");
        setUnitMode("grams");
        setAutoInput("");
      }
    },
    [handleSelectFood, updateSearch, isEditMode, selectedFood, setGrams]
  );

  // --- Quick Add Functions ---
  const pickImageAndAnalyze = useCallback(
    async (source: "camera" | "gallery") => {
      if (isEditMode) return;
      let permissionResult;
      let pickerResult: ImagePicker.ImagePickerResult;
      setQuickAddLoading(true);
      setQuickAddItems([]);
      setSelectedQuickAddIndices(new Set());
      setEditingQuickAddItemIndex(null);
      setModalMode("quickAddSelect");
      handleSelectFood(null);
      updateSearch("");
      setGrams("");
      try {
        if (source === "camera") {
          permissionResult = await ImagePicker.requestCameraPermissionsAsync();
          if (!permissionResult.granted) {
            Alert.alert("Permission Required", "Camera access needed.");
            throw new Error("Permission denied");
          }
          pickerResult = await ImagePicker.launchCameraAsync({
            quality: 1,
            exif: false,
          });
        } else {
          permissionResult =
            await ImagePicker.requestMediaLibraryPermissionsAsync();
          if (!permissionResult.granted) {
            Alert.alert("Permission Required", "Gallery access needed.");
            throw new Error("Permission denied");
          }
          pickerResult = await ImagePicker.launchImageLibraryAsync({
            mediaTypes: ImagePicker.MediaTypeOptions.Images, // Corrected usage
            quality: 1,
          });
        }
        if (pickerResult.canceled) throw new Error("User cancelled");
        if (pickerResult.assets && pickerResult.assets.length > 0) {
          const originalAsset = pickerResult.assets[0];
          const compressedResult = await compressImageIfNeeded(originalAsset);
          const assetForAnalysis = compressedResult
            ? {
                ...originalAsset,
                uri: compressedResult.uri,
                width: compressedResult.width,
                height: compressedResult.height,
                mimeType: "image/jpeg", // Compressor standardizes to JPEG
              }
            : originalAsset;
          const base64Image = await getBase64FromUri(assetForAnalysis.uri);
          const mimeType = determineMimeType(assetForAnalysis);
          const results = await getMultipleFoodsFromImage(
            base64Image,
            mimeType
          );
          if (results.length === 0) {
            // Alert is handled by getMultipleFoodsFromImage, just reset modal mode
            console.log("No foods identified by backend.");
            setModalMode("normal");
          } else {
            setQuickAddItems(results);
            setSelectedQuickAddIndices(new Set(results.map((_, i) => i)));
          }
        } else throw new Error("Could not select image.");
      } catch (error: any) {
        if (
          error.message !== "User cancelled" &&
          error.message !== "Permission denied" && // Avoid double alert
          !(error instanceof BackendError) // Backend errors show alerts via utils/macros
        ) {
          Alert.alert(
            "Error",
            error.message || "An unexpected error occurred."
          );
        }
        // Reset to normal mode if any error occurred during process
        setModalMode("normal");
        setQuickAddItems([]);
        setSelectedQuickAddIndices(new Set());
      } finally {
        // Add slight delay to allow UI to settle before removing loading indicator
        setTimeout(() => setQuickAddLoading(false), 150);
      }
    },
    [isEditMode, handleSelectFood, updateSearch, setGrams]
  );

  const handleQuickAddImage = useCallback(async () => {
    Keyboard.dismiss();
    if (isEditMode || isActionDisabled) return;
    if (editingQuickAddItemIndex !== null) {
      Alert.alert(
        "Finish Editing",
        "Please save or cancel the current edit first."
      );
      return;
    }
    Alert.alert(
      "Quick Add from Image",
      "Identify multiple foods from an image.",
      [
        { text: "Cancel", style: "cancel" },
        { text: "Camera", onPress: () => pickImageAndAnalyze("camera") },
        { text: "Gallery", onPress: () => pickImageAndAnalyze("gallery") },
      ]
    );
  }, [
    isEditMode,
    editingQuickAddItemIndex,
    isActionDisabled,
    pickImageAndAnalyze,
  ]);

  const handleToggleQuickAddItem = useCallback(
    (index: number) => {
      if (editingQuickAddItemIndex !== null || isActionDisabled) return;
      setSelectedQuickAddIndices((prev) => {
        const newSet = new Set(prev);
        if (newSet.has(index)) newSet.delete(index);
        else newSet.add(index);
        return newSet;
      });
    },
    [editingQuickAddItemIndex, isActionDisabled]
  );

  const handleEditQuickAddItem = useCallback(
    (index: number) => {
      if (editingQuickAddItemIndex !== null || isActionDisabled) {
        if (editingQuickAddItemIndex !== null)
          Alert.alert(
            "Finish Editing",
            "Please save or cancel the current edit first."
          );
        return;
      }
      const item = quickAddItems[index];
      setEditingQuickAddItemIndex(index);
      setEditedFoodName(item.foodName);
      setEditedGrams(String(Math.round(item.estimatedWeightGrams)));
    },
    [editingQuickAddItemIndex, quickAddItems, isActionDisabled]
  );

  const handleSaveQuickAddItemEdit = useCallback(() => {
    if (editingQuickAddItemIndex === null || isActionDisabled) return;
    const trimmedName = editedFoodName.trim();
    if (!trimmedName) {
      Alert.alert("Invalid Name", "Food name cannot be empty.");
      return;
    }
    const numericGrams = parseFloat(editedGrams);
    if (!isValidNumberInput(editedGrams) || numericGrams <= 0) {
      Alert.alert("Invalid Grams", "Please enter a valid positive number.");
      return;
    }
    const roundedGrams = Math.round(numericGrams);
    setQuickAddItems((prevItems) =>
      prevItems.map((item, index) =>
        index === editingQuickAddItemIndex
          ? {
              ...item,
              foodName: trimmedName,
              estimatedWeightGrams: roundedGrams,
            }
          : item
      )
    );
    setEditingQuickAddItemIndex(null);
    setEditedFoodName("");
    setEditedGrams("");
    Keyboard.dismiss();
  }, [editingQuickAddItemIndex, editedFoodName, editedGrams, isActionDisabled]);

  const handleCancelQuickAddItemEdit = useCallback(() => {
    if (isActionDisabled) return;
    setEditingQuickAddItemIndex(null);
    setEditedFoodName("");
    setEditedGrams("");
    Keyboard.dismiss();
  }, [isActionDisabled]);

  const handleConfirmQuickAdd = useCallback(() => {
    Keyboard.dismiss();
    if (isEditMode || isActionDisabled) return;
    if (editingQuickAddItemIndex !== null) {
      Alert.alert("Finish Editing", "Save or cancel your edit before adding.");
      return;
    }
    if (selectedQuickAddIndices.size === 0) {
      Alert.alert("No Items Selected", "Select items to add.");
      return;
    }
    try {
      const entriesToAdd: { food: Food; grams: number }[] = [];
      Array.from(selectedQuickAddIndices).forEach((index) => {
        if (index >= 0 && index < quickAddItems.length) {
          const item = quickAddItems[index];
          // Create a Food object compliant with the app's Food type
          const quickFood: Food = {
            id: uuidv4(), // Generate a local UUID for this potentially new food
            name: item.foodName,
            calories: Math.round(Number(item.calories_per_100g) || 0),
            protein: Math.round(Number(item.protein_per_100g) || 0),
            carbs: Math.round(Number(item.carbs_per_100g) || 0),
            fat: Math.round(Number(item.fat_per_100g) || 0),
          };
          const entryGrams = Math.max(
            1, // Ensure grams is at least 1
            Math.round(Number(item.estimatedWeightGrams) || 1)
          );
          entriesToAdd.push({ food: quickFood, grams: entryGrams });
        } else
          console.warn(
            `Skipping invalid index ${index} during quick add confirm.`
          );
      });
      if (entriesToAdd.length > 0) handleAddMultipleEntries(entriesToAdd);
      else
        Alert.alert(
          "Nothing to Add",
          "No valid items were selected or prepared."
        );
    } catch (error) {
      console.error("Error confirming Quick Add:", error);
      Alert.alert("Error", "Could not prepare items to add.");
    }
  }, [
    quickAddItems,
    selectedQuickAddIndices,
    editingQuickAddItemIndex,
    handleAddMultipleEntries,
    isEditMode,
    isActionDisabled,
  ]);

  const handleQuickAddGramsChange = useCallback((text: string) => {
    // Allow only numbers (and potentially a single decimal point if needed later)
    const cleanedText = text.replace(/[^0-9]/g, "");
    setEditedGrams(cleanedText);
  }, []);

  // --- Computed States for Disabling UI Elements ---
  const isAddButtonDisabled =
    modalMode !== "normal" ||
    !selectedFood ||
    !isValidNumberInput(grams) ||
    parseFloat(grams) <= 0 ||
    isActionDisabled;
  const isAiButtonDisabled =
    modalMode !== "normal" ||
    !selectedFood ||
    !autoInput.trim() ||
    isActionDisabled;
  const isQuickAddConfirmDisabled =
    isEditMode ||
    modalMode !== "quickAddSelect" ||
    selectedQuickAddIndices.size === 0 ||
    editingQuickAddItemIndex !== null ||
    isActionDisabled;
  const isQuickAddImageButtonDisabled = isEditMode || isActionDisabled;

  // --- Build list data for the main FlatList ---
  const listData = useMemo((): ListItemType[] => {
    const items: ListItemType[] = [];
    if (modalMode === "normal") {
      items.push({ type: "searchBar", key: "searchBar" });
      if (!search && recentFoods.length > 0) {
        items.push({ type: "recentFoods", key: "recentFoods" });
      }
      if (search) {
        if (filteredFoods.length > 0) {
          filteredFoods.forEach((food) =>
            items.push({
              type: "searchResults",
              key: `search-${food.id}`,
              data: food,
            })
          );
        } else {
          items.push({ type: "noResults", key: "noResults" });
        }
      }
      if (selectedFood) {
        items.push({ type: "amountInput", key: "amountInput" });
      }
    } else if (modalMode === "quickAddSelect") {
      items.push({ type: "quickAddHeader", key: "quickAddHeader" });
      // Push the QuickAddList component instead of individual items
      items.push({ type: "quickAddList", key: "quickAddList" });
    }
    // Add a spacer at the bottom to prevent content being hidden by action buttons
    items.push({ type: "spacer", key: "bottom-spacer", height: 60 });
    return items;
  }, [
    modalMode,
    search,
    recentFoods,
    filteredFoods,
    selectedFood,
    // Quick add state needed for QuickAddList extraData or component update
    quickAddItems,
    editingQuickAddItemIndex,
    selectedQuickAddIndices,
    quickAddLoading,
  ]);

  // --- Render individual item types for the main FlatList ---
  const renderListItem = useCallback(
    ({ item }: { item: ListItemType }): React.ReactElement | null => {
      switch (item.type) {
        case "searchBar":
          return (
            <SearchBar
              placeholder="Search Foods..."
              onChangeText={updateSearch}
              value={search}
              platform={Platform.OS === "ios" ? "ios" : "android"}
              containerStyle={styles.searchBarContainer}
              inputContainerStyle={styles.searchBarInputContainer}
              inputStyle={styles.searchInputStyle}
              onCancel={() => updateSearch("")}
              showCancel={Platform.OS === "ios"}
              onClear={() => updateSearch("")}
              disabled={isActionDisabled || modalMode !== "normal"}
            />
          );
        case "recentFoods":
          // If there are no recent foods, render nothing for this case.
          if (!recentFoods || recentFoods.length === 0) {
            return null;
          }
          return (
            <View style={styles.recentFoodsSection}>
              <Text style={styles.sectionTitle}>Recent</Text>
              <ScrollView
                horizontal
                showsHorizontalScrollIndicator={false}
                contentContainerStyle={styles.recentFoodsContainer}
                keyboardShouldPersistTaps="handled" // Good practice for scrollviews with touchables
              >
                {recentFoods.map((food) => (
                  <TouchableOpacity
                    key={`recent-${food.id}`}
                    style={[
                      styles.recentFoodItem,
                      // Apply conditional styles
                      screenWidth < 350 && styles.smallRecentFoodItem,
                      selectedFood?.id === food.id &&
                        styles.selectedRecentFoodItem,
                      isActionDisabled && styles.disabledOverlay,
                    ]}
                    onPress={() =>
                      !isActionDisabled && handleInternalSelectFood(food)
                    }
                    disabled={isActionDisabled}
                  >
                    {/* --- Start: Icon/Image/Indicator Rendering (No spaces between elements) --- */
                    foodIcons[food.name] !== undefined ? (
                      foodIcons[food.name] ? (
                        <Image
                          source={{ uri: foodIcons[food.name] as string }}
                          style={styles.foodIconSmall}
                          onError={() =>
                            setFoodIcons((prev) => ({
                              ...prev,
                              [food.name]: null,
                            }))
                          }
                          resizeMode="contain"
                        />
                      ) : (
                        <View
                          style={[
                            styles.foodIconSmall,
                            styles.iconPlaceholderSmall,
                          ]}
                        >
                          <Icon
                            name="fastfood"
                            type="material"
                            size={12}
                            color={theme.colors.grey2}
                          />
                        </View>
                      )
                    ) : (
                      <ActivityIndicator
                        size="small"
                        color={theme.colors.grey3}
                        style={styles.foodIconSmall}
                      />
                    )}
                    {/* --- End: Icon Block --- */
                    /* --- Start: Text Block (Immediately follows Icon Block) --- */}
                    <Text
                      style={[
                        styles.recentFoodText,
                        screenWidth < 350 && styles.smallRecentFoodText,
                      ]}
                      numberOfLines={1}
                      ellipsizeMode="tail"
                    >
                      {food.name}
                    </Text>
                    {/* --- End: Text Block --- */}
                  </TouchableOpacity>
                ))}
              </ScrollView>
            </View>
          );
        case "searchResults": {
          const food = item.data;
          const isSelected = selectedFood?.id === food.id;
          return (
            <TouchableOpacity
              onPress={() =>
                !isActionDisabled && handleInternalSelectFood(food)
              }
              disabled={isActionDisabled}
              style={[isActionDisabled && styles.disabledOverlay]}
            >
              <ListItem
                bottomDivider
                containerStyle={[
                  styles.listItemContainer,
                  isSelected && styles.selectedListItem,
                ]}
              >
                {/* --- Start: Icon Block (No spaces between elements) --- */
                foodIcons[food.name] !== undefined ? (
                  foodIcons[food.name] ? (
                    <Image
                      source={{ uri: foodIcons[food.name] as string }}
                      style={styles.foodIcon}
                      onError={() =>
                        setFoodIcons((prev) => ({ ...prev, [food.name]: null }))
                      }
                      resizeMode="contain"
                    />
                  ) : (
                    <View style={styles.defaultIconContainer}>
                      <Icon
                        name="restaurant"
                        type="material"
                        size={18}
                        color={theme.colors.grey3}
                      />
                    </View>
                  )
                ) : (
                  <ActivityIndicator
                    size="small"
                    color={theme.colors.grey3}
                    style={styles.foodIcon}
                  />
                )/* --- End: Icon Block --- */
                /* --- Start: Content Block (Immediately follows Icon Block) --- */}
                <ListItem.Content>
                  <ListItem.Title style={styles.listItemTitle}>
                    {food.name}
                  </ListItem.Title>
                </ListItem.Content>
                {/* --- End: Content Block --- */
                /* --- Start: Checkmark Block (Immediately follows Content Block) --- */
                isSelected && (
                  <Icon
                    name="checkmark-circle"
                    type="ionicon"
                    color={theme.colors.primary}
                    size={24}
                  />
                )/* --- End: Checkmark Block --- */}
              </ListItem>
            </TouchableOpacity>
          );
        }
        case "noResults":
          return (
            <Text style={styles.noFoodsText}>
              {modalMode === "quickAddSelect"
                ? "No food items found in the image."
                : `No foods found matching "${search}".`}
            </Text>
          );
        case "amountInput":
          if (!selectedFood) {
            return null;
          }
          return (
            <View style={styles.amountSection}>
              {/* --- Unit Selector --- */}
              <View style={styles.unitSelectorContainer}>
                <Text style={styles.inputLabel}>Amount</Text>
                <ButtonGroup
                  buttons={["Grams", "Auto (AI)"]}
                  selectedIndex={unitMode === "grams" ? 0 : 1}
                  onPress={(index) =>
                    !isActionDisabled &&
                    setUnitMode(index === 0 ? "grams" : "auto")
                  }
                  containerStyle={styles.buttonGroupContainer}
                  selectedButtonStyle={{
                    backgroundColor: theme.colors.primary,
                  }}
                  textStyle={styles.buttonGroupText}
                  selectedTextStyle={{ color: theme.colors.white }}
                  disabled={isEditMode ? [1] : isActionDisabled ? [0, 1] : []}
                  disabledStyle={styles.disabledButtonGroup}
                  disabledTextStyle={{ color: theme.colors.grey3 }}
                />
              </View>
              {/* --- Grams Input Mode --- */}
              {unitMode === "grams" && (
                <>
                  {/* --- Serving Size Suggestions --- */}
                  {!isEditMode && servingSizeSuggestions.length > 0 && (
                    <View style={styles.servingSizeRow}>
                      <Text style={styles.servingSizeLabel}>Quick Add:</Text>
                      <ScrollView
                        horizontal
                        showsHorizontalScrollIndicator={false}
                        contentContainerStyle={styles.servingSizeContainer}
                        keyboardShouldPersistTaps="handled"
                      >
                        {servingSizeSuggestions.map((suggestion) => (
                          <TouchableOpacity
                            key={suggestion.label}
                            style={[
                              styles.servingSizeButton,
                              isActionDisabled && styles.disabledOverlay,
                            ]}
                            onPress={() =>
                              !isActionDisabled && setGrams(suggestion.value)
                            }
                            disabled={isActionDisabled}
                          >
                            <Text style={styles.servingSizeButtonTitle}>
                              {suggestion.label}
                            </Text>
                          </TouchableOpacity>
                        ))}
                      </ScrollView>
                    </View>
                  )}
                  {/* --- Grams Input Field --- */}
                  <Input
                    placeholder={
                      isEditMode ? "Update grams" : "Enter grams (e.g., 150)"
                    }
                    keyboardType="numeric"
                    value={grams}
                    onChangeText={(text) => {
                      const cleanedText = text
                        .replace(/[^0-9.]/g, "")
                        .replace(/(\..*?)\./g, "$1");
                      setGrams(cleanedText);
                    }}
                    inputStyle={styles.gramInputStyle}
                    inputContainerStyle={styles.gramInputContainerStyle}
                    errorMessage={
                      !isValidNumberInput(grams) &&
                      grams !== "" &&
                      grams !== "."
                        ? "Enter a valid number"
                        : ""
                    }
                    errorStyle={{ color: theme.colors.error }}
                    rightIcon={<Text style={styles.unitText}>g</Text>}
                    containerStyle={{ paddingHorizontal: 0 }}
                    key={`grams-input-${selectedFood.id}-${isEditMode}`}
                    disabled={isActionDisabled}
                  />
                </>
              )}
              {/* --- Auto (AI) Input Mode --- */}
              {unitMode === "auto" && !isEditMode && (
                <View style={styles.autoInputRow}>
                  <Input
                    placeholder="Describe quantity (e.g., 1 cup cooked)"
                    value={autoInput}
                    onChangeText={setAutoInput}
                    inputStyle={[styles.gramInputStyle, styles.autoInputField]}
                    inputContainerStyle={styles.gramInputContainerStyle}
                    containerStyle={styles.autoInputContainer}
                    multiline={false}
                    onSubmitEditing={handleEstimateGrams}
                    key={`auto-input-${selectedFood.id}`}
                    disabled={isActionDisabled}
                  />
                  <Button
                    onPress={handleEstimateGrams}
                    disabled={isAiButtonDisabled || isActionDisabled}
                    loading={isAiLoading}
                    buttonStyle={styles.aiButton}
                    icon={
                      isAiLoading ? undefined : (
                        <Icon
                          name="calculator-variant"
                          type="material-community"
                          size={20}
                          color={theme.colors.white}
                        />
                      )
                    }
                    title={isAiLoading ? "" : ""}
                  />
                </View>
              )}
            </View>
          );
        case "quickAddHeader":
          return (
            <View style={styles.quickAddHeader}>
              <Text style={styles.sectionTitle}>
                {/* Removed extra spaces inside {} */}
                {editingQuickAddItemIndex !== null
                  ? "Editing Item Details"
                  : "Select Items from Image"}
              </Text>
              {editingQuickAddItemIndex === null && (
                <Button
                  type="clear"
                  title="Back"
                  onPress={() => {
                    if (isActionDisabled) return;
                    setModalMode("normal");
                    setQuickAddItems([]);
                    setSelectedQuickAddIndices(new Set());
                    setEditingQuickAddItemIndex(null);
                  }}
                  titleStyle={{ color: theme.colors.primary, fontSize: 14 }}
                  icon={
                    <Icon
                      name="arrow-back"
                      type="ionicon"
                      size={18}
                      color={theme.colors.primary}
                    />
                  }
                  disabled={isActionDisabled}
                />
              )}
            </View>
          );
        case "quickAddList":
          return (
            <QuickAddList
              items={quickAddItems}
              selectedIndices={selectedQuickAddIndices}
              editingIndex={editingQuickAddItemIndex}
              editedName={editedFoodName}
              editedGrams={editedGrams}
              onToggleItem={handleToggleQuickAddItem}
              onEditItem={handleEditQuickAddItem}
              onSaveEdit={handleSaveQuickAddItemEdit}
              onCancelEdit={handleCancelQuickAddItemEdit}
              onNameChange={setEditedFoodName} // Pass setter directly
              onGramsChange={handleQuickAddGramsChange} // Pass specific handler
              isLoading={quickAddLoading} // Pass loading state
              style={styles.quickAddListStyle} // Add specific styles if needed
            />
          );
        case "spacer":
          return <View style={{ height: item.height }} />;
        default:
          return null;
      }
    },
    [
      // Include all dependencies used within the callback
      search, updateSearch, isActionDisabled, modalMode, recentFoods, screenWidth,
      selectedFood, foodIcons, setFoodIcons, handleInternalSelectFood, filteredFoods,
      unitMode, setUnitMode, isEditMode, servingSizeSuggestions, setGrams, grams,
      autoInput, setAutoInput, handleEstimateGrams, isAiLoading, isAiButtonDisabled,
      theme, styles, // Styles and theme are used
      // Quick Add State/Handlers for QuickAddList props and other parts
      quickAddLoading, quickAddItems, editingQuickAddItemIndex, selectedQuickAddIndices,
      editedFoodName, editedGrams, handleToggleQuickAddItem, handleEditQuickAddItem,
      handleSaveQuickAddItemEdit, handleCancelQuickAddItemEdit, handleQuickAddGramsChange,
      // Other general handlers
      handleAddOrUpdateSingleEntry, handleConfirmQuickAdd, handleQuickAddImage,
      handleAddMultipleEntries,
    ]
  );

  // --- Render ---
  const combinedOverlayStyle = StyleSheet.flatten([
    styles.overlayStyle,
    { backgroundColor: theme.colors.background },
  ]);

  return (
    <Overlay
      isVisible={isVisible}
      onBackdropPress={!isActionDisabled ? toggleOverlay : undefined}
      animationType="slide"
      overlayStyle={styles.overlayContainer}
    >
      <KeyboardAvoidingView
        behavior={Platform.OS === "ios" ? "padding" : "height"}
        style={styles.keyboardAvoidingView}
        keyboardVerticalOffset={KEYBOARD_VERTICAL_OFFSET}
      >
        <View style={combinedOverlayStyle}>
          {/* Header */}
          <View style={styles.header}>
            <TouchableOpacity
              onPress={!isActionDisabled ? toggleOverlay : undefined}
              style={styles.closeIconTouchable}
              disabled={isActionDisabled}
            >
              <Icon
                name="close"
                type="material"
                size={28}
                color={
                  isActionDisabled ? theme.colors.grey3 : theme.colors.text
                }
              />
            </TouchableOpacity>
            <Text
              h4
              h4Style={[
                styles.overlayTitle,
                isEditMode && modalMode === "normal" && styles.editModeTitle,
              ]}
              numberOfLines={1}
              ellipsizeMode="tail"
            >
              {modalMode === "quickAddSelect"
                ? editingQuickAddItemIndex !== null
                  ? "Edit Item"
                  : "Select Items to Add"
                : isEditMode
                ? "Edit Entry"
                : "Add Entry"}
            </Text>
            {/* Conditional Action Buttons */}
            {modalMode === "normal" ? (
              <View style={styles.headerActionsNormal}>
                {!isEditMode && (
                  <TouchableOpacity
                    onPress={handleQuickAddImage}
                    disabled={isQuickAddImageButtonDisabled}
                    style={styles.headerIcon}
                  >
                    {quickAddLoading && modalMode === "normal" ? ( // Show indicator if loading started from normal mode
                      <ActivityIndicator
                        size="small"
                        color={theme.colors.primary}
                      />
                    ) : (
                      <Icon
                        name="camera-burst"
                        type="material-community"
                        size={26}
                        color={
                          isQuickAddImageButtonDisabled
                            ? theme.colors.grey3
                            : theme.colors.primary
                        }
                      />
                    )}
                  </TouchableOpacity>
                )}
                <Button
                  title={isEditMode ? "Update" : "Add"}
                  onPress={handleAddOrUpdateSingleEntry}
                  disabled={isAddButtonDisabled}
                  buttonStyle={[
                    styles.addButton,
                    isEditMode && styles.updateButton,
                  ]}
                  titleStyle={styles.buttonTitle}
                  // Show loading indicator on Add/Update if AI is processing (related action)
                  loading={isAiLoading && unitMode === "auto"}
                />
              </View>
            ) : editingQuickAddItemIndex === null ? ( // Quick Add Confirm Button
              <Button
                title={`Add ${selectedQuickAddIndices.size}`}
                onPress={handleConfirmQuickAdd}
                disabled={isQuickAddConfirmDisabled}
                buttonStyle={[
                  styles.addButton,
                  { backgroundColor: theme.colors.success },
                ]}
                titleStyle={styles.buttonTitle}
                // Show loading indicator if quick add backend call is active
                loading={quickAddLoading}
              />
            ) : (
              // Placeholder for alignment when editing a quick add item (Save/Cancel are inside list)
              <View style={{ width: 70, marginLeft: 5 }} />
            )}
          </View>

          {/* Content Area - FlatList */}
          <FlatList
            data={listData}
            renderItem={renderListItem}
            keyExtractor={(item) => item.key}
            extraData={{ // Ensure FlatList updates when these states change
              selectedFood, grams, unitMode, autoInput, isAiLoading, search,
              foodIcons, modalMode, quickAddItems, selectedQuickAddIndices,
              editingQuickAddItemIndex, editedFoodName, editedGrams,
              isActionDisabled, quickAddLoading
            }}
            style={styles.flatListContainer}
            contentContainerStyle={styles.flatListContentContainer}
            keyboardShouldPersistTaps="handled"
            initialNumToRender={10}
            maxToRenderPerBatch={10}
            windowSize={5}
          />
        </View>
      </KeyboardAvoidingView>
      {/* Toast needs to be outside Overlay for visibility */}
      {/* <Toast /> <-- Consider placing Toast outside or ensuring Overlay doesn't block it */}
    </Overlay>
  );
};

// --- Styles --- (Removed QuickAdd specific item styles as they are now in QuickAddList. Added style for the list container itself)
const useStyles = makeStyles((theme) => ({
    overlayContainer: {
        backgroundColor: "transparent", // Allows underlying content blur/dim
        width: "90%",
        maxWidth: 500, // Max width for larger screens/tablets
        padding: 0, // Handled by overlayStyle inside
        borderRadius: 15,
        shadowColor: "#000",
        shadowOffset: { width: 0, height: 3 },
        shadowOpacity: 0.2,
        shadowRadius: 5,
        elevation: 6,
        overflow: "hidden", // Clip content to rounded corners
        maxHeight: Dimensions.get("window").height * 0.85, // Limit height
    },
    overlayStyle: { // Inner container styling
        width: "100%",
        height: "100%",
        borderRadius: 15, // Match outer container
        padding: 15, // Standard padding
        paddingBottom: 0, // Allow FlatList to manage bottom space
        backgroundColor: theme.colors.background,
        flex: 1, // Ensure it takes full space of the overlay container
    },
    keyboardAvoidingView: { width: "100%", height: "100%" }, // Take full overlay space
    header: {
        flexDirection: "row",
        justifyContent: "space-between",
        alignItems: "center",
        marginBottom: 15,
        paddingHorizontal: 0, // Padding managed by overlayStyle
    },
    closeIconTouchable: { padding: 5, zIndex: 1 }, // Ensure touchable, on top
    overlayTitle: {
        color: theme.colors.text,
        fontWeight: "bold",
        fontSize: 20,
        textAlign: "center",
        flex: 1, // Allow title to take available space
        marginHorizontal: 5, // Space around title
    },
    editModeTitle: { color: theme.colors.warning },
    headerActionsNormal: { flexDirection: "row", alignItems: "center" },
    headerIcon: { padding: 5, marginHorizontal: 5, zIndex: 1 },
    addButton: {
        borderRadius: 20, // Pill shape
        paddingHorizontal: 15,
        paddingVertical: 8,
        minWidth: 70, // Ensure minimum size
        marginLeft: 5, // Space from icon/edge
        backgroundColor: theme.colors.primary,
        zIndex: 1,
    },
    updateButton: { backgroundColor: theme.colors.warning }, // Specific color for update
    buttonTitle: { color: theme.colors.white, fontWeight: "600", fontSize: 15 },
    flatListContainer: { flex: 1, width: "100%" }, // Take remaining vertical space
    flatListContentContainer: { paddingBottom: 30 }, // Space at the bottom of list
    searchBarContainer: {
        backgroundColor: "transparent",
        borderBottomColor: "transparent",
        borderTopColor: "transparent",
        paddingHorizontal: 0, // Use container padding
        marginBottom: 10,
    },
    searchBarInputContainer: {
        borderRadius: 25,
        backgroundColor: theme.colors.searchBg || theme.colors.grey5,
        height: 40, // Standard height
    },
    searchInputStyle: { color: theme.colors.text, fontSize: 15 },
    recentFoodsSection: { marginBottom: 15 },
    sectionTitle: {
        fontWeight: "600",
        marginBottom: 8,
        color: theme.colors.text,
        fontSize: 14,
        marginLeft: 5,
        textTransform: "uppercase",
    },
    recentFoodsContainer: { paddingHorizontal: 5, paddingVertical: 2 },
    recentFoodItem: {
        paddingHorizontal: 10,
        paddingVertical: 6,
        borderRadius: 16, // Pill shape
        backgroundColor: theme.colors.grey5,
        marginRight: 8,
        flexDirection: "row", // Align icon and text
        alignItems: "center",
        borderWidth: 1.5, // For selection highlight
        borderColor: "transparent", // Default border
    },
    selectedRecentFoodItem: { borderColor: theme.colors.primary }, // Highlight selected
    smallRecentFoodItem: { paddingHorizontal: 8, paddingVertical: 5 }, // Adjust for smaller screens
    foodIconSmall: {
        width: 20, height: 20, marginRight: 6, borderRadius: 10, // Circular small icon
        resizeMode: "contain", alignItems: "center", justifyContent: "center",
        backgroundColor: theme.colors.grey4, // BG for placeholder/loading
    },
    iconPlaceholderSmall: {
        backgroundColor: theme.colors.grey4,
        alignItems: "center", justifyContent: "center",
    },
    recentFoodText: { color: theme.colors.text, fontSize: 13, maxWidth: 80 }, // Limit text width
    smallRecentFoodText: { fontSize: 12, maxWidth: 70 },
    listItemContainer: {
        backgroundColor: "transparent", // Use parent background
        paddingVertical: 8,
        paddingHorizontal: 5,
        borderBottomColor: theme.colors.divider,
    },
    selectedListItem: { backgroundColor: theme.colors.grey5, borderRadius: 8 }, // Selection feedback
    defaultIconContainer: { // Placeholder icon wrapper
        width: 35, height: 35, marginRight: 12, borderRadius: 17.5, // Circular
        backgroundColor: theme.colors.grey5, alignItems: "center", justifyContent: "center",
    },
    foodIcon: { // Style for actual Image or loading indicator view
        width: 35, height: 35, marginRight: 12, borderRadius: 17.5, // Circular
        resizeMode: "contain", backgroundColor: theme.colors.grey5, // BG for loading/placeholder
        alignItems: "center", justifyContent: "center",
    },
    listItemTitle: { color: theme.colors.text, fontSize: 16, fontWeight: "500" },
    noFoodsText: {
        color: theme.colors.grey2, fontStyle: "italic", textAlign: "center",
        marginTop: 20, marginBottom: 10, paddingHorizontal: 10,
    },
    amountSection: {
        marginTop: 10, borderTopWidth: 1, borderTopColor: theme.colors.divider,
        paddingTop: 15, paddingHorizontal: 0, // Use container padding
    },
    unitSelectorContainer: {
        flexDirection: "row", alignItems: "center", justifyContent: "space-between",
        marginBottom: 15, paddingHorizontal: 5,
    },
    inputLabel: {
        fontWeight: "600", color: theme.colors.grey1, fontSize: 14,
        marginRight: 10, textTransform: "uppercase",
    },
    buttonGroupContainer: {
        flex: 0.7, maxWidth: 220, height: 35, borderRadius: 8,
        borderColor: theme.colors.primary, borderWidth: 1,
        backgroundColor: theme.colors.background,
    },
    buttonGroupText: { fontSize: 14, color: theme.colors.text },
    disabledButtonGroup: { backgroundColor: theme.colors.grey5 },
    servingSizeRow: {
        flexDirection: "row", alignItems: "center", marginBottom: 12, paddingHorizontal: 5,
    },
    servingSizeLabel: { color: theme.colors.grey2, fontSize: 13, marginRight: 8 },
    servingSizeContainer: { flexGrow: 0 }, // Don't let scrollview grow infinitely
    servingSizeButton: {
        backgroundColor: theme.colors.grey4, borderRadius: 15, // Rounded pill
        marginRight: 8, paddingHorizontal: 12, paddingVertical: 5,
        justifyContent: "center", alignItems: "center", height: 30,
    },
    servingSizeButtonTitle: { color: theme.colors.text, fontSize: 13 },
    gramInputStyle: {
        color: theme.colors.text, fontSize: 16, paddingVertical: 8, height: 40,
    },
    gramInputContainerStyle: {
        borderBottomColor: theme.colors.grey3, paddingHorizontal: 5,
    },
    unitText: { // For the 'g' unit
        color: theme.colors.grey2, fontSize: 15, fontWeight: "500", paddingRight: 5,
    },
    autoInputRow: {
        flexDirection: "row", alignItems: "center", paddingHorizontal: 0, // Use container padding
    },
    autoInputContainer: { flex: 1, paddingHorizontal: 0, marginRight: 10 },
    autoInputField: { height: 40 }, // Consistent height with grams input
    aiButton: {
        backgroundColor: theme.colors.secondary, borderRadius: 20, // Circular
        width: 40, height: 40, padding: 0, justifyContent: "center", alignItems: "center",
        minWidth: 40, // Ensure size doesn't shrink
    },
    quickAddHeader: {
        flexDirection: "row", justifyContent: "space-between", alignItems: "center",
        marginBottom: 10, paddingHorizontal: 5, borderBottomWidth: 1,
        borderBottomColor: theme.colors.divider, paddingBottom: 8,
    },
    // Style for the QuickAddList component container within the modal's FlatList
    quickAddListStyle: {
        // Allow QuickAddList to take available space within the modal's FlatList area
        // Max height can be implicitly controlled by the Overlay's maxHeight
        // Add padding/margins here ONLY if QuickAddList itself doesn't have them internally
        // e.g., paddingHorizontal: 5,
    },
    disabledOverlay: { // Simple opacity to indicate disabled state
        opacity: 0.6,
    },
}));

export default AddEntryModal;
// ---------- END src/components/AddEntryModal.tsx ----------
---------- END AddEntryModal.tsx ----------


---------- AddFoodModal.tsx ----------
import React, { useState, useEffect, useCallback } from "react";
import {
    View,
    KeyboardAvoidingView,
    Platform,
    ActivityIndicator,
    Alert,
    ScrollView,
    StyleSheet,
    TouchableOpacity,
} from "react-native";
import {
    Button,
    Input,
    Text,
    Overlay,
    makeStyles,
    useTheme,
    Icon,
} from "@rneui/themed";
import { Food } from "../types/food";
import { MaterialCommunityIcons } from "@expo/vector-icons";
import Toast from "react-native-toast-message";
import {
    getMacrosFromText,
    getMacrosForImageFile,
    BackendError,
    determineMimeType
} from "../utils/macros";
import * as ImagePicker from "expo-image-picker";
import { ImagePickerAsset, ImagePickerResult } from 'expo-image-picker';
import { isNotEmpty } from "../utils/validationUtils";
import { compressImageIfNeeded, getBase64FromUri } from '../utils/imageUtils';
import FoodFormFields from "./FoodFormFields"; // Import the extracted component

interface AddFoodModalProps {
    isVisible: boolean;
    toggleOverlay: () => void;
    newFood: Omit<Food, "id">; // For adding
    editFood: Food | null; // For editing
    errors: { [key: string]: string };
    handleInputChange: (
        key: keyof Omit<Food, "id">,
        value: string,
        isEdit: boolean
    ) => void;
    handleCreateFood: () => Promise<void>;
    handleUpdateFood: () => Promise<void>;
    validateFood: (food: Omit<Food, "id"> | Food) => { [key: string]: string } | null;
    setErrors: React.Dispatch<React.SetStateAction<{ [key: string]: string }>>;
}

const KEYBOARD_VERTICAL_OFFSET = Platform.OS === "ios" ? 60 : 0;

const AddFoodModal: React.FC<AddFoodModalProps> = ({
    isVisible,
    toggleOverlay,
    newFood,
    editFood,
    errors,
    handleInputChange,
    handleCreateFood,
    handleUpdateFood,
    validateFood,
    setErrors,
}) => {
    const { theme } = useTheme();
    const styles = useStyles();
    const [loading, setLoading] = useState(false);
    const [mode, setMode] = useState<"normal" | "ingredients">("normal");
    const [ingredients, setIngredients] = useState("");
    const [aiTextLoading, setAiTextLoading] = useState(false);
    const [aiImageLoading, setAiImageLoading] = useState(false);

    useEffect(() => {
        if (isVisible) {
            setErrors({});
            setMode("normal");
            setIngredients("");
            setAiTextLoading(false);
            setAiImageLoading(false);
            setLoading(false);
        }
    }, [isVisible, setErrors]);

    // Helper to get the current food object (editFood or newFood)
    const getCurrentFoodData = (): Partial<Omit<Food, 'id'>> => {
        return editFood ? editFood : newFood;
    };

    // Handle Add/Update button press
    const handleCreateOrUpdate = async () => {
        const isUpdate = !!editFood;
        const currentData = getCurrentFoodData();

        // Ensure name is present and trimmed for validation
        const dataToValidate = {
            name: (currentData.name ?? "").trim(),
            calories: currentData.calories ?? 0,
            protein: currentData.protein ?? 0,
            carbs: currentData.carbs ?? 0,
            fat: currentData.fat ?? 0,
        };

        const validationErrors = validateFood(dataToValidate);
        if (validationErrors) {
            setErrors(validationErrors);
            Toast.show({ type: "error", text1: "Please fix the errors", position: 'bottom' });
            return;
        }
        setErrors({});
        setLoading(true);

        try {
            if (isUpdate) {
                await handleUpdateFood();
                Toast.show({ type: "success", text1: `"${dataToValidate.name}" Updated!`, position: 'bottom' });
            } else {
                await handleCreateFood();
                Toast.show({ type: "success", text1: `"${dataToValidate.name}" Added!`, position: 'bottom' });
            }
            toggleOverlay();
        } catch (error: any) {
            console.error(`AddFoodModal: Error during ${isUpdate ? 'update' : 'create'} food handler:`, error);
            Alert.alert("Error", error.message || `Failed to ${isUpdate ? "update" : "add"} food.`);
        } finally {
            setLoading(false);
        }
    };

    // Handle AI Text/Recipe button click (unchanged)
    const handleAiTextButtonClick = async () => {
        const currentFoodName = (getCurrentFoodData().name ?? "").trim();
        const isUpdate = !!editFood;
        if (mode === "normal") {
            setMode("ingredients");
            handleInputChange("calories", "", isUpdate); handleInputChange("protein", "", isUpdate);
            handleInputChange("carbs", "", isUpdate); handleInputChange("fat", "", isUpdate);
        } else {
            if (!currentFoodName && !ingredients.trim()) { Alert.alert("Input Needed", "Please enter a food name or ingredients to analyze."); return; }
            setAiTextLoading(true);
            try {
                const macros = await getMacrosFromText(currentFoodName, ingredients);
                handleInputChange("calories", String(Math.round(macros.calories)), isUpdate); handleInputChange("protein", String(Math.round(macros.protein)), isUpdate);
                handleInputChange("carbs", String(Math.round(macros.carbs)), isUpdate); handleInputChange("fat", String(Math.round(macros.fat)), isUpdate);
                setMode("normal");
                Toast.show({ type: 'info', text1: 'Macros estimated from text.', position: 'bottom' });
            } catch (error) { console.error("AI Macro fetch error (recipe - modal):", error); }
            finally { setAiTextLoading(false); }
        }
    };

    // Handle Get Macros from Image button click (unchanged)
    const handleGetImageAndAnalyze = async () => {
        if (aiImageLoading || aiTextLoading || loading) return;
        const processImage = async (pickerResult: ImagePickerResult) => {
            if (pickerResult.canceled) return;
            if (pickerResult.assets && pickerResult.assets.length > 0) {
                const originalAsset = pickerResult.assets[0]; setAiImageLoading(true);
                try {
                     const compressedResult = await compressImageIfNeeded(originalAsset);
                     const assetForAnalysis = compressedResult ? { ...originalAsset, uri: compressedResult.uri, width: compressedResult.width, height: compressedResult.height, mimeType: 'image/jpeg' } : originalAsset;
                     const result = await getMacrosForImageFile(assetForAnalysis);
                     const isUpdate = !!editFood;
                     handleInputChange("name", result.foodName, isUpdate); handleInputChange("calories", String(Math.round(result.calories)), isUpdate);
                     handleInputChange("protein", String(Math.round(result.protein)), isUpdate); handleInputChange("carbs", String(Math.round(result.carbs)), isUpdate);
                     handleInputChange("fat", String(Math.round(result.fat)), isUpdate);
                     setMode("normal"); setIngredients("");
                     Toast.show({ type: 'success', text1: 'Food Identified!', text2: `Identified as ${result.foodName}. Macros estimated.`, position: 'bottom', });
                } catch (analysisError) { console.error("Error during image analysis (modal):", analysisError); }
                finally { setAiImageLoading(false); }
            } else { Alert.alert("Error", "Could not get image asset."); setAiImageLoading(false); }
        };
        Alert.alert("Get Image", "Choose a source for the food image:",
            [ { text: "Cancel", style: "cancel" },
              { text: "Camera", onPress: async () => { try { const perm = await ImagePicker.requestCameraPermissionsAsync(); if (!perm.granted) { Alert.alert("Permission Required", "Camera access needed."); return; } const res = await ImagePicker.launchCameraAsync({ quality: 1, exif: false }); await processImage(res); } catch (e) { console.error(e); Alert.alert("Camera Error"); } } },
              { text: "Gallery", onPress: async () => { try { const perm = await ImagePicker.requestMediaLibraryPermissionsAsync(); if (!perm.granted) { Alert.alert("Permission Required", "Gallery access needed."); return; } const res = await ImagePicker.launchImageLibraryAsync({ mediaTypes: ImagePicker.MediaTypeOptions.Images, quality: 1 }); await processImage(res); } catch (e) { console.error(e); Alert.alert("Gallery Error"); } } }, ],
            { cancelable: true }
        );
    };

    // --- Computed State ---
    const isAnyLoading = loading || aiTextLoading || aiImageLoading;

    // --- Render ---
    const combinedOverlayStyle = StyleSheet.flatten([
        styles.overlayStyle,
        { backgroundColor: theme.colors.background }
    ]);

    return (
        <Overlay isVisible={isVisible} onBackdropPress={!isAnyLoading ? toggleOverlay : undefined} animationType="fade" overlayStyle={styles.overlayContainer} >
            <KeyboardAvoidingView behavior={Platform.OS === "ios" ? "padding" : "height"} style={styles.keyboardAvoidingView} keyboardVerticalOffset={KEYBOARD_VERTICAL_OFFSET} >
                <View style={combinedOverlayStyle}>
                    {/* Header (unchanged) */}
                    <View style={styles.header}>
                        <Text h4 style={styles.overlayTitle}> {editFood ? "Edit Food" : "Add New Food"} </Text>
                        <Button title={editFood ? "Update" : "Add"} onPress={handleCreateOrUpdate}
                                buttonStyle={[ styles.button, { backgroundColor: editFood ? theme.colors.warning : theme.colors.primary } ]}
                                titleStyle={styles.buttonTitle} loading={loading} disabled={isAnyLoading} containerStyle={styles.buttonContainer} />
                        <Icon name="close" type="material" size={28} color={theme.colors.text} onPress={!isAnyLoading ? toggleOverlay : undefined}
                              containerStyle={styles.closeIcon} disabled={isAnyLoading} disabledStyle={{ backgroundColor: 'transparent' }} />
                    </View>

                    <ScrollView keyboardShouldPersistTaps="handled">
                        {/* Image Picker/Camera Icon Button */}
                        <View style={styles.imageButtonContainer}>
                            <TouchableOpacity onPress={handleGetImageAndAnalyze} disabled={isAnyLoading} style={styles.iconButton}>
                                {aiImageLoading ? ( <ActivityIndicator size="small" color={theme.colors.primary} /> ) : (
                                    <Icon name="camera-enhance-outline" type="material-community" size={28} color={isAnyLoading ? theme.colors.grey3 : theme.colors.primary} />
                                )}
                            </TouchableOpacity>
                             <Text style={styles.imageButtonLabel}>Get from Image</Text>
                        </View>

                        {/* Macro Inputs or Ingredient Input */}
                        {mode === "normal" ? (
                             // Use the extracted FoodFormFields component
                            <FoodFormFields
                                values={getCurrentFoodData()} // Pass the current data object
                                errors={errors}
                                onInputChange={handleInputChange}
                                isEditing={!!editFood}
                                disabled={isAnyLoading}
                            />
                        ) : ( // mode === "ingredients"
                            <>
                                <View style={styles.backButtonContainer}>
                                    <Icon name="arrow-left" type="material-community" size={24} color={theme.colors.primary} onPress={() => !isAnyLoading && setMode("normal")} disabled={isAnyLoading} containerStyle={styles.backIcon} />
                                    <Text style={[styles.backButtonText, isAnyLoading && styles.disabledText]} onPress={() => !isAnyLoading && setMode("normal")}> Back to Manual Input </Text>
                                </View>
                                {/* Keep ingredient input here as it's specific to this mode */}
                                 <Input
                                    label="Ingredients (Optional)" labelStyle={styles.inputLabel} value={ingredients} onChangeText={setIngredients} multiline={true}
                                    numberOfLines={4} inputContainerStyle={[styles.inputContainerStyle, styles.multilineInputContainer]} inputStyle={[styles.inputStyle, styles.multilineInput]}
                                    placeholder="e.g.\n100g Chicken Breast\n50g Rice\n1 tbsp Olive Oil" placeholderTextColor={theme.colors.grey3}
                                    leftIcon={<MaterialCommunityIcons name="format-list-bulleted" size={24} color={theme.colors.grey1} style={styles.multilineIcon} />}
                                    disabled={isAnyLoading}
                                />
                            </>
                        )}

                        {/* AI (Text) Button (unchanged) */}
                        <Button
                            title={mode === "normal" ? "Calculate with AI (Recipe/Text)" : ingredients ? "Get Macros from Ingredients" : "Get Macros from Name Only"}
                            onPress={handleAiTextButtonClick} buttonStyle={[styles.button, styles.aiButton, { backgroundColor: theme.colors.secondary }]}
                            titleStyle={styles.aiButtonTitle} loading={aiTextLoading} disabled={isAnyLoading}
                            icon={mode === "normal" ? <MaterialCommunityIcons name="text-box-search-outline" size={18} color={theme.colors.white} style={{ marginRight: 8 }} /> : undefined}
                            containerStyle={[styles.buttonContainer, { marginTop: 15 }]} />

                        {/* Barcode Placeholder (unchanged) */}
                        <View style={styles.futureInputContainer}>
                            <Text style={styles.futureInputLabel}> Barcode Input (Coming Soon) </Text>
                        </View>
                    </ScrollView>
                </View>
            </KeyboardAvoidingView>
        </Overlay>
    );
};

// --- Styles --- (Removed redundant input styles now in FoodFormFields)
const useStyles = makeStyles((theme) => ({
    overlayContainer: {
        backgroundColor: 'transparent', width: '90%', maxWidth: 500, padding: 0, borderRadius: 15,
        shadowColor: "#000", shadowOffset: { width: 0, height: 2, }, shadowOpacity: 0.25,
        shadowRadius: 3.84, elevation: 5, overflow: 'hidden',
    },
    overlayStyle: { width: '100%', borderRadius: 15, padding: 20, paddingBottom: 30, maxHeight: '90%', backgroundColor: theme.colors.background },
    keyboardAvoidingView: { width: "100%", },
    header: {
        flexDirection: "row", justifyContent: "space-between", alignItems: "center",
        marginBottom: 20, paddingBottom: 10, borderBottomWidth: 1, borderBottomColor: theme.colors.divider,
    },
    overlayTitle: { color: theme.colors.text, fontWeight: "bold", fontSize: 20, flexShrink: 1, marginRight: 10, },
    closeIcon: { padding: 5, marginLeft: 10, },
    // Image Button Styles
     imageButtonContainer: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'flex-start', // Align to left
        marginBottom: 15, // Space before next inputs
        paddingHorizontal: 10, // Match input padding
    },
    iconButton: {
        padding: 8,
        marginRight: 8,
        // Optional: add border or background for visual cue
        // borderWidth: 1,
        // borderColor: theme.colors.grey3,
        // borderRadius: 20,
    },
    imageButtonLabel: {
        color: theme.colors.primary,
        fontSize: 14,
        fontWeight: '500',
    },
    // Styles still needed in the modal
    inputLabel: { color: theme.colors.text, fontWeight: '500', marginBottom: 2, fontSize: 14 },
    inputContainerStyle: { borderBottomWidth: 1, borderBottomColor: theme.colors.grey4, marginBottom: 5, paddingBottom: 2, },
    inputStyle: { color: theme.colors.text, marginLeft: 10, fontSize: 16, },
    multilineInputContainer: {
        borderWidth: 1, borderColor: theme.colors.grey4, borderRadius: 8, paddingVertical: 8,
        paddingHorizontal: 5, marginBottom: 10, borderBottomWidth: 1, borderBottomColor: theme.colors.grey4,
        minHeight: 100,
    },
    multilineInput: { marginLeft: 5, textAlignVertical: 'top', fontSize: 16, color: theme.colors.text, },
    multilineIcon: { marginTop: 8, marginRight: 5, },
    futureInputContainer: {
        backgroundColor: theme.colors.grey5, padding: 15, borderRadius: 10,
        marginTop: 20, marginBottom: 10, alignItems: "center",
    },
    futureInputLabel: { color: theme.colors.grey2, fontStyle: "italic", },
    buttonContainer: { },
    button: { borderRadius: 8, paddingHorizontal: 15, paddingVertical: 10, },
    buttonTitle: { color: theme.colors.white, fontWeight: "600", fontSize: 15 },
    aiButton: { paddingVertical: 12, },
    aiButtonTitle: { fontWeight: "600", fontSize: 15, textAlign: 'center', },
    backButtonContainer: { flexDirection: "row", alignItems: "center", marginBottom: 15, marginTop: 5, },
    backIcon: { marginRight: 5, padding: 5, },
    backButtonText: { color: theme.colors.primary, fontSize: 16, fontWeight: '500', },
    disabledText: { color: theme.colors.grey3, }
}));

export default AddFoodModal;
---------- END AddFoodModal.tsx ----------


---------- ConfirmationModal.tsx ----------
// components/ConfirmationModal.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Overlay, Button, Input, Text, useTheme } from '@rneui/themed';

interface ConfirmationModalProps {
  isVisible: boolean;
  onCancel: () => void;
  onConfirm: () => void;
  confirmationText: string;
  setConfirmationText: (text: string) => void;
  title?: string; // Optional title
  message?: string;  //Optional message
}

const ConfirmationModal: React.FC<ConfirmationModalProps> = ({
  isVisible,
  onCancel,
  onConfirm,
  confirmationText,
  setConfirmationText,
  title = "Confirm Action", //default title
  message = "Are you sure you want to perform this action?"
}) => {
  const { theme } = useTheme();

  return (
    <Overlay
      isVisible={isVisible}
      onBackdropPress={onCancel}
      overlayStyle={styles.overlay}
      backdropStyle={styles.backdrop} // Add the backdropStyle
    >
      <View style={[styles.container, {backgroundColor: theme.colors.background}]}>
        <Text style={[styles.title, {color: theme.colors.text}]}>{title}</Text>
        <Text style={[styles.message, {color: theme.colors.text}]}>{message}</Text>
        <Input
          placeholder="Enter confirmation text"
          placeholderTextColor={theme.colors.text}
          value={confirmationText}
          onChangeText={setConfirmationText}
          containerStyle={styles.inputContainer}
          inputStyle={{ color: theme.colors.text }}
          inputContainerStyle={{borderBottomColor: theme.colors.text}}
        />
        <View style={styles.buttonContainer}>
          <Button title="Cancel" onPress={onCancel} type="outline" buttonStyle={styles.button} />
          <Button
            title="Confirm"
            onPress={onConfirm}
            color="error"
            buttonStyle={styles.button}
            disabled={confirmationText === ""}  //Disable when empty
          />
        </View>
      </View>
    </Overlay>
  );
};

const styles = StyleSheet.create({
    overlay: {
        borderRadius: 10,
        width: '80%', // Responsive width
        padding: 6,
        backgroundColor: 'rgba(200, 200, 200, 0.5)'
    },
  container: {
    padding: 20,
    borderRadius: 7,
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 10,
    textAlign: 'center', //center align
  },
  message: {
    marginBottom: 15,
    textAlign: 'center'
  },
  inputContainer: {
    marginBottom: 20,
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
  },
  button: {
    width: 100,
    padding: 10,
  },
  backdrop: {  // Add styles for the backdrop
    backgroundColor: 'rgba(0, 0, 0, 0.5)', // Semi-transparent black
  },
});

export default ConfirmationModal;
---------- END ConfirmationModal.tsx ----------


---------- DailyEntryListItem.tsx ----------
import React, { useState, useEffect, useCallback, memo } from 'react';
import { View, Image, ActivityIndicator, StyleSheet } from 'react-native';
import { ListItem, Button, Icon as RNEIcon, useTheme, makeStyles } from '@rneui/themed';
import { DailyEntryItem } from '../types/dailyEntry';

interface DailyEntryListItemProps {
    item: DailyEntryItem;
    reversedIndex: number; // Index in the reversed list for removal/edit identification
    foodIcons: { [foodName: string]: string | null | undefined };
    setFoodIcons: React.Dispatch<React.SetStateAction<{ [foodName: string]: string | null | undefined }>>;
    onEdit: (item: DailyEntryItem, reversedIndex: number) => void;
    onRemove: (reversedIndex: number) => void;
    isSaving: boolean;
}

const DailyEntryListItem = memo<DailyEntryListItemProps>(({
    item,
    reversedIndex,
    foodIcons,
    setFoodIcons, // Needed to update cache on image error
    onEdit,
    onRemove,
    isSaving,
}) => {
    const { theme } = useTheme();
    const styles = useStyles();
    const [iconLoadError, setIconLoadError] = useState(false);

    const iconStatus = item?.food?.name ? foodIcons[item.food.name] : undefined;
    const isLoadingIcon = iconStatus === undefined;

    const handleImageError = useCallback(() => {
        console.warn(`Image component failed to load icon for ${item.food.name}: ${iconStatus}`);
        setIconLoadError(true);
        // Explicitly update state in cache to null if Image fails
        if (item?.food?.name && foodIcons[item.food.name] !== null) {
            setFoodIcons(prev => ({ ...prev, [item.food.name]: null }));
        }
    }, [item.food.name, iconStatus, foodIcons, setFoodIcons]); // Added dependencies

    // Reset error state if the URL changes (e.g., during refresh)
    useEffect(() => {
        setIconLoadError(false);
    }, [iconStatus]);

    const renderListItemIcon = () => {
        if (!item?.food) {
             return ( // Placeholder if food data is somehow missing
                 <View style={[styles.foodIcon, styles.iconPlaceholder]}>
                     <RNEIcon name="help-circle-outline" type="ionicon" size={20} color={theme.colors.grey3} />
                 </View>
             );
        }
        if (isLoadingIcon) {
            // Consistent Loading Placeholder
            return (
                <View style={[styles.foodIcon, styles.iconPlaceholder]}>
                    <ActivityIndicator size="small" color={theme.colors.grey3} />
                </View>
            );
        } else if (iconStatus && !iconLoadError) {
            // Display Image
            return <Image source={{ uri: iconStatus }} style={styles.foodIconImage} onError={handleImageError} resizeMode="contain" />;
        } else {
            // Consistent Default/Error Placeholder
            return (
                <View style={[styles.foodIcon, styles.iconPlaceholder]}>
                    <RNEIcon
                        name="fast-food-outline" // Default icon consistent with FoodListScreen
                        type="ionicon"
                        size={20}
                        color={theme.colors.grey3}
                    />
                </View>
            );
        }
    };

    // Safe rendering check
     if (!item || !item.food) {
         console.warn("DailyEntryListItem: Attempted to render with invalid item:", item);
         // Optionally render a placeholder or null
         return (
             <ListItem containerStyle={styles.listItemContainer}>
                 <ListItem.Content>
                      <ListItem.Title style={{color: theme.colors.error}}>Invalid Entry Data</ListItem.Title>
                 </ListItem.Content>
             </ListItem>
         );
     }

    const handleEditPress = () => {
        if (!isSaving) {
            onEdit(item, reversedIndex);
        }
    };

    const handleDeletePress = () => {
        if (!isSaving) {
            onRemove(reversedIndex);
        }
    };

    return (
        <ListItem.Swipeable
            bottomDivider
            leftContent={(reset) => (
                <Button
                    title="Edit"
                    onPress={() => { handleEditPress(); reset(); }}
                    icon={{ name: "edit", color: theme.colors.white }}
                    buttonStyle={styles.swipeButtonEdit}
                    titleStyle={styles.swipeButtonTitle}
                    disabled={isSaving}
                />
            )}
            rightContent={(reset) => (
                <Button
                    title="Delete"
                    onPress={() => { handleDeletePress(); reset(); }}
                    icon={{ name: "delete", color: theme.colors.white }}
                    buttonStyle={styles.swipeButtonDelete}
                    titleStyle={styles.swipeButtonTitle}
                    disabled={isSaving}
                />
            )}
            containerStyle={styles.listItemContainer}
        >
            {renderListItemIcon()}

            <ListItem.Content>
                <ListItem.Title style={styles.listItemTitle}>
                    {item.food.name}
                </ListItem.Title>
                {/* Display Grams and Calculated Calories */}
                <ListItem.Subtitle style={styles.listItemSubtitle}>
                    {`${item.grams}g • ${Math.round((item.food.calories / 100) * item.grams)} kcal`}
                </ListItem.Subtitle>
            </ListItem.Content>
            {/* Chevron indicates interactibility (swipe) */}
            <ListItem.Chevron color={theme.colors.grey3} />
        </ListItem.Swipeable>
    );
});

const useStyles = makeStyles((theme) => ({
    // Consistent Icon Styles (Adopted from FoodItem/FoodListScreen)
    foodIcon: { // Container style for placeholder/loading icon
        width: 40,
        height: 40,
        marginRight: 15, // Consistent spacing
        borderRadius: 8, // Consistent shape
        alignItems: 'center',
        justifyContent: 'center',
    },
    foodIconImage: { // Specific style for the Image component itself
        width: 40,
        height: 40,
        marginRight: 15,
        borderRadius: 8, // Consistent shape
    },
    iconPlaceholder: {
        backgroundColor: theme.colors.grey5, // Consistent placeholder background
    },
    // Consistent List Item Styles
    listItemContainer: {
        backgroundColor: theme.colors.background,
        paddingVertical: 12,
        paddingHorizontal: 15,
        borderBottomColor: theme.colors.divider,
    },
    listItemTitle: {
        color: theme.colors.text,
        fontWeight: "600", // Slightly bolder than default
        fontSize: 16,
        marginBottom: 3, // Space between title and subtitle
    },
    listItemSubtitle: {
        color: theme.colors.secondary,
        fontSize: 14,
    },
    // Consistent Swipe Button Styles
    swipeButtonEdit: {
        minHeight: "100%",
        backgroundColor: theme.colors.warning, // Use theme color
        justifyContent: 'center', // Center content vertically
        alignItems: 'center', // Center content horizontally
    },
    swipeButtonDelete: {
        minHeight: "100%",
        backgroundColor: theme.colors.error, // Use theme color
        justifyContent: 'center', // Center content vertically
        alignItems: 'center', // Center content horizontally
    },
    swipeButtonTitle: {
        color: theme.colors.white,
        fontWeight: 'bold',
        fontSize: 15,
    },
}));

export default DailyEntryListItem;
---------- END DailyEntryListItem.tsx ----------


---------- DailyGoalsInput.tsx ----------
// components/DailyGoalsInput.tsx
import React from "react";
import { Input, Text } from "@rneui/themed";
import { MacroType } from "../types/settings";
import { useTheme } from "@rneui/themed";


interface DailyGoalsInputProps {
    dailyGoals: { [key in MacroType]: number };
    onGoalChange: (goalType: MacroType, value: string) => void;
}

const DailyGoalsInput: React.FC<DailyGoalsInputProps> = ({
  dailyGoals,
  onGoalChange,
}) => {

    const { theme } = useTheme();

  return (
    <>
      {["calories", "protein", "carbs", "fat"].map((macro) => (
        <Input
          key={macro}
          label={<Text style={{ color: theme.colors.text }}>{`${macro.charAt(0).toUpperCase() + macro.slice(1)} Goal`}</Text>} // Wrap label in <Text>
          keyboardType="numeric"
          value={dailyGoals?.[macro as MacroType]?.toString() || ""}
          onChangeText={(value) => onGoalChange(macro as MacroType, value)}
          style={{ color: theme.colors.text }}
          inputContainerStyle={{ borderBottomColor: theme.colors.text }}
          labelStyle={{ color: theme.colors.text }}
        />
      ))}
    </>
  );
};

export default DailyGoalsInput;
---------- END DailyGoalsInput.tsx ----------


---------- DailyProgress.tsx ----------
// components/DailyProgress.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, useTheme } from '@rneui/themed';

interface DailyProgressProps {
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
  goals: {
    calories?: number;
    protein?: number;
    carbs?: number;
    fat?: number;
  };
}

const DailyProgress: React.FC<DailyProgressProps> = ({
  calories,
  protein,
  carbs,
  fat,
  goals,
}) => {
  const { theme } = useTheme();

  const calculateProgress = (current: number, goal?: number) => {
    if (!goal || goal <= 0) return 0; // Avoid division by zero and handle undefined goals
    return Math.min(current / goal, 1); // Cap at 100%
  };

  const renderProgressBar = (label: string, current: number, goal: number | undefined, color: string) => {
      const progress = calculateProgress(current, goal);
      return (
          <View style={styles.macroContainer} key={label}>
              <View style={styles.labelContainer}>
                    <Text style={[styles.macroLabel, {color: theme.colors.text}]}>{label}:</Text>
                    <Text style={[styles.macroValue, {color: theme.colors.text}]}>
                        {`${Math.round(current)} / ${goal || 0}`}
                    </Text>
              </View>
              <View style={styles.progressBarContainer}>
                  <View style={[styles.progressBar, { width: `${progress * 100}%`, backgroundColor: color }]} />
              </View>
          </View>
      )
  }


  return (
    <View style={styles.container}>
        {renderProgressBar('Calories', calories, goals.calories, theme.colors.primary)}
        {renderProgressBar('Protein', protein, goals.protein, 'green')}
        {renderProgressBar('Carbs', carbs, goals.carbs, 'orange')}
        {renderProgressBar('Fat', fat, goals.fat, 'blue')}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: 20,
    padding: 10,
    borderRadius: 8, // Rounded corners for the container
    //backgroundColor: '#f0f0f0', // Light background for contrast Removed for theme consistency
  },
  macroContainer: {
    marginBottom: 10,
  },
  labelContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 5,
  },
  macroLabel: {
    fontWeight: 'bold',
  },
  macroValue: {},
  progressBarContainer: {
      backgroundColor: '#e0e0e0', //Light grey for track
      borderRadius: 5,
      height: 10
  },
  progressBar: {
    height: 10,
    borderRadius: 5,
  },
});

export default DailyProgress;
---------- END DailyProgress.tsx ----------


---------- DataManagementButtons.tsx ----------
// src/components/DataManagementButtons.tsx
import React, { useState } from "react";
import { Alert, Platform } from "react-native"; // Import Platform
import { Button, Icon } from "@rneui/themed";
import * as DocumentPicker from "expo-document-picker";
import * as FileSystem from "expo-file-system";
import * as Sharing from 'expo-sharing'; // Import Sharing
import { formatDateISO } from "../utils/dateUtils"; // CORRECTED IMPORT
import {
  clearAllData,
  loadDailyEntries,
  saveDailyEntries,
  loadFoods,
  saveFoods,
  loadSettings,
  saveSettings
} from "../services/storageService";
import ConfirmationModal from "./ConfirmationModal";
import { DailyEntry } from "../types/dailyEntry";
import { Food } from "../types/food";
import { Settings } from "../types/settings";
import { useTheme } from "@rneui/themed";


interface DataManagementButtonsProps {
  onDataOperation: () => void; // Callback to signal data changes
}

const DataManagementButtons: React.FC<DataManagementButtonsProps> = ({
    onDataOperation
}) => {
  const [isConfirmationVisible, setIsConfirmationVisible] = useState(false);
  const [confirmationText, setConfirmationText] = useState("");
  const { theme } = useTheme();

  const handleExportData = async () => {
    try {
      const dailyEntries = await loadDailyEntries();
      const foods = await loadFoods();
      const settings = await loadSettings();

      const exportData = {
        dailyEntries,
        foods,
        settings
      };

      const exportDataString = JSON.stringify(exportData, null, 2); // Pretty print JSON
      // Use the correct formatting function and remove unnecessary replace
      const formattedDate = formatDateISO(new Date());
      const fileName = `macro_data_${formattedDate}.json`;
      const fileUri = FileSystem.documentDirectory + fileName;

      await FileSystem.writeAsStringAsync(fileUri, exportDataString, {
        encoding: FileSystem.EncodingType.UTF8,
      });

      // Use expo-sharing to share the file
      if (!(await Sharing.isAvailableAsync())) {
        Alert.alert('Sharing Error', 'Sharing is not available on your platform.');
        return;
      }

      await Sharing.shareAsync(fileUri, {
          mimeType: 'application/json',
          dialogTitle: 'Export Macro Data',
          UTI: 'public.json' // For iOS
      });
      // No need to call onDataOperation on export, as data didn't change locally

    } catch (error: any) {
      console.error("Export Error:", error);
      Alert.alert(
        "Export Failed",
        error.message || "An error occurred while exporting data."
      );
    }
  };

  const handleImportData = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: ["application/json", "public.json"], // Accept JSON files, public.json for iOS compatibility
        copyToCacheDirectory: true // Recommended for reliability
      });

      if (result.canceled) {
          console.log("Import cancelled by user.");
          return; // User cancelled, do nothing
      }

      if (result.assets && result.assets.length > 0) {
        const file = result.assets[0];

        // Check file extension more robustly
        if (!file.name?.toLowerCase().endsWith(".json")) {
          Alert.alert("Invalid File Type", "Please select a valid '.json' file.");
          return;
        }

        // Check file size (optional, but good practice)
        if (file.size && file.size > 10 * 1024 * 1024) { // Example: 10MB limit
            Alert.alert("File Too Large", "The selected file is too large (max 10MB).");
            return;
        }

        const fileContent = await FileSystem.readAsStringAsync(file.uri, {
          encoding: FileSystem.EncodingType.UTF8,
        });

        try {
          const importedData = JSON.parse(fileContent);

          // Basic structure validation:
          if (
            typeof importedData !== 'object' || importedData === null ||
            !importedData.hasOwnProperty("dailyEntries") || !Array.isArray(importedData.dailyEntries) ||
            !importedData.hasOwnProperty("foods") || !Array.isArray(importedData.foods) ||
            !importedData.hasOwnProperty("settings") || typeof importedData.settings !== 'object'
          ) {
            Alert.alert(
              "Import Failed",
              "The imported file has an invalid structure or is missing required data (dailyEntries, foods, settings)."
            );
            return;
          }

          // Add more specific validation if needed (e.g., check types within arrays)

          // Perform saves
          await saveDailyEntries(importedData.dailyEntries as DailyEntry[]);
          await saveFoods(importedData.foods as Food[]);
          await saveSettings(importedData.settings as Settings);

          Alert.alert("Import Successful", "Data imported and saved successfully.");
          onDataOperation(); // Trigger reload in parent screen

        } catch (parseError) {
          console.error("JSON Parse Error during import:", parseError);
          Alert.alert(
            "Import Failed",
            "The imported file is not valid JSON or has corrupted content."
          );
          return;
        }
      } else {
        // Should not happen if !result.canceled, but handle defensively
        console.warn("Document picker returned no assets without cancellation.");
        Alert.alert("Import Failed", "Could not access the selected file.");
      }
    } catch (error: any) {
      console.error("Import Error:", error);
      // Handle specific DocumentPicker errors if necessary
      if (error.code === 'NO_PERMISSIONS') {
           Alert.alert("Permission Error", "Storage permissions are required to import files.");
      } else {
           Alert.alert(
             "Import Failed",
             error.message || "An unknown error occurred during import."
           );
      }
    }
  };

  const handleClearData = () => {
      // Check if there's actually data to clear (optional)
      // const entries = await loadDailyEntries(); // Example check
      // if (entries.length === 0 && ...) { Alert.alert("No Data", "There is no data to clear."); return; }

      setIsConfirmationVisible(true);
  };

  const confirmClearData = async () => {
    // Case-insensitive and trim check for robustness
    if (confirmationText.trim().toUpperCase() === "CLEAR DATA") {
      try {
        await clearAllData();
        Alert.alert("Data Cleared", "All application data has been successfully cleared.");
        onDataOperation(); // Trigger reload in parent screen
      } catch (error: any) {
        console.error("Clear Data Error:", error);
        Alert.alert("Clear Data Failed", error.message || "Failed to clear data.");
      } finally {
        setConfirmationText(""); // Clear input regardless of outcome
        setIsConfirmationVisible(false);
      }
    } else {
      Alert.alert("Confirmation Failed", "Incorrect confirmation text entered. Data was not cleared.");
      // Keep modal open and text field populated for user correction
    }
  };

  return (
    <>
      <Button
        title="Export Data"
        onPress={handleExportData}
        buttonStyle={{ marginBottom: 10, backgroundColor: theme.colors.primary }}
        icon={<Icon name="export" type="material-community" color="white" size={20} style={{ marginRight: 8 }} />}
      />
      <Button
        title="Import Data"
        onPress={handleImportData}
        buttonStyle={{ marginBottom: 10, backgroundColor: theme.colors.primary }}
        icon={<Icon name="import" type="material-community" color="white" size={20} style={{ marginRight: 8 }} />}
      />
      <Button
        title="Clear All Data"
        onPress={handleClearData}
        color="error" // Use theme's error color directly
        buttonStyle={{ marginBottom: 10 }}
        icon={<Icon name="trash-can-outline" type="material-community" color="white" size={20} style={{ marginRight: 8 }} />}
      />

      <ConfirmationModal
        isVisible={isConfirmationVisible}
        onCancel={() => {
            setIsConfirmationVisible(false);
            setConfirmationText(""); // Clear text on cancel
        }}
        onConfirm={confirmClearData}
        confirmationText={confirmationText}
        setConfirmationText={setConfirmationText}
        title="Confirm Clear All Data"
        message={'This action is irreversible and will delete all entries, foods, and settings.\n\nEnter "CLEAR DATA" to proceed.'}
      />
    </>
  );
};

export default DataManagementButtons;
---------- END DataManagementButtons.tsx ----------


---------- DateNavigator.tsx ----------
import React from 'react';
import { View, TouchableOpacity, StyleSheet } from 'react-native';
import { Button, Text, Icon as RNEIcon, useTheme, makeStyles } from '@rneui/themed';
import { parseISO, isValid } from 'date-fns';
import { formatDateReadable } from '../utils/dateUtils'; // Ensure correct path

interface DateNavigatorProps {
    selectedDate: string; // ISO String 'YYYY-MM-DD'
    onPreviousDay: () => void;
    onNextDay: () => void;
    onShowDatePicker: () => void;
    isSaving: boolean;
    isLoadingData: boolean;
}

const DateNavigator: React.FC<DateNavigatorProps> = ({
    selectedDate,
    onPreviousDay,
    onNextDay,
    onShowDatePicker,
    isSaving,
    isLoadingData,
}) => {
    const { theme } = useTheme();
    const styles = useStyles();

    const parsedDate = parseISO(selectedDate);
    const displayDate = isValid(parsedDate) ? formatDateReadable(parsedDate) : 'Invalid Date';
    const isDisabled = isSaving || isLoadingData;

    return (
        <View style={styles.dateNavigation}>
            <Button
                type="clear"
                onPress={onPreviousDay}
                icon={<RNEIcon name="chevron-back-outline" type="ionicon" color={theme.colors.primary} size={28} />}
                buttonStyle={styles.navButton}
                disabled={isDisabled}
                disabledStyle={styles.disabledButton}
            />
            <TouchableOpacity onPress={onShowDatePicker} disabled={isDisabled}>
                <Text h4 h4Style={[styles.dateText, isDisabled && styles.disabledText]}>
                    {displayDate}
                </Text>
            </TouchableOpacity>
            <Button
                type="clear"
                onPress={onNextDay}
                icon={<RNEIcon name="chevron-forward-outline" type="ionicon" color={theme.colors.primary} size={28} />}
                buttonStyle={styles.navButton}
                disabled={isDisabled}
                disabledStyle={styles.disabledButton}
            />
        </View>
    );
};

const useStyles = makeStyles((theme) => ({
    dateNavigation: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
        paddingVertical: 10,
        paddingHorizontal: 10,
        backgroundColor: theme.colors.background,
        // Optional: add subtle shadow or border if needed
        // borderBottomWidth: StyleSheet.hairlineWidth,
        // borderBottomColor: theme.colors.divider,
    },
    navButton: {
        paddingHorizontal: 8,
    },
    dateText: {
        fontSize: 18,
        fontWeight: 'bold',
        color: theme.colors.text,
        textAlign: 'center',
        paddingVertical: 5,
    },
    disabledButton: {
        // backgroundColor: 'transparent', // Keep background transparent
        opacity: 0.5, // Reduce opacity for visual feedback
    },
    disabledText: {
        color: theme.colors.grey3, // Use a grey color for disabled text
    },
}));

export default DateNavigator;
---------- END DateNavigator.tsx ----------


---------- FoodFormFields.tsx ----------
import React from 'react';
import { Input, makeStyles, useTheme } from '@rneui/themed';
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { Food } from '../types/food';

// Define the shape of the values prop (can be partial for newFood)
type FoodFormValues = Partial<Omit<Food, 'id'>>;

interface FoodFormFieldsProps {
    values: FoodFormValues; // Use partial type
    errors: { [key: string]: string };
    onInputChange: (key: keyof Omit<Food, 'id'>, value: string, isEdit: boolean) => void;
    isEditing: boolean;
    disabled: boolean;
}

const FoodFormFields: React.FC<FoodFormFieldsProps> = ({
    values,
    errors,
    onInputChange,
    isEditing,
    disabled,
}) => {
    const { theme } = useTheme();
    const styles = useStyles();

    // Helper to get string value, handling initial undefined/0 for newFood
    const getValue = (key: keyof Omit<Food, 'id'>): string => {
         const val = values[key];
         if (typeof val === 'number') {
              // Show empty string for 0 when NOT editing (initial state)
              if (val === 0 && !isEditing) return "";
              return String(val);
         }
         return String(val ?? ""); // Default to empty string for name if null/undefined
    };

    return (
        <>
            {/* Food Name Input */}
            <Input
                label="Food Name" labelStyle={styles.inputLabel}
                value={getValue("name")}
                onChangeText={(text) => onInputChange("name", text, isEditing)}
                errorMessage={errors.name}
                inputContainerStyle={styles.inputContainerStyle}
                inputStyle={styles.inputStyle}
                leftIcon={<MaterialCommunityIcons name="food-apple" size={24} color={errors.name ? theme.colors.error : theme.colors.grey1} />}
                disabled={disabled}
                autoCapitalize="words"
            />
            {/* Macro Inputs */}
            <Input
                label="Calories (per 100g)" labelStyle={styles.inputLabel}
                keyboardType="numeric" value={getValue("calories")}
                onChangeText={(text) => onInputChange("calories", text, isEditing)}
                errorMessage={errors.calories} inputContainerStyle={styles.inputContainerStyle}
                inputStyle={styles.inputStyle}
                leftIcon={<MaterialCommunityIcons name="fire" size={24} color={errors.calories ? theme.colors.error : theme.colors.grey1} />}
                disabled={disabled}
            />
            <Input
                label="Protein (per 100g)" labelStyle={styles.inputLabel}
                keyboardType="numeric" value={getValue("protein")}
                onChangeText={(text) => onInputChange("protein", text, isEditing)}
                errorMessage={errors.protein} inputContainerStyle={styles.inputContainerStyle}
                inputStyle={styles.inputStyle}
                leftIcon={<MaterialCommunityIcons name="food-drumstick" size={24} color={errors.protein ? theme.colors.error : theme.colors.grey1} />}
                disabled={disabled}
            />
            <Input
                label="Carbs (per 100g)" labelStyle={styles.inputLabel}
                keyboardType="numeric" value={getValue("carbs")}
                onChangeText={(text) => onInputChange("carbs", text, isEditing)}
                errorMessage={errors.carbs} inputContainerStyle={styles.inputContainerStyle}
                inputStyle={styles.inputStyle}
                leftIcon={<MaterialCommunityIcons name="bread-slice" size={24} color={errors.carbs ? theme.colors.error : theme.colors.grey1} />}
                disabled={disabled}
            />
            <Input
                label="Fat (per 100g)" labelStyle={styles.inputLabel}
                keyboardType="numeric" value={getValue("fat")}
                onChangeText={(text) => onInputChange("fat", text, isEditing)}
                errorMessage={errors.fat} inputContainerStyle={styles.inputContainerStyle}
                inputStyle={styles.inputStyle}
                leftIcon={<MaterialCommunityIcons name="oil" size={24} color={errors.fat ? theme.colors.error : theme.colors.grey1} />}
                disabled={disabled}
            />
        </>
    );
};

// Reusing styles from AddFoodModal for consistency
const useStyles = makeStyles((theme) => ({
    inputLabel: { color: theme.colors.text, fontWeight: '500', marginBottom: 2, fontSize: 14 },
    inputContainerStyle: { borderBottomWidth: 1, borderBottomColor: theme.colors.grey4, marginBottom: 5, paddingBottom: 2, },
    inputStyle: { color: theme.colors.text, marginLeft: 10, fontSize: 16, },
}));

export default FoodFormFields;
---------- END FoodFormFields.tsx ----------


---------- FoodItem.tsx ----------
// src/components/FoodItem.tsx
import React, { forwardRef, useState, useCallback, memo } from "react";
import { StyleSheet, View, Image, ActivityIndicator } from "react-native"; // Added ActivityIndicator
import { ListItem, Icon as RNEIcon, useTheme, Button, makeStyles, Text } from "@rneui/themed";
import { Food } from "../types/food";
import Toast from "react-native-toast-message";

interface FoodItemProps {
  food: Food;
  onEdit: (food: Food) => void;
  onDelete: (foodId: string) => void;
  onUndoDelete: (food: Food) => void;
  foodIconUrl: string | null | undefined;
}

const FoodItem = memo(forwardRef<any, FoodItemProps>(
  ({ food, onEdit, onDelete, onUndoDelete, foodIconUrl }, ref) => {
    const { theme } = useTheme();
    const styles = useStyles();
    const [iconLoadError, setIconLoadError] = useState(false);

    // --- Declare handleUndo FIRST ---
    const handleUndo = useCallback(() => {
         onUndoDelete(food); // Parent handles actual restoration
    }, [food, onUndoDelete]);

    // --- Declare handleDelete SECOND, now it can safely use handleUndo ---
    const handleDelete = useCallback(() => {
      onDelete(food.id); // Parent handles logic and initial toast
       Toast.show({ // Show UNDO toast here for consistency
            type: 'info',
            text1: `${food.name} deleted`,
            text2: 'Tap here to undo',
            position: 'bottom',
            visibilityTime: 4000,
            onPress: handleUndo, // Call local undo handler declared above
            bottomOffset: 80,
        });
    }, [food.id, food.name, onDelete, handleUndo]); // Dependency array is now valid

    const handleImageError = useCallback(() => {
        console.warn(`Failed to load image for ${food.name} from URL: ${foodIconUrl}`);
        setIconLoadError(true);
    }, [food.name, foodIconUrl]);

    // Reset error state if the URL changes
    React.useEffect(() => {
        setIconLoadError(false);
    }, [foodIconUrl]);

    const renderIcon = () => {
        const isLoadingIcon = foodIconUrl === undefined;
        if (isLoadingIcon) {
            return (
                <View style={[styles.foodIcon, styles.iconPlaceholder]}>
                    <ActivityIndicator size="small" color={theme.colors.grey3} />
                </View>
            );
        } else if (foodIconUrl && !iconLoadError) {
             return (
                <Image
                    source={{ uri: foodIconUrl }}
                    style={styles.foodIconImage}
                    onError={handleImageError}
                    resizeMode="contain"
                />
            );
        } else {
            return (
                <View style={[styles.foodIcon, styles.iconPlaceholder]}>
                    <RNEIcon
                        name="fast-food-outline" // Consistent placeholder
                        type="ionicon"
                        size={20}
                        color={theme.colors.grey3}
                    />
                </View>
            );
        }
    };

    return (
      <ListItem.Swipeable
        ref={ref}
        bottomDivider
        leftContent={(reset) => (
          <Button
            title="Edit"
            onPress={() => {
              onEdit(food);
              reset();
            }}
            icon={{ name: "edit", color: theme.colors.white }}
            buttonStyle={styles.swipeButtonEdit} // Apply centered style
            titleStyle={styles.swipeButtonTitle}
          />
        )}
        rightContent={(reset) => (
          <Button
            title="Delete"
            onPress={() => {
                handleDelete(); // Use local handler to show toast
                reset();
            }}
            icon={{ name: "delete", color: theme.colors.white }}
            buttonStyle={styles.swipeButtonDelete} // Apply centered style
            titleStyle={styles.swipeButtonTitle}
          />
        )}
        containerStyle={styles.listItemContainer} // Consistent container style
      >
        {renderIcon()}

        <ListItem.Content>
          <ListItem.Title style={styles.title}>
            {food.name}
          </ListItem.Title>
          <ListItem.Subtitle style={styles.subtitle}>
            {`100g: Cal: ${Math.round(food.calories)} P: ${Math.round(food.protein)} C: ${Math.round(food.carbs)} F: ${Math.round(food.fat)}`}
          </ListItem.Subtitle>
        </ListItem.Content>
         {/* Chevron indicates interactibility (swipe) */}
        <ListItem.Chevron color={theme.colors.grey3} />
      </ListItem.Swipeable>
    );
  }
));

// Consistent Styles matching DailyEntryScreen where applicable
const useStyles = makeStyles((theme) => ({
    listItemContainer: {
        backgroundColor: theme.colors.background, // Use theme background
        paddingVertical: 12,
        paddingHorizontal: 15,
        borderBottomColor: theme.colors.divider, // Use theme divider
    },
    title: {
        color: theme.colors.text, // Use theme text color
        fontWeight: "600",
        fontSize: 16,
        marginBottom: 3,
    },
    subtitle: {
        color: theme.colors.secondary, // Use theme grey
        fontSize: 13, // Slightly smaller subtitle
        marginTop: 2,
    },
    swipeButtonEdit: {
        minHeight: "100%",
        backgroundColor: theme.colors.warning, // Theme color
        justifyContent: 'center', // Center content vertically
        alignItems: 'center', // Center content horizontally
    },
    swipeButtonDelete: {
        minHeight: "100%",
        backgroundColor: theme.colors.error, // Theme color
        justifyContent: 'center', // Center content vertically
        alignItems: 'center', // Center content horizontally
    },
    swipeButtonTitle: {
        color: theme.colors.white, // White text on colored buttons
        fontWeight: 'bold',
        fontSize: 15,
    },
   // Consistent Icon styles
   foodIcon: {
       width: 40,
       height: 40,
       marginRight: 15,
       borderRadius: 8, // Slightly rounded square
       alignItems: 'center',
       justifyContent: 'center',
   },
   foodIconImage: {
       width: 40,
       height: 40,
       marginRight: 15,
       borderRadius: 8,
   },
   iconPlaceholder: {
      backgroundColor: theme.colors.grey5, // Consistent placeholder background
   }
}));

export default FoodItem;
---------- END FoodItem.tsx ----------


---------- QuickAddList.tsx ----------
// src/components/QuickAddList.tsx
// ---------- Corrected File ----------
import React from 'react';
import {
    View,
    FlatList,
    StyleSheet,
    TouchableOpacity,
    Pressable,
    Dimensions,
    ActivityIndicator,
} from 'react-native';
import {
    ListItem,
    CheckBox,
    Input,
    Icon,
    Text,
    useTheme,
    makeStyles,
} from '@rneui/themed';
import { EstimatedFoodItem } from '../types/macros';
import { isValidNumberInput } from '../utils/validationUtils';

interface QuickAddListProps {
    items: EstimatedFoodItem[];
    selectedIndices: Set<number>;
    editingIndex: number | null;
    editedName: string;
    editedGrams: string;
    onToggleItem: (index: number) => void;
    onEditItem: (index: number) => void;
    onSaveEdit: () => void;
    onCancelEdit: () => void;
    onNameChange: (name: string) => void;
    onGramsChange: (grams: string) => void;
    style?: object; // Optional style prop for the FlatList container
    isLoading?: boolean; // Optional loading state for the list itself
}

const QuickAddList: React.FC<QuickAddListProps> = ({
    items,
    selectedIndices,
    editingIndex,
    editedName,
    editedGrams,
    onToggleItem,
    onEditItem,
    onSaveEdit,
    onCancelEdit,
    onNameChange,
    onGramsChange,
    style,
    isLoading,
}) => {
    const { theme } = useTheme();
    const styles = useStyles();

    const renderItem = ({ item, index }: { item: EstimatedFoodItem; index: number }) => {
        const isSelected = selectedIndices.has(index);
        const isEditingThisItem = editingIndex === index;
        const isAnyItemEditing = editingIndex !== null;
        const estimatedCalories = Math.round(
            (item.calories_per_100g / 100) * item.estimatedWeightGrams
        );

        return (
            <Pressable
                onPress={() => !isEditingThisItem && onToggleItem(index)}
                disabled={(isAnyItemEditing && !isEditingThisItem)}
            >
                <ListItem
                    bottomDivider
                    containerStyle={[
                        styles.quickAddItemContainer,
                        isEditingThisItem && styles.quickAddItemEditing,
                        isSelected && styles.quickAddItemSelected,
                        isAnyItemEditing && !isEditingThisItem && { opacity: 0.6 },
                    ]}
                >
                    {isEditingThisItem ? (
                        // --- EDIT VIEW for Quick Add Item ---
                        <View style={styles.quickAddEditView}>
                            <Input
                                value={editedName}
                                onChangeText={onNameChange}
                                placeholder="Food Name"
                                inputContainerStyle={styles.quickEditInputContainer}
                                inputStyle={styles.quickEditInput}
                                containerStyle={styles.quickEditNameContainer}
                                autoFocus
                                selectTextOnFocus
                            />
                            <View style={styles.quickEditGramsRow}>
                                <Input
                                    value={editedGrams}
                                    onChangeText={onGramsChange} // Use the specific handler for cleaning
                                    placeholder="Grams"
                                    keyboardType="numeric"
                                    inputContainerStyle={styles.quickEditInputContainer}
                                    inputStyle={styles.quickEditInput}
                                    containerStyle={styles.quickEditGramsContainer}
                                    // *** CORRECTED THIS LINE ***
                                    rightIcon={<Text style={styles.quickEditUnitText}>g</Text>}
                                    errorMessage={ !isValidNumberInput(editedGrams) && editedGrams !== "" ? "Invalid" : "" }
                                    errorStyle={styles.inputError}
                                />
                                {/* Save/Cancel Edit Buttons */}
                                <TouchableOpacity onPress={onSaveEdit} style={styles.quickEditButton}>
                                    <Icon name="checkmark" type="ionicon" color={theme.colors.success} size={26} />
                                </TouchableOpacity>
                                <TouchableOpacity onPress={onCancelEdit} style={styles.quickEditButton}>
                                    <Icon name="close-circle-outline" type="ionicon" color={theme.colors.error} size={26} />
                                </TouchableOpacity>
                            </View>
                        </View>
                    ) : (
                        // --- DISPLAY VIEW for Quick Add Item ---
                        <>
                            <CheckBox
                                checked={isSelected}
                                onPress={() => onToggleItem(index)}
                                containerStyle={styles.quickAddCheckbox}
                                checkedColor={theme.colors.primary}
                                disabled={isAnyItemEditing}
                            />
                            <ListItem.Content>
                                <ListItem.Title style={styles.quickAddItemTitle}>
                                    <Text>{item.foodName}</Text>
                                </ListItem.Title>
                                <ListItem.Subtitle style={styles.quickAddItemSubtitle}>
                                    <Text>{`Est: ${Math.round(item.estimatedWeightGrams)}g • ~${estimatedCalories} kcal`}</Text>
                                </ListItem.Subtitle>
                            </ListItem.Content>
                            {/* Edit Icon */}
                            {!isAnyItemEditing && (
                                <TouchableOpacity onPress={() => onEditItem(index)} style={styles.quickEditIconButton}>
                                    <Icon name="pencil" type="material-community" size={20} color={theme.colors.grey1} />
                                </TouchableOpacity>
                            )}
                        </>
                    )}
                </ListItem>
            </Pressable>
        );
    };

    if (isLoading) {
         return (
             <View style={styles.centeredContent}>
                 <ActivityIndicator size="large" color={theme.colors.primary} />
                 <Text style={styles.loadingText}>Analyzing...</Text>
             </View>
         );
    }

    return (
        <FlatList
            data={items}
            keyExtractor={(item, index) => `quickadd-${index}-${item.foodName}`}
            renderItem={renderItem}
            ListEmptyComponent={ // Show if API returned no items initially
                <View style={styles.emptyListContainer}>
                    <Icon name="image-off-outline" type="material-community" size={40} color={theme.colors.grey3} />
                    <Text style={styles.emptyListText}> No identifiable foods found in the image. </Text>
                    <Text style={styles.emptyListSubText}> Try a different image or add manually. </Text>
                </View>
            }
            style={[styles.listDefaults, style]} // Combine default styles with passed styles
            extraData={{ selectedIndices, editingIndex }} // Ensure re-render on state change
            keyboardShouldPersistTaps="handled"
            contentContainerStyle={items.length === 0 ? styles.listContentContainerEmpty : {}}
        />
    );
};

const useStyles = makeStyles((theme) => ({
    listDefaults: { // Default styles for the FlatList itself
        // maxHeight: Dimensions.get("window").height * 0.55, // Moved to parent or style prop
        // flexGrow: 0, // Moved to parent or style prop
        // marginBottom: 10, // Moved to parent or style prop
    },
    listContentContainerEmpty: {
        flexGrow: 1,
        justifyContent: 'center',
    },
    quickAddItemContainer: {
        paddingVertical: 6, paddingHorizontal: 5, backgroundColor: theme.colors.background,
        borderBottomColor: theme.colors.divider, flexDirection: "row", alignItems: "center",
        minHeight: 60, // Ensure consistent item height
    },
    quickAddItemSelected: { backgroundColor: theme.colors.successLight || '#d4edda' },
    quickAddItemEditing: { backgroundColor: theme.colors.grey5, paddingVertical: 8, },
    quickAddCheckbox: { padding: 0, margin: 0, marginRight: 10, backgroundColor: "transparent", borderWidth: 0, },
    quickAddItemTitle: { fontWeight: "bold", color: theme.colors.text, fontSize: 16, },
    quickAddItemSubtitle: { color: theme.colors.grey1, fontSize: 13, marginTop: 2, },
    quickEditIconButton: { padding: 8, marginLeft: 8, },
    quickAddEditView: { flex: 1, paddingLeft: 10, },
    quickEditInputContainer: {
        borderBottomWidth: 1, borderBottomColor: theme.colors.primary, height: 35, paddingHorizontal: 0,
        // paddingBottom: 0, // Reduce bottom padding to avoid height issues
        // marginBottom: 0, // Reduce margin
    },
    quickEditInput: {
        fontSize: 15, color: theme.colors.text, paddingVertical: 0, // Remove vertical padding
        // lineHeight: 18, // Control line height if needed
        // height: 'auto', // Auto height? Test this carefully
    },
    quickEditNameContainer: { paddingHorizontal: 0, marginBottom: 5, },
    quickEditGramsRow: { flexDirection: "row", alignItems: "center", },
    quickEditGramsContainer: { flex: 1, paddingHorizontal: 0, },
    quickEditUnitText: { color: theme.colors.grey2, fontSize: 14, fontWeight: "500", paddingRight: 5 /* Add padding if needed */ },
    quickEditButton: { paddingLeft: 10, paddingVertical: 5, },
    emptyListContainer: {
        alignItems: "center", paddingVertical: 30, paddingHorizontal: 15,
    },
    emptyListText: { color: theme.colors.grey2, fontSize: 16, textAlign: "center", marginTop: 10 },
    emptyListSubText: { fontSize: 14, color: theme.colors.grey3, textAlign: "center", marginTop: 5, },
    inputError: { color: theme.colors.error, fontSize: 10, marginVertical: 0, height: 12 }, // Compact error message
     centeredContent: { // Centered loading/empty states within main area
      flex: 1,
      alignItems: 'center',
      justifyContent: 'center',
      padding: 20,
      minHeight: 150, // Ensure it takes some space
   },
    loadingText: { marginTop: 10, color: theme.colors.text, fontSize: 16, fontWeight: "500", },
}));

export default QuickAddList;
---------- END QuickAddList.tsx ----------


---------- StatisticsChart.tsx ----------
// components/StatisticsChart.tsx (Modified)
import React from "react";
import { View, StyleSheet } from "react-native";
import { WebView } from "react-native-webview";
import { Statistics, MacroType, macros } from "../types/settings"; // Import types
import { useTheme } from "@rneui/themed";


interface StatisticsChartProps {
  statistics: Statistics;
}

const StatisticsChart: React.FC<StatisticsChartProps> = ({ statistics }) => {

  const { theme } = useTheme();

  const generateChartHTML = () => {
    const chartData = macros.reduce((acc, macro) => {
      // Prepare data for each macro, including goal if applicable
      acc[macro] = statistics[macro].map((series) =>
        series.map((item) => [item.x / 1000, item.y])
      );
      return acc;
    }, {} as { [key in MacroType]: number[][][] });

    const textColor = theme.colors.text;
    const gridColor = theme.colors.grey5; // Lighter grid
    const axisColor = theme.colors.grey3; // Slightly darker axis
    const fontFamily = "Helvetica, Arial, sans-serif";

    // Define color palette for the lines, using theme colors if possible
    const lineColors = {
      calories: theme.colors.primary,
      protein: theme.colors.success,
      carbs: theme.colors.warning,
      fat: theme.colors.error,
    };


    // Re-enabled caching, but *only* cache the HTML itself, not the data.  The data is now dynamic.
    return `
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>Macro Charts</title>
            <style>
            body { font-family: ${fontFamily}; margin: 0; padding: 0; background-color: ${theme.colors.background}; color: ${textColor};}
                .chart-container { width: 95%; height: 250px; margin: 10px auto; }
            </style>
            <link rel="stylesheet" href="https://unpkg.com/uplot@1.6.27/dist/uPlot.min.css">
            <script src="https://unpkg.com/uplot@1.6.27/dist/uPlot.iife.min.js"></script>
        </head>
        <body>
            ${macros
      .map((macro) => {
        const isCalories = macro === "calories";
        const seriesCount = isCalories ? 2 : 1; // Two series for calories (intake, goal)

        const seriesConfig = isCalories
          ? `[
                      {},
                      {
                        stroke: "${lineColors[macro] || theme.colors.primary}",
                        width: 2,
                        label: "Intake",
                        points: { show: false }
                      },
                      {
                        stroke: "red",
                        width: 1,
                        dash: [5, 5],
                        label: "Goal",
                        points: { show: false }
                      }
                    ]`
          : `[
                      {},
                      {
                        stroke: "${lineColors[macro] || theme.colors.primary}",
                        width: 2,
                        label: "${macro.charAt(0).toUpperCase() + macro.slice(1)}",
                        points: { show: false }
                      }
                    ]`;


        const uPlotData =
          seriesCount === 2
            ? `[data[0].map(d => d[0]), data[0].map(d => d[1]), data[1].map(d => d[1])]`
            : `[data[0].map(d => d[0]), data[0].map(d => d[1])]`;



        return `
                <div id="${macro}-chart" class="chart-container"></div>
                <script>
                    const data = ${JSON.stringify(chartData[macro])};
                    const opts = {
                        title: "${macro.charAt(0).toUpperCase() + macro.slice(1)}",
                        width: window.innerWidth * 0.95,
                        height: 250,
                        scales: {
                            x: { time: true },
                            y: { },
                        },
                        axes: [
                            {
                                stroke: "${textColor}",
                                font: "14px ${fontFamily}",
                            grid: {
                                    stroke: "${gridColor}",
                                    width: 1
                                },
                                ticks: {
                                    stroke: "${gridColor}",
                                    width: 1
                                }
                            },
                            {
                                stroke: "${textColor}",
                                font: "14px ${fontFamily}",
                                grid: {
                                    stroke: "${gridColor}",
                                    width: 1
                                },
                                ticks: {
                                    stroke: "${gridColor}",
                                    width: 1
                                }
                            }
                        ],
                        series: ${seriesConfig},
                        cursor: {
                            drag: { setScale: false },
                            points: {
                                size: 6,
                                fill: (self, i) => self.series[i]._stroke,
                                stroke: (self, i) => self.series[i]._stroke,
                            }
                        },
                        ${isCalories ? `
                        hooks: {
                            draw: [
                                (u) => {
                                   const ctx = u.ctx;
                                    u.series.forEach((series, seriesIdx) => {
                                      if (seriesIdx === 1) {
                                        const intakeData = data[0];
                                        const goalData = data[1];

                                        ctx.beginPath();
                                        ctx.fillStyle = "rgba(255, 0, 0, 0.3)"; // Semi-transparent red

                                        for (let i = 0; i < intakeData.length; i++) {
                                          const intakeY = intakeData[i][1];
                                          const goalY = goalData[i][1];
                                          const x = u.valToPos(intakeData[i][0], "x", true);
                                          
                                           // Check if intake exceeds the goal
                                            if(intakeY > goalY){
                                                const intakeYPos = u.valToPos(intakeY, 'y', true);
                                                const goalYPos = u.valToPos(goalY, 'y', true);
                                               
                                                //if this is the first point or last point, move to x, other wise line to x
                                                if(i === 0){
                                                   ctx.moveTo(x, intakeYPos);
                                                }else{
                                                  ctx.lineTo(x, intakeYPos);
                                                }
                                            }
                                        }
                                        //go back along the goal data
                                         for (let i = intakeData.length-1; i >= 0; i--) {
                                            const intakeY = intakeData[i][1];
                                            const goalY = goalData[i][1];
                                             const x = u.valToPos(intakeData[i][0], "x", true);
                                               // Check if intake exceeds the goal
                                            if(intakeY > goalY){
                                                 const goalYPos = u.valToPos(goalY, 'y', true);
                                                ctx.lineTo(x, goalYPos);
                                            }
                                         }

                                        ctx.closePath();
                                        ctx.fill();
                                        }

                                    });

                                }
                            ]
                        }
                        ` : ''}
                    };
                    new uPlot(opts, ${uPlotData}, document.getElementById('${macro}-chart'));
                </script>
            `;
      })
      .join("")}
        </body>
        </html>
        `;

  };

  return (
    <View style={styles.webViewContainer}>
      <WebView
        originWhitelist={["*"]}
        source={{ html: generateChartHTML() }}
        style={styles.webView}
        scalesPageToFit={false}
        scrollEnabled={false}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  webViewContainer: {
    height: 'auto',
    width: "100%",
    marginTop: 10,
  },
  webView: {
    height: 340, // Explicit height, adjust as needed.
  },
});

export default StatisticsChart;
---------- END StatisticsChart.tsx ----------


---------- ThemeSwitch.tsx ----------
// components/ThemeSwitch.tsx (Corrected)
import React from "react";
import { ListItem, Switch } from "@rneui/themed";
import { useTheme } from "@rneui/themed";

interface ThemeSwitchProps {
  currentTheme: 'light' | 'dark' | 'system'; // Use theme string
  onToggle: (theme: 'light' | 'dark' | 'system') => void; // Pass the theme string
}

const ThemeSwitch: React.FC<ThemeSwitchProps> = ({ currentTheme, onToggle }) => {
  const { theme } = useTheme();

  return (
    <ListItem
      bottomDivider
      containerStyle={{ backgroundColor: theme.colors.background }}
    >
      <ListItem.Content>
        <ListItem.Title style={{ color: theme.colors.text }}>
          Dark Mode
        </ListItem.Title>
      </ListItem.Content>
      <Switch
        value={currentTheme === 'dark'} // Correctly reflect theme
        onValueChange={(newValue) => {
          onToggle(newValue ? 'dark' : 'light'); // Toggle between 'light' and 'dark'
        }}
      />
    </ListItem>
  );
};

export default ThemeSwitch;
---------- END ThemeSwitch.tsx ----------


---------- AppNavigator.tsx ----------
// navigation/AppNavigator.tsx
import React, { useState, useCallback } from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { Icon, useTheme } from '@rneui/themed';
import DailyEntryScreen from '../screens/DailyEntryScreen';
import FoodListScreen from '../screens/FoodListScreen';
import SettingsScreen from '../screens/SettingsScreen';

const Tab = createBottomTabNavigator();

interface AppNavigatorProps {
  onThemeChange: (theme: 'light' | 'dark' | 'system') => void;
}

const AppNavigator: React.FC<AppNavigatorProps> = ({ onThemeChange }) => {
  const { theme } = useTheme();
  const [foodListRefresh, setFoodListRefresh] = useState(false);

  const handleFoodChange = useCallback(() => {
    setFoodListRefresh(prev => !prev); // Toggle the state to trigger refresh
  }, []);

  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        tabBarIcon: ({ focused, color, size }) => {
          let iconName: string = '';
          let type: string = '';

          if (route.name === 'Daily Entry') {
            iconName = focused ? 'calendar' : 'calendar-outline';
            type = 'ionicon';
          } else if (route.name === 'Foods') {
            iconName = focused ? 'fast-food' : 'fast-food-outline';
            type = 'ionicon'; // Consistent icon set
          } else if (route.name === 'Settings') {
            iconName = focused ? 'settings' : 'settings-outline';
            type = 'ionicon';
          }

          return <Icon name={iconName} type={type} size={size} color={color} />;
        },
        tabBarActiveTintColor: theme.colors.primary,
        tabBarInactiveTintColor: theme.colors.secondary, // Use secondary color
        headerShown: false,
        tabBarStyle: {
          backgroundColor: theme.colors.background,
          borderTopColor: theme.colors.divider, // Add a subtle border
        },
        tabBarLabelStyle: {
          fontWeight: 'bold', // Make labels more prominent
        }
      })}
    >
      <Tab.Screen name="Daily Entry">
        {() => <DailyEntryScreen key={foodListRefresh ? 'refresh' : 'normal'} />}
      </Tab.Screen>
      <Tab.Screen name="Foods">
        {() => <FoodListScreen onFoodChange={handleFoodChange} />}
      </Tab.Screen>
      <Tab.Screen name="Settings">
        {() => <SettingsScreen onThemeChange={onThemeChange} onDataOperation={function (): void {
          throw new Error('Function not implemented.');
        } } />}
      </Tab.Screen>
    </Tab.Navigator>
  );
};

export default AppNavigator;
---------- END AppNavigator.tsx ----------


---------- DailyEntryScreen.tsx ----------
// ---------- src/screens/DailyEntryScreen.tsx ----------
// src/screens/DailyEntryScreen.tsx
import React, { useState, useEffect, useCallback, useMemo, useRef } from "react"; // Added useRef
import {
  View,
  FlatList,
  Alert,
  Platform,
  StyleSheet,
  ActivityIndicator,
} from "react-native";
import { DailyEntry, DailyEntryItem } from "../types/dailyEntry";
import { Food } from "../types/food";
import { getFoods } from "../services/foodService";
import {
  saveDailyEntries,
  loadDailyEntries,
  loadSettings,
} from "../services/storageService";
import {
  getTodayDateString,
  formatDateISO,
  formatDateReadable,
} from "../utils/dateUtils";
import { isValidNumberInput } from "../utils/validationUtils";
import DailyProgress from "../components/DailyProgress";
import {
  Text,
  FAB,
  makeStyles,
  useTheme,
  Divider,
  Icon as RNEIcon,
} from "@rneui/themed";
import DateTimePicker, {
  DateTimePickerEvent,
} from "@react-native-community/datetimepicker";
import { addDays, subDays, parseISO, formatISO, isValid } from "date-fns";
import { SafeAreaView } from "react-native-safe-area-context";
import AddEntryModal from "../components/AddEntryModal";
import "react-native-get-random-values";
import Toast from "react-native-toast-message";
import { useFocusEffect } from "@react-navigation/native";
import { getFoodIconUrl } from "../utils/iconUtils"; // Correct import
import DateNavigator from "../components/DateNavigator"; // Import extracted component
import DailyEntryListItem from "../components/DailyEntryListItem"; // Import extracted component

interface DailyGoals {
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
}

const DailyEntryScreen: React.FC = () => {
  const [dailyEntries, setDailyEntries] = useState<DailyEntry[]>([]);
  const [selectedDate, setSelectedDate] = useState<string>(
    getTodayDateString()
  );
  const [foods, setFoods] = useState<Food[]>([]);
  const [selectedFood, setSelectedFood] = useState<Food | null>(null);
  const [grams, setGrams] = useState("");
  const [isOverlayVisible, setIsOverlayVisible] = useState(false);
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [dailyGoals, setDailyGoals] = useState<DailyGoals>({
    calories: 2000,
    protein: 150,
    carbs: 200,
    fat: 70,
  });
  const [search, setSearch] = useState("");
  const [editIndex, setEditIndex] = useState<number | null>(null); // Modal edit index (reversed)
  const [foodIcons, setFoodIcons] = useState<{
    [foodName: string]: string | null | undefined;
  }>({});
  const [isLoadingData, setIsLoadingData] = useState(true);
  const [isSaving, setIsSaving] = useState(false);

  const { theme } = useTheme();
  const styles = useStyles();
  // Ref to hold the current foodIcons state for checking inside triggerIconPrefetch without causing dependency loop
  const foodIconsRef = useRef(foodIcons);
  useEffect(() => {
    foodIconsRef.current = foodIcons;
  }, [foodIcons]);


  // --- Icon Pre-fetching Trigger ---
  // **** IMPORTANT FIX: Removed foodIcons from dependency array ****
  const triggerIconPrefetch = useCallback((entries: DailyEntry[], currentSelectedDate: string) => {
      const uniqueFoodNames = new Set<string>();
      entries.forEach(entry => {
          if (entry.date === currentSelectedDate && entry.items) {
              entry.items.forEach(item => {
                  if (item.food?.name) {
                      uniqueFoodNames.add(item.food.name);
                  }
              });
          }
      });

      if (uniqueFoodNames.size > 0) {
          console.log(`DailyEntryScreen: Triggering pre-fetch for ${uniqueFoodNames.size} unique names on date ${currentSelectedDate}...`);
          const currentIcons = foodIconsRef.current; // Read current icons from ref
          const prefetchPromises = Array.from(uniqueFoodNames).map(name => {
              // Check *current* status from ref, not state dependency
              if (currentIcons[name] === undefined) {
                  // Set state to loading IF NOT ALREADY SET (prevents infinite triggers if fetch fails quickly)
                  // We check state here because ref might not update instantly if fetch starts immediately
                   if (foodIconsRef.current[name] === undefined) {
                      setFoodIcons(prev => ({...prev, [name]: undefined}));
                   }
                  // Fetch and update state directly in promise handlers
                  return getFoodIconUrl(name).then(url => {
                      setFoodIcons(prev => ({...prev, [name]: url}));
                  }).catch(err => {
                      console.warn(`Icon pre-fetch failed for ${name}:`, err);
                      setFoodIcons(prev => ({...prev, [name]: null}));
                  });
              }
              return Promise.resolve(); // Already known/loading
          });

          Promise.allSettled(prefetchPromises).then(() => {
              console.log(`DailyEntryScreen: Icon pre-fetch settle completed for date ${currentSelectedDate}.`);
          });
      } else {
          console.log(`DailyEntryScreen: No unique food names found to pre-fetch for date ${currentSelectedDate}.`);
      }
  // **** REMOVED foodIcons FROM DEPENDENCIES ****
  // Now depends only on external variables, should be stable unless they change
  }, []); // Empty dependency array (or add stable external fns if needed)


  // --- Data Loading ---
  // **** IMPORTANT FIX: Removed triggerIconPrefetch from dependency array ****
  // triggerIconPrefetch is now stable due to its own empty dependency array
  const loadData = useCallback(async () => {
    console.log(`DailyEntryScreen: Loading data for date: ${selectedDate}`);
    setIsLoadingData(true);
    try {
      const [loadedFoods, loadedEntries, loadedSettings] = await Promise.all([
        getFoods(),
        loadDailyEntries(),
        loadSettings(),
      ]);
      const currentGoals = loadedSettings?.dailyGoals ?? { calories: 2000, protein: 150, carbs: 200, fat: 70, };
      setDailyGoals(currentGoals);
      loadedFoods.sort((a, b) => a.name.localeCompare(b.name));
      setFoods(loadedFoods);
      setDailyEntries(loadedEntries);
      console.log( `DailyEntryScreen: Loaded ${loadedFoods.length} foods, ${loadedEntries.length} entry days.` );
      // Call the stable pre-fetch function
      triggerIconPrefetch(loadedEntries, selectedDate);
    } catch (error) {
      console.error("DailyEntryScreen: Error loading data:", error);
      Alert.alert("Load Error", "Failed to load necessary data.");
      setFoods([]); setDailyEntries([]); setDailyGoals({ calories: 0, protein: 0, carbs: 0, fat: 0 });
    } finally {
      setIsLoadingData(false);
    }
  // **** Only depends on selectedDate now ****
  }, [selectedDate, triggerIconPrefetch]); // Keep triggerIconPrefetch here, but it's stable now


  // --- Focus Effect ---
  // **** IMPORTANT FIX: loadData dependency is now stable unless selectedDate changes ****
  useFocusEffect(
    useCallback(() => {
      console.log("DailyEntryScreen: Focused. Running effect.");
      loadData(); // Runs on focus or if selectedDate changes (via loadData dependency)
      return () => {
        console.log("DailyEntryScreen: Cleanup effect run (blur or dependency change).");
        // Cleanup logic remains the same
        setSearch("");
        setIsOverlayVisible(false);
        setEditIndex(null);
      };
    }, [loadData]) // Dependency on loadData is now correct and stable
  );

  // --- List and Index Management (Unchanged) ---
  const currentEntryItems = useMemo(() => {
    const entry = dailyEntries.find((e) => e.date === selectedDate);
    return entry ? [...entry.items].reverse() : [];
  }, [dailyEntries, selectedDate]);

  const getOriginalIndex = useCallback(
    (reversedIndex: number): number => {
      const entry = dailyEntries.find((e) => e.date === selectedDate);
      if (!entry || reversedIndex < 0 || reversedIndex >= entry.items.length) {
        console.error( `getOriginalIndex: Invalid reversedIndex ${reversedIndex} for entry length ${entry?.items?.length}` );
        return -1;
      }
      return entry.items.length - 1 - reversedIndex;
    },
    [dailyEntries, selectedDate]
  );

  // --- State Update Helper (Unchanged) ---
  const updateAndSaveEntries = useCallback(
    async (updatedEntries: DailyEntry[]) => {
      setIsSaving(true);
      const previousEntries = dailyEntries; // Store previous state for potential revert
      const entryForSelectedDate = updatedEntries.find( (e) => e.date === selectedDate );
      console.log( `DailyEntryScreen: updateAndSaveEntries called. Saving ${updatedEntries.length} total entries.` );
      console.log( `Entry for ${selectedDate} contains ${ entryForSelectedDate?.items?.length ?? 0 } items.` );
      setDailyEntries(updatedEntries); // Optimistic UI update
      try {
        await saveDailyEntries(updatedEntries);
        console.log( "DailyEntryScreen: Successfully saved updated entries to storage." );
      } catch (error) {
        console.error( "DailyEntryScreen: Failed to save updated entries to storage:", error );
        Alert.alert("Save Error", "Could not save changes. Please try again.");
        // Revert UI on save failure
        setDailyEntries(previousEntries);
      } finally {
        setIsSaving(false);
      }
    },
    [selectedDate, dailyEntries] // Add dailyEntries here so previous state is captured correctly
  );

  // --- Add/Update/Remove Handlers (Only minor change: removed explicit triggerIconFetch) ---
  const handleSingleEntryAction = useCallback(async () => {
    if (isSaving) return;
    if (!selectedFood || !selectedFood.id) { Alert.alert("Food Not Selected", "Please select a valid food item."); return; }
    const trimmedGrams = grams.trim();
    if (!isValidNumberInput(trimmedGrams) || parseFloat(trimmedGrams) <= 0) { Alert.alert( "Invalid Amount", "Please enter a valid positive number for grams." ); return; }
    const numericGrams = parseFloat(trimmedGrams);
    const entryItem: DailyEntryItem = { food: selectedFood, grams: numericGrams };
    const isEditMode = editIndex !== null;
    const existingEntryIndex = dailyEntries.findIndex( (entry) => entry.date === selectedDate );
    let updatedEntries: DailyEntry[];
    if (existingEntryIndex > -1) {
      const existingEntry = dailyEntries[existingEntryIndex]; let updatedItems;
      if (isEditMode) {
        const originalEditIndex = getOriginalIndex(editIndex!);
        if (originalEditIndex === -1) { console.error("..."); Alert.alert("..."); return; }
        updatedItems = existingEntry.items.map((item, index) => index === originalEditIndex ? entryItem : item );
      } else { updatedItems = [entryItem, ...(existingEntry.items ?? [])]; }
      const updatedEntry = { ...existingEntry, items: updatedItems };
      updatedEntries = dailyEntries.map((entry, index) => index === existingEntryIndex ? updatedEntry : entry );
    } else {
      if (isEditMode) { console.error("..."); Alert.alert("..."); return; }
      const newDailyEntry: DailyEntry = { date: selectedDate, items: [entryItem] };
      updatedEntries = [...dailyEntries, newDailyEntry];
      updatedEntries.sort((a, b) => a.date.localeCompare(b.date));
    }
    await updateAndSaveEntries(updatedEntries);

    // No need to explicitly trigger icon fetch here, pre-fetch should handle it,
    // and iconUtils already fetches if needed on render.

    setSelectedFood(null); setGrams(""); setEditIndex(null);
    setIsOverlayVisible(false); setSearch("");
    Toast.show({ type: "success", text1: `Entry ${isEditMode ? "updated" : "added"}`, position: "bottom", visibilityTime: 2000, });
  }, [ selectedFood, grams, editIndex, dailyEntries, selectedDate, isSaving, getOriginalIndex, updateAndSaveEntries ]);

  const handleAddMultipleEntries = useCallback(
    async (entriesToAdd: { food: Food; grams: number }[]) => {
      if (isSaving) return;
      try {
        if (!entriesToAdd || entriesToAdd.length === 0) { return; }
        const newItems: DailyEntryItem[] = entriesToAdd.map((entry) => ({ food: entry.food, grams: entry.grams }));
        const existingEntryIndex = dailyEntries.findIndex((entry) => entry.date === selectedDate);
        let updatedEntries: DailyEntry[];
        if (existingEntryIndex > -1) {
          const existingEntry = dailyEntries[existingEntryIndex];
          const updatedItems = [...newItems, ...(existingEntry.items ?? [])];
          const updatedEntry = { ...existingEntry, items: updatedItems };
          updatedEntries = dailyEntries.map((entry, index) => index === existingEntryIndex ? updatedEntry : entry );
        } else {
          const newDailyEntry: DailyEntry = { date: selectedDate, items: newItems };
          updatedEntries = [...dailyEntries, newDailyEntry];
          updatedEntries.sort((a, b) => a.date.localeCompare(b.date));
        }
        await updateAndSaveEntries(updatedEntries);

        // No need to explicitly trigger icon fetch here

        Toast.show({ type: "success", text1: `${entriesToAdd.length} item(s) added`, text2: `to ${formatDateReadable(parseISO(selectedDate))}`, position: "bottom", visibilityTime: 3000, });
        setIsOverlayVisible(false); setSelectedFood(null); setGrams("");
        setEditIndex(null); setSearch("");
      } catch (error) { console.error("...", error); Alert.alert("...", `...`); setIsOverlayVisible(false); }
    }, [ dailyEntries, selectedDate, isSaving, updateAndSaveEntries ]
  );

  const handleSelectFood = (item: Food | null) => { // Unchanged
    setSelectedFood(item);
    if (item && editIndex === null) setGrams("");
  };

  const handleRemoveEntry = useCallback( async (reversedIndex: number) => { // Unchanged
      if (isSaving) return;
      const originalIndex = getOriginalIndex(reversedIndex); if (originalIndex === -1) return;
      const currentEntry = dailyEntries.find((e) => e.date === selectedDate); if (!currentEntry || originalIndex >= currentEntry.items.length) return;
      const itemToRemove = currentEntry.items[originalIndex];
      const updatedItems = currentEntry.items.filter((_, i) => i !== originalIndex); let finalEntries: DailyEntry[];
      if (updatedItems.length === 0) { finalEntries = dailyEntries.filter((entry) => entry.date !== selectedDate); }
      else { const updatedEntry = { ...currentEntry, items: updatedItems }; finalEntries = dailyEntries.map((entry) => entry.date === selectedDate ? updatedEntry : entry ); }
      await updateAndSaveEntries(finalEntries);
      Toast.show({ type: "info", text1: `${itemToRemove.food.name} removed`, text2: "Tap here to undo", position: "bottom", bottomOffset: 80, visibilityTime: 4000, onPress: () => handleUndoRemoveEntry(itemToRemove, selectedDate, originalIndex), });
    }, [ dailyEntries, selectedDate, isSaving, getOriginalIndex, updateAndSaveEntries ]
  );

  const handleUndoRemoveEntry = useCallback( async ( itemToRestore: DailyEntryItem, entryDate: string, originalIndex: number ) => { // Unchanged
      if (isSaving) return;
      const existingEntryIndex = dailyEntries.findIndex((e) => e.date === entryDate); let updatedEntries;
      if (existingEntryIndex > -1) {
        const entryToUpdate = dailyEntries[existingEntryIndex]; const updatedItems = [...entryToUpdate.items];
        updatedItems.splice(originalIndex, 0, itemToRestore);
        const restoredEntry = { ...entryToUpdate, items: updatedItems };
        updatedEntries = dailyEntries.map((entry, index) => index === existingEntryIndex ? restoredEntry : entry );
      } else {
        const newEntry: DailyEntry = { date: entryDate, items: [itemToRestore] };
        updatedEntries = [...dailyEntries, newEntry]; updatedEntries.sort((a, b) => a.date.localeCompare(b.date));
      }
      await updateAndSaveEntries(updatedEntries); Toast.hide();
      Toast.show({ type: "success", text1: "Entry restored!", visibilityTime: 1500, position: "bottom" });
    }, [ dailyEntries, isSaving, updateAndSaveEntries ]
  );

  const updateSearch = (search: string) => setSearch(search); // Unchanged

  const toggleOverlay = useCallback( ( itemToEdit: DailyEntryItem | null = null, reversedIndex: number | null = null ) => { // Unchanged
      if (isSaving) return;
      setSelectedFood(null); setGrams(""); setEditIndex(null); setSearch("");
      if (itemToEdit && reversedIndex !== null) {
        setSelectedFood(itemToEdit.food); setGrams(String(itemToEdit.grams)); setEditIndex(reversedIndex);
      }
      setIsOverlayVisible((current) => !current);
    }, [isSaving]
  );

  const handleEditEntryViaModal = ( item: DailyEntryItem, reversedIndex: number ) => toggleOverlay(item, reversedIndex); // Unchanged

  const handleDateChange = useCallback( (event: DateTimePickerEvent, selectedDateValue?: Date) => { // Unchanged
      const isAndroidDismiss = Platform.OS === "android" && event.type === "dismissed";
      setShowDatePicker(Platform.OS === "ios");
      if (!isAndroidDismiss && event.type === "set" && selectedDateValue) {
        if (isValid(selectedDateValue)) {
          const formattedDate = formatISO(selectedDateValue, { representation: "date" });
          if (formattedDate !== selectedDate) {
            setSelectedDate(formattedDate); setEditIndex(null);
          }
        } else { Alert.alert("Invalid Date", "Selected date is not valid."); }
      }
      if (Platform.OS === "android") setShowDatePicker(false);
    }, [selectedDate]
  );

  const handlePreviousDay = useCallback(() => { // Unchanged
    if (isSaving || isLoadingData) return;
    try {
      const currentDateObj = parseISO(selectedDate); if (!isValid(currentDateObj)) return;
      const newDate = subDays(currentDateObj, 1); const newDateString = formatISO(newDate, { representation: "date" });
      setSelectedDate(newDateString); setEditIndex(null);
    } catch (e) { console.error("...", e); }
  }, [selectedDate, isSaving, isLoadingData]);

  const handleNextDay = useCallback(() => { // Unchanged
     if (isSaving || isLoadingData) return;
    try {
      const currentDateObj = parseISO(selectedDate); if (!isValid(currentDateObj)) return;
      const newDate = addDays(currentDateObj, 1); const newDateString = formatISO(newDate, { representation: "date" });
      setSelectedDate(newDateString); setEditIndex(null);
    } catch (e) { console.error("...", e); }
  }, [selectedDate, isSaving, isLoadingData]);

  const calculateTotals = useMemo(() => { // Unchanged
    const currentOriginalEntry = dailyEntries.find((entry) => entry.date === selectedDate);
    let totals = { totalCalories: 0, totalProtein: 0, totalCarbs: 0, totalFat: 0 };
    if (currentOriginalEntry) {
      currentOriginalEntry.items.forEach((item) => {
        if ( item.food && typeof item.food.calories === "number" && typeof item.food.protein === "number" && typeof item.food.carbs === "number" && typeof item.food.fat === "number" && typeof item.grams === "number" && item.grams > 0 ) {
          const factor = item.grams / 100; totals.totalCalories += item.food.calories * factor; totals.totalProtein += item.food.protein * factor; totals.totalCarbs += item.food.carbs * factor; totals.totalFat += item.food.fat * factor;
        } else console.warn("...");
      });
    }
    return { totalCalories: Math.round(totals.totalCalories), totalProtein: Math.round(totals.totalProtein), totalCarbs: Math.round(totals.totalCarbs), totalFat: Math.round(totals.totalFat), };
  }, [dailyEntries, selectedDate]);

  // --- Main Render (Unchanged) ---
  return (
    <SafeAreaView style={styles.container} edges={["top", "left", "right"]}>
      <DateNavigator
        selectedDate={selectedDate} onPreviousDay={handlePreviousDay} onNextDay={handleNextDay}
        onShowDatePicker={() => !isSaving && !isLoadingData && setShowDatePicker(true)}
        isSaving={isSaving} isLoadingData={isLoadingData}
      />
      {showDatePicker && ( <DateTimePicker value={parseISO(selectedDate)} mode="date" display={Platform.OS === "ios" ? "spinner" : "default"} onChange={handleDateChange} /> )}
      <View style={styles.progressContainer}>
        <DailyProgress calories={calculateTotals.totalCalories} protein={calculateTotals.totalProtein} carbs={calculateTotals.totalCarbs} fat={calculateTotals.totalFat} goals={dailyGoals} />
      </View>
      <Divider style={styles.divider} />
      {isSaving && ( <View style={styles.savingIndicator}><ActivityIndicator size="small" color={theme.colors.primary} /><Text style={styles.savingText}>Saving...</Text></View> )}
      <Text style={styles.sectionTitle}> Today's Entries </Text>
      {isLoadingData ? ( <View style={styles.centeredLoader}><ActivityIndicator size="large" color={theme.colors.primary} /><Text style={styles.loadingText}>Loading Entries...</Text></View>
      ) : (
        <FlatList
          data={currentEntryItems} keyExtractor={(item, index) => `entry-${item?.food?.id ?? "unknown"}-${getOriginalIndex(index)}-${ item?.grams ?? index }`}
          renderItem={({ item, index }) => ( <DailyEntryListItem item={item} reversedIndex={index} foodIcons={foodIcons} setFoodIcons={setFoodIcons} onEdit={handleEditEntryViaModal} onRemove={handleRemoveEntry} isSaving={isSaving} /> )}
          ListEmptyComponent={ <View style={styles.emptyListContainer}><RNEIcon name="reader-outline" type="ionicon" size={50} color={theme.colors.grey3} /><Text style={styles.emptyListText}> No entries recorded for this day. </Text><Text style={styles.emptyListSubText}> Tap '+' to add your first meal. </Text></View> }
          initialNumToRender={10} maxToRenderPerBatch={5} windowSize={11} contentContainerStyle={styles.listContentContainer} keyboardShouldPersistTaps="handled"
        />
      )}
      <FAB icon={<RNEIcon name="add" color="white" />} color={theme.colors.primary} onPress={() => !isSaving && toggleOverlay()} placement="right" size="large" style={styles.fab} disabled={isSaving || isLoadingData} />
      <AddEntryModal
        isVisible={isOverlayVisible} toggleOverlay={toggleOverlay} selectedFood={selectedFood} grams={grams} setGrams={setGrams} foods={foods}
        handleAddEntry={handleSingleEntryAction} handleAddMultipleEntries={handleAddMultipleEntries} handleSelectFood={handleSelectFood}
        search={search} updateSearch={updateSearch} isEditMode={editIndex !== null} initialGrams={editIndex !== null ? grams : undefined}
      />
    </SafeAreaView>
  );
};

// --- Styles (Unchanged) ---
const useStyles = makeStyles((theme) => ({
  container: { flex: 1, backgroundColor: theme.colors.background },
  progressContainer: { paddingHorizontal: 15, paddingTop: 10 },
  divider: { marginVertical: 0, height: StyleSheet.hairlineWidth, backgroundColor: theme.colors.divider, },
  sectionTitle: { marginTop: 15, marginBottom: 10, paddingHorizontal: 15, fontWeight: "bold", fontSize: 18, color: theme.colors.text, },
  fab: { position: "absolute", margin: 16, right: 10, bottom: 10 },
  emptyListContainer: { flex: 1, alignItems: "center", justifyContent: "center", padding: 30, marginTop: 50, },
  emptyListText: { fontSize: 17, color: theme.colors.grey2, textAlign: "center", marginTop: 15, },
  emptyListSubText: { fontSize: 14, color: theme.colors.grey3, textAlign: "center", marginTop: 8, },
  centeredLoader: { flex: 1, justifyContent: "center", alignItems: "center", paddingBottom: 50, },
  loadingText: { marginTop: 10, color: theme.colors.grey2, fontSize: 16 },
  savingIndicator: { flexDirection: "row", alignItems: "center", justifyContent: "center", paddingVertical: 5, backgroundColor: theme.colors.grey5, },
  savingText: { marginLeft: 8, color: theme.colors.primary, fontSize: 14, fontStyle: "italic", },
  listContentContainer: { paddingBottom: 80 },
}));

export default DailyEntryScreen;
---------- END DailyEntryScreen.tsx ----------


---------- FoodListScreen.tsx ----------
// ---------- src/screens/FoodListScreen.tsx ----------
// src/screens/FoodListScreen.tsx
import React, { useState, useEffect, useCallback, useMemo, useRef } from "react"; // Added useRef
import { View, FlatList, Alert, Platform, ActivityIndicator, StyleSheet } from "react-native";
import {
    createFood,
    getFoods,
    updateFood,
    deleteFood,
} from "../services/foodService";
import { Food } from "../types/food";
import { isNotEmpty } from "../utils/validationUtils";
import FoodItem from "../components/FoodItem";
import { Button, SearchBar, useTheme, makeStyles, Text, Icon as RNEIcon } from "@rneui/themed";
import { FAB } from "@rneui/base";
import { SafeAreaView } from "react-native-safe-area-context";
import AddFoodModal from "../components/AddFoodModal";
import Toast from "react-native-toast-message";
import { useFocusEffect } from "@react-navigation/native";
import { getFoodIconUrl } from "../utils/iconUtils"; // Correct import

interface FoodListScreenProps {
    onFoodChange?: () => void;
}

const FoodListScreen: React.FC<FoodListScreenProps> = ({ onFoodChange }) => {
    const [foods, setFoods] = useState<Food[]>([]);
    const [foodIcons, setFoodIcons] = useState<{ [foodName: string]: string | null | undefined }>({});
    const [isLoading, setIsLoading] = useState(true);
    const [isOverlayVisible, setIsOverlayVisible] = useState(false);
    const [search, setSearch] = useState("");
    const [newFood, setNewFood] = useState<Omit<Food, "id">>({
        name: "", calories: 0, protein: 0, carbs: 0, fat: 0,
    });
    const [editFood, setEditFood] = useState<Food | null>(null);
    const [errors, setErrors] = useState<{ [key: string]: string }>({});
    const [isSaving, setIsSaving] = useState(false);

    const { theme } = useTheme();
    const styles = useStyles();
    const flatListRef = useRef<FlatList>(null);
    // Ref to hold the current foodIcons state for checking inside triggerIconPrefetch
    const foodIconsRef = useRef(foodIcons);
    useEffect(() => {
      foodIconsRef.current = foodIcons;
    }, [foodIcons]);

    // --- Icon Pre-fetching ---
    // **** IMPORTANT FIX: Removed foodIcons from dependency array ****
    const triggerIconPrefetch = useCallback((foodsToFetch: Food[]) => {
        if (!foodsToFetch || foodsToFetch.length === 0) return;

        const uniqueFoodNames = new Set(foodsToFetch.map(f => f.name));
        if (uniqueFoodNames.size === 0) return;

        console.log(`FoodListScreen: Triggering pre-fetch for ${uniqueFoodNames.size} unique food names...`);
        const currentIcons = foodIconsRef.current; // Read current icons from ref
        const prefetchPromises = Array.from(uniqueFoodNames).map(name => {
            // Check *current* status from ref, not state dependency
            if (currentIcons[name] === undefined) {
                // Set state to loading IF NOT ALREADY SET
                 if (foodIconsRef.current[name] === undefined) {
                    setFoodIcons(prev => ({...prev, [name]: undefined}));
                 }
                // Fetch and update state directly in promise handlers
                return getFoodIconUrl(name).then(url => {
                    setFoodIcons(prev => ({...prev, [name]: url}));
                }).catch(err => {
                    console.warn(`Icon pre-fetch failed for ${name}:`, err);
                    setFoodIcons(prev => ({...prev, [name]: null}));
                });
            }
             return Promise.resolve(); // Already known/loading
        });

        // Run fetches in background
        Promise.allSettled(prefetchPromises).then(() => {
            console.log("FoodListScreen: Icon pre-fetch settle completed.");
        });
    // **** REMOVED foodIcons FROM DEPENDENCIES ****
    }, []); // Empty dependency array


    // --- Data Loading ---
    // **** IMPORTANT FIX: Removed triggerIconPrefetch from dependency array ****
    const loadFoodData = useCallback(async () => {
        console.log("FoodListScreen: Loading food data...");
        setIsLoading(true);
        setFoodIcons({}); // Clear icons on full reload
        try {
            const loadedFoods = await getFoods();
            loadedFoods.sort((a, b) => a.name.localeCompare(b.name));
            setFoods(loadedFoods);
            console.log(`FoodListScreen: Loaded ${loadedFoods.length} foods.`);
            // Call the stable pre-fetch function
            triggerIconPrefetch(loadedFoods);
        } catch (error) {
            console.error("FoodListScreen: Error loading food data:", error);
            Alert.alert("Error", "Failed to load food list.");
            setFoods([]);
        } finally {
            setIsLoading(false);
        }
    // **** REMOVED triggerIconPrefetch FROM DEPENDENCIES ****
    }, [triggerIconPrefetch]); // Dependency is stable


    // --- Focus Effect ---
    // **** IMPORTANT FIX: loadData dependency is now stable ****
    useFocusEffect(
        useCallback(() => {
            console.log("FoodListScreen: Focused. Running effect.");
            loadFoodData(); // Runs on focus
            return () => {
                 console.log("FoodListScreen: Cleanup effect run (blur).");
                 setSearch("");
                 setIsOverlayVisible(false);
                 // No need to clear icons here, they persist between focuses
            };
        }, [loadFoodData]) // Dependency is now stable
    );

    // --- Validation (Unchanged) ---
    const validateFood = (food: Omit<Food, "id"> | Food): { [key: string]: string } | null => {
        const newErrors: { [key: string]: string } = {};
        if (!isNotEmpty(food.name)) newErrors.name = "Name is required";
        if (isNaN(food.calories) || food.calories < 0) newErrors.calories = "Must be a non-negative number";
        if (isNaN(food.protein) || food.protein < 0) newErrors.protein = "Must be a non-negative number";
        if (isNaN(food.carbs) || food.carbs < 0) newErrors.carbs = "Must be a non-negative number";
        if (isNaN(food.fat) || food.fat < 0) newErrors.fat = "Must be a non-negative number";
        return Object.keys(newErrors).length === 0 ? null : newErrors;
    };

    // --- CRUD Operations (Only minor changes: removed explicit triggerIconFetch) ---
    const handleCreateFood = async () => {
        const trimmedFood = { ...newFood, name: newFood.name.trim() };
        const validationErrors = validateFood(trimmedFood);
        if (validationErrors) { setErrors(validationErrors); Toast.show({ type: 'error', text1: 'Please fix errors', position: 'bottom' }); return; }
        setErrors({}); setIsSaving(true);
        try {
            const createdFood = await createFood(trimmedFood);
            const updatedFoods = [...foods, createdFood].sort((a, b) => a.name.localeCompare(b.name));
            setFoods(updatedFoods);

            // No need to explicitly trigger icon fetch here

            setNewFood({ name: "", calories: 0, protein: 0, carbs: 0, fat: 0 });
            setIsOverlayVisible(false); onFoodChange?.();
            Toast.show({ type: 'success', text1: `${createdFood.name} added`, position: 'bottom' });
        } catch (error: any) {
            console.error("FoodListScreen: Error creating food:", error);
            Alert.alert("Error", error.message || "Failed to create food.");
        } finally { setIsSaving(false); }
    };

    const handleUpdateFood = async () => {
        if (!editFood) return;
        const trimmedFood = { ...editFood, name: editFood.name.trim() };
        const validationErrors = validateFood(trimmedFood);
        if (validationErrors) { setErrors(validationErrors); Toast.show({ type: 'error', text1: 'Please fix errors', position: 'bottom' }); return; }
        setErrors({}); setIsSaving(true);
        try {
            const updated = await updateFood(trimmedFood);
            const originalFood = foods.find(f => f.id === updated.id);
            const updatedFoods = foods.map((f) => (f.id === updated.id ? updated : f)).sort((a, b) => a.name.localeCompare(b.name));
            setFoods(updatedFoods);

            // No need to explicitly trigger icon fetch here

            setEditFood(null); setIsOverlayVisible(false); onFoodChange?.();
            Toast.show({ type: 'success', text1: `${updated.name} updated`, position: 'bottom' });
        } catch (error: any) {
            console.error("FoodListScreen: Error updating food:", error);
            Alert.alert("Error", error.message || "Failed to update food.");
        } finally { setIsSaving(false); }
    };

    const handleDeleteFood = async (foodId: string) => { // (Unchanged)
        const foodToDelete = foods.find((f) => f.id === foodId); if (!foodToDelete) return;
        const previousFoods = foods; // Store previous state
        setFoods(foods.filter((f) => f.id !== foodId)); // Optimistic UI
        try {
            await deleteFood(foodId);
            onFoodChange?.();
            setFoodIcons(prev => { const newIcons = {...prev}; delete newIcons[foodToDelete.name]; return newIcons; });
        } catch (error) {
            console.error("FoodListScreen: Error deleting food:", error);
            setFoods(previousFoods); // Revert on error
            Alert.alert("Delete Error", "Failed to delete food from storage. Restored item.");
        }
    };

    const handleUndoDeleteFood = useCallback((food: Food) => { // (Unchanged)
        const restoredFoods = [...foods, food].sort((a, b) => a.name.localeCompare(b.name));
        setFoods(restoredFoods); Toast.hide(); onFoodChange?.();
        Toast.show({ type: 'success', text1: `${food.name} restored`, position: 'bottom', visibilityTime: 2000 });
        // Re-fetch icon if needed (prefetch logic handles this implicitly now)
        // if (foodIconsRef.current[food.name] === undefined) {
        //    triggerIconPrefetch([food]); // Or just let render handle it via iconUtils
        // }
    }, [foods, onFoodChange]); // Removed foodIcons, triggerIconPrefetch

    // --- Modal and Input Handling (Unchanged) ---
    const toggleOverlay = (foodToEdit?: Food) => {
        if (isSaving) return;
        if (foodToEdit) { setEditFood({ ...foodToEdit }); setNewFood({ name: "", calories: 0, protein: 0, carbs: 0, fat: 0 }); }
        else { setEditFood(null); setNewFood({ name: "", calories: 0, protein: 0, carbs: 0, fat: 0 }); }
        setErrors({}); setIsOverlayVisible(!isOverlayVisible);
    };

    const updateSearch = (search: string) => setSearch(search);

    const filteredFoods = useMemo(() => {
        return foods.filter((food) => food.name.toLowerCase().includes(search.toLowerCase()));
    }, [foods, search]);

    const handleInputChange = useCallback(( key: keyof Omit<Food, "id">, value: string, isEdit: boolean ) => {
        const numericKeys: (keyof Omit<Food, "id">)[] = ['calories', 'protein', 'carbs', 'fat']; let processedValue: string | number = value;
        if (numericKeys.includes(key)) {
            if (value === "" || value === ".") { processedValue = value; } else {
                const cleaned = value.replace(/[^0-9.]/g, "").replace(/(\..*)\./g, "$1");
                if (cleaned === "" || !isNaN(parseFloat(cleaned))) { processedValue = cleaned; } else { return; }
            }
        }
        const updateState = (prevState: any) => {
             let finalValue: string | number;
             if (numericKeys.includes(key)) { finalValue = (processedValue === "" || processedValue === ".") ? 0 : parseFloat(processedValue as string); } else { finalValue = processedValue; }
             return { ...prevState, [key]: finalValue };
        };
        if (isEdit) { setEditFood(updateState); } else { setNewFood(updateState); }
    }, []);

    // --- Render (Unchanged) ---
    if (isLoading) {
        return (
            <SafeAreaView style={styles.centeredLoader}>
                <ActivityIndicator size="large" color={theme.colors.primary} />
                <Text style={styles.loadingText}>Loading Foods...</Text>
            </SafeAreaView>
        );
    }

    return (
        <SafeAreaView style={styles.container} edges={['top', 'left', 'right']}>
            <SearchBar
                placeholder="Search Your Food Library..." onChangeText={updateSearch} value={search} platform={Platform.OS === "ios" ? "ios" : "android"}
                containerStyle={styles.searchBarContainer} inputContainerStyle={styles.searchBarInputContainer} inputStyle={styles.searchInputStyle}
                onClear={() => setSearch('')} showCancel={Platform.OS === 'ios'}
            />
            <FlatList
                ref={flatListRef} data={filteredFoods} keyExtractor={(item) => item.id}
                renderItem={({ item }) => ( <FoodItem food={item} onEdit={toggleOverlay} onDelete={handleDeleteFood} onUndoDelete={handleUndoDeleteFood} foodIconUrl={foodIcons[item.name]} /> )}
                ListEmptyComponent={ <View style={styles.emptyListContainer}><RNEIcon name="nutrition-outline" type="ionicon" size={50} color={theme.colors.grey3} /><Text style={styles.emptyListText}> {search ? `No foods found matching "${search}"` : "Your food library is empty."} </Text>{!search && <Text style={styles.emptyListSubText}>Tap '+' to add your first food item!</Text>}</View> }
                contentContainerStyle={filteredFoods.length === 0 ? styles.listContentContainerEmpty : styles.listContentContainer}
                initialNumToRender={15} maxToRenderPerBatch={10} windowSize={21} keyboardShouldPersistTaps="handled"
            />
            <FAB
                icon={<RNEIcon name="add" color={theme.colors.white} />} color={theme.colors.primary} onPress={() => !isSaving && toggleOverlay()}
                placement="right" size="large" style={styles.fab} disabled={isSaving}
            />
            <AddFoodModal
                isVisible={isOverlayVisible} toggleOverlay={() => !isSaving && setIsOverlayVisible(false)} newFood={newFood} editFood={editFood}
                errors={errors} handleInputChange={handleInputChange} handleCreateFood={handleCreateFood} handleUpdateFood={handleUpdateFood}
                validateFood={validateFood} setErrors={setErrors}
            />
        </SafeAreaView>
    );
};

// --- Styles (Unchanged) ---
const useStyles = makeStyles((theme) => ({
    container: { flex: 1, backgroundColor: theme.colors.background, },
    centeredLoader: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: theme.colors.background, },
    loadingText: { marginTop: 15, color: theme.colors.grey1, fontSize: 16, },
    emptyListContainer: { flex: 1, alignItems: 'center', justifyContent: 'center', padding: 30, marginTop: 50, },
    emptyListText: { fontSize: 17, color: theme.colors.grey2, textAlign: 'center', marginTop: 15, },
    emptyListSubText: { fontSize: 14, color: theme.colors.grey3, textAlign: 'center', marginTop: 8, },
    searchBarContainer: { backgroundColor: theme.colors.background, borderBottomColor: theme.colors.divider, borderTopColor: theme.colors.background, borderBottomWidth: StyleSheet.hairlineWidth, paddingHorizontal: 10, paddingVertical: 8, marginBottom: 0, },
    searchBarInputContainer: { backgroundColor: theme.colors.searchBg || theme.colors.grey5, height: 40, borderRadius: 20, },
    searchInputStyle: { color: theme.colors.text, fontSize: 15, },
    listContentContainer: { paddingBottom: 80, },
    listContentContainerEmpty: { flexGrow: 1, justifyContent: 'center', },
    fab: { position: 'absolute', margin: 16, right: 10, bottom: 10, },
}));

export default FoodListScreen;
---------- END FoodListScreen.tsx ----------


---------- SettingsScreen.tsx ----------
// src/screens/SettingsScreen.tsx
import React, { useState, useEffect, useCallback } from "react";
import { View, ScrollView, Alert, StyleSheet, ActivityIndicator } from "react-native";
import { Text, makeStyles, Button, Icon, useTheme } from "@rneui/themed";
import DailyGoalsInput from "../components/DailyGoalsInput";
import DataManagementButtons from "../components/DataManagementButtons";
import ThemeSwitch from "../components/ThemeSwitch";
import StatisticsChart from "../components/StatisticsChart";
import AccountSettings from "../components/AccountSettings"; // Import extracted component
import { loadSettings, saveSettings, loadDailyEntries } from "../services/storageService";
import { Settings, Statistics, MacroType, MacroData } from "../types/settings";
import { parseISO, isValid } from "date-fns";
import { DailyEntry } from "../types/dailyEntry";
import { useFocusEffect } from "@react-navigation/native";
import { clearIconCache } from "../utils/iconUtils";
import Toast from "react-native-toast-message";
import { getUserStatus, addCoinsToUser, BackendError } from "../services/backendService";

interface SettingsScreenProps {
  onThemeChange: (theme: "light" | "dark" | "system") => void;
  // Prop added by AppNavigator for data reload propagation
  onDataOperation: () => void; // Callback from AppNavigator
}

const SettingsScreen: React.FC<SettingsScreenProps> = ({ onThemeChange }) => {
  // Initial default state - will be overwritten by loadSettings
  const [settings, setSettings] = useState<Settings>({
    theme: "system",
    dailyGoals: { calories: 0, protein: 0, carbs: 0, fat: 0 },
    settingsHistory: [],
  });

  const [statistics, setStatistics] = useState<Statistics>({
    calories: [], protein: [], carbs: [], fat: [],
  });
  const [chartUpdateKey, setChartUpdateKey] = useState(0);
  const [isClearingCache, setIsClearingCache] = useState(false);
  // State for user coins (moved to this screen as it manages the AccountSettings component)
  const [userCoins, setUserCoins] = useState<number | null>(null);
  const [isLoadingCoins, setIsLoadingCoins] = useState(false);
  const [isAddingCoins, setIsAddingCoins] = useState(false);

  const { theme } = useTheme();
  const styles = useStyles();

  // --- Statistics Calculation (unchanged) ---
  const getStatisticsData = useCallback(( dailyEntries: DailyEntry[], macro: MacroType, currentGoals: { [key in MacroType]: number } ): MacroData[][] => {
    const intakeData: MacroData[] = []; const goalData: MacroData[] = [];
    dailyEntries.forEach((entry) => {
       try {
            const entryDate = parseISO(entry.date); if (!isValid(entryDate)) { console.warn(`Invalid date: ${entry.date}`); return; }
            const entryTimestamp = entryDate.getTime(); let intakeValue = 0;
            if (entry.items && Array.isArray(entry.items)) intakeValue = entry.items.reduce((total, item) => { if (item.food && typeof item.food[macro] === 'number' && typeof item.grams === 'number' && item.grams > 0) return total + (item.food[macro] / 100) * item.grams; return total; }, 0);
            const goalValue = currentGoals[macro] ?? 0; intakeData.push({ x: entryTimestamp, y: Math.round(intakeValue) });
            if (macro === "calories") goalData.push({ x: entryTimestamp, y: Math.round(goalValue) });
        } catch (parseError) { console.error(`Error processing entry ${entry.date}:`, parseError); }
    });
    intakeData.sort((a, b) => a.x - b.x); if (macro === "calories") { goalData.sort((a, b) => a.x - b.x); return [intakeData, goalData]; } else return [intakeData];
  }, []);

  // --- Update Statistics State (unchanged) ---
  const updateStatistics = useCallback(async (currentGoals: { [key in MacroType]: number }) => {
    console.log("SettingsScreen: Updating statistics...");
    try {
        const loadedEntries = await loadDailyEntries(); const updatedStats: Statistics = {
            calories: getStatisticsData(loadedEntries, "calories", currentGoals), protein: getStatisticsData(loadedEntries, "protein", currentGoals),
            carbs: getStatisticsData(loadedEntries, "carbs", currentGoals), fat: getStatisticsData(loadedEntries, "fat", currentGoals), };
        setStatistics(updatedStats); setChartUpdateKey((prevKey) => prevKey + 1); console.log("SettingsScreen: Statistics updated.");
    } catch (error) { console.error("SettingsScreen: Failed to update statistics:", error); }
  }, [getStatisticsData]);

  // --- Fetch User Status (unchanged) ---
  const fetchUserStatus = useCallback(async () => {
    setIsLoadingCoins(true);
    try { console.log("Fetching user status..."); const status = await getUserStatus(); setUserCoins(status.coins); console.log(`User status fetched. Coins: ${status.coins}`); }
    catch (error) { console.error("Failed to fetch user status:", error); setUserCoins(null); Toast.show({ type: 'error', text1: 'Could not load coin balance', text2: error instanceof BackendError ? error.message : 'Check connection.', position: 'bottom', }); }
    finally { setIsLoadingCoins(false); }
  }, []);

  // --- Load Data on Focus (unchanged) ---
  useFocusEffect( useCallback(() => {
      let isActive = true; console.log("SettingsScreen: Focused. Loading data.");
      const loadAndProcessData = async () => { try { const loadedSettings = await loadSettings(); if (!isActive) return; setSettings(loadedSettings); await fetchUserStatus(); updateStatistics(loadedSettings.dailyGoals); } catch (error) { if (isActive) { console.error("Error loading data:", error); Alert.alert("Load Error", "Failed to load settings or stats."); } } };
      loadAndProcessData(); return () => { isActive = false; console.log("SettingsScreen: Unfocused."); };
    }, [updateStatistics, fetchUserStatus])
  );

  // --- Handle Goal Changes (unchanged) ---
  const handleGoalChange = useCallback(async (goalType: MacroType, value: string) => {
    const numericValue = parseFloat(value) || 0; let latestSettings: Settings | null = null;
    setSettings((prevSettings) => { const updatedGoals = { ...prevSettings.dailyGoals, [goalType]: numericValue }; const updatedSettings: Settings = { ...prevSettings, dailyGoals: updatedGoals }; latestSettings = updatedSettings;
      (async () => { if (!latestSettings) return; try { await saveSettings(latestSettings); console.log("Settings saved."); updateStatistics(latestSettings.dailyGoals); } catch (error) { console.error("Failed save/update stats:", error); Alert.alert("Save Error"); } })();
      return updatedSettings; });
  }, [updateStatistics]);

  // --- Handle Data Management Button Trigger (unchanged) ---
  const handleDataOperation = useCallback(async () => {
    console.log("Data operation triggered. Reloading...");
    try { const reloadedSettings = await loadSettings(); setSettings(reloadedSettings); updateStatistics(reloadedSettings.dailyGoals); fetchUserStatus(); onThemeChange(reloadedSettings.theme); Toast.show({ type: 'info', text1: 'Data reloaded.', position: 'bottom'}); }
    catch (error) { console.error("Error reloading data:", error); Alert.alert("Reload Error"); }
  }, [updateStatistics, onThemeChange, fetchUserStatus]);

  // --- Handle Icon Cache Clearing (unchanged) ---
   const handleClearIconCache = useCallback(async () => {
      console.log("Clearing icon cache..."); setIsClearingCache(true);
      try { await clearIconCache(); Toast.show({ type: 'success', text1: 'Icon Cache Cleared', text2: 'Icons will refresh.', position: 'bottom' }); console.log("Icon cache cleared."); }
      catch (error) { console.error("Failed to clear icon cache:", error); Toast.show({ type: 'error', text1: 'Failed to Clear Cache', text2: error instanceof Error ? error.message : 'Unknown error.', position: 'bottom' }); }
      finally { setIsClearingCache(false); }
   }, []);

   // --- Handle Add Coins Button (unchanged) ---
    const handleAddTestCoins = useCallback(async () => {
        setIsAddingCoins(true);
        try { const amount = 10; console.log(`Adding ${amount} coins...`); const updatedStatus = await addCoinsToUser(amount); setUserCoins(updatedStatus.coins); console.log(`Coins added. New balance: ${updatedStatus.coins}`); Toast.show({ type: 'success', text1: `${amount} Coins Added!`, text2: `Balance: ${updatedStatus.coins}`, position: 'bottom' }); }
        catch (error) { console.error("Failed to add coins:", error); Toast.show({ type: 'error', text1: 'Failed to Add Coins', text2: error instanceof BackendError ? error.message : 'Try again.', position: 'bottom' }); }
        finally { setIsAddingCoins(false); }
    }, []);

  // --- Render ---
  return (
    <ScrollView style={styles.container} contentContainerStyle={styles.scrollContentContainer}>
        {/* Account Section using AccountSettings Component */}
        <Text h3 style={styles.sectionTitle}>Account</Text>
        <AccountSettings
             userCoins={userCoins}
             isLoadingCoins={isLoadingCoins}
             isAddingCoins={isAddingCoins}
             onAddTestCoins={handleAddTestCoins}
        />

        {/* General Section (unchanged) */}
        <Text h3 style={styles.sectionTitle}>General</Text>
        <ThemeSwitch currentTheme={settings.theme} onToggle={onThemeChange} />

        {/* Goals Section (unchanged) */}
        <Text h3 style={styles.sectionTitle}>Daily Goals</Text>
        <View style={styles.inputGroup}>
            <DailyGoalsInput dailyGoals={settings.dailyGoals} onGoalChange={handleGoalChange} />
        </View>

        {/* Cache Management Section (unchanged) */}
        <Text h3 style={styles.sectionTitle}>Cache Management</Text>
        <View style={styles.buttonGroup}>
            <Button title="Refresh Food Icons" onPress={handleClearIconCache} buttonStyle={[styles.button, { backgroundColor: theme.colors.secondary }]}
                    icon={<Icon name="refresh-outline" type="ionicon" color="white" size={20} style={{ marginRight: 8 }} />}
                    loading={isClearingCache} disabled={isClearingCache} />
        </View>

        {/* Statistics Section (unchanged) */}
        <Text h3 style={styles.sectionTitle}>Statistics</Text>
        <View style={styles.chartContainer}>
            <StatisticsChart statistics={statistics} key={chartUpdateKey} />
        </View>

        {/* Data Management Section (unchanged) */}
        <Text h3 style={styles.sectionTitle}>Data Management</Text>
        <View style={styles.buttonGroup}>
            <DataManagementButtons onDataOperation={handleDataOperation} />
        </View>
    </ScrollView>
  );
};

// Styles (AccountSettings styles moved)
const useStyles = makeStyles((theme) => ({
  container: { flex: 1, backgroundColor: theme.colors.background, },
  scrollContentContainer: { padding: 15, paddingBottom: 40, },
  sectionTitle: {
    color: theme.colors.text, marginTop: 25, marginBottom: 15, paddingLeft: 5,
    borderLeftWidth: 3, borderLeftColor: theme.colors.primary, },
  inputGroup: { marginBottom: 10, paddingHorizontal: 5, },
  buttonGroup: { marginBottom: 10, paddingHorizontal: 5, },
  button: { marginBottom: 10, borderRadius: 8, },
  chartContainer: { minHeight: 300, height: 'auto', marginBottom: 20, },
}));

export default SettingsScreen;
---------- END SettingsScreen.tsx ----------


---------- backendService.ts ----------
// ---------- src/services/backendService.ts ----------
// ---------- backendService.ts (Improved Error Handling, Logging, Auth Flag) ----------
import Constants from 'expo-constants';
import { getClientId } from './clientIDService';
import { EstimatedFoodItem, Macros, MacrosWithFoodName } from '../types/macros';
import { Platform } from 'react-native'; // For logging platform info
import uuid from 'react-native-uuid'; // Import uuid

// --- Configuration ---
const getBackendUrl = (): string => {
    // Prefer environment variable set during build (e.g., EXPO_PUBLIC_BACKEND_URL)
    const envUrl = process.env.EXPO_PUBLIC_BACKEND_URL;
    if (envUrl) {
        console.log("Using Backend URL from EXPO_PUBLIC_BACKEND_URL:", envUrl);
        return envUrl.endsWith('/api/v1') ? envUrl : `${envUrl.replace(/\/$/, '')}/api/v1`;
    }

    // Fallback to expoConfig (less ideal for production secrets)
    const configUrl = Constants.expoConfig?.extra?.env?.BACKEND_URL;
    if (configUrl) {
        console.warn("Using Backend URL from app.json extra.env. Consider using build-time environment variables (EXPO_PUBLIC_*) for production.");
        return configUrl.endsWith('/api/v1') ? configUrl : `${configUrl.replace(/\/$/, '')}/api/v1`;
    }

    // Final fallback for local development (clearly indicate this)
    console.error("BACKEND_URL not found in environment variables or app.json extra.env. Using default DEVELOPMENT URL. THIS IS NOT FOR PRODUCTION.");
    // Replace with your actual development backend IP/hostname
    const DEV_URL = 'http://192.168.1.15:8000'; // Or your machine's local IP
    return `${DEV_URL}/api/v1`;
};

const BASE_URL = getBackendUrl();
console.log(`Backend Service Initialized. Base URL: ${BASE_URL}`);


// --- Interfaces ---
interface GramsResponse {
    grams: number;
}

interface IconResponse {
    icon_url: string | null;
}

export interface UserStatus {
    client_id: string; // Changed to string to match backend UUID string representation
    coins: number;
}

interface BackendErrorDetail {
    // Matches FastAPI validation error structure
    loc?: (string | number)[];
    msg?: string;
    type?: string;
}

interface BackendErrorResponse {
    detail?: string | BackendErrorDetail[]; // Can be string or validation error list
}


// --- Custom Error Class ---
export class BackendError extends Error {
    status: number;
    detail?: string | BackendErrorDetail[]; // Can be string or parsed validation errors
    requestId?: string | null; // Optional request ID from response header

    constructor(message: string, status: number, detail?: string | BackendErrorDetail[], requestId?: string | null) {
        super(message);
        this.name = 'BackendError';
        this.status = status;
        this.detail = detail;
        this.requestId = requestId;
    }
}

// --- API Call Helper ---
async function fetchBackend<T>(
    endpoint: string,
    options: RequestInit = {},
    needsAuth: boolean = true // <<< Added flag to control auth header
): Promise<T> {
    const cleanEndpoint = endpoint.startsWith('/') ? endpoint : `/${endpoint}`;
    const url = `${BASE_URL}${cleanEndpoint}`;
    const method = options.method || 'GET';
    let response: Response | null = null; // Define response outside try block
    let requestId: string | null = null; // For logging correlation

    console.log(`[API Request] ${method} ${url} - Starting (Auth: ${needsAuth})`);

    const defaultHeaders: HeadersInit = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        // Add platform info for backend logging/debugging
        'X-Platform': Platform.OS,
        // 'X-App-Version': Constants.expoConfig?.version || 'unknown', // Example app version
    };

    let authHeaders: HeadersInit = {};
    if (needsAuth) {
        const clientId = await getClientId(); // Fetch client ID only if needed
         // Validate client ID format before sending
        if (!uuid.validate(clientId)) {
            console.error(`[API Request] Invalid Client ID format detected: ${clientId}. Aborting request.`);
            throw new BackendError("Invalid client ID format.", 400, "Invalid client ID format.");
        }
        authHeaders = { 'X-Client-ID': clientId };
        console.log(`[API Request] Adding X-Client-ID header.`);
    }


    const config: RequestInit = {
        ...options,
        headers: {
            ...defaultHeaders,
            ...authHeaders, // Add auth headers only if needsAuth is true
            ...options.headers,
        },
        // Consider adding a timeout (if not using default)
        // signal: AbortSignal.timeout(30000), // Example 30 second timeout
    };

     // Log request body structure carefully (avoid logging full sensitive data)
     if (config.body && typeof config.body === 'string') {
          try {
              const bodyObj = JSON.parse(config.body);
              const bodyKeys = Object.keys(bodyObj);
              const bodyPreview = bodyKeys.length > 0 ? `{ keys: [${bodyKeys.join(', ')}] }` : '{}';
              console.log(`[API Request] ${method} ${url} - Body Preview: ${bodyPreview}`);
              // DEBUG only: Log snippet of body value for specific fields if safe
              // if (bodyObj.food_name) console.debug(`[API Request] Body food_name: ${String(bodyObj.food_name).substring(0, 50)}`);
              // if (bodyObj.image_base64) console.debug(`[API Request] Body image_base64: (length ${bodyObj.image_base64.length})`);
          } catch {
              console.log(`[API Request] ${method} ${url} - Body: (non-JSON or failed parse)`);
          }
     }


    try {
        response = await fetch(url, config);
        requestId = response.headers.get("X-Request-ID"); // Get request ID from response
        const status = response.status;
        const contentType = response.headers.get("content-type");

        console.log(`[API Response] ${method} ${url} - Status: ${status}, Content-Type: ${contentType}, RequestID: ${requestId || 'N/A'}`);

        // Handle No Content success case
        if (status === 204) {
             console.log(`[API Response] ${method} ${url} - Success (204 No Content)`);
             // Return null or an appropriate empty value based on expected type T
             // Casting to T might be unsafe if T doesn't expect null. Consider checking T.
             return null as T;
        }

        // Attempt to parse JSON, otherwise get text
        let responseBody: any;
        let isJson = false;
        try {
            if (contentType && contentType.includes("application/json")) {
                responseBody = await response.json();
                isJson = true;
            } else {
                responseBody = await response.text(); // Read as text for non-JSON
                console.log(`[API Response] ${method} ${url} - Received Text: ${responseBody.substring(0, 200)}...`);
            }
        } catch (parseError) {
            // Handle cases where parsing fails (e.g., empty body, malformed JSON)
            console.error(`[API Error] ${method} ${url} - Failed to parse response body (Status: ${status}):`, parseError);
             // Use raw text if available and parsing failed
            const rawText = await response.text().catch(() => '(Could not get raw text)');
            if (!response.ok) {
                throw new BackendError(`Backend request failed (Status ${status}), failed to parse response.`, status, rawText, requestId);
            } else {
                // If response was OK but parsing failed, this might be an issue
                console.warn(`[API Warning] ${method} ${url} - Status ${status} OK, but failed to parse response body.`);
                 // Depending on T, might return null or throw
                 return null as T;
            }
        }

        // Check if the response status indicates failure
        if (!response.ok) {
            let errorMessage = `Backend request failed (Status ${status})`;
            let errorDetail: string | BackendErrorDetail[] | undefined = undefined;

            if (isJson && responseBody) {
                 const errorData = responseBody as BackendErrorResponse;
                 if (typeof errorData.detail === 'string') {
                    errorMessage = errorData.detail; // Use backend's string detail
                    errorDetail = errorMessage;
                 } else if (Array.isArray(errorData.detail)) {
                     // Handle validation errors
                     errorMessage = "Validation failed. Please check your input.";
                     errorDetail = errorData.detail; // Keep the array of details
                     console.warn(`[API Validation Error] ${method} ${url} - Details:`, JSON.stringify(errorDetail));
                 } else {
                      // Fallback if detail is missing or not string/array
                      errorMessage = `Backend error (Status ${status}), unexpected detail format.`;
                      errorDetail = JSON.stringify(responseBody); // Stringify the whole body as detail
                 }
            } else if (!isJson) {
                 // Use the text response as detail if it wasn't JSON
                 errorMessage = `Backend request failed (Status ${status}). Server response: ${responseBody.substring(0, 100)}...`;
                 errorDetail = responseBody;
            }

            // Specific handling for common error codes
            if (status === 401 && needsAuth) errorMessage = "Authentication failed. Invalid Client ID."; // Modify 401 message context
            if (status === 403) errorMessage = "Permission denied.";
            if (status === 404) errorMessage = "Resource not found.";
            if (status === 429) errorMessage = "Too many requests. Please try again later.";
            if (status === 402) errorMessage = "Insufficient coins for this action."; // Specific message for 402

            console.error(`[API Error] ${method} ${url} - Status: ${status}, Message: "${errorMessage}", Detail:`, errorDetail);
            throw new BackendError(errorMessage, status, errorDetail, requestId);
        }

        // Success case
        console.log(`[API Response] ${method} ${url} - Success (Status: ${status})`);
        // DEBUG only: Log successful response body snippet
        // if (isJson) console.debug(`[API Response] Body: ${JSON.stringify(responseBody).substring(0, 200)}...`);
        return responseBody as T;

    } catch (error) {
        // Log request ID if available
        const logRequestId = requestId ? ` (RequestID: ${requestId})` : '';

        if (error instanceof BackendError) {
            // Already logged in the block above
            throw error; // Re-throw known backend errors
        }

        // Handle network errors, timeouts, etc.
        console.error(`[API Network Error] ${method} ${url}${logRequestId} - Error:`, error);
        let networkErrorMessage = `Failed to communicate with the backend.`;
         if (error instanceof Error) {
             if (error.name === 'AbortError' || error.message.includes('timed out')) {
                 networkErrorMessage = 'The request timed out. Please try again.';
             } else if (error.message.includes('Network request failed')) {
                 networkErrorMessage += ' Please check your network connection.';
             } else {
                 networkErrorMessage += ` Details: ${error.message}`;
             }
         } else {
             networkErrorMessage += ' An unknown network error occurred.';
         }
        // Use status 0 or a custom code (e.g., 599) for client-side network errors
        throw new BackendError(networkErrorMessage, 0, networkErrorMessage, requestId);
    }
}

// --- Service Functions (Endpoints remain the same, auth flag used) ---

export const getUserStatus = async (): Promise<UserStatus> => {
    const clientId = await getClientId();
    // Ensure clientId is valid UUID format before sending? Backend likely handles.
    return fetchBackend<UserStatus>(`/users/status/${clientId}`, {}, true); // needsAuth = true
};

export const getMacrosForRecipe = async (foodName: string, ingredients: string): Promise<Macros> => {
    const body = { food_name: foodName, ingredients };
    return fetchBackend<Macros>('/ai/macros_recipe', {
        method: 'POST',
        body: JSON.stringify(body),
    }, true); // needsAuth = true
};

export const getMacrosForImageSingle = async (image_base64: string, mime_type: string): Promise<MacrosWithFoodName> => {
    const body = { image_base64, mime_type };
    return fetchBackend<MacrosWithFoodName>('/ai/macros_image_single', {
        method: 'POST',
        body: JSON.stringify(body),
    }, true); // needsAuth = true
};

export const getMacrosForImageMultiple = async (image_base64: string, mime_type: string): Promise<EstimatedFoodItem[]> => {
    const body = { image_base64, mime_type };
    return fetchBackend<EstimatedFoodItem[]>('/ai/macros_image_multiple', {
        method: 'POST',
        body: JSON.stringify(body),
    }, true); // needsAuth = true
};

export const estimateGramsNaturalLanguage = async (foodName: string, quantityDescription: string): Promise<number> => {
    const body = { food_name: foodName, quantity_description: quantityDescription };
    const response = await fetchBackend<GramsResponse>('/ai/grams_natural_language', {
        method: 'POST',
        body: JSON.stringify(body),
    }, true); // needsAuth = true
    // Handle potential null response from fetchBackend if server returned 204 or non-JSON OK
    if (response === null || typeof response.grams !== 'number') {
        console.error("Received unexpected null or invalid response format while estimating grams.");
        throw new BackendError("Failed to get grams estimation due to unexpected response.", 500, "Invalid response format");
    }
    return response.grams;
};

export const getFoodIcon = async (foodName: string, locale: string = 'en'): Promise<string | null> => {
    const encodedFoodName = encodeURIComponent(foodName);
    const encodedLocale = encodeURIComponent(locale);
    try {
        // Expecting IconResponse = { icon_url: string | null }
        const response = await fetchBackend<IconResponse>(
            `/icons/food?food_name=${encodedFoodName}&locale=${encodedLocale}`,
            {}, // Default GET options
            false // <<< Set needsAuth = false for this endpoint
        );
        // Handle null response from fetchBackend (e.g., 204 No Content)
        if (response === null) {
            // console.log(`Received null response for icon ${foodName}, treating as not found.`);
            return null;
        }
        return response.icon_url; // Can be string or null as intended by backend
    } catch (error) {
        if (error instanceof BackendError && error.status === 404) {
             console.log(`Icon not found for ${foodName} (404).`);
             return null;
        }
        // Log other errors but return null to calling function
        console.error(`Failed to get icon for ${foodName} via backend service:`, error);
         return null;
    }
};

export const addCoinsToUser = async (amount: number): Promise<UserStatus> => {
    const clientId = await getClientId();
    const body = { amount };
    if (amount <= 0) {
        // Basic client-side validation
        throw new BackendError("Amount to add must be positive.", 400, "Amount must be positive.");
    }
    return fetchBackend<UserStatus>(`/users/add_coins/${clientId}`, {
        method: 'POST',
        body: JSON.stringify(body),
    }, true); // needsAuth = true
};
---------- END backendService.ts ----------


---------- clientIDService.ts ----------
// src/services/clientIDService.ts
import AsyncStorage from '@react-native-async-storage/async-storage';
import uuid from 'react-native-uuid';

const CLIENT_ID_KEY = '@MacroTracker:clientId';
let currentClientId: string | null = null; // In-memory cache

export const getClientId = async (): Promise<string> => {
  if (currentClientId) {
    return currentClientId;
  }

  try {
    let clientId = await AsyncStorage.getItem(CLIENT_ID_KEY);
    if (!clientId) {
      clientId = uuid.v4() as string;
      console.log('Generated new client ID:', clientId);
      await AsyncStorage.setItem(CLIENT_ID_KEY, clientId);
    } else {
      console.log('Retrieved existing client ID:', clientId);
    }
    currentClientId = clientId;
    return clientId;
  } catch (error) {
    console.error('Error handling client ID:', error);
    // Fallback or throw error depending on desired behavior
    // For now, generating a temporary one if storage fails
    return uuid.v4() as string;
  }
};

// Optional: Function to clear ID for testing
export const clearClientId = async (): Promise<void> => {
    currentClientId = null;
    try {
        await AsyncStorage.removeItem(CLIENT_ID_KEY);
        console.log('Client ID cleared.');
    } catch (error) {
        console.error('Error clearing client ID:', error);
    }
};
---------- END clientIDService.ts ----------


---------- foodService.ts ----------
// services/foodService.ts
import { Food } from '../types/food';
import { saveFoods, loadFoods } from './storageService';
import 'react-native-get-random-values';
import { v4 as uuidv4 } from 'uuid';

export const createFood = async (foodData: Omit<Food, 'id'>): Promise<Food> => {
  const newFood: Food = {
    id: uuidv4(),
    ...foodData,
  };
  const foods = await loadFoods();
  foods.push(newFood);
  await saveFoods(foods);
  return newFood;
};

export const getFoods = async (): Promise<Food[]> => {
  return loadFoods();
};

export const updateFood = async (updatedFood: Food): Promise<Food> => {
  const foods = await loadFoods();
  const index = foods.findIndex((f) => f.id === updatedFood.id);
  if (index === -1) {
    throw new Error('Food not found'); // Throw an error if not found
  }
  foods[index] = updatedFood;
  await saveFoods(foods);
  return updatedFood;
};

export const deleteFood = async (foodId: string): Promise<void> => {
  const foods = await loadFoods();
  const filteredFoods = foods.filter((f) => f.id !== foodId);
  await saveFoods(filteredFoods);
};
---------- END foodService.ts ----------


---------- storageService.ts ----------
// services/storageService.ts (Modified for Timestamps)
import AsyncStorage from '@react-native-async-storage/async-storage';
import { DailyEntry } from '../types/dailyEntry';
import { Food } from '../types/food';
import { Settings } from '../types/settings';
import { formatISO, parseISO } from 'date-fns';


const DAILY_ENTRIES_KEY = 'dailyEntries';
const FOODS_KEY = 'foods';
const SETTINGS_KEY = 'settings';
const RECENT_FOODS = 'recentFoods';


export const saveDailyEntries = async (entries: DailyEntry[]): Promise<void> => {
  try {
    await AsyncStorage.setItem(DAILY_ENTRIES_KEY, JSON.stringify(entries));
  } catch (error) {
    console.error('Error saving daily entries:', error);
    throw error;
  }
};

export const loadDailyEntries = async (): Promise<DailyEntry[]> => {
  try {
    const entriesJson = await AsyncStorage.getItem(DAILY_ENTRIES_KEY);
    return entriesJson ? JSON.parse(entriesJson) : [];
  } catch (error) {
    console.error('Error loading daily entries:', error);
    return [];
  }
};

export const saveFoods = async (foods: Food[]): Promise<void> => {
  try {
    await AsyncStorage.setItem(FOODS_KEY, JSON.stringify(foods));
  } catch (error) {
    console.error('Error saving foods:', error);
    throw error; // Re-throw the error
  }
};

export const loadFoods = async (): Promise<Food[]> => {
  try {
    const foodsJson = await AsyncStorage.getItem(FOODS_KEY);
    return foodsJson ? JSON.parse(foodsJson) : [];
  } catch (error) {
    console.error('Error loading foods:', error);
    return []; // Return an empty array on error
  }
};



export const saveSettings = async (settings: Settings): Promise<void> => {
  try {
    await AsyncStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
  } catch (error) {
    console.error('Error saving settings:', error);
    throw error;
  }
};

export const loadSettings = async (): Promise<Settings> => {
  try {
    const settingsJson = await AsyncStorage.getItem(SETTINGS_KEY);
    const loadedSettings = settingsJson ? JSON.parse(settingsJson) : {};

    // Apply defaults and ensure structure
    const defaultSettings: Settings = {
      theme: 'system',
      dailyGoals: { calories: 2000, protein: 50, carbs: 200, fat: 70 },
      settingsHistory: [] // Ensure settingsHistory exists
    };


    return {
      ...defaultSettings, // Start with defaults
        ...loadedSettings, // Override with loaded values
        dailyGoals: {
          ...defaultSettings.dailyGoals,  //ensure no fields missing from daily goals
            ...(loadedSettings.dailyGoals || {}) // And override *those* with any loaded dailyGoals
        }
    }

  } catch (error: any) {
    console.error('Error loading settings:', error);

    // *** KEY CHANGE: Handle "Row too big" error ***
    if (error.message.includes('Row too big')) {
      console.warn('Detected oversized settings data. Clearing settings.');
      try {
        await AsyncStorage.removeItem(SETTINGS_KEY); // Clear the oversized data
      } catch (clearError) {
        console.error('Error clearing oversized settings:', clearError);
        // You might want to handle this more gracefully, e.g., by showing an error to the user.
      }
    }

    // Return defaults if loading fails (or after clearing)
    return {
      theme: 'system',
      dailyGoals: { calories: 2000, protein: 50, carbs: 200, fat: 70 },
      settingsHistory: [] // Ensure settingsHistory exists in default
    };
  }
};

export const clearAllData = async (): Promise<void> => {
  try {
    await AsyncStorage.clear();
  } catch (error) {
    console.error('Error clearing data:', error);
    throw error;
  }
};

// Function to save recent foods
export const saveRecentFoods = async (foods: Food[]) => {
    try {
        await AsyncStorage.setItem(RECENT_FOODS, JSON.stringify(foods));
    } catch (error) {
        console.error('Error saving recent foods:', error);
        throw error; // Important: Re-throw the error so calling code knows it failed
    }
};

// Function to load recent foods
export const loadRecentFoods = async (): Promise<Food[]> => {
    try {
        const foods = await AsyncStorage.getItem(RECENT_FOODS);
        return foods ? JSON.parse(foods) : [];
    } catch (error) {
        console.error('Error loading recent foods:', error);
        return []; // Return empty array on error, don't throw
    }
};
---------- END storageService.ts ----------


---------- dailyEntry.ts ----------
// types/dailyEntry.ts (Modified)
import { Food } from "./food";

export interface DailyEntryItem {
  food: Food;
  grams: number;
}

export interface DailyEntry {
  date: string; // YYYY-MM-DD format
  items: DailyEntryItem[];
  goals?: {  // Optional goals
    calories?: number;
    protein?: number;
    carbs?: number;
    fat?: number;
  };
}

export interface FoodItem { //No changes here.
    id: string;
    name: string;
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
  }
---------- END dailyEntry.ts ----------


---------- food.ts ----------
// types/food.ts
export interface Food {
  id: string;
  name: string;
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
  // category: string;  // REMOVED
}
---------- END food.ts ----------


---------- macros.ts ----------
// src/types/macros.ts

// Basic macro structure
export interface Macros {
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
  }
  
  // Macros structure including the identified food name
  export interface MacrosWithFoodName extends Macros {
    foodName: string;
  }
  
  /**
   * Represents a single food item estimated from an image,
   * including its name, estimated weight, and macros per 100g.
   * Matches the structure expected/returned by the backend service.
   */
  export interface EstimatedFoodItem {
    foodName: string;
    estimatedWeightGrams: number;
    calories_per_100g: number;
    protein_per_100g: number;
    carbs_per_100g: number;
    fat_per_100g: number;
  }
---------- END macros.ts ----------


---------- openRouterTypes.ts ----------
// src/utils/types.ts

// =====================================
// Consolidated OpenRouter Type Definitions
// =====================================

// --- Content Parts (for multi-modal input like images) ---
export type OpenRouterContentPart =
  | { type: "text"; text: string }
  | { type: "image_url"; image_url: { url: string; detail?: "low" | "high" | "auto" } };

// --- Message Structure ---
// Allows content to be a simple string OR an array of content parts for vision models
export interface OpenRouterMessage {
  role: "user" | "assistant" | "system";
  content: string | OpenRouterContentPart[]; // Consolidated definition
  name?: string; // Optional name field
}

// --- Choice Structure (within the response) ---
// This structure aligns with standard Chat Completion APIs (like OpenAI/OpenRouter)
export interface OpenRouterChatChoice {
  index: number;
  message: OpenRouterMessage; // Contains the actual message content and role
  logprobs?: any | null; // Optional log probabilities (use a specific type if known)
  finish_reason: string | null; // Can be null sometimes
  // text?: string; // Usually the content is inside message.content, keep optional if some models return it differently
}

// --- API Usage Information ---
export interface OpenRouterUsage {
  prompt_tokens: number;
  completion_tokens: number;
  total_tokens: number;
}

// --- Main Chat Completion Response Structure ---
// Consolidates the fields from both previous declarations
export interface OpenRouterChatCompletionResponse {
  id: string;
  object: string; // Typically "chat.completion"
  created: number; // Timestamp
  model: string; // Model used
  choices: OpenRouterChatChoice[]; // Array of choices using the defined structure
  usage?: OpenRouterUsage; // Usage information is often optional
  // Add any other relevant fields you might encounter from OpenRouter
  // system_fingerprint?: string; // Example optional field
}


// =====================================
// Removed Redundant/Conflicting Declarations:
// =====================================

/*
// REMOVED - Duplicate/Outdated OpenRouterMessage
export interface OpenRouterMessage {
  role: "user" | "assistant" | "system"; // Add system role
  content: string;
}

// REMOVED - Less standard choice structure (often message.content is used instead of top-level text)
export interface OpenRouterChoice {
  text: any; // 'any' is vague, content is usually in message
  message: OpenRouterMessage; // This duplicates content info if 'text' is also present
  finish_reason?: string;
  index?: number;
}

// REMOVED - Duplicate/Simpler OpenRouterChatCompletionResponse
export interface OpenRouterChatCompletionResponse {
  choices: OpenRouterChoice[]; // Used the less standard choice type
  id?: string;
  created?: number;
  model?: string;
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}
*/
---------- END openRouterTypes.ts ----------


---------- settings.ts ----------
// types/settings.ts (Modified)
export const macros = ["calories", "protein", "carbs", "fat"] as const;
export type MacroType = (typeof macros)[number];

export interface MacroData {
  x: number; // Timestamp
  y: number; // Macro value
}

export interface Statistics {
  calories: MacroData[][];
  protein: MacroData[][];
  carbs: MacroData[][];
  fat: MacroData[][];
}

export interface Settings {
  theme: "light" | "dark" | "system";
  dailyGoals: {
    [key in MacroType]: number;
  };
  settingsHistory?: { date: number; dailyGoals: { [key in MacroType]: number } }[]; // CHANGED: Store timestamp
}

export interface SettingsScreenProps {
  onThemeChange: (theme: "light" | "dark" | "system") => void;
}
---------- END settings.ts ----------


---------- dateUtils.ts ----------
// utils/dateUtils.ts (Corrected type for formatDateReadable)
import { format, parseISO, formatISO, isValid } from 'date-fns';

/**
 * Formats a Date object, timestamp (number), or ISO date string (YYYY-MM-DD)
 * into a standard YYYY-MM-DD string representation.
 * Returns an empty string if the input is invalid.
 * @param dateInput - The date to format (Date object, timestamp number, or 'YYYY-MM-DD' string).
 * @returns The formatted date string 'YYYY-MM-DD' or empty string on error.
 */
export const formatDateISO = (dateInput: number | string | Date): string => {
    try {
        let dateObj: Date;
        if (dateInput instanceof Date) {
            dateObj = dateInput;
        } else if (typeof dateInput === 'string') {
            // Assume 'YYYY-MM-DD' format if string
            dateObj = parseISO(dateInput);
        } else if (typeof dateInput === 'number') {
            // Assume timestamp if number
            dateObj = new Date(dateInput);
        } else {
            throw new Error("Invalid input type");
        }

        if (!isValid(dateObj)) {
             throw new Error("Invalid date value");
        }
        return formatISO(dateObj, { representation: 'date' });
    } catch (error) {
        console.error("Error in formatDateISO:", error, "Input:", dateInput);
        return ""; // Return empty string on error
    }
};


/**
 * Formats a Date object, timestamp (number), or ISO date string (YYYY-MM-DD)
 * into a human-readable format (e.g., "MMMM dd, yyyy").
 * Returns 'Invalid Date' if the input is invalid.
 * @param dateInput - The date to format (Date object, timestamp number, or 'YYYY-MM-DD' string).
 * @returns The formatted readable date string or 'Invalid Date' on error.
 */
export const formatDateReadable = (dateInput: number | string | Date): string => {
    try {
        let dateObj: Date;
        if (dateInput instanceof Date) {
            dateObj = dateInput;
        } else if (typeof dateInput === 'string') {
            // Assume 'YYYY-MM-DD' format if string
            dateObj = parseISO(dateInput);
        } else if (typeof dateInput === 'number') {
             // Assume timestamp if number
            dateObj = new Date(dateInput);
        } else {
             throw new Error("Invalid input type");
        }

        if (!isValid(dateObj)) {
            throw new Error("Invalid date value");
        }
        return format(dateObj, 'MMMM dd, yyyy'); // Example format
    } catch (error) {
         console.error("Error in formatDateReadable:", error, "Input:", dateInput);
         return 'Invalid Date'; // Return indicator string on error
    }
};

/**
 * Gets today's date as a standard YYYY-MM-DD string.
 * @returns Today's date in 'YYYY-MM-DD' format.
 */
export const getTodayDateString = (): string => {
  // formatISO handles Date object correctly
  return formatISO(new Date(), { representation: 'date' });
};
---------- END dateUtils.ts ----------


---------- iconUtils.ts ----------
// ---------- src/utils/iconUtils.ts ----------
// Import necessary modules
import AsyncStorage from '@react-native-async-storage/async-storage';
import { getFoodIcon } from '../services/backendService'; // Import backend service

// Cache Configuration
const ICON_CACHE_TTL_MS = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds

// Define the cache entry type including timestamp
type CacheEntry = {
  url: string | null;
  timestamp: number; // Unix timestamp (ms) when the entry was created/updated
};

// In-memory cache for fast access
const memoryCache = new Map<string, CacheEntry>();

// Prefix for AsyncStorage keys (versioned)
const STORAGE_KEY_PREFIX = 'foodIconCacheBE_v2_'; // Updated version for TTL change

// --- Main Exported Function ---

/**
 * Gets the icon URL for a food item.
 * Checks memory cache, then AsyncStorage (respecting TTL), then calls the backend service.
 * Caches the result (including null for failures/not found) with a timestamp.
 *
 * @param foodName The name of the food item.
 * @param locale The desired locale for the icon search (defaults to 'en').
 * @returns A Promise resolving to the icon URL (string) or null if not found or an error occurred.
 */
export const getFoodIconUrl = async (foodName: string, locale: string = 'en'): Promise<string | null> => {
  if (!foodName || foodName.trim() === '') {
      console.warn("getFoodIconUrl called with empty foodName.");
      return null;
  }

  const cacheKey = `${locale}_${foodName.toLowerCase().trim()}`;
  const now = Date.now();

  // 1. Check Memory Cache (and TTL)
  const memoryEntry = memoryCache.get(cacheKey);
  if (memoryEntry !== undefined) {
    if (now < memoryEntry.timestamp + ICON_CACHE_TTL_MS) {
        // console.log(`Icon Cache HIT (Memory, valid): ${cacheKey} -> ${memoryEntry.url}`);
        return memoryEntry.url;
    } else {
        // console.log(`Icon Cache STALE (Memory): ${cacheKey}`);
        memoryCache.delete(cacheKey); // Remove stale entry from memory
    }
  }

  // 2. Check AsyncStorage (and TTL)
  const storageKey = STORAGE_KEY_PREFIX + cacheKey;
  try {
    const storedValue = await AsyncStorage.getItem(storageKey);
    if (storedValue !== null) {
      const parsed: CacheEntry = JSON.parse(storedValue);
      if (parsed && typeof parsed.timestamp === 'number' && typeof parsed.url !== 'undefined') {
        if (now < parsed.timestamp + ICON_CACHE_TTL_MS) {
            // console.log(`Icon Cache HIT (Storage, valid): ${cacheKey} -> ${parsed.url}`);
            memoryCache.set(cacheKey, parsed); // Update memory cache
            return parsed.url;
        } else {
            // console.log(`Icon Cache STALE (Storage): ${cacheKey}`);
            // Don't need to remove from storage here, fetching new will overwrite
        }
      } else {
         console.warn(`Invalid cache entry format found in storage for ${storageKey}. Ignoring.`);
         // Optionally remove invalid entry: await AsyncStorage.removeItem(storageKey);
      }
    }
  } catch (error) {
    console.error(`Error reading icon cache from AsyncStorage for key ${storageKey}:`, error);
    // Continue to fetch if storage read fails
  }

  // 3. Fetch from Backend API
  // console.log(`Icon Cache MISS or STALE / Fetching Backend API: ${cacheKey}`);
  let iconUrl: string | null = null;
  try {
      // Call the backend service function - it handles its own errors and returns null on failure
      iconUrl = await getFoodIcon(foodName, locale);
      // console.log(`Backend returned icon URL for ${foodName}: ${iconUrl}`);

  } catch (error) {
      // This catch block might be redundant if getFoodIcon handles all errors,
      // but kept as a safeguard against unexpected issues in the service call itself.
      console.error(`Unexpected error calling getFoodIcon service for ${foodName}:`, error);
      iconUrl = null; // Ensure null is cached on unexpected error during service call
  }

  // 4. Cache the final result (even nulls) from backend with current timestamp
  const newCacheEntry: CacheEntry = { url: iconUrl, timestamp: now };
  memoryCache.set(cacheKey, newCacheEntry); // Cache in memory
  try {
    // Cache in AsyncStorage
    await AsyncStorage.setItem(storageKey, JSON.stringify(newCacheEntry));
  } catch (error) {
    console.error(`Error saving icon cache to AsyncStorage for key ${storageKey}:`, error);
  }

  return iconUrl;
};

// --- Cache Management (Unchanged - manual clear still useful) ---

export const clearIconCache = async () => {
    memoryCache.clear();
    try {
        const keys = await AsyncStorage.getAllKeys();
        const cacheKeys = keys.filter(key => key.startsWith(STORAGE_KEY_PREFIX));
        if (cacheKeys.length > 0) {
             await AsyncStorage.multiRemove(cacheKeys);
             console.log(`Cleared ${cacheKeys.length} items from AsyncStorage icon cache (Backend Version).`);
        }
    } catch (error) {
        console.error("Error clearing backend icon cache from AsyncStorage:", error);
    }
};

export const logMemoryCacheSize = () => {
    console.log(`In-memory icon cache size: ${memoryCache.size}`);
};
---------- END iconUtils.ts ----------


---------- imageUtils.ts ----------
import * as ImageManipulator from 'expo-image-manipulator';
import { ImagePickerAsset } from 'expo-image-picker';
import { Alert } from 'react-native';
import * as FileSystem from 'expo-file-system';

const MAX_IMAGE_DIMENSION = 1024; // Max width/height for compressed image
const IMAGE_COMPRESSION_QUALITY = 0.7; // Compression quality (0.0 - 1.0)

/**
 * Compresses an image asset if its dimensions exceed the maximum allowed.
 * @param asset The original ImagePickerAsset.
 * @returns A promise resolving to the compressed ImageManipulator.ImageResult or null if compression fails/is unnecessary.
 */
export const compressImageIfNeeded = async (
    asset: ImagePickerAsset
): Promise<ImageManipulator.ImageResult | null> => {
    console.log(`Compress Check: Original image dimensions: ${asset.width}x${asset.height}`);
    try {
        const actions: ImageManipulator.Action[] = [];
        let needsResize = false;

        // Determine target dimensions based on MAX_IMAGE_DIMENSION
        if (asset.width > MAX_IMAGE_DIMENSION || asset.height > MAX_IMAGE_DIMENSION) {
            needsResize = true;
            const resizeOptions: ImageManipulator.ActionResize['resize'] = { // Access nested type
                width: undefined,
                height: undefined,
            };
            if (asset.width > asset.height) {
                resizeOptions.width = MAX_IMAGE_DIMENSION;
            } else {
                resizeOptions.height = MAX_IMAGE_DIMENSION;
            }
            // Add the resize action object correctly structured
            actions.push({ resize: resizeOptions });
            console.log(`Compress Check: Resizing image to max dimension ${MAX_IMAGE_DIMENSION}`);
        } else {
            console.log(`Compress Check: Image dimensions within limits, no resize needed.`);
            // If no resize is needed, we might not need to manipulate at all,
            // unless we always want to ensure JPEG format and quality.
            // For simplicity now, return null if no resize is performed.
            // If always ensuring format/quality is desired, remove this return.
            return null; // Indicate no compression was performed
        }

        // Only proceed with manipulation if resize was necessary
        if (needsResize) {
            const saveOptions: ImageManipulator.SaveOptions = {
                compress: IMAGE_COMPRESSION_QUALITY,
                format: ImageManipulator.SaveFormat.JPEG, // Standardize format
                base64: false, // Base64 is handled separately
            };

            const result = await ImageManipulator.manipulateAsync(asset.uri, actions, saveOptions);
            console.log(`Compress Check: Compressed image dimensions: ${result.width}x${result.height}`);
            console.log(`Compress Check: Compressed image URI: ${result.uri}`);
            return result;
        } else {
            return null; // No manipulation was performed
        }

    } catch (error) {
        console.error("Compress Check: Failed to compress image:", error);
        Alert.alert("Compression Error", "Could not process the image for compression.");
        return null; // Return null if compression fails
    }
};


/**
 * Converts a file URI to a base64 string. Includes error handling.
 * @param uri The file URI to read.
 * @returns A promise resolving to the base64 encoded string.
 * @throws An error if reading the file fails.
 */
export async function getBase64FromUri(uri: string): Promise<string> {
    try {
        const base64 = await FileSystem.readAsStringAsync(uri, {
            encoding: FileSystem.EncodingType.Base64,
        });
        return base64;
    } catch (error: any) {
        console.error(`getBase64FromUri: Failed to read file as base64: ${uri}`, error);
        // Provide a more specific error message to the caller
        throw new Error(`Failed to read image file: ${error.message || 'Unknown error'}`);
    }
}
---------- END imageUtils.ts ----------


---------- macros.ts ----------
// src/utils/macros.ts
import * as FileSystem from 'expo-file-system';
import {
    getMacrosForRecipe,
    getMacrosForImageSingle,
    getMacrosForImageMultiple,
    BackendError // Re-export for components if needed
} from '../services/backendService';
import { Alert } from 'react-native';
import { Macros, MacrosWithFoodName, EstimatedFoodItem } from '../types/macros';
import { ImagePickerAsset } from 'expo-image-picker';
import { getBase64FromUri } from './imageUtils'; // Use shared utility

// --- Helper function to determine MIME type ---
export function determineMimeType(asset: {
    uri: string;
    mimeType?: string | null;
    fileName?: string | null;
}): string {
    // 1. Prioritize asset.mimeType
    if (asset.mimeType && asset.mimeType.includes('/')) {
        console.log(`MIME Type: Using provided type: ${asset.mimeType}`);
        return asset.mimeType;
    }

    // 2. Infer from URI extension (fallback)
    const uriParts = asset.uri.split('.');
    const extension = uriParts.pop()?.toLowerCase();
    console.log(`MIME Type: Inferring from extension: .${extension}`);
    switch (extension) {
        case 'jpg': case 'jpeg': return 'image/jpeg';
        case 'png': return 'image/png';
        case 'gif': return 'image/gif';
        case 'webp': return 'image/webp';
        case 'bmp': return 'image/bmp';
        default:
            console.warn(`MIME Type: Could not determine specific type for URI: ${asset.uri}. Defaulting to image/jpeg.`);
            return 'image/jpeg'; // Default
    }
}


// --- Service Interaction Functions (with improved error handling context) ---

// Get macros from recipe text
export async function getMacrosFromText(
    foodName: string,
    ingredients: string
): Promise<Macros> {
    try {
        console.log(`Util: Requesting macros for recipe: "${foodName}"`);
        const macros = await getMacrosForRecipe(foodName, ingredients);
        console.log(`Util: Received macros for recipe: "${foodName}"`);
        return macros;
    } catch (error) {
        console.error(`Util: Error getting macros for recipe "${foodName}":`, error);
        const message = error instanceof BackendError
            ? error.message
            : `Failed to get macros for recipe: ${error instanceof Error ? error.message : String(error)}`;
        // Display error, but let the caller handle further actions (like stopping loading states)
        Alert.alert("AI Error (Recipe)", message);
        throw error; // Re-throw to allow caller to handle
    }
}

// Get macros for a single food item from an image asset
export async function getMacrosForImageFile(asset: ImagePickerAsset): Promise<MacrosWithFoodName> {
    let base64File: string;
    try {
        // Use shared utility for base64 conversion
        base64File = await getBase64FromUri(asset.uri);
    } catch (err) {
        Alert.alert("Image Read Error", err instanceof Error ? err.message : "Failed to read image file.");
        throw err; // Re-throw error for caller to handle
    }

    const mimeType = determineMimeType(asset);
    console.log(`Util: Requesting single food analysis. MIME: ${mimeType}, Asset URI: ${asset.uri}`);

    try {
        const result = await getMacrosForImageSingle(base64File, mimeType);
        console.log(`Util: Received single food analysis: ${result.foodName}`);
        return result;
    } catch (error) {
        console.error(`Util: Error getting single food macros for image ${asset.uri}:`, error);
        const message = error instanceof BackendError
            ? error.message
            : `Image analysis failed: ${error instanceof Error ? error.message : String(error)}`;
        Alert.alert("Analysis Failed (Single Item)", message);
        throw error; // Re-throw error
    }
}

// Get multiple estimated food items from an image asset
export async function getMultipleFoodsFromImage(base64Image: string, mimeType: string): Promise<EstimatedFoodItem[]> {
    console.log(`Util: Requesting multi-food analysis. MIME: ${mimeType}`);

    try {
        const results = await getMacrosForImageMultiple(base64Image, mimeType);
        console.log(`Util: Received ${results.length} estimated items from backend.`);
        // Optional: Basic validation of results structure here if needed
        if (!Array.isArray(results)) {
            console.error("Util: Backend returned non-array for multiple food items:", results);
            throw new Error("Invalid response format from server for multiple items.");
        }
        return results;
    } catch (error) {
        console.error(`Util: Error getting multiple food macros from image:`, error);
         const message = error instanceof BackendError
            ? error.message
            : `Could not analyze image: ${error instanceof Error ? error.message : String(error)}`;
        Alert.alert("Quick Add Failed (Multi-Item)", message);
        throw error; // Re-throw error
    }
}

// Re-export types and potentially BackendError if components need it directly
export { BackendError, EstimatedFoodItem, Macros, MacrosWithFoodName };
---------- END macros.ts ----------


---------- units.ts ----------
// src/utils/units.ts
import { Alert } from 'react-native';
import { estimateGramsNaturalLanguage, BackendError } from '../services/backendService';

/**
 * Estimates the weight in grams based on a natural language description and food item, using the backend service.
 * @param foodName The name of the food item (e.g., "Apple").
 * @param quantityDescription The natural language description (e.g., "2 small", "1 cup chopped").
 * @returns A promise that resolves with the estimated weight in grams (number).
 */
export async function getGramsFromNaturalLanguage(
    foodName: string,
    quantityDescription: string
): Promise<number> {
    try {
        const grams = await estimateGramsNaturalLanguage(foodName, quantityDescription);
        return grams; // Backend service already rounds
    } catch (error) {
        console.error("Error getting grams estimation from backend:", error);
        const message = error instanceof BackendError
            ? error.message
            : `Could not estimate grams: ${error instanceof Error ? error.message : String(error)}`;
        Alert.alert("AI Estimation Failed", message);
        throw error; // Re-throw error
    }
}
---------- END units.ts ----------


---------- validationUtils.ts ----------
// utils/validationUtils.ts

export const isValidNumberInput = (value: string): boolean => {
    return /^[0-9]*(\.[0-9]*)?$/.test(value) && !isNaN(parseFloat(value));
  };
  
  export const isNotEmpty = (value: string): boolean => {
    return value.trim() !== '';
  };
---------- END validationUtils.ts ----------


---------- tsconfig.json ----------
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true

  }
}
---------- END tsconfig.json ----------

