.gitignore
app.json
App.tsx
assets/
  adaptive-icon.png
  favicon.png
  icon.png
  splash.png
eas.json
index.ts
package.json
projectToFile.js
src/
  assets/
    food_icons/
      iconDefinitions.ts
  components/
    AccountSettings.tsx
    AddEntryModal/
      AddEntryModal.tsx
      AmountInputSection.tsx
      FoodSelectionList.tsx
      ModalHeader.tsx
    AddFoodModal.tsx
    ConfirmationModal.tsx
    DailyEntryListItem.tsx
    DailyGoalsInput.tsx
    DailyProgress.tsx
    DataManagementButtons.tsx
    DateNavigator.tsx
    Entry/
      QuickAddItem.tsx
    FoodFormFields.tsx
    FoodItem.tsx
    QuickAddList.tsx
    StatisticsChart.tsx
    ThemeSwitch.tsx
  localization/
    i18n.ts
    languages/
      en.json
      he.json
      ru.json
  navigation/
    AppNavigator.tsx
  screens/
    DailyEntryScreen.tsx
    FoodListScreen.tsx
    QuestionnaireScreen.tsx
    SettingsScreen.tsx
  services/
    backendService.ts
    clientIDService.ts
    foodService.ts
    storageService.ts
  types/
    dailyEntry.ts
    food.ts
    macros.ts
    openRouterTypes.ts
    questionnaire.ts
    settings.ts
  utils/
    dateUtils.ts
    foodIconMatcher.ts
    gradingUtils.ts
    iconUtils.ts
    imageUtils.ts
    languageUtils.ts
    macros.ts
    units.ts
    validationUtils.ts
tsconfig.json

---------- .gitignore ----------
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

---------- END .gitignore ----------


---------- app.json ----------
{
  "expo": {
    "name": "MacrosVisionAI",
    "slug": "MacroTracker",
    "version": "2.0.2",
    "owner": "danprav",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "scheme": "macrosvisionai",
    "userInterfaceStyle": "automatic",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#000000"
    },
    "androidStatusBar": {
      "backgroundColor": "#000000",
      "translucent": false,
      "barStyle": "light-content"
    },
    "assetBundlePatterns": [
      "**/*"
    ],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.macrosvisionai.app",
      "infoPlist": {
        "UIStatusBarStyle": "UIStatusBarStyleAutomatic",
        "NSCameraUsageDescription": "Allow $(PRODUCT_NAME) to access your camera to take photos of food for macro analysis.",
        "NSPhotoLibraryUsageDescription": "Allow $(PRODUCT_NAME) to access your photos to select food images for macro analysis."
      }
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "package": "com.macrosvisionai.app",
      "userInterfaceStyle": "automatic",
      "permissions": [
        "android.permission.CAMERA",
        "android.permission.READ_EXTERNAL_STORAGE",
        "android.permission.WRITE_EXTERNAL_STORAGE"
      ],
      "intentFilters": [
        {
          "action": "VIEW",
          "autoVerify": true,
          "data": [
            {
              "scheme": "macrosvisionai",
              "host": "open-add-food-modal"
            }
          ],
          "category": [
            "BROWSABLE",
            "DEFAULT"
          ]
        }
      ]
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      [
        "expo-document-picker",
        {
          "appleTeamId": "YOUR_TEAM_ID"
        }
      ],
      [
        "expo-image-picker",
        {
          "photosPermission": "Allow $(PRODUCT_NAME) to access your photos to select food images for macro analysis.",
          "cameraPermission": "Allow $(PRODUCT_NAME) to access your camera to take photos of food for macro analysis."
        }
      ]
    ],
    "extra": {
      "eas": {
        "projectId": "25ac2bcf-78a3-4f2c-a635-4fcaae7b93f1"
      },
      "env": {
         "BACKEND_URL_PRODUCTION": "https://macros-vision-ai.xyz",
         "BACKEND_URL_DEVELOPMENT": "http://192.168.1.185:8000"
      }
    }
  }
}
---------- END app.json ----------


---------- App.tsx ----------
// App.tsx
// App.tsx
import "react-native-get-random-values"; // MUST BE FIRST
import Toast from "react-native-toast-message";
import React, { useState, useEffect } from "react";
import AppNavigator from "./src/navigation/AppNavigator";
import { SafeAreaProvider, SafeAreaView } from "react-native-safe-area-context";
import { ThemeProvider, createTheme } from "@rneui/themed";
import { loadSettings, saveSettings } from "./src/services/storageService";
import {
  useColorScheme,
  AppState,
  AppStateStatus,
  Platform,
  I18nManager, // Import I18nManager
  Alert, // For restart prompt
  DevSettings // For dev reload
} from "react-native";
import * as Localization from 'expo-localization';
import * as Linking from 'expo-linking'; // Import expo-linking
import {
  NavigationContainer,
  DefaultTheme,
  DarkTheme,
  LinkingOptions, // Import LinkingOptions
} from "@react-navigation/native";
import { Colors } from "@rneui/base";
import { Settings, LanguageCode } from "./src/types/settings";
import { LogBox, View, Text } from "react-native";
import { StatusBar } from "expo-status-bar";
import { getClientId } from "./src/services/clientIDService";
import i18n, { setLocale, t } from './src/localization/i18n'; // Import i18n setup
import { MainTabParamList } from "./src/navigation/AppNavigator"; // For linking config

LogBox.ignoreLogs(["Function components cannot be given refs"]);

declare module "@rneui/themed" {
  export interface Colors {
    text: string;
    card: string;
    successLight: string;
  }
}

interface MyTheme {
  mode: "light" | "dark";
  colors: Colors;
}

const lightTheme: MyTheme = {
  mode: "light",
  colors: {
    primary: "#2e86de",
    secondary: "#6c757d",
    background: "#f8f9fa",
    grey5: "#e9ecef",
    white: "#ffffff",
    grey4: "#ced4da",
    success: "#28a745",
    successLight: "#d4edda",
    black: "#000000",
    text: "#212529",
    card: "#ffffff",
    error: "#dc3545",
    warning: "#ffc107",
    disabled: "#6c757d",
    divider: "#ced4da",
    platform: { ios: {}, android: {}, web: {}, default: {} } as any,
    grey0: "#f8f9fa", grey1: "#e9ecef", grey2: "#dee2e6", grey3: "#ced4da",
    greyOutline: "#adb5bd", searchBg: "#ffffff",
  },
};

const darkTheme: MyTheme = {
  mode: "dark",
  colors: {
    primary: "#2e86de", secondary: "#adb5bd", background: "#121212",
    grey5: "#2c2c2c", white: "#ffffff", grey4: "#343a40",
    success: "#28a745", successLight: "#1f5139", black: "#000000",
    text: "#f8f9fa", card: "#1e1e1e", error: "#dc3545",
    warning: "#ffc107", disabled: "#6c757d", divider: "#343a40",
    platform: { ios: {}, android: {}, web: {}, default: {} } as any,
    grey0: "#212529", grey1: "#2c2c2c", grey2: "#343a40",
    grey3: "#495057", greyOutline: "#6c757d", searchBg: "#1e1e1e",
  },
};

// Linking configuration
const linking: LinkingOptions<MainTabParamList> = { // Explicitly type the linking object
  prefixes: [Linking.createURL('/')], // Handles macrosvisionai://
  config: {
    screens: {
      // Define how paths map to your MainTabParamList screens
      FoodListRoute: {
        path: 'open-add-food-modal', // e.g., macrosvisionai://open-add-food-modal?foodData=...
        // foodData query param will be passed to FoodListScreen route.params
      },
      // Add other deep linkable routes here if needed
      // Example:
      // DailyEntryRoute: 'daily/:date',
    } // REMOVED "satisfies MainTabParamList" from here
  },
};


const App = () => {
  const [themeMode, setThemeMode] = useState<"light" | "dark" | "system">(
    "system"
  );
  const [currentLanguage, setCurrentLanguage] = useState<LanguageCode>('system');
  const [loadedSettings, setLoadedSettings] = useState<Settings | null>(null);
  const colorScheme = useColorScheme();
  const [appState, setAppState] = useState(AppState.currentState);
  const [isClientIdReady, setIsClientIdReady] = useState(false);
  const [isInitialized, setIsInitialized] = useState(false); // New state for overall initialization

  // Initialize Client ID, Load initial settings, and set up i18n
  useEffect(() => {
    const initializeApp = async () => {
      try {
        await getClientId();
        setIsClientIdReady(true);
        console.log('Client ID is ready.');

        const settings = await loadSettings();
        setThemeMode(settings.theme);
        setCurrentLanguage(settings.language);

        if (settings.language === 'system') {
          const deviceLocale = Localization.getLocales()?.[0]?.languageTag || 'en-US';
          setLocale(deviceLocale);
        } else {
          setLocale(settings.language);
        }
        setLoadedSettings(settings);
        console.log('Settings loaded and locale set:', i18n.locale);
        setIsInitialized(true); // Mark initialization as complete
      } catch (error) {
        console.error("Initialization Error:", error);
        setIsInitialized(true); // Still mark as initialized to show app, even with error
      }
    };
    initializeApp();
  }, []);

  // AppState Listener
  useEffect(() => {
    const handleAppStateChange = (nextAppState: AppStateStatus) => {
      setAppState(nextAppState);
    };
    const subscription = AppState.addEventListener("change", handleAppStateChange);
    return () => {
      subscription.remove();
    };
  }, []);

  const updateTheme = (newThemeMode: "light" | "dark" | "system") => {
    const isDark =
      newThemeMode === "system"
        ? colorScheme === "dark"
        : newThemeMode === "dark";
    return isDark ? darkTheme : lightTheme;
  };

  const handleThemeChange = async (newTheme: "light" | "dark" | "system") => {
    setThemeMode(newTheme);
    if (loadedSettings) {
      const updatedSettings: Settings = {
        ...loadedSettings,
        theme: newTheme,
      };
      await saveSettings(updatedSettings);
      setLoadedSettings(updatedSettings);
    }
  };

  const handleLocaleChange = async (newLocale: LanguageCode) => {
    const oldLocale = currentLanguage === 'system'
        ? (Localization.getLocales()?.[0]?.languageTag || 'en-US').split('-')[0]
        : currentLanguage;
    
    setCurrentLanguage(newLocale);
    if (newLocale === 'system') {
        const deviceLocale = Localization.getLocales()?.[0]?.languageTag || 'en-US';
        setLocale(deviceLocale);
    } else {
        setLocale(newLocale);
    }

    if (loadedSettings) {
        const updatedSettings: Settings = { ...loadedSettings, language: newLocale };
        await saveSettings(updatedSettings);
        setLoadedSettings(updatedSettings);
    }

    const newEffectiveLocale = newLocale === 'system'
        ? (Localization.getLocales()?.[0]?.languageTag || 'en-US').split('-')[0]
        : newLocale;

    // Prompt for restart if RTL/LTR direction changes
    const oldIsRTL = oldLocale === 'he';
    const newIsRTL = newEffectiveLocale === 'he';

    if (oldIsRTL !== newIsRTL) {
        Alert.alert(
            t('confirmationModal.restartRequiredTitle'),
            t('settingsScreen.language.restartMessage'),
            [
                {
                    text: t('app.alertButtons.later'),
                    style: "cancel"
                },
                {
                    text: t('app.alertButtons.restartNow'),
                    onPress: () => {
                        // In a real build, you'd use Updates.reloadAsync()
                        // For development in Expo Go, this reloads the JS bundle
                        DevSettings.reload();
                    }
                }
            ]
        );
    }
  };


  const currentTheme = updateTheme(themeMode);

  const navigationTheme = {
    dark: {
      ...DarkTheme,
      colors: {
        ...DarkTheme.colors,
        primary: currentTheme.colors.primary, background: currentTheme.colors.background,
        card: currentTheme.colors.card, text: currentTheme.colors.text,
        border: currentTheme.colors.divider, notification: currentTheme.colors.successLight,
      },
    },
    light: {
      ...DefaultTheme,
      colors: {
        ...DefaultTheme.colors,
        primary: currentTheme.colors.primary, background: currentTheme.colors.background,
        card: currentTheme.colors.card, text: currentTheme.colors.text,
        border: currentTheme.colors.divider, notification: currentTheme.colors.success,
      },
    },
  };

  const statusBarTheme = themeMode === "system" ? colorScheme : themeMode;
  const backgroundColor = currentTheme.colors.background;

  if (!isInitialized) { // Check overall initialization
    return (
      <SafeAreaView style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: backgroundColor }}>
        <Text style={{ color: currentTheme.colors.text }}>{t('app.initializing')}</Text>
      </SafeAreaView>
    );
  }

  return (
    <ThemeProvider theme={createTheme(currentTheme)}>
      <SafeAreaView style={{ flex: 1, backgroundColor: backgroundColor }}>
        <StatusBar
          style={statusBarTheme === "dark" ? "light" : "dark"}
          backgroundColor={backgroundColor}
          translucent={false}
        />
        <NavigationContainer
          theme={
            currentTheme.mode === "dark"
              ? navigationTheme.dark
              : navigationTheme.light
          }
          linking={linking}
          fallback={<Text style={{color: currentTheme.colors.text, textAlign: 'center', marginTop: 50}}>{t('app.initializing')}</Text>} // Fallback for deep linking
        >
          <AppNavigator onThemeChange={handleThemeChange} onLocaleChange={handleLocaleChange} />
        </NavigationContainer>
        <Toast />
      </SafeAreaView>
    </ThemeProvider>
  );
};

export default App;
---------- END App.tsx ----------


---------- adaptive-icon.png ----------
(Image file - content not included)
---------- END adaptive-icon.png ----------


---------- favicon.png ----------
(Image file - content not included)
---------- END favicon.png ----------


---------- icon.png ----------
(Image file - content not included)
---------- END icon.png ----------


---------- splash.png ----------
(Image file - content not included)
---------- END splash.png ----------


---------- eas.json ----------
{
  "cli": {
    "version": ">= 13.4.1",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal"
    },
    "preview": {
      "android": {
        "buildType": "apk"
      },
      "env": {
         "BACKEND_URL_PRODUCTION": "https://macros-vision-ai.xyz",
         "BACKEND_URL_DEVELOPMENT": "http://192.168.1.185:8000"
      }
    },
    "production": {
      "autoIncrement": true
    }
  },
  "submit": {
    "production": {}
  }
}
---------- END eas.json ----------


---------- index.ts ----------
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);

---------- END index.ts ----------


---------- package.json ----------
{
  "name": "macrosvisionai",
  "license": "0BSD",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@react-native-async-storage/async-storage": "^2.1.2",
    "@react-native-community/datetimepicker": "8.2.0",
    "@react-native-picker/picker": "^2.11.0",
    "@react-navigation/bottom-tabs": "^7.3.1",
    "@react-navigation/native": "^7.0.17",
    "@react-navigation/native-stack": "^7.3.12",
    "@rneui/base": "^4.0.0-rc.7",
    "@rneui/themed": "^4.0.0-rc.8",
    "@types/d3-scale": "^4.0.9",
    "d3-scale": "^4.0.2",
    "date-fns": "^4.1.0",
    "expo": "~52.0.40",
    "expo-constants": "~16.0.2",
    "expo-document-picker": "^13.0.3",
    "expo-file-system": "^18.0.12",
    "expo-image-manipulator": "~13.0.5",
    "expo-image-picker": "^16.0.6",
    "expo-localization": "~15.0.3",
    "expo-sharing": "~13.0.1",
    "expo-status-bar": "~2.0.1",
    "i18n-js": "^4.5.1",
    "react": "18.3.1",
    "react-native": "0.76.7",
    "react-native-config": "^1.5.5",
    "react-native-get-random-values": "^1.11.0",
    "react-native-mime-types": "^2.5.0",
    "react-native-reanimated": "~3.16.1",
    "react-native-safe-area-context": "^4.14.1",
    "react-native-screens": "^4.9.2",
    "react-native-svg": "^15.11.2",
    "react-native-toast-message": "^2.2.1",
    "react-native-uuid": "^2.0.3",
    "react-native-webview": "^13.13.4",
    "uuid": "^11.1.0",
    "expo-linking": "~7.0.5"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/i18n-js": "^4.0.1",
    "@types/react": "~18.3.12",
    "@types/react-native": "^0.73.0",
    "@types/react-native-svg-charts": "^5.0.16",
    "@types/uuid": "^10.0.0",
    "typescript": "^5.3.3",
    "victory": "^37.3.6"
  },
  "private": true
}

---------- END package.json ----------


---------- projectToFile.js ----------
const fs = require('fs');
const path = require('path');

async function generateProjectStructureAndContent(projectRoot, outputFile) {
    const excludedDirs = ['node_modules', '.git', '.expo', 'android', 'ios', '__tests__', 'dist', 'build', '.vscode'];
    const excludedFiles = ['.DS_Store', 'package-lock.json', 'yarn.lock', 'bun.lockb', 'metro.config.js', 'babel.config.js'];
    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.webp', '.ico']; // Add more if needed

    let fileStructureTree = '';  // For the initial tree structure
    let fileContents = '';      // For the file contents

    async function traverseDirectory(dir, indent = '') {
        const entries = await fs.promises.readdir(dir, { withFileTypes: true });

        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);

            if (excludedDirs.includes(entry.name)) {
                continue;
            }

            if (entry.isDirectory()) {
                fileStructureTree += `${indent}${entry.name}/\n`;
                await traverseDirectory(fullPath, indent + '  ');
            } else if (entry.isFile()) {
                if (excludedFiles.includes(entry.name)) {
                    continue;
                }
                fileStructureTree += `${indent}${entry.name}\n`;
                const fileExtension = path.extname(entry.name).toLowerCase();

                if (!imageExtensions.includes(fileExtension)) {
                    fileContents += `\n---------- ${entry.name} ----------\n`;
                    try {
                        const fileContent = await fs.promises.readFile(fullPath, 'utf-8');
                        fileContents += `${fileContent}\n`;
                    } catch (readError) {
                        fileContents += `ERROR READING FILE: ${readError.message}\n`;
                    }
                    fileContents += `---------- END ${entry.name} ----------\n\n`;
                } else {
                     fileContents += `\n---------- ${entry.name} ----------\n`;
                     fileContents += `(Image file - content not included)\n`;
                     fileContents += `---------- END ${entry.name} ----------\n\n`;
                }
            }
        }
    }

    try {
        await traverseDirectory(projectRoot);
        const fullOutput = fileStructureTree + fileContents;

        await fs.promises.writeFile(outputFile, fullOutput);
        console.log(`Project structure and content written to ${outputFile}`);

    } catch (error) {
        console.error('An error occurred:', error);
        process.exit(1);
    }
}

// --- Main execution ---

const projectRoot = process.cwd(); // Use the current working directory
const outputFile = 'project_structure.txt';

// Check if the projectRoot exists.
fs.stat(projectRoot, (err, stats) => {
    if (err) {
        console.error(`Error: Project root directory "${projectRoot}" not found or not accessible.`);
        process.exit(1);
    }

    if (!stats.isDirectory()) {
        console.error(`Error: "${projectRoot}" is not a directory.`);
        process.exit(1);
    }

    generateProjectStructureAndContent(projectRoot, outputFile);
});
---------- END projectToFile.js ----------


---------- iconDefinitions.ts ----------
// src/assets/food_icons/iconDefinitions.ts

// The `icon` property should be an emoji string.
// The `tagKey` property refers to a key within the "foodIconTags" section of your language JSON files.
// For example, a `tagKey` of "apple" will look for `t('foodIconTags.apple')` which should return an array of tags.
export interface FoodIconDefinition {
  icon: string; // Emoji character
  tagKey: string; // Base key for tags, e.g., "apple", "banana". Full key will be "foodIconTags.apple"
  priority?: number; // Optional: Higher number means higher priority if multiple tags match
}

export const foodIconDefinitions: FoodIconDefinition[] = [
  // Fruits
  { icon: 'ðŸŽ', tagKey: 'apple', priority: 10 },
  { icon: 'ðŸŒ', tagKey: 'banana', priority: 10 },
  { icon: 'ðŸ‡', tagKey: 'grapes', priority: 10 },
  { icon: 'ðŸ“', tagKey: 'strawberry', priority: 10 },
  { icon: 'ðŸ«', tagKey: 'blueberry', priority: 10 },
  { icon: 'ðŸŠ', tagKey: 'orange', priority: 10 },
  { icon: 'ðŸ‹', tagKey: 'lemonLime', priority: 10 },
  { icon: 'ðŸ‰', tagKey: 'watermelon', priority: 10 },
  { icon: 'ðŸ', tagKey: 'pineapple', priority: 10 },
  { icon: 'ðŸ¥­', tagKey: 'mango', priority: 10 },
  { icon: 'ðŸ¥', tagKey: 'kiwi', priority: 10 },
  { icon: 'ðŸ‘', tagKey: 'peachNectarine', priority: 10 },
  { icon: 'ðŸ’', tagKey: 'cherry', priority: 10 },
  { icon: 'ðŸ', tagKey: 'pear', priority: 10 },
  { icon: 'ðŸ¥‘', tagKey: 'avocado', priority: 10 },
  { icon: 'ðŸ¥¥', tagKey: 'coconut', priority: 10 },
  { icon: 'ðŸ…', tagKey: 'tomato', priority: 9 }, // Often culinary vegetable

  // Vegetables
  { icon: 'ðŸ¥•', tagKey: 'carrot', priority: 10 },
  { icon: 'ðŸ¥¦', tagKey: 'broccoli', priority: 10 },
  { icon: 'ðŸ¥¬', tagKey: 'leafyGreen', priority: 10 },
  { icon: 'ðŸ¥’', tagKey: 'cucumber', priority: 10 },
  { icon: 'ðŸŒ¶ï¸', tagKey: 'pepperGeneral', priority: 10 }, // General pepper
  { icon: 'ðŸ«‘', tagKey: 'bellPepper', priority: 11 },   // More specific bell pepper (can cover green, yellow, orange)
  { icon: 'ðŸŒ½', tagKey: 'corn', priority: 10 },
  { icon: 'ðŸ¥”', tagKey: 'potato', priority: 10 },
  { icon: 'ðŸ§…', tagKey: 'onion', priority: 10 },
  { icon: 'ðŸ§„', tagKey: 'garlic', priority: 10 },
  { icon: 'ðŸ†', tagKey: 'eggplant', priority: 10 },
  { icon: 'ðŸ„', tagKey: 'mushroom', priority: 10 },

  // Meats & Poultry
  { icon: 'ðŸ—', tagKey: 'poultry', priority: 10 },
  { icon: 'ðŸ¥©', tagKey: 'redMeat', priority: 10 },
  { icon: 'ðŸ¥“', tagKey: 'bacon', priority: 10 },
  { icon: 'ðŸ–', tagKey: 'processedMeat', priority: 9 },

  // Seafood
  { icon: 'ðŸŸ', tagKey: 'fish', priority: 10 },
  { icon: 'ðŸ¦', tagKey: 'shrimpPrawn', priority: 10 },
  { icon: 'ðŸ¦ž', tagKey: 'lobster', priority: 10 },
  { icon: 'ðŸ¦€', tagKey: 'crab', priority: 10 },
  { icon: 'ðŸ£', tagKey: 'sushi', priority: 10 },

  // Dairy & Eggs
  { icon: 'ðŸ¥š', tagKey: 'egg', priority: 10 },
  { icon: 'ðŸ¥›', tagKey: 'milk', priority: 10 },
  { icon: 'ðŸ§€', tagKey: 'cheese', priority: 10 },
  { icon: 'ðŸ§ˆ', tagKey: 'butter', priority: 10 },
  { icon: 'ðŸ¦', tagKey: 'iceCream', priority: 8 },
  { icon: 'ðŸ§', tagKey: 'yogurt', priority: 10 }, // Changed from ðŸ§ to a more generic yogurt emoji, or keep ðŸ§ for frozen

  // Grains, Bread, Pasta, Cereal
  { icon: 'ðŸž', tagKey: 'bread', priority: 10 },
  { icon: 'ðŸš', tagKey: 'rice', priority: 10 },
  { icon: 'ðŸ', tagKey: 'pasta', priority: 10 },
  { icon: 'ðŸ¥£', tagKey: 'cerealOats', priority: 10 },
  { icon: 'ðŸŒ¾', tagKey: 'otherGrains', priority: 10 }, // Quinoa, couscous etc.
  { icon: 'ðŸ«“', tagKey: 'flatbread', priority: 10 },

  // Legumes
  { icon: 'ðŸ«˜', tagKey: 'beansLegumes', priority: 10 },
  { icon: 'ðŸ¥œ', tagKey: 'peanut', priority: 9 },

  // Nuts & Seeds
  { icon: 'ðŸŒ°', tagKey: 'nuts', priority: 10 },
  { icon: 'ðŸŒ»', tagKey: 'seeds', priority: 10 }, // Using sunflower as general seed representation

  // Sweets & Snacks
  { icon: 'ðŸ©', tagKey: 'donut', priority: 7 },
  { icon: 'ðŸª', tagKey: 'cookie', priority: 7 },
  { icon: 'ðŸ«', tagKey: 'chocolate', priority: 7 },
  { icon: 'ðŸ°', tagKey: 'cake', priority: 7 },
  { icon: 'ðŸ¬', tagKey: 'candy', priority: 6 },
  { icon: 'ðŸ¿', tagKey: 'popcorn', priority: 8 },
  { icon: 'ðŸ¥¨', tagKey: 'pretzel', priority: 8 },
  { icon: 'ðŸŸ', tagKey: 'friesChips', priority: 7 },

  // Drinks
  { icon: 'â˜•', tagKey: 'coffee', priority: 9 },
  { icon: 'ðŸµ', tagKey: 'tea', priority: 9 },
  { icon: 'ðŸ¥¤', tagKey: 'softDrinkJuice', priority: 8 },
  { icon: 'ðŸ’§', tagKey: 'water', priority: 10 },
  { icon: 'ðŸ·', tagKey: 'wine', priority: 7 },
  { icon: 'ðŸº', tagKey: 'beer', priority: 7 },
  { icon: 'ðŸ¸', tagKey: 'cocktail', priority: 7 },

  // Prepared Meals / Dishes
  { icon: 'ðŸ•', tagKey: 'pizza', priority: 8 },
  { icon: 'ðŸ”', tagKey: 'burger', priority: 8 },
  { icon: 'ðŸŒ®', tagKey: 'tacoBurrito', priority: 8 },
  { icon: 'ðŸ¥ª', tagKey: 'sandwich', priority: 9 },
  { icon: 'ðŸ²', tagKey: 'soupStew', priority: 9 },
  { icon: 'ðŸ¥—', tagKey: 'salad', priority: 10 },
  { icon: 'ðŸœ', tagKey: 'noodleDish', priority: 9 },


  // Generic fallbacks - these should have broad tags in the language files
  { icon: 'ðŸ“', tagKey: 'genericFruit', priority: 2 },
  { icon: 'ðŸ¥¬', tagKey: 'genericVegetable', priority: 2 },
  { icon: 'ðŸ½ï¸', tagKey: 'genericMeal', priority: 1 },
  { icon: 'â“', tagKey: 'unknownFood', priority: 0 }, // Lowest priority
];
---------- END iconDefinitions.ts ----------


---------- AccountSettings.tsx ----------
// src/components/AccountSettings.tsx
import React from 'react';
import { View, ActivityIndicator } from 'react-native';
import { Text, makeStyles, Button, Icon, ListItem, useTheme } from '@rneui/themed';
import { t } from '../localization/i18n';

interface AccountSettingsProps {
    userCoins: number | null;
    isLoadingCoins: boolean;
    isAddingCoins: boolean;
    onAddTestCoins: () => void;
}

const AccountSettings: React.FC<AccountSettingsProps> = ({
    userCoins,
    isLoadingCoins,
    isAddingCoins,
    onAddTestCoins,
}) => {
    const { theme } = useTheme();
    const styles = useStyles();

    return (
        <View>
            <ListItem bottomDivider containerStyle={styles.listItem}>
                <Icon name="database" type="material-community" color={theme.colors.warning} />
                <ListItem.Content>
                    <ListItem.Title style={styles.listItemTitle}>{t('accountSettings.coinBalance')}</ListItem.Title>
                </ListItem.Content>
                {isLoadingCoins ? (
                    <ActivityIndicator size="small" color={theme.colors.primary} />
                ) : (
                    <Text style={styles.coinValue}>{userCoins !== null ? userCoins : t('accountSettings.notApplicable')}</Text>
                )}
            </ListItem>

            {/* REMOVE OR PROTECT THIS BUTTON IN PRODUCTION */}
            <Button
                title={t('accountSettings.addTestCoins')}
                onPress={onAddTestCoins}
                buttonStyle={[styles.button, { backgroundColor: theme.colors.success, marginTop: 10 }]}
                icon={<Icon name="plus-circle-outline" type="material-community" color="white" size={20} style={{ marginRight: 8 }} />}
                loading={isAddingCoins}
                disabled={isAddingCoins || isLoadingCoins}
            />
            <Text style={styles.testButtonWarning}>
                {t('accountSettings.testButtonWarning')}
            </Text>
        </View>
    );
};

const useStyles = makeStyles((theme) => ({
    listItem: {
        backgroundColor: theme.colors.background,
        paddingVertical: 15,
    },
    listItemTitle: {
        color: theme.colors.text,
        fontWeight: '500',
        textAlign: 'left',
    },
    coinValue: {
        color: theme.colors.primary,
        fontWeight: 'bold',
        fontSize: 16,
    },
    button: {
        marginBottom: 10,
        borderRadius: 8,
    },
    testButtonWarning: {
        fontSize: 12,
        color: theme.colors.grey3,
        fontStyle: 'italic',
        textAlign: 'center',
        marginTop: 0,
        marginBottom: 15,
        marginHorizontal: 10,
    },
}));

export default AccountSettings;
---------- END AccountSettings.tsx ----------


---------- AddEntryModal.tsx ----------
// src/components/AddEntryModal/AddEntryModal.tsx
import React, {
  useEffect,
  useState,
  useMemo,
  useCallback,
  // useRef, // No longer needed here if list scrolling isn't an issue
} from "react";
import {
  View,
  KeyboardAvoidingView,
  Platform,
  Dimensions,
  StyleSheet,
  Alert,
  Keyboard,
} from "react-native";
import {
  Overlay,
  makeStyles,
  useTheme,
} from "@rneui/themed";
import { Food } from "../../types/food";
import { isValidNumberInput } from "../../utils/validationUtils";
import {
  loadRecentFoods,
  saveRecentFoods,
  loadLastUsedPortions,
  saveLastUsedPortions,
  LastUsedPortions,
} from "../../services/storageService";
import { getFoodIconUrl } from "../../utils/iconUtils"; // Correct
import { getGramsFromNaturalLanguage } from "../../utils/units";
import Toast from "react-native-toast-message";
import * as ImagePicker from "expo-image-picker";
import {
  EstimatedFoodItem,
  getMultipleFoodsFromImage,
  BackendError,
  determineMimeType,
} from "../../utils/macros";
import { compressImageIfNeeded, getBase64FromUri } from "../../utils/imageUtils";
import { v4 as uuidv4 } from "uuid";
import QuickAddList from "../QuickAddList";
import { t } from '../../localization/i18n'; // No i18n instance needed directly for locale here
import { calculateDailyEntryGrade, FoodGradeResult } from "../../utils/gradingUtils";
import { Settings } from '../../types/settings';

import ModalHeader from './ModalHeader';
import FoodSelectionList from './FoodSelectionList';
import AmountInputSection from './AmountInputSection';

interface AddEntryModalProps {
  isVisible: boolean;
  toggleOverlay: () => void;
  handleAddEntry: (food: Food, grams: number) => void;
  handleAddMultipleEntries: (entries: { food: Food; grams: number }[]) => void;
  foods: Food[];
  isEditMode: boolean;
  initialGrams?: string;
  initialSelectedFoodForEdit?: Food | null;
  onAddNewFoodRequest: () => void;
  onCommitFoodToLibrary: (foodData: Omit<Food, 'id'> | Food, isUpdate: boolean) => Promise<Food | null>;
  dailyGoals: Settings['dailyGoals'];
}

const KEYBOARD_VERTICAL_OFFSET = Platform.OS === "ios" ? 80 : 0;
const MAX_RECENT_FOODS = 5;

type UnitMode = "grams" | "auto";
type ModalMode = "normal" | "quickAddSelect";

const AddEntryModal: React.FC<AddEntryModalProps> = ({
  isVisible,
  toggleOverlay,
  handleAddEntry: parentHandleAddEntry,
  handleAddMultipleEntries: parentHandleAddMultipleEntries,
  foods,
  isEditMode,
  initialGrams,
  initialSelectedFoodForEdit,
  onAddNewFoodRequest,
  onCommitFoodToLibrary,
  dailyGoals,
}) => {
  const { theme } = useTheme();
  const styles = useStyles();

  const [internalSelectedFood, setInternalSelectedFood] = useState<Food | null>(null);
  const [internalGrams, setInternalGrams] = useState("");
  const [internalSearch, setInternalSearch] = useState("");

  const [recentFoods, setRecentFoods] = useState<Food[]>([]);
  const [foodIcons, setFoodIcons] = useState<{
    [foodName: string]: string | null;
  }>({});

  const [unitMode, setUnitMode] = useState<UnitMode>("grams");
  const [autoInput, setAutoInput] = useState("");
  const [isAiLoading, setIsAiLoading] = useState(false);

  const [modalMode, setModalMode] = useState<ModalMode>("normal");
  const [quickAddLoading, setQuickAddLoading] = useState(false);
  const [quickAddItems, setQuickAddItems] = useState<EstimatedFoodItem[]>([]);
  const [selectedQuickAddIndices, setSelectedQuickAddIndices] = useState<
    Set<number>
  >(new Set());
  const [editingQuickAddItemIndex, setEditingQuickAddItemIndex] = useState<
    number | null
  >(null);
  const [editedFoodName, setEditedFoodName] = useState<string>("");
  const [editedGrams, setEditedGrams] = useState<string>("");

  const [lastUsedPortions, setLastUsedPortions] = useState<LastUsedPortions>({});
  const [selectedMultipleFoods, setSelectedMultipleFoods] = useState<Map<string, { food: Food; grams: number }>>(new Map());

  const isActionDisabled = isAiLoading || quickAddLoading;

  const resolveAndSetIcon = useCallback((foodName: string) => {
    if (!foodName || foodIcons[foodName] !== undefined) return;
    const icon = getFoodIconUrl(foodName); // No locale needed
    setFoodIcons(prevIcons => ({ ...prevIcons, [foodName]: icon }));
  }, [foodIcons]); // Removed i18n.locale

  const foodGradeResult = useMemo((): FoodGradeResult | null => {
    const numericGramsValue = parseFloat(internalGrams);
    if (internalSelectedFood && isValidNumberInput(internalGrams) && numericGramsValue > 0 && dailyGoals) {
        return calculateDailyEntryGrade(internalSelectedFood, numericGramsValue, dailyGoals);
    }
    return null;
  }, [internalSelectedFood, internalGrams, dailyGoals]);

  useEffect(() => {
    if (isVisible) {
        loadLastUsedPortions().then(setLastUsedPortions).catch(err => {
            // console.warn("Failed to load last used portions:", err)
        });
    }
  }, [isVisible]);

  useEffect(() => {
    if (isVisible) {
      const actuallyEditingDailyItem = isEditMode && initialSelectedFoodForEdit && initialGrams !== undefined;

      if (actuallyEditingDailyItem) {
        setInternalSelectedFood(initialSelectedFoodForEdit);
        setInternalGrams(initialGrams);
        setUnitMode("grams"); setAutoInput(""); setInternalSearch("");
        setSelectedMultipleFoods(new Map()); setModalMode("normal");
        if (initialSelectedFoodForEdit?.name) resolveAndSetIcon(initialSelectedFoodForEdit.name);
      } else if (initialSelectedFoodForEdit) {
        setInternalSelectedFood(initialSelectedFoodForEdit);
        setInternalGrams(initialGrams || "");
        setUnitMode("grams"); setAutoInput(""); setInternalSearch("");
        setSelectedMultipleFoods(new Map()); setModalMode("normal");
        if (initialSelectedFoodForEdit?.name) resolveAndSetIcon(initialSelectedFoodForEdit.name);
      } else {
        if (modalMode !== "quickAddSelect") {
          setInternalSelectedFood(null); setInternalGrams(""); setInternalSearch("");
          setUnitMode("grams"); setAutoInput(""); setSelectedMultipleFoods(new Map());
          setModalMode("normal");
        }
      }
    } else {
      const timer = setTimeout(() => {
        setInternalSelectedFood(null); setInternalSearch(""); setInternalGrams("");
        setUnitMode("grams"); setAutoInput(""); setSelectedMultipleFoods(new Map());
        setModalMode("normal"); setQuickAddItems([]); setSelectedQuickAddIndices(new Set());
        setEditingQuickAddItemIndex(null); setEditedFoodName(""); setEditedGrams("");
        setIsAiLoading(false); setQuickAddLoading(false);
      }, 300);
      return () => clearTimeout(timer);
    }
  }, [isVisible, isEditMode, initialSelectedFoodForEdit, initialGrams, resolveAndSetIcon]);

  useEffect(() => {
    if (isVisible && modalMode === "normal") {
       loadRecentFoods().then(loadedRecent => {
           setRecentFoods(loadedRecent);
           loadedRecent.forEach(food => resolveAndSetIcon(food.name));
       }).catch(err => {
            // console.warn("Failed to load recent foods:", err);
       });
    }
  }, [isVisible, modalMode, resolveAndSetIcon]);

  useEffect(() => {
    if (!isVisible) return;

    let itemsToCheckNames: string[] = [];
    if (modalMode === "normal") {
        const currentDisplayItems: Food[] = [];
        if (!internalSearch) {
            currentDisplayItems.push(...recentFoods);
            const recentIds = new Set(recentFoods.map(f => f.id));
            currentDisplayItems.push(...foods.filter(f => !recentIds.has(f.id)).slice(0,10));
        } else {
            currentDisplayItems.push(...foods.filter(f => f.name.toLowerCase().includes(internalSearch.toLowerCase())).slice(0,10));
        }
        itemsToCheckNames = currentDisplayItems.map(item => item.name).filter(Boolean);
    } else if (modalMode === "quickAddSelect" && quickAddItems.length > 0) {
        itemsToCheckNames = quickAddItems.map(item => item.foodName).filter(Boolean);
    }

    if (itemsToCheckNames.length > 0) {
        itemsToCheckNames.forEach(name => resolveAndSetIcon(name));
    }
  }, [isVisible, modalMode, internalSearch, recentFoods, foods, quickAddItems, resolveAndSetIcon]);


  const addToRecentFoods = useCallback(async (food: Food) => {
    if (!food || !food.id) return;
    setRecentFoods((prevRecent) => {
      if (prevRecent.length > 0 && prevRecent[0].id === food.id) return prevRecent;
      const updated = prevRecent.filter((rf) => rf.id !== food.id);
      updated.unshift(food);
      const trimmed = updated.slice(0, MAX_RECENT_FOODS);
      saveRecentFoods(trimmed).catch(() => {});
      return trimmed;
    });
  }, []);

  const servingSizeSuggestions = useMemo(() => {
    if (!internalSelectedFood || !internalSelectedFood.id) return [];
    const suggestions = [];
    const lastUsed = lastUsedPortions[internalSelectedFood.id];

    if (lastUsed) {
      suggestions.push({ label: t('addEntryModal.lastUsedServing', {grams: lastUsed}), value: String(lastUsed) });
    }
    const defaultSuggestions = [
        { label: "50g", value: "50" }, { label: "100g", value: "100" },
        { label: "150g", value: "150" }, { label: "200g", value: "200" }
    ];
    defaultSuggestions.forEach(sugg => {
        if (!lastUsed || String(lastUsed) !== sugg.value) {
            suggestions.push(sugg);
        }
    });
    return suggestions;
    // Removed i18n.locale from dependency array as t() will use current global locale
  }, [internalSelectedFood, lastUsedPortions, t]);


  const handleEstimateGrams = useCallback(async () => {
    Keyboard.dismiss();
    if (!internalSelectedFood || !autoInput.trim()) {
      Alert.alert(t('addEntryModal.alertInputMissing'), t('addEntryModal.alertInputMissingMessage')); return;
    }
    if (isAiLoading) return; setIsAiLoading(true);
    try {
      const estimatedGrams = await getGramsFromNaturalLanguage(internalSelectedFood.name, autoInput);
      const roundedGrams = String(Math.round(estimatedGrams)); setInternalGrams(roundedGrams);
      setUnitMode("grams"); setAutoInput("");
      Toast.show({ type: "success", text1: t('addEntryModal.alertGramsEstimated'), text2: t('addEntryModal.alertGramsEstimatedMessage', {grams: roundedGrams, foodName: internalSelectedFood.name}), position: "bottom", });
    } catch (error: any) { /* Error already handled by getGramsFromNaturalLanguage with an Alert */ }
    finally { setIsAiLoading(false); }
  }, [internalSelectedFood, autoInput, isAiLoading, t]);

  const handleAddOrUpdateSingleEntry = useCallback(async () => {
    Keyboard.dismiss();
    if (!internalSelectedFood || !internalSelectedFood.id) {
        Alert.alert(t('addEntryModal.alertFoodNotSelected'), t('addEntryModal.alertFoodNotSelectedMessage'));
        return;
    }
    const numericGramsValue = parseFloat(internalGrams);
    if (!isValidNumberInput(internalGrams) || numericGramsValue <= 0) {
        Alert.alert(t('addEntryModal.alertInvalidAmount'), t('addEntryModal.alertInvalidAmountMessage'));
        return;
    }
    if (isActionDisabled) return;

    parentHandleAddEntry(internalSelectedFood, numericGramsValue);

    if (!isEditMode) {
        addToRecentFoods(internalSelectedFood);
        const updatedPortions = { ...lastUsedPortions, [internalSelectedFood.id]: numericGramsValue };
        setLastUsedPortions(updatedPortions);
        saveLastUsedPortions(updatedPortions).catch(() => {});
    } else if (isEditMode && internalSelectedFood.id) {
        const updatedPortions = { ...lastUsedPortions, [internalSelectedFood.id]: numericGramsValue };
        setLastUsedPortions(updatedPortions);
        saveLastUsedPortions(updatedPortions).catch(() => {});
    }
  }, [ internalSelectedFood, internalGrams, isActionDisabled, isEditMode, parentHandleAddEntry, addToRecentFoods, lastUsedPortions, t ]);

  const handleToggleMultipleFoodSelection = useCallback((food: Food, displayGrams: number) => {
    if (isEditMode || internalSelectedFood) return;
    setSelectedMultipleFoods(prev => {
        const newSelection = new Map(prev);
        if (newSelection.has(food.id)) {
            newSelection.delete(food.id);
        } else {
            newSelection.set(food.id, { food, grams: displayGrams });
        }
        return newSelection;
    });
  }, [isEditMode, internalSelectedFood]);

  const handleConfirmAddMultipleSelected = useCallback(async () => {
    if (isEditMode || internalSelectedFood || selectedMultipleFoods.size === 0 || isActionDisabled) return;
    Keyboard.dismiss();
    const entriesToAdd: { food: Food; grams: number }[] = Array.from(selectedMultipleFoods.values());
    if (entriesToAdd.length === 0) return;

    parentHandleAddMultipleEntries(entriesToAdd);

    const newPortionsToSave: LastUsedPortions = { ...lastUsedPortions };
    entriesToAdd.forEach(entry => {
        if (entry.food.id) { newPortionsToSave[entry.food.id] = entry.grams; }
        addToRecentFoods(entry.food);
    });
    setLastUsedPortions(newPortionsToSave);
    saveLastUsedPortions(newPortionsToSave).catch(() => {});
    setSelectedMultipleFoods(new Map());
  }, [ isEditMode, internalSelectedFood, selectedMultipleFoods, isActionDisabled, parentHandleAddMultipleEntries, lastUsedPortions, addToRecentFoods ]);


  const pickImageAndAnalyze = useCallback( async (source: "camera" | "gallery") => {
      if (isEditMode) return;

      setQuickAddItems([]); setSelectedQuickAddIndices(new Set()); setEditingQuickAddItemIndex(null);
      setModalMode("quickAddSelect");
      setQuickAddLoading(true);
      setSelectedMultipleFoods(new Map());
      setInternalSelectedFood(null); setInternalSearch(""); setInternalGrams("");

      let permissionResult; let pickerResult: ImagePicker.ImagePickerResult;
      try {
        if (source === "camera") {
          permissionResult = await ImagePicker.requestCameraPermissionsAsync();
          if (!permissionResult.granted) { Alert.alert(t('addEntryModal.alertQuickAddPermission'), t('addEntryModal.alertQuickAddCameraPermission')); throw new Error("Permission denied"); }
          pickerResult = await ImagePicker.launchCameraAsync({ quality: 1, exif: false });
        } else {
          permissionResult = await ImagePicker.requestMediaLibraryPermissionsAsync();
          if (!permissionResult.granted) { Alert.alert(t('addEntryModal.alertQuickAddPermission'), t('addEntryModal.alertQuickAddGalleryPermission')); throw new Error("Permission denied"); }
          pickerResult = await ImagePicker.launchImageLibraryAsync({ mediaTypes: ImagePicker.MediaTypeOptions.Images, quality: 1 });
        }

        if (pickerResult.canceled) throw new Error(t('addEntryModal.alertQuickAddUserCancelled'));

        if (pickerResult.assets && pickerResult.assets.length > 0) {
          const originalAsset = pickerResult.assets[0];
          const compressedResult = await compressImageIfNeeded(originalAsset);
          const assetForAnalysis = compressedResult ? { ...originalAsset, uri: compressedResult.uri, width: compressedResult.width, height: compressedResult.height, mimeType: 'image/jpeg' } : originalAsset;
          const base64Image = await getBase64FromUri(assetForAnalysis.uri);
          const mimeType = determineMimeType(assetForAnalysis);

          const results = await getMultipleFoodsFromImage(base64Image, mimeType);

          if (results.length === 0) {
            Toast.show({type: 'info', text1: t('addEntryModal.noQuickAddResults'), position: 'bottom'});
            setQuickAddItems([]);
            setQuickAddLoading(false);
            setModalMode("normal");
          } else {
            setQuickAddItems(results);
            setSelectedQuickAddIndices(new Set(results.map((_, i) => i)));
            results.forEach(qaItem => { if (qaItem.foodName) { resolveAndSetIcon(qaItem.foodName); } });
            setQuickAddLoading(false);
          }
        } else {
          throw new Error(t('addEntryModal.alertQuickAddCouldNotSelect'));
        }
      } catch (error: any) {
        if ( error.message !== t('addEntryModal.alertQuickAddUserCancelled') && error.message !== "Permission denied" && !(error instanceof BackendError) ) {
          Alert.alert(t('addEntryModal.alertQuickAddError'), error.message || t('addEntryModal.alertQuickAddErrorMessage'));
        }
        setModalMode("normal");
        setQuickAddItems([]);
        setSelectedQuickAddIndices(new Set());
        setQuickAddLoading(false);
      }
    }, [isEditMode, resolveAndSetIcon, t]
  );

  const handleQuickAddImage = useCallback(async () => {
    Keyboard.dismiss(); if (isEditMode || isActionDisabled) return;
    if (editingQuickAddItemIndex !== null) { Alert.alert(t('addEntryModal.alertQuickAddFinishEditing'), t('addEntryModal.alertQuickAddFinishEditingSaveOrCancel')); return; }
    Alert.alert( t('addEntryModal.alertQuickAddFromImageTitle'), t('addEntryModal.alertQuickAddFromImageMessage'),
      [ { text: t('addEntryModal.cancel'), style: "cancel" },
        { text: t('addEntryModal.camera'), onPress: () => pickImageAndAnalyze("camera") },
        { text: t('addEntryModal.gallery'), onPress: () => pickImageAndAnalyze("gallery") }, ]
    );
  }, [ isEditMode, editingQuickAddItemIndex, isActionDisabled, pickImageAndAnalyze, t ]);


  const handleToggleQuickAddItem = useCallback( (index: number) => {
      if (editingQuickAddItemIndex !== null || isActionDisabled) return;
      setSelectedQuickAddIndices((prev) => { const newSet = new Set(prev); if (newSet.has(index)) newSet.delete(index); else newSet.add(index); return newSet; });
    }, [editingQuickAddItemIndex, isActionDisabled]
  );

  const handleEditQuickAddItem = useCallback( (index: number) => {
      if (editingQuickAddItemIndex !== null || isActionDisabled) {
        if (editingQuickAddItemIndex !== null) Alert.alert(t('addEntryModal.alertQuickAddFinishEditing'), t('addEntryModal.alertQuickAddFinishEditingSaveOrCancel'));
        return;
      }
      const item = quickAddItems[index]; setEditingQuickAddItemIndex(index);
      setEditedFoodName(item.foodName); setEditedGrams(String(Math.round(item.estimatedWeightGrams)));
    }, [editingQuickAddItemIndex, quickAddItems, isActionDisabled, t]
  );

  const handleSaveQuickAddItemEdit = useCallback(() => {
    if (editingQuickAddItemIndex === null || isActionDisabled) return;
    const trimmedName = editedFoodName.trim(); if (!trimmedName) { Alert.alert(t('addEntryModal.alertQuickAddInvalidName'), t('addEntryModal.alertQuickAddInvalidNameMessage')); return; }
    const numericEditedGramsValue = parseFloat(editedGrams); if (!isValidNumberInput(editedGrams) || numericEditedGramsValue <= 0) { Alert.alert(t('addEntryModal.alertQuickAddInvalidGrams'), t('addEntryModal.alertQuickAddInvalidGramsMessage')); return; }
    const roundedGrams = Math.round(numericEditedGramsValue);
    setQuickAddItems((prevItems) => prevItems.map((item, index) => index === editingQuickAddItemIndex ? { ...item, foodName: trimmedName, estimatedWeightGrams: roundedGrams, } : item ));
    if (trimmedName) { resolveAndSetIcon(trimmedName); }
    setEditingQuickAddItemIndex(null); setEditedFoodName(""); setEditedGrams(""); Keyboard.dismiss();
  }, [editingQuickAddItemIndex, editedFoodName, editedGrams, isActionDisabled, resolveAndSetIcon, t]);

  const handleCancelQuickAddItemEdit = useCallback(() => {
    if (isActionDisabled) return; setEditingQuickAddItemIndex(null);
    setEditedFoodName(""); setEditedGrams(""); Keyboard.dismiss();
  }, [isActionDisabled]);

  const handleConfirmQuickAdd = useCallback(() => {
    Keyboard.dismiss(); if (isEditMode || isActionDisabled) return;
    if (editingQuickAddItemIndex !== null) { Alert.alert(t('addEntryModal.alertQuickAddFinishEditing'), t('addEntryModal.alertQuickAddFinishEditingSaveOrCancel')); return; }
    if (selectedQuickAddIndices.size === 0) { Alert.alert(t('addEntryModal.alertQuickAddNoItemsSelected'), t('addEntryModal.alertQuickAddNoItemsSelectedMessage')); return; }
    try {
      const entriesToAdd: { food: Food; grams: number }[] = [];
      const newPortionsToSave: LastUsedPortions = { ...lastUsedPortions };

      Array.from(selectedQuickAddIndices).forEach((index) => {
        if (index >= 0 && index < quickAddItems.length) {
          const item = quickAddItems[index];
          const existingFood = foods.find(f => f.name.toLowerCase() === item.foodName.toLowerCase());
          let foodToAdd: Food = existingFood ? existingFood : { id: uuidv4(), name: item.foodName, calories: Math.round(Number(item.calories_per_100g) || 0), protein: Math.round(Number(item.protein_per_100g) || 0), carbs: Math.round(Number(item.carbs_per_100g) || 0), fat: Math.round(Number(item.fat_per_100g) || 0), };
          const entryGrams = Math.max(1, Math.round(Number(item.estimatedWeightGrams) || 1));
          entriesToAdd.push({ food: foodToAdd, grams: entryGrams });

          if (foodToAdd.id) { newPortionsToSave[foodToAdd.id] = entryGrams; }
        }
      });

      if (entriesToAdd.length > 0) {
        parentHandleAddMultipleEntries(entriesToAdd);
        setLastUsedPortions(newPortionsToSave);
        saveLastUsedPortions(newPortionsToSave).catch(() => {});
      } else { Alert.alert(t('addEntryModal.alertQuickAddNothingToAdd'), t('addEntryModal.alertQuickAddNothingToAddMessage')); }
    } catch (error) { Alert.alert(t('addEntryModal.alertQuickAddErrorPreparing'), t('addEntryModal.alertQuickAddErrorPreparingMessage')); }
  }, [ foods, quickAddItems, selectedQuickAddIndices, editingQuickAddItemIndex, parentHandleAddMultipleEntries, isEditMode, isActionDisabled, lastUsedPortions, t ]);


  const handleQuickAddGramsChange = useCallback((text: string) => {
    const cleanedText = text.replace(/[^0-9]/g, "");
    setEditedGrams(cleanedText);
  }, []);

  const handleSaveQuickAddItemToLibrary = useCallback(async (
    item: EstimatedFoodItem,
    setSavingState: (isSaving: boolean) => void
  ) => {
    setSavingState(true);
    try {
        const foodData: Omit<Food, 'id'> = {
            name: item.foodName, calories: Math.round(item.calories_per_100g),
            protein: Math.round(item.protein_per_100g), carbs: Math.round(item.carbs_per_100g),
            fat: Math.round(item.fat_per_100g),
        };
        const existingFood = foods.find(f => f.name.toLowerCase() === item.foodName.toLowerCase());

        if (existingFood) {
            Alert.alert( t('addEntryModal.alertOverwriteFoodTitle'), t('addEntryModal.alertOverwriteFoodMessage', { foodName: item.foodName }),
                [ { text: t('addEntryModal.cancel'), style: 'cancel', onPress: () => setSavingState(false) },
                  { text: t('addEntryModal.overwrite'), onPress: async () => {
                          const foodToUpdate: Food = { ...existingFood, ...foodData };
                          const updatedFood = await onCommitFoodToLibrary(foodToUpdate, true);
                          if (updatedFood) { Toast.show({ type: 'success', text1: t('addEntryModal.toastFoodUpdatedInLibrary', { foodName: updatedFood.name }), position: 'bottom' }); resolveAndSetIcon(updatedFood.name); }
                          setSavingState(false);
                      },
                  }, ]
            );
        } else {
            const newFood = await onCommitFoodToLibrary(foodData, false);
            if (newFood) { Toast.show({ type: 'success', text1: t('addEntryModal.toastFoodSavedToLibrary', { foodName: newFood.name }), position: 'bottom' }); resolveAndSetIcon(newFood.name); }
            setSavingState(false);
        }
    } catch (error) {
        Toast.show({ type: 'error', text1: t('addEntryModal.toastErrorSavingToLibrary'), position: 'bottom' });
        setSavingState(false);
    }
  }, [foods, onCommitFoodToLibrary, resolveAndSetIcon, t]);


  const modalTitle = modalMode === "quickAddSelect"
    ? editingQuickAddItemIndex !== null ? t('addEntryModal.titleQuickAddEdit')
    : quickAddLoading ? t('addEntryModal.titleQuickAddAnalyzing')
    : t('addEntryModal.titleQuickAddSelect')
    : isEditMode ? t('addEntryModal.titleEdit')
    : t('addEntryModal.titleAdd');

  const numericGramsValueForValidation = parseFloat(internalGrams);
  const isSingleAddButtonDisabled = modalMode !== "normal" || !internalSelectedFood || !isValidNumberInput(internalGrams) || numericGramsValueForValidation <= 0 || isActionDisabled;
  const isMultiAddButtonDisabled = modalMode !== "normal" || selectedMultipleFoods.size === 0 || !!internalSelectedFood || isEditMode || isActionDisabled;
  const isAiButtonDisabled = modalMode !== "normal" || !internalSelectedFood || !autoInput.trim() || isActionDisabled || isAiLoading;
  const isQuickAddConfirmDisabled = isEditMode || modalMode !== "quickAddSelect" || selectedQuickAddIndices.size === 0 || editingQuickAddItemIndex !== null || isActionDisabled || quickAddLoading;
  const isQuickAddImageButtonDisabled = isEditMode || isActionDisabled || quickAddLoading;

  const combinedOverlayStyle = StyleSheet.flatten([ styles.overlayStyle, { backgroundColor: theme.colors.background }, ]);

  return (
    <Overlay isVisible={isVisible} onBackdropPress={!isActionDisabled ? toggleOverlay : undefined} animationType="slide" overlayStyle={styles.overlayContainer} >
      <KeyboardAvoidingView behavior={Platform.OS === "ios" ? "padding" : "height"} style={styles.keyboardAvoidingView} keyboardVerticalOffset={KEYBOARD_VERTICAL_OFFSET} >
        <View style={combinedOverlayStyle}>
          <ModalHeader
            title={modalTitle}
            isEditMode={isEditMode}
            modalMode={modalMode}
            quickAddLoading={quickAddLoading}
            selectedFood={internalSelectedFood}
            selectedMultipleFoodsSize={selectedMultipleFoods.size}
            selectedQuickAddIndicesSize={selectedQuickAddIndices.size}
            editingQuickAddItemIndex={editingQuickAddItemIndex}
            isActionDisabled={isActionDisabled}
            isSingleAddButtonDisabled={isSingleAddButtonDisabled}
            isMultiAddButtonDisabled={isMultiAddButtonDisabled}
            isQuickAddConfirmDisabled={isQuickAddConfirmDisabled}
            isQuickAddImageButtonDisabled={isQuickAddImageButtonDisabled}
            isAiLoading={isAiLoading}
            toggleOverlay={toggleOverlay}
            onAddOrUpdateSingleEntry={handleAddOrUpdateSingleEntry}
            onConfirmAddMultipleSelected={handleConfirmAddMultipleSelected}
            onConfirmQuickAdd={handleConfirmQuickAdd}
            onQuickAddImage={handleQuickAddImage}
            onBackFromQuickAdd={() => {
                setModalMode("normal");
                setQuickAddItems([]);
                setSelectedQuickAddIndices(new Set());
                setEditingQuickAddItemIndex(null);
            }}
          />

          {modalMode === "normal" && (
            <View style={styles.normalModeContentContainer}>
              <FoodSelectionList
                search={internalSearch}
                updateSearch={setInternalSearch}
                foods={foods}
                recentFoods={recentFoods}
                selectedFood={internalSelectedFood}
                handleSelectFood={setInternalSelectedFood}
                setGrams={setInternalGrams}
                setSelectedMultipleFoods={setSelectedMultipleFoods}
                selectedMultipleFoods={selectedMultipleFoods}
                handleToggleMultipleFoodSelection={handleToggleMultipleFoodSelection}
                foodIcons={foodIcons}
                onAddNewFoodRequest={onAddNewFoodRequest}
                isActionDisabled={isActionDisabled}
                isEditMode={isEditMode}
                lastUsedPortions={lastUsedPortions}
                modalMode={modalMode}
              />
              {internalSelectedFood && (
                <AmountInputSection
                  selectedFood={internalSelectedFood}
                  grams={internalGrams}
                  setGrams={setInternalGrams}
                  unitMode={unitMode}
                  setUnitMode={setUnitMode}
                  autoInput={autoInput}
                  setAutoInput={setAutoInput}
                  handleEstimateGrams={handleEstimateGrams}
                  isAiLoading={isAiLoading}
                  isAiButtonDisabled={isAiButtonDisabled}
                  isEditMode={isEditMode}
                  servingSizeSuggestions={servingSizeSuggestions}
                  isActionDisabled={isActionDisabled}
                  foodGradeResult={foodGradeResult}
                />
              )}
            </View>
          )}

          {modalMode === "quickAddSelect" && (
             <QuickAddList
                items={quickAddItems}
                selectedIndices={selectedQuickAddIndices}
                editingIndex={editingQuickAddItemIndex}
                editedName={editedFoodName}
                editedGrams={editedGrams}
                onToggleItem={handleToggleQuickAddItem}
                onEditItem={handleEditQuickAddItem}
                onSaveEdit={handleSaveQuickAddItemEdit}
                onCancelEdit={handleCancelQuickAddItemEdit}
                onNameChange={setEditedFoodName}
                onGramsChange={handleQuickAddGramsChange}
                isLoading={quickAddLoading}
                foodIcons={foodIcons}
                style={styles.quickAddListStyle}
                onSaveItemToLibrary={handleSaveQuickAddItemToLibrary}
                foods={foods}
            />
          )}
           <View style={{ height: Platform.OS === 'ios' ? 20 : 40 }} />
        </View>
      </KeyboardAvoidingView>
    </Overlay>
  );
};

const useStyles = makeStyles((theme) => ({
    overlayContainer: { backgroundColor: "transparent", width: "90%", maxWidth: 500, padding: 0, borderRadius: 15, shadowColor: "#000", shadowOffset: { width: 0, height: 3 }, shadowOpacity: 0.2, shadowRadius: 5, elevation: 6, overflow: "hidden", maxHeight: Dimensions.get("window").height * 0.85, },
    overlayStyle: { width: "100%", height: "100%", borderRadius: 15, padding: 15, paddingBottom: 0, backgroundColor: theme.colors.background, flex: 1, },
    keyboardAvoidingView: { width: "100%", height: "100%" },
    normalModeContentContainer: {
        flex: 1,
        justifyContent: 'flex-start',
    },
    quickAddListStyle: {
        flex: 1,
    },
}));

export default AddEntryModal;
---------- END AddEntryModal.tsx ----------


---------- AmountInputSection.tsx ----------
// src/components/AddEntryModal/AmountInputSection.tsx
import React from 'react';
import { View, ScrollView, TouchableOpacity, Keyboard } from 'react-native';
import { Text, Input, Icon, ButtonGroup, Button, useTheme, makeStyles } from '@rneui/themed';
import { Food } from '../../types/food';
import { FoodGradeResult } from '../../utils/gradingUtils';
import { isValidNumberInput } from '../../utils/validationUtils';
import { t } from '../../localization/i18n';

type UnitMode = "grams" | "auto";

interface AmountInputSectionProps {
    selectedFood: Food;
    grams: string;
    setGrams: (grams: string) => void;
    unitMode: UnitMode;
    setUnitMode: (mode: UnitMode) => void;
    autoInput: string;
    setAutoInput: (input: string) => void;
    handleEstimateGrams: () => void;
    isAiLoading: boolean;
    isAiButtonDisabled: boolean;
    isEditMode: boolean;
    servingSizeSuggestions: { label: string; value: string }[];
    isActionDisabled: boolean;
    foodGradeResult: FoodGradeResult | null;
}

const AmountInputSection: React.FC<AmountInputSectionProps> = ({
    selectedFood,
    grams,
    setGrams,
    unitMode,
    setUnitMode,
    autoInput,
    setAutoInput,
    handleEstimateGrams,
    isAiLoading,
    isAiButtonDisabled,
    isEditMode,
    servingSizeSuggestions,
    isActionDisabled,
    foodGradeResult,
}) => {
    const { theme } = useTheme();
    const styles = useStyles();

    const handleGramsChange = (text: string) => {
        const cleanedText = text.replace(/[^0-9.]/g, "").replace(/(\..*?)\./g, "$1");
        setGrams(cleanedText);
    };

    return (
        <View style={styles.amountSection}>
            <View style={styles.unitSelectorContainer}>
                <View style={styles.amountLabelContainer}>
                    <Text style={styles.inputLabel}>{t('addEntryModal.amount')}</Text>
                    {foodGradeResult && (
                        <Text style={[styles.gradePill, { backgroundColor: foodGradeResult.color }]}>
                            {foodGradeResult.letter}
                        </Text>
                    )}
                </View>
                <ButtonGroup
                    buttons={[t('addEntryModal.grams'), t('addEntryModal.autoAi')]}
                    selectedIndex={unitMode === "grams" ? 0 : 1}
                    onPress={(index) => {
                        if (!isActionDisabled) {
                            setUnitMode(index === 0 ? "grams" : "auto");
                            Keyboard.dismiss();
                        }
                    }}
                    containerStyle={styles.buttonGroupContainer}
                    selectedButtonStyle={{ backgroundColor: theme.colors.primary }}
                    textStyle={styles.buttonGroupText}
                    selectedTextStyle={{ color: theme.colors.white }}
                    disabled={isEditMode ? [1] : isActionDisabled ? [0, 1] : []}
                    disabledStyle={styles.disabledButtonGroup}
                    disabledTextStyle={{ color: theme.colors.grey3 }}
                />
            </View>
            {unitMode === "grams" && (
                <>
                    {!isEditMode && servingSizeSuggestions.length > 0 && (
                        <View style={styles.servingSizeRow}>
                            <Text style={styles.servingSizeLabel}>{t('addEntryModal.quickAddServing')}</Text>
                            <ScrollView horizontal showsHorizontalScrollIndicator={false} contentContainerStyle={styles.servingSizeContainer} keyboardShouldPersistTaps="handled">
                                {servingSizeSuggestions.map((suggestion) => (
                                    <TouchableOpacity
                                        key={suggestion.label}
                                        style={[styles.servingSizeButton, isActionDisabled && styles.disabledOverlay]}
                                        onPress={() => {
                                            if (!isActionDisabled) {
                                                setGrams(suggestion.value);
                                                Keyboard.dismiss();
                                            }
                                        }}
                                        disabled={isActionDisabled}
                                    >
                                        <Text style={styles.servingSizeButtonTitle}>{suggestion.label}</Text>
                                    </TouchableOpacity>
                                ))}
                            </ScrollView>
                        </View>
                    )}
                    <Input
                        placeholder={isEditMode ? t('addEntryModal.gramsPlaceholderEdit') : t('addEntryModal.gramsPlaceholder')}
                        keyboardType="numeric"
                        value={grams}
                        onChangeText={handleGramsChange}
                        inputStyle={styles.gramInputStyle}
                        inputContainerStyle={styles.gramInputContainerStyle}
                        errorMessage={!isValidNumberInput(grams) && grams !== "" && grams !== "." ? t('addEntryModal.gramsError') : ""}
                        errorStyle={{ color: theme.colors.error }}
                        rightIcon={<Text style={styles.unitText}>g</Text>}
                        containerStyle={{ paddingHorizontal: 0 }}
                        key={`grams-input-${selectedFood.id}-${isEditMode}`}
                        disabled={isActionDisabled}
                        autoFocus={!isEditMode} // autofocus only when adding new, not editing
                    />
                </>
            )}
            {unitMode === "auto" && !isEditMode && (
                <View style={styles.autoInputRow}>
                    <Input
                        placeholder={t('addEntryModal.autoPlaceholder')}
                        value={autoInput}
                        onChangeText={setAutoInput}
                        inputStyle={[styles.gramInputStyle, styles.autoInputField]}
                        inputContainerStyle={styles.gramInputContainerStyle}
                        containerStyle={styles.autoInputContainer}
                        multiline={false}
                        onSubmitEditing={handleEstimateGrams}
                        key={`auto-input-${selectedFood.id}`}
                        disabled={isActionDisabled}
                        autoFocus
                    />
                    <Button
                        onPress={() => { Keyboard.dismiss(); handleEstimateGrams(); }}
                        disabled={isAiButtonDisabled || isActionDisabled}
                        loading={isAiLoading}
                        buttonStyle={styles.aiButton}
                        icon={isAiLoading ? undefined : (
                            <Icon name="calculator-variant" type="material-community" size={20} color={theme.colors.white} />
                        )}
                        title={isAiLoading ? "" : ""}
                    />
                </View>
            )}
        </View>
    );
};

const useStyles = makeStyles((theme) => ({
    amountSection: {
        marginTop: 10,
        borderTopWidth: 1,
        borderTopColor: theme.colors.divider,
        paddingTop: 15,
        paddingHorizontal: 0,
    },
    unitSelectorContainer: {
        flexDirection: "row",
        alignItems: "center",
        justifyContent: "space-between",
        marginBottom: 15,
        paddingHorizontal: 5,
    },
    amountLabelContainer: {
        flexDirection: 'row',
        alignItems: 'center',
    },
    gradePill: {
        fontSize: 11,
        fontWeight: 'bold',
        color: theme.colors.white,
        paddingHorizontal: 5,
        paddingVertical: 1.5,
        borderRadius: 7,
        marginLeft: 8,
        minWidth: 18,
        textAlign: 'center',
        overflow: 'hidden',
    },
    inputLabel: {
        fontWeight: "600",
        color: theme.colors.grey1,
        fontSize: 14,
        marginRight: 0,
        textTransform: "uppercase",
        textAlign: 'left',
    },
    buttonGroupContainer: {
        flex: 0.7,
        maxWidth: 220,
        height: 35,
        borderRadius: 8,
        borderColor: theme.colors.primary,
        borderWidth: 1,
        backgroundColor: theme.colors.background,
    },
    buttonGroupText: {
        fontSize: 14,
        color: theme.colors.text,
    },
    disabledButtonGroup: {
        backgroundColor: theme.colors.grey5,
    },
    servingSizeRow: {
        flexDirection: "row",
        alignItems: "center",
        marginBottom: 12,
        paddingHorizontal: 5,
    },
    servingSizeLabel: {
        color: theme.colors.grey2,
        fontSize: 13,
        marginRight: 8,
        textAlign: 'left',
    },
    servingSizeContainer: {
        flexGrow: 0,
    },
    servingSizeButton: {
        backgroundColor: theme.colors.grey4,
        borderRadius: 15,
        marginRight: 8,
        paddingHorizontal: 12,
        paddingVertical: 5,
        justifyContent: "center",
        alignItems: "center",
        height: 30,
    },
    servingSizeButtonTitle: {
        color: theme.colors.text,
        fontSize: 13,
    },
    gramInputStyle: {
        color: theme.colors.text,
        fontSize: 16,
        paddingVertical: 8,
        height: 40,
        textAlign: 'left',
    },
    gramInputContainerStyle: {
        borderBottomColor: theme.colors.grey3,
        paddingHorizontal: 5,
    },
    unitText: {
        color: theme.colors.grey2,
        fontSize: 15,
        fontWeight: "500",
        paddingRight: 5,
    },
    autoInputRow: {
        flexDirection: "row",
        alignItems: "center",
        paddingHorizontal: 0,
    },
    autoInputContainer: {
        flex: 1,
        paddingHorizontal: 0,
        marginRight: 10,
    },
    autoInputField: {
        height: 40,
    },
    aiButton: {
        backgroundColor: theme.colors.secondary,
        borderRadius: 20,
        width: 40,
        height: 40,
        padding: 0,
        justifyContent: "center",
        alignItems: "center",
        minWidth: 40,
    },
    disabledOverlay: {
        opacity: 0.6,
    },
}));

export default AmountInputSection;
---------- END AmountInputSection.tsx ----------


---------- FoodSelectionList.tsx ----------
// src/components/AddEntryModal/FoodSelectionList.tsx
import React, { useMemo, useCallback, useRef, useEffect } from 'react';
import { View, FlatList, TouchableOpacity, ActivityIndicator, Platform, Keyboard, StyleSheet, I18nManager } from 'react-native';
import { Text, ListItem, Icon, Button, SearchBar, CheckBox, useTheme, makeStyles } from '@rneui/themed';
import { Food } from '../../types/food';
import { LastUsedPortions } from '../../services/storageService';
import { t } from '../../localization/i18n';

const DEFAULT_GRAMS_FOR_MULTI_ADD = 100;

interface FoodSelectionListProps {
    search: string;
    updateSearch: (search: string) => void;
    foods: Food[]; // Full library
    recentFoods: Food[];
    selectedFood: Food | null;
    handleSelectFood: (food: Food | null) => void;
    setGrams: (grams: string) => void;
    setSelectedMultipleFoods: React.Dispatch<React.SetStateAction<Map<string, { food: Food; grams: number }>>>;
    selectedMultipleFoods: Map<string, { food: Food; grams: number }>;
    handleToggleMultipleFoodSelection: (food: Food, displayGrams: number) => void;
    foodIcons: { [foodName: string]: string | null }; // No 'undefined'
    onAddNewFoodRequest: () => void;
    isActionDisabled: boolean;
    isEditMode: boolean;
    lastUsedPortions: LastUsedPortions;
    modalMode: "normal" | "quickAddSelect";
}

type DisplayFoodItem = Food & { isRecent?: boolean };

const FoodSelectionList: React.FC<FoodSelectionListProps> = ({
    search,
    updateSearch,
    foods,
    recentFoods,
    selectedFood, 
    handleSelectFood,
    setGrams,
    setSelectedMultipleFoods,
    selectedMultipleFoods,
    handleToggleMultipleFoodSelection,
    foodIcons,
    onAddNewFoodRequest,
    isActionDisabled,
    isEditMode,
    lastUsedPortions,
    modalMode,
}) => {
    const { theme } = useTheme();
    const styles = useStyles();
    const flatListRef = useRef<FlatList<DisplayFoodItem>>(null);

    const filteredFoodsForSearch = useMemo(() => {
        if (!search) return [];
        const searchTerm = search.toLowerCase();
        return foods.filter((food) =>
            food.name.toLowerCase().includes(searchTerm)
        );
    }, [foods, search]);

    const listDisplayData = useMemo((): DisplayFoodItem[] => {
        if (search) {
            return filteredFoodsForSearch;
        }
        const tempCombinedList: DisplayFoodItem[] = [];
        const displayedIds = new Set<string>();
        if (selectedFood) {
            const isSelRecent = recentFoods.some(rf => rf.id === selectedFood.id);
            tempCombinedList.push({ ...selectedFood, isRecent: isSelRecent });
            displayedIds.add(selectedFood.id);
        }
        recentFoods.forEach(rf => {
            if (!displayedIds.has(rf.id)) {
                tempCombinedList.push({ ...rf, isRecent: true });
                displayedIds.add(rf.id);
            }
        });
        const otherLibraryFoods = foods
            .filter(food => !displayedIds.has(food.id))
            .sort((a, b) => a.name.localeCompare(b.name))
            .slice(0, 10); 
        otherLibraryFoods.forEach(olf => {
            tempCombinedList.push({ ...olf, isRecent: false });
        });
        return tempCombinedList;
    }, [search, recentFoods, foods, filteredFoodsForSearch, selectedFood]);

    useEffect(() => {
        if (selectedFood && flatListRef.current && listDisplayData.length > 0 && !search) {
            const index = listDisplayData.findIndex(item => item.id === selectedFood.id);
            if (index !== -1) {
                setTimeout(() => {
                    flatListRef.current?.scrollToIndex({ index, animated: true, viewPosition: 0.3 }); 
                }, 150);
            }
        }
    }, [selectedFood, listDisplayData, search]);

    const handleInternalSingleSelectFood = useCallback((item: Food | null) => {
        if (selectedMultipleFoods.size > 0 && item !== null && (!selectedFood || selectedFood.id !== item.id)) {
            Keyboard.dismiss();
            return; 
        }
        Keyboard.dismiss();
        if (selectedFood && item && selectedFood.id === item.id) {
            handleSelectFood(null);
            setGrams(""); 
            updateSearch(""); 
            setSelectedMultipleFoods(new Map()); 
        } else if (item === null) { 
            handleSelectFood(null);
            setGrams("");
        } else if (item !== null) { 
            handleSelectFood(item);
            updateSearch(""); 
            setSelectedMultipleFoods(new Map()); 
            if (!isEditMode) { 
                const lastPortion = lastUsedPortions[item.id];
                if (lastPortion) {
                    setGrams(String(lastPortion));
                } else {
                    setGrams(""); 
                }
            }
        }
    }, [
        handleSelectFood, 
        updateSearch, 
        selectedFood, 
        setGrams, 
        lastUsedPortions, 
        setSelectedMultipleFoods, 
        isEditMode,
        selectedMultipleFoods.size 
    ]);
    
    const handleSearchChange = (text: string) => {
        updateSearch(text);
        if (selectedFood && text.trim() !== "") { 
            handleInternalSingleSelectFood(null);
        }
    };

    const renderFoodItem = ({ item }: { item: DisplayFoodItem }) => {
        const foodItem = item;
        const isSingleSelectedViaState = selectedFood?.id === foodItem.id;
        const isMultiSelected = selectedMultipleFoods.has(foodItem.id);
        const iconIdentifier = foodIcons[foodItem.name];
        const displayGramsForMulti = lastUsedPortions[foodItem.id] || DEFAULT_GRAMS_FOR_MULTI_ADD;

        const canShowCheckbox = modalMode === "normal" && !isEditMode && (selectedMultipleFoods.size > 0 || !selectedFood);
        const showSingleSelectCheckmark = isSingleSelectedViaState && selectedMultipleFoods.size === 0 && !search;

        return (
            <TouchableOpacity
                onPress={() => {
                    if (isActionDisabled) return;
                    if (selectedMultipleFoods.size > 0) {
                        handleToggleMultipleFoodSelection(foodItem, displayGramsForMulti);
                    } else {
                        handleInternalSingleSelectFood(foodItem);
                    }
                }}
                disabled={isActionDisabled}
                style={[isActionDisabled && styles.disabledOverlay]}
            >
                <ListItem
                    bottomDivider
                    containerStyle={[
                        styles.listItemContainer,
                        (showSingleSelectCheckmark || isMultiSelected) && styles.selectedListItem,
                        isMultiSelected && styles.multiSelectedListItemBorder,
                    ]}
                >
                    {canShowCheckbox && (
                        <CheckBox
                            checked={isMultiSelected}
                            onPress={() => { 
                                if (isActionDisabled) return;
                                handleToggleMultipleFoodSelection(foodItem, displayGramsForMulti);
                            }}
                            containerStyle={styles.multiSelectCheckboxContainer}
                            size={22}
                            disabled={isActionDisabled}
                        />
                    )}
                    {iconIdentifier ? (
                        <Text style={styles.foodIconEmoji}>{iconIdentifier}</Text>
                    ) : (
                        <View style={styles.defaultIconContainer}>
                            <Icon name="help-outline" type="material" size={22} color={theme.colors.grey3} />
                        </View>
                    )}
                    <ListItem.Content>
                        <ListItem.Title style={styles.listItemTitle} numberOfLines={1} ellipsizeMode="tail">
                            {foodItem.name}
                        </ListItem.Title>
                        {canShowCheckbox && (
                            <ListItem.Subtitle style={styles.listItemSubtitleSecondary}>
                                {t('addEntryModal.grams')}: {displayGramsForMulti}g
                            </ListItem.Subtitle>
                        )}
                        {foodItem.isRecent && !search && (!selectedFood || selectedFood.id !== foodItem.id) && (
                             <Text style={styles.recentBadge}>{t('addEntryModal.recent')}</Text>
                        )}
                    </ListItem.Content>
                    {showSingleSelectCheckmark && (<Icon name="checkmark-circle" type="ionicon" color={theme.colors.primary} size={24} />)}
                </ListItem>
            </TouchableOpacity>
        );
    };

    const renderEmptyOrNoResults = () => {
        if (search && filteredFoodsForSearch.length === 0) {
            return (
                <View style={styles.noResultsContainer}>
                    <Text style={styles.noFoodsText}>
                        {t('addEntryModal.noResults', { searchTerm: search })}
                    </Text>
                    <Button
                        title={t('addEntryModal.addNewFoodButton')}
                        onPress={onAddNewFoodRequest}
                        type="outline"
                        buttonStyle={styles.addNewFoodButton}
                        titleStyle={styles.addNewFoodButtonTitle}
                        icon={<Icon name="add-circle-outline" type="ionicon" size={20} color={theme.colors.primary} />}
                        disabled={isActionDisabled}
                    />
                </View>
            );
        }
        if (!search && foods.length === 0 && recentFoods.length === 0) { 
             return (
                 <View style={styles.noResultsContainer}>
                     <Text style={styles.noFoodsText}>
                         {t('addEntryModal.emptyLibraryMessage')}
                     </Text>
                     <Button
                         title={t('addEntryModal.addNewFoodButton')}
                         onPress={onAddNewFoodRequest}
                         type="outline"
                         buttonStyle={styles.addNewFoodButton}
                         titleStyle={styles.addNewFoodButtonTitle}
                         icon={<Icon name="add-circle-outline" type="ionicon" size={20} color={theme.colors.primary} />}
                         disabled={isActionDisabled}
                     />
                 </View>
             );
        }
        return null;
    };

    return (
        <View>
            <SearchBar
                placeholder={t('addEntryModal.searchPlaceholder')}
                onChangeText={handleSearchChange}
                value={search}
                platform={Platform.OS === "ios" ? "ios" : "android"}
                containerStyle={styles.searchBarContainer}
                inputContainerStyle={styles.searchBarInputContainer}
                inputStyle={styles.searchInputStyle}
                onCancel={() => { updateSearch(""); Keyboard.dismiss();}}
                showCancel={Platform.OS === "ios"}
                onClear={() => updateSearch("")}
                disabled={isActionDisabled || modalMode !== "normal"}
            />
            <FlatList
                ref={flatListRef}
                data={listDisplayData}
                renderItem={renderFoodItem}
                keyExtractor={(item) => `food-sel-${item.id}`}
                ListEmptyComponent={renderEmptyOrNoResults}
                extraData={{ selectedFoodId: selectedFood?.id, foodIcons, selectedMultipleFoodsSize: selectedMultipleFoods.size, search, listLength: listDisplayData.length }}
                keyboardShouldPersistTaps="handled"
                initialNumToRender={15}
                maxToRenderPerBatch={10}
                windowSize={21} 
                removeClippedSubviews={Platform.OS === 'android'}
                style={styles.flatListContainer}
                contentContainerStyle={styles.flatListContentContainer}
                getItemLayout={(data, index) => (
                    { length: 65, offset: 65 * index, index } 
                )}
            />
        </View>
    );
};

const useStyles = makeStyles((theme) => ({
    searchBarContainer: {
        backgroundColor: "transparent",
        borderBottomColor: "transparent",
        borderTopColor: "transparent",
        paddingHorizontal: 0,
        marginBottom: 10,
    },
    searchBarInputContainer: {
        borderRadius: 25,
        backgroundColor: theme.colors.searchBg || theme.colors.grey5,
        height: 40,
    },
    searchInputStyle: {
        color: theme.colors.text,
        fontSize: 15,
        textAlign: I18nManager.isRTL ? 'right' : 'left',
    },
    flatListContainer: {
        maxHeight: 250, 
        minHeight: 150,
    },
    flatListContentContainer: {
        paddingBottom: 10,
    },
    foodIconEmoji: {
        fontSize: 26,
        width: 35,
        height: 35,
        textAlign: 'center',
        textAlignVertical: 'center',
        marginRight: 10,
    },
    defaultIconContainer: {
        width: 35,
        height: 35,
        marginRight: 10,
        borderRadius: 17.5,
        backgroundColor: theme.colors.grey5,
        alignItems: "center",
        justifyContent: "center",
    },
    listItemContainer: {
        backgroundColor: "transparent",
        paddingVertical: 8,
        paddingHorizontal: 5,
        borderBottomColor: theme.colors.divider,
        minHeight: 65,
    },
    selectedListItem: { 
        backgroundColor: theme.colors.grey5, 
        borderRadius: 8,
    },
    multiSelectedListItemBorder: { 
        borderLeftWidth: 3, 
        borderLeftColor: theme.colors.success, 
    },
    multiSelectCheckboxContainer: { 
        padding: 10, 
        marginRight: 0, 
        marginLeft: -10, 
        backgroundColor: 'transparent',
        borderWidth: 0,
    },
    listItemTitle: {
        color: theme.colors.text,
        fontSize: 16,
        fontWeight: "500",
        textAlign: 'left',
        flexShrink: 1,
    },
    listItemSubtitleSecondary: {
        color: theme.colors.secondary,
        fontSize: 12,
        textAlign: 'left',
        marginTop: 2,
    },
    recentBadge: {
        position: 'absolute',
        top: -2,
        right: 0,
        fontSize: 10,
        color: theme.colors.primary,
        backgroundColor: theme.colors.grey5,
        paddingHorizontal: 4,
        paddingVertical: 1,
        borderRadius: 4,
        fontWeight: 'bold',
        textTransform: 'uppercase'
    },
    disabledOverlay: {
        opacity: 0.6,
    },
    noResultsContainer: {
        alignItems: 'center',
        paddingVertical: 20,
        paddingHorizontal: 10,
        minHeight: 150, 
        justifyContent: 'center',
    },
    noFoodsText: {
        color: theme.colors.grey2,
        fontStyle: "italic",
        textAlign: "center",
        marginBottom: 15,
    },
    addNewFoodButton: {
        marginTop: 10,
        borderColor: theme.colors.primary,
        paddingHorizontal: 20,
        borderRadius: 20,
    },
    addNewFoodButtonTitle: {
        color: theme.colors.primary,
        fontWeight: '600',
    },
}));

export default FoodSelectionList;
---------- END FoodSelectionList.tsx ----------


---------- ModalHeader.tsx ----------
// src/components/AddEntryModal/ModalHeader.tsx
import React from 'react';
import { View, TouchableOpacity, ActivityIndicator, StyleSheet, Keyboard } from 'react-native';
import { Text, Icon, Button, useTheme, makeStyles } from '@rneui/themed';
import { Food } from '../../types/food';
import { t } from '../../localization/i18n';

type ModalMode = 'normal' | 'quickAddSelect';

interface ModalHeaderProps {
    title: string;
    isEditMode: boolean;
    modalMode: ModalMode;
    quickAddLoading: boolean;
    selectedFood: Food | null;
    selectedMultipleFoodsSize: number;
    selectedQuickAddIndicesSize: number;
    editingQuickAddItemIndex: number | null;
    isActionDisabled: boolean;
    isSingleAddButtonDisabled: boolean;
    isMultiAddButtonDisabled: boolean;
    isQuickAddConfirmDisabled: boolean;
    isQuickAddImageButtonDisabled: boolean;
    isAiLoading: boolean; // For loading state on single add/update
    toggleOverlay: () => void;
    onAddOrUpdateSingleEntry: () => void;
    onConfirmAddMultipleSelected: () => void;
    onConfirmQuickAdd: () => void;
    onQuickAddImage: () => void;
    onBackFromQuickAdd: () => void;
}

const ModalHeader: React.FC<ModalHeaderProps> = ({
    title,
    isEditMode,
    modalMode,
    quickAddLoading,
    selectedFood,
    selectedMultipleFoodsSize,
    selectedQuickAddIndicesSize,
    editingQuickAddItemIndex,
    isActionDisabled,
    isSingleAddButtonDisabled,
    isMultiAddButtonDisabled,
    isQuickAddConfirmDisabled,
    isQuickAddImageButtonDisabled,
    isAiLoading,
    toggleOverlay,
    onAddOrUpdateSingleEntry,
    onConfirmAddMultipleSelected,
    onConfirmQuickAdd,
    onQuickAddImage,
    onBackFromQuickAdd,
}) => {
    const { theme } = useTheme();
    const styles = useStyles();

    const handleClose = () => {
        Keyboard.dismiss();
        toggleOverlay();
    };

    return (
        <View style={styles.header}>
            {modalMode === 'quickAddSelect' && editingQuickAddItemIndex === null ? (
                <Button
                    type="clear"
                    onPress={() => { if (isActionDisabled) return; Keyboard.dismiss(); onBackFromQuickAdd(); }}
                    icon={<Icon name="arrow-back" type="ionicon" size={24} color={isActionDisabled ? theme.colors.grey3 : theme.colors.primary} />}
                    containerStyle={styles.closeIconContainer}
                    disabled={isActionDisabled}
                />
            ) : (
                <TouchableOpacity
                    onPress={handleClose}
                    style={styles.closeIconContainer}
                    disabled={isActionDisabled}
                    hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
                >
                    <Icon name="close" type="material" size={28} color={isActionDisabled ? theme.colors.grey3 : theme.colors.text} />
                </TouchableOpacity>
            )}

            <Text h4 h4Style={[styles.overlayTitle, isEditMode && modalMode === 'normal' && styles.editModeTitle]} numberOfLines={1} ellipsizeMode="tail">
                {title}
            </Text>

            <View style={styles.headerActionsContainer}>
                {modalMode === 'normal' && (
                    <>
                        {!isEditMode && !selectedFood && (
                            <TouchableOpacity onPress={onQuickAddImage} disabled={isQuickAddImageButtonDisabled} style={styles.headerIcon} hitSlop={{ top: 10, bottom: 10, left: 5, right: 5 }}>
                                {quickAddLoading ? (
                                    <ActivityIndicator size="small" color={theme.colors.primary} />
                                ) : (
                                    <Icon name="camera-burst" type="material-community" size={26} color={isQuickAddImageButtonDisabled ? theme.colors.grey3 : theme.colors.primary} />
                                )}
                            </TouchableOpacity>
                        )}
                        {isEditMode ? (
                            <Button title={t('addEntryModal.buttonUpdate')} onPress={onAddOrUpdateSingleEntry} disabled={isSingleAddButtonDisabled} buttonStyle={[styles.actionButton, styles.updateButton]} titleStyle={styles.buttonTitle} loading={isAiLoading && !!selectedFood} />
                        ) : selectedFood ? (
                            <Button title={t('addEntryModal.buttonAdd')} onPress={onAddOrUpdateSingleEntry} disabled={isSingleAddButtonDisabled} buttonStyle={styles.actionButton} titleStyle={styles.buttonTitle} loading={isAiLoading} />
                        ) : (
                            <Button title={t('addEntryModal.buttonAddSelected', { count: selectedMultipleFoodsSize })} onPress={onConfirmAddMultipleSelected} disabled={isMultiAddButtonDisabled} buttonStyle={[styles.actionButton, { backgroundColor: theme.colors.success }]} titleStyle={styles.buttonTitle} />
                        )}
                    </>
                )}
                {modalMode === 'quickAddSelect' && editingQuickAddItemIndex === null && (
                    <Button title={quickAddLoading ? t('addEntryModal.buttonLoading') : t('addEntryModal.buttonAddSelected', { count: selectedQuickAddIndicesSize })} onPress={onConfirmQuickAdd} disabled={isQuickAddConfirmDisabled} buttonStyle={[styles.actionButton, { backgroundColor: theme.colors.success }]} titleStyle={styles.buttonTitle} loading={quickAddLoading} />
                )}
                {modalMode === 'quickAddSelect' && editingQuickAddItemIndex !== null && (
                     <View style={styles.placeholderActionView} /> // Keep layout consistent when editing in quick add
                )}
            </View>
        </View>
    );
};

const useStyles = makeStyles((theme) => ({
    header: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: 15,
        paddingHorizontal: 0,
    },
    closeIconContainer: {
        padding: 5,
        minWidth: 40, // Ensure touchable area
        alignItems: 'flex-start',
    },
    overlayTitle: {
        color: theme.colors.text,
        fontWeight: 'bold',
        fontSize: 20,
        textAlign: 'center',
        flex: 1,
        marginHorizontal: 5,
    },
    editModeTitle: {
        color: theme.colors.warning,
    },
    headerActionsContainer: {
        flexDirection: 'row',
        alignItems: 'center',
        minWidth: 80, // Ensure space for buttons or icons
        justifyContent: 'flex-end',
    },
    headerIcon: {
        paddingHorizontal: 8, // Combined padding for the icon itself
        marginRight: 5,
    },
    actionButton: {
        borderRadius: 20,
        paddingHorizontal: 12,
        paddingVertical: 8,
        minWidth: 70,
        marginLeft: 5, // Spacing between icon and button if both present
        backgroundColor: theme.colors.primary,
    },
    updateButton: {
        backgroundColor: theme.colors.warning,
    },
    buttonTitle: {
        color: theme.colors.white,
        fontWeight: '600',
        fontSize: 14,
    },
    placeholderActionView: { // Used to balance header when no action button is on the right in quick add edit
        width: 70,
        marginLeft: 5,
    },
}));

export default ModalHeader;
---------- END ModalHeader.tsx ----------


---------- AddFoodModal.tsx ----------
// src/components/AddFoodModal.tsx
import React, { useState, useEffect, useCallback } from "react";
import {
    View,
    KeyboardAvoidingView,
    Platform,
    ActivityIndicator,
    Alert,
    ScrollView,
    StyleSheet,
    TouchableOpacity,
} from "react-native";
import {
    Button,
    Input,
    Text,
    Overlay,
    makeStyles,
    useTheme,
    Icon,
} from "@rneui/themed";
import { Food } from "../types/food";
import { MaterialCommunityIcons } from "@expo/vector-icons";
import Toast from "react-native-toast-message";
import {
    getMacrosFromText,
    getMacrosForImageFile,
    BackendError,
} from "../utils/macros";
import * as ImagePicker from "expo-image-picker";
import { ImagePickerResult } from 'expo-image-picker';
import { compressImageIfNeeded } from '../utils/imageUtils';
import FoodFormFields from "./FoodFormFields";
import { t } from '../localization/i18n';

interface AddFoodModalProps {
    isVisible: boolean;
    toggleOverlay: () => void;
    newFood: Omit<Food, "id">;
    editFood: Food | null;
    errors: { [key: string]: string };
    handleInputChange: (
        key: keyof Omit<Food, "id">,
        value: string,
        isEdit: boolean
    ) => void;
    handleCreateFood: () => Promise<void>;
    handleUpdateFood: () => Promise<void>;
    validateFood: (food: Omit<Food, "id"> | Food) => { [key: string]: string } | null;
    setErrors: React.Dispatch<React.SetStateAction<{ [key: string]: string }>>;
}

const KEYBOARD_VERTICAL_OFFSET = Platform.OS === "ios" ? 60 : 0;

const AddFoodModal: React.FC<AddFoodModalProps> = ({
    isVisible,
    toggleOverlay,
    newFood,
    editFood,
    errors,
    handleInputChange,
    handleCreateFood,
    handleUpdateFood,
    validateFood,
    setErrors,
}) => {
    const { theme } = useTheme();
    const styles = useStyles();
    const [loading, setLoading] = useState(false);
    const [mode, setMode] = useState<"normal" | "ingredients">("normal");
    const [ingredients, setIngredients] = useState("");
    const [aiTextLoading, setAiTextLoading] = useState(false);
    const [aiImageLoading, setAiImageLoading] = useState(false);

    useEffect(() => {
        if (isVisible) {
            setErrors({}); setMode("normal"); setIngredients("");
            setAiTextLoading(false); setAiImageLoading(false); setLoading(false);
        }
    }, [isVisible, setErrors]);

    const getCurrentFoodData = (): Partial<Omit<Food, 'id'>> => {
        return editFood ? editFood : newFood;
    };

    const handleCreateOrUpdate = async () => {
        const isUpdate = !!editFood;
        const currentData = getCurrentFoodData();
        const dataToValidate = {
            name: (currentData.name ?? "").trim(), calories: currentData.calories ?? 0,
            protein: currentData.protein ?? 0, carbs: currentData.carbs ?? 0, fat: currentData.fat ?? 0,
        };
        const validationErrors = validateFood(dataToValidate);
        if (validationErrors) {
            setErrors(validationErrors);
            Toast.show({ type: "error", text1: t('foodListScreen.fixErrors'), position: 'bottom' });
            return;
        }
        setErrors({}); setLoading(true);
        try {
            if (isUpdate) {
                await handleUpdateFood();
                Toast.show({ type: "success", text1: t('foodListScreen.foodUpdated', { foodName: dataToValidate.name }), position: 'bottom' });
            } else {
                await handleCreateFood();
                Toast.show({ type: "success", text1: t('foodListScreen.foodAdded', { foodName: dataToValidate.name }), position: 'bottom' });
            }
            toggleOverlay();
        } catch (error: any) {
            Alert.alert(t('foodListScreen.errorLoad'), error.message || t(isUpdate ? 'foodListScreen.errorUpdateMessage' : 'foodListScreen.errorCreateMessage'));
        } finally { setLoading(false); }
    };

    const handleAiTextButtonClick = async () => {
        const currentFoodName = (getCurrentFoodData().name ?? "").trim();
        const isUpdate = !!editFood;
        if (mode === "normal") {
            setMode("ingredients");
            handleInputChange("calories", "", isUpdate); handleInputChange("protein", "", isUpdate);
            handleInputChange("carbs", "", isUpdate); handleInputChange("fat", "", isUpdate);
        } else {
            if (!currentFoodName && !ingredients.trim()) { Alert.alert(t('addFoodModal.alertInputNeeded'), t('addFoodModal.alertInputNeededMessage')); return; }
            setAiTextLoading(true);
            try {
                const macros = await getMacrosFromText(currentFoodName, ingredients);
                handleInputChange("calories", String(Math.round(macros.calories)), isUpdate); handleInputChange("protein", String(Math.round(macros.protein)), isUpdate);
                handleInputChange("carbs", String(Math.round(macros.carbs)), isUpdate); handleInputChange("fat", String(Math.round(macros.fat)), isUpdate);
                setMode("normal"); Toast.show({ type: 'info', text1: t('addFoodModal.macrosEstimatedText'), position: 'bottom' });
            } catch (error) { console.error("AI Macro fetch error (recipe - modal):", error); }
            finally { setAiTextLoading(false); }
        }
    };

    const handleGetImageAndAnalyze = async () => {
        if (aiImageLoading || aiTextLoading || loading) return;
        const processImage = async (pickerResult: ImagePickerResult) => {
            if (pickerResult.canceled) return;
            if (pickerResult.assets && pickerResult.assets.length > 0) {
                const originalAsset = pickerResult.assets[0]; setAiImageLoading(true);
                try {
                     const compressedResult = await compressImageIfNeeded(originalAsset);
                     const assetForAnalysis = compressedResult ? { ...originalAsset, uri: compressedResult.uri, width: compressedResult.width, height: compressedResult.height, mimeType: 'image/jpeg' } : originalAsset;
                     const result = await getMacrosForImageFile(assetForAnalysis);
                     const isUpdate = !!editFood;
                     handleInputChange("name", result.foodName, isUpdate); handleInputChange("calories", String(Math.round(result.calories)), isUpdate);
                     handleInputChange("protein", String(Math.round(result.protein)), isUpdate); handleInputChange("carbs", String(Math.round(result.carbs)), isUpdate);
                     handleInputChange("fat", String(Math.round(result.fat)), isUpdate);
                     setMode("normal"); setIngredients("");
                     Toast.show({ type: 'success', text1: t('addFoodModal.foodIdentified'), text2: t('addFoodModal.foodIdentifiedMessage', { foodName: result.foodName }), position: 'bottom', });
                } catch (analysisError) { console.error("Error during image analysis (modal):", analysisError); }
                finally { setAiImageLoading(false); }
            } else { Alert.alert(t('addFoodModal.errorGetImage'), t('addEntryModal.alertQuickAddCouldNotSelect')); setAiImageLoading(false); }
        };
        Alert.alert(t('addFoodModal.errorGetImage'), t('addFoodModal.errorGetImageMessage'),
            [ { text: t('addEntryModal.cancel'), style: "cancel" },
              { text: t('addEntryModal.camera'), onPress: async () => { try { const perm = await ImagePicker.requestCameraPermissionsAsync(); if (!perm.granted) { Alert.alert(t('addFoodModal.errorPermission'), t('addFoodModal.errorCameraPermission')); return; } const res = await ImagePicker.launchCameraAsync({ quality: 1, exif: false }); await processImage(res); } catch (e) { console.error(e); Alert.alert(t('addFoodModal.errorCamera')); } } },
              { text: t('addEntryModal.gallery'), onPress: async () => { try { const perm = await ImagePicker.requestMediaLibraryPermissionsAsync(); if (!perm.granted) { Alert.alert(t('addFoodModal.errorPermission'), t('addEntryModal.alertQuickAddGalleryPermission')); return; } const res = await ImagePicker.launchImageLibraryAsync({ mediaTypes: ImagePicker.MediaTypeOptions.Images, quality: 1 }); await processImage(res); } catch (e) { console.error(e); Alert.alert(t('addFoodModal.errorGallery')); } } }, ],
            { cancelable: true }
        );
    };

    const isAnyLoading = loading || aiTextLoading || aiImageLoading;
    const combinedOverlayStyle = StyleSheet.flatten([ styles.overlayStyle, { backgroundColor: theme.colors.background } ]);

    return (
        <Overlay isVisible={isVisible} onBackdropPress={!isAnyLoading ? toggleOverlay : undefined} animationType="fade" overlayStyle={styles.overlayContainer} >
            <KeyboardAvoidingView behavior={Platform.OS === "ios" ? "padding" : "height"} style={styles.keyboardAvoidingView} keyboardVerticalOffset={KEYBOARD_VERTICAL_OFFSET} >
                <View style={combinedOverlayStyle}>
                    <View style={styles.header}>
                        <Text h4 style={styles.overlayTitle}> {editFood ? t('addFoodModal.titleEdit') : t('addFoodModal.titleAdd')} </Text>
                        <Button title={editFood ? t('addFoodModal.buttonUpdate') : t('addFoodModal.buttonAdd')} onPress={handleCreateOrUpdate}
                                buttonStyle={[ styles.button, { backgroundColor: editFood ? theme.colors.warning : theme.colors.primary } ]}
                                titleStyle={styles.buttonTitle} loading={loading} disabled={isAnyLoading} containerStyle={styles.buttonContainer} />
                        <Icon name="close" type="material" size={28} color={theme.colors.text} onPress={!isAnyLoading ? toggleOverlay : undefined}
                              containerStyle={styles.closeIcon} disabled={isAnyLoading} disabledStyle={{ backgroundColor: 'transparent' }} />
                    </View>
                    <ScrollView keyboardShouldPersistTaps="handled">
                        <View style={styles.imageButtonContainer}>
                            <TouchableOpacity onPress={handleGetImageAndAnalyze} disabled={isAnyLoading} style={styles.iconButton}>
                                {aiImageLoading ? ( <ActivityIndicator size="small" color={theme.colors.primary} /> ) : (
                                    <Icon name="camera-enhance-outline" type="material-community" size={28} color={isAnyLoading ? theme.colors.grey3 : theme.colors.primary} />
                                )}
                            </TouchableOpacity>
                             <Text style={styles.imageButtonLabel}>{t('addFoodModal.getFromImage')}</Text>
                        </View>
                        {mode === "normal" ? (
                            <FoodFormFields values={getCurrentFoodData()} errors={errors} onInputChange={handleInputChange} isEditing={!!editFood} disabled={isAnyLoading} />
                        ) : (
                            <>
                                <View style={styles.backButtonContainer}>
                                    <Icon name="arrow-left" type="material-community" size={24} color={theme.colors.primary} onPress={() => !isAnyLoading && setMode("normal")} disabled={isAnyLoading} containerStyle={styles.backIcon} />
                                    <Text style={[styles.backButtonText, isAnyLoading && styles.disabledText]} onPress={() => !isAnyLoading && setMode("normal")}> {t('addFoodModal.backToManual')} </Text>
                                </View>
                                 <Input
                                    label={t('addFoodModal.ingredientsOptional')} labelStyle={styles.inputLabel} value={ingredients} onChangeText={setIngredients} multiline={true}
                                    numberOfLines={4} inputContainerStyle={[styles.inputContainerStyle, styles.multilineInputContainer]} inputStyle={[styles.inputStyle, styles.multilineInput]}
                                    placeholder={t('addFoodModal.ingredientsPlaceholder')} placeholderTextColor={theme.colors.grey3}
                                    leftIcon={<MaterialCommunityIcons name="format-list-bulleted" size={24} color={theme.colors.grey1} style={styles.multilineIcon} />}
                                    disabled={isAnyLoading}
                                />
                            </>
                        )}
                        <Button
                            title={mode === "normal" ? t('addFoodModal.aiCalculateRecipe') : ingredients ? t('addFoodModal.aiGetFromIngredients') : t('addFoodModal.aiGetFromNameOnly')}
                            onPress={handleAiTextButtonClick} buttonStyle={[styles.button, styles.aiButton, { backgroundColor: theme.colors.secondary }]}
                            titleStyle={styles.aiButtonTitle} loading={aiTextLoading} disabled={isAnyLoading}
                            icon={mode === "normal" ? <MaterialCommunityIcons name="text-box-search-outline" size={18} color={theme.colors.white} style={{ marginRight: 8 }} /> : undefined}
                            containerStyle={[styles.buttonContainer, { marginTop: 15 }]} />
                        <View style={styles.futureInputContainer}>
                            <Text style={styles.futureInputLabel}> {t('addFoodModal.barcodeComingSoon')} </Text>
                        </View>
                    </ScrollView>
                </View>
            </KeyboardAvoidingView>
        </Overlay>
    );
};

const useStyles = makeStyles((theme) => ({
    overlayContainer: { backgroundColor: 'transparent', width: '90%', maxWidth: 500, padding: 0, borderRadius: 15, shadowColor: "#000", shadowOffset: { width: 0, height: 2, }, shadowOpacity: 0.25, shadowRadius: 3.84, elevation: 5, overflow: 'hidden', },
    overlayStyle: { width: '100%', borderRadius: 15, padding: 20, paddingBottom: 30, maxHeight: '90%', backgroundColor: theme.colors.background },
    keyboardAvoidingView: { width: "100%", },
    header: { flexDirection: "row", justifyContent: "space-between", alignItems: "center", marginBottom: 20, paddingBottom: 10, borderBottomWidth: 1, borderBottomColor: theme.colors.divider, },
    overlayTitle: { color: theme.colors.text, fontWeight: "bold", fontSize: 20, flexShrink: 1, marginRight: 10, textAlign: 'left' },
    closeIcon: { padding: 5, marginLeft: 10, },
    imageButtonContainer: { flexDirection: 'row', alignItems: 'center', justifyContent: 'flex-start', marginBottom: 15, paddingHorizontal: 10, },
    iconButton: { padding: 8, marginRight: 8, },
    imageButtonLabel: { color: theme.colors.primary, fontSize: 14, fontWeight: '500', textAlign: 'left' },
    inputLabel: { color: theme.colors.text, fontWeight: '500', marginBottom: 2, fontSize: 14, textAlign: 'left' },
    inputContainerStyle: { borderBottomWidth: 1, borderBottomColor: theme.colors.grey4, marginBottom: 5, paddingBottom: 2, },
    inputStyle: { color: theme.colors.text, marginLeft: 10, fontSize: 16, textAlign: 'left' },
    multilineInputContainer: { borderWidth: 1, borderColor: theme.colors.grey4, borderRadius: 8, paddingVertical: 8, paddingHorizontal: 5, marginBottom: 10, borderBottomWidth: 1, borderBottomColor: theme.colors.grey4, minHeight: 100, },
    multilineInput: { marginLeft: 5, textAlignVertical: 'top', fontSize: 16, color: theme.colors.text, textAlign: 'left' },
    multilineIcon: { marginTop: 8, marginRight: 5, },
    futureInputContainer: { backgroundColor: theme.colors.grey5, padding: 15, borderRadius: 10, marginTop: 20, marginBottom: 10, alignItems: "center", },
    futureInputLabel: { color: theme.colors.grey2, fontStyle: "italic", },
    buttonContainer: { },
    button: { borderRadius: 8, paddingHorizontal: 15, paddingVertical: 10, },
    buttonTitle: { color: theme.colors.white, fontWeight: "600", fontSize: 15 },
    aiButton: { paddingVertical: 12, },
    aiButtonTitle: { fontWeight: "600", fontSize: 15, textAlign: 'center', },
    backButtonContainer: { flexDirection: "row", alignItems: "center", marginBottom: 15, marginTop: 5, },
    backIcon: { marginRight: 5, padding: 5, },
    backButtonText: { color: theme.colors.primary, fontSize: 16, fontWeight: '500', textAlign: 'left' },
    disabledText: { color: theme.colors.grey3, }
}));

export default AddFoodModal;
---------- END AddFoodModal.tsx ----------


---------- ConfirmationModal.tsx ----------
// src/components/ConfirmationModal.tsx
// components/ConfirmationModal.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Overlay, Button, Input, Text, useTheme } from '@rneui/themed';
import { t } from '../localization/i18n';

interface ConfirmationModalProps {
  isVisible: boolean;
  onCancel: () => void;
  onConfirm: () => void;
  confirmationText: string;
  setConfirmationText: (text: string) => void;
  title?: string;
  message?: string;
  inputPlaceholder?: string;
}

const ConfirmationModal: React.FC<ConfirmationModalProps> = ({
  isVisible,
  onCancel,
  onConfirm,
  confirmationText,
  setConfirmationText,
  title,
  message,
  inputPlaceholder
}) => {
  const { theme } = useTheme();

  const modalTitle = title || t('confirmationModal.defaultTitle');
  const modalMessage = message || t('confirmationModal.defaultMessage');
  const modalPlaceholder = inputPlaceholder || t('confirmationModal.enterTextPlaceholder');


  return (
    <Overlay
      isVisible={isVisible}
      onBackdropPress={onCancel}
      overlayStyle={styles.overlay}
      backdropStyle={styles.backdrop}
    >
      <View style={[styles.container, {backgroundColor: theme.colors.background}]}>
        <Text style={[styles.title, {color: theme.colors.text}]}>{modalTitle}</Text>
        <Text style={[styles.message, {color: theme.colors.text}]}>{modalMessage}</Text>
        <Input
          placeholder={modalPlaceholder}
          placeholderTextColor={theme.colors.grey3} // Adjusted for better visibility
          value={confirmationText}
          onChangeText={setConfirmationText}
          containerStyle={styles.inputContainer}
          inputStyle={{ color: theme.colors.text, textAlign: 'left' }}
          inputContainerStyle={{borderBottomColor: theme.colors.text}}
        />
        <View style={styles.buttonContainer}>
          <Button title={t('confirmationModal.cancel')} onPress={onCancel} type="outline" buttonStyle={styles.button} />
          <Button
            title={t('confirmationModal.confirm')}
            onPress={onConfirm}
            color="error"
            buttonStyle={styles.button}
            disabled={confirmationText === ""}
          />
        </View>
      </View>
    </Overlay>
  );
};

const styles = StyleSheet.create({
    overlay: {
        borderRadius: 10,
        width: '80%',
        padding: 6,
        backgroundColor: 'rgba(200, 200, 200, 0.5)'
    },
  container: {
    padding: 20,
    borderRadius: 7,
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 10,
    textAlign: 'center',
  },
  message: {
    marginBottom: 15,
    textAlign: 'center'
  },
  inputContainer: {
    marginBottom: 20,
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
  },
  button: {
    width: 100,
    padding: 10,
  },
  backdrop: {
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
});

export default ConfirmationModal;
---------- END ConfirmationModal.tsx ----------


---------- DailyEntryListItem.tsx ----------
// src/components/DailyEntryListItem.tsx
import React, { useState, useEffect, useCallback, memo, useMemo } from 'react';
import { View, StyleSheet } from 'react-native';
import { ListItem, Button, Icon as RNEIcon, useTheme, makeStyles, Text } from '@rneui/themed';
import { DailyEntryItem } from '../types/dailyEntry';
import { t } from '../localization/i18n';
import { calculateDailyEntryGrade, FoodGradeResult } from '../utils/gradingUtils';
import { Settings } from '../types/settings';
import { getFoodIconUrl } from '../utils/iconUtils';


interface DailyEntryListItemProps {
    item: DailyEntryItem;
    reversedIndex: number;
    foodIcons: { [foodName: string]: string | null };
    setFoodIcons: React.Dispatch<React.SetStateAction<{ [foodName: string]: string | null }>>;
    onEdit: (item: DailyEntryItem, reversedIndex: number) => void;
    onRemove: (reversedIndex: number) => void;
    isSaving: boolean;
    dailyGoals: Settings['dailyGoals'];
}

const DailyEntryListItem = memo<DailyEntryListItemProps>(({
    item,
    reversedIndex,
    foodIcons,
    setFoodIcons,
    onEdit,
    onRemove,
    isSaving,
    dailyGoals,
}) => {
    const { theme } = useTheme();
    const styles = useStyles();

    const iconIdentifier = useMemo(() => {
        if (item?.food?.name) {
            if (foodIcons[item.food.name] !== undefined) {
                return foodIcons[item.food.name];
            }
            return getFoodIconUrl(item.food.name); // No locale needed
        }
        return null;
    }, [item.food?.name, foodIcons]);

    useEffect(() => {
        if (item?.food?.name && iconIdentifier !== undefined && foodIcons[item.food.name] === undefined) {
            setFoodIcons(prev => ({ ...prev, [item.food.name]: iconIdentifier }));
        }
    }, [item.food?.name, iconIdentifier, foodIcons, setFoodIcons]);


    const gradeResult: FoodGradeResult | null = useMemo(() => {
        if (!item || !item.food || !dailyGoals) return null;
        return calculateDailyEntryGrade(item.food, item.grams, dailyGoals);
    }, [item, dailyGoals]);


    const renderListItemIcon = () => {
        if (!item?.food) {
             return (
                 <View style={[styles.foodIcon, styles.iconPlaceholder]}>
                     <RNEIcon name="help-circle-outline" type="ionicon" size={20} color={theme.colors.grey3} />
                 </View>
             );
        }
        if (iconIdentifier) {
            return <Text style={styles.foodIconEmoji}>{iconIdentifier}</Text>;
        } else {
            return (
                <View style={[styles.foodIcon, styles.iconPlaceholder]}>
                    <RNEIcon name="fast-food-outline" type="ionicon" size={20} color={theme.colors.grey3} />
                </View>
            );
        }
    };

     if (!item || !item.food) {
         return (
             <ListItem containerStyle={styles.listItemContainer}>
                 <ListItem.Content>
                      <ListItem.Title style={[{color: theme.colors.error}, styles.textLeft]}>{t('dailyEntryScreen.invalidEntryData')}</ListItem.Title>
                 </ListItem.Content>
             </ListItem>
         );
     }

    const handleEditPress = () => { if (!isSaving) onEdit(item, reversedIndex); };
    const handleDeletePress = () => { if (!isSaving) onRemove(reversedIndex); };

    const calculatedCalories = Math.round((item.food.calories / 100) * item.grams);
    const calculatedProtein = Math.round((item.food.protein / 100) * item.grams);
    const calculatedCarbs = Math.round((item.food.carbs / 100) * item.grams);
    const calculatedFat = Math.round((item.food.fat / 100) * item.grams);

    return (
        <ListItem.Swipeable
            bottomDivider
            leftContent={(reset) => (
                <Button
                    title={t('dailyEntryScreen.edit')}
                    onPress={() => { handleEditPress(); reset(); }}
                    icon={{ name: "edit", color: theme.colors.white }}
                    buttonStyle={styles.swipeButtonEdit}
                    titleStyle={styles.swipeButtonTitle}
                    disabled={isSaving}
                />
            )}
            rightContent={(reset) => (
                <Button
                    title={t('dailyEntryScreen.delete')}
                    onPress={() => { handleDeletePress(); reset(); }}
                    icon={{ name: "delete", color: theme.colors.white }}
                    buttonStyle={styles.swipeButtonDelete}
                    titleStyle={styles.swipeButtonTitle}
                    disabled={isSaving}
                />
            )}
            containerStyle={styles.listItemContainer}
        >
            {renderListItemIcon()}
            <ListItem.Content>
                <View style={styles.titleContainer}>
                    {gradeResult && (
                        <Text style={[styles.gradePill, { backgroundColor: gradeResult.color }]}>
                            {gradeResult.letter}
                        </Text>
                    )}
                    <ListItem.Title style={styles.listItemTitle}>
                        {item.food.name}
                    </ListItem.Title>
                </View>
                <ListItem.Subtitle style={styles.listItemSubtitle}>
                    {`${item.grams}g â€¢ Cal: ${calculatedCalories} P: ${calculatedProtein} C: ${calculatedCarbs} F: ${calculatedFat}`}
                </ListItem.Subtitle>
            </ListItem.Content>
            <ListItem.Chevron color={theme.colors.grey3} />
        </ListItem.Swipeable>
    );
});

const useStyles = makeStyles((theme) => ({
    foodIcon: { width: 40, height: 40, marginRight: 15, borderRadius: 8, alignItems: 'center', justifyContent: 'center', },
    foodIconEmoji: {
        fontSize: 28,
        width: 40,
        height: 40,
        marginRight: 15,
        textAlign: 'center',
        textAlignVertical: 'center',
    },
    iconPlaceholder: { backgroundColor: theme.colors.grey5, },
    listItemContainer: { backgroundColor: theme.colors.background, paddingVertical: 12, paddingHorizontal: 15, borderBottomColor: theme.colors.divider, },
    titleContainer: { flexDirection: 'row', alignItems: 'center', marginBottom: 3, },
    gradePill: {
        fontSize: 12,
        fontWeight: 'bold',
        color: theme.colors.white,
        paddingHorizontal: 6,
        paddingVertical: 2,
        borderRadius: 8,
        marginRight: 8,
        minWidth: 20,
        textAlign: 'center',
        overflow: 'hidden',
    },
    listItemTitle: {
        color: theme.colors.text,
        fontWeight: "600",
        fontSize: 16,
        flexShrink: 1,
        textAlign: 'left',
    },
    listItemSubtitle: { color: theme.colors.secondary, fontSize: 14, textAlign: 'left', },
    swipeButtonEdit: { minHeight: "100%", backgroundColor: theme.colors.warning, justifyContent: 'center', alignItems: 'center', },
    swipeButtonDelete: { minHeight: "100%", backgroundColor: theme.colors.error, justifyContent: 'center', alignItems: 'center', },
    swipeButtonTitle: { color: theme.colors.white, fontWeight: 'bold', fontSize: 15, },
    textLeft: { textAlign: 'left'},
}));

export default DailyEntryListItem;
---------- END DailyEntryListItem.tsx ----------


---------- DailyGoalsInput.tsx ----------
// src/components/DailyGoalsInput.tsx
// components/DailyGoalsInput.tsx
import React from "react";
import { Input, Text } from "@rneui/themed";
import { MacroType } from "../types/settings";
import { useTheme, makeStyles } from "@rneui/themed"; // Import makeStyles
import { t } from '../localization/i18n';

interface DailyGoalsInputProps {
    dailyGoals: { [key in MacroType]: number };
    onGoalChange: (goalType: MacroType, value: string) => void;
}

const DailyGoalsInput: React.FC<DailyGoalsInputProps> = ({
  dailyGoals,
  onGoalChange,
}) => {
  const { theme } = useTheme();
  const styles = useStyles(); // Use styles

  const getLabel = (macro: MacroType) => {
    switch(macro) {
        case 'calories': return t('dailyGoalsInput.caloriesGoal');
        case 'protein': return t('dailyGoalsInput.proteinGoal');
        case 'carbs': return t('dailyGoalsInput.carbsGoal');
        case 'fat': return t('dailyGoalsInput.fatGoal');
        default: return macro;
    }
  }

  return (
    <>
      {(["calories", "protein", "carbs", "fat"] as MacroType[]).map((macro) => (
        <Input
          key={macro}
          label={<Text style={[styles.labelStyle, { color: theme.colors.text }]}>{getLabel(macro)}</Text>}
          keyboardType="numeric"
          value={dailyGoals?.[macro]?.toString() || ""}
          onChangeText={(value) => onGoalChange(macro, value)}
          style={[styles.inputStyle, { color: theme.colors.text }]} // Apply inputStyle
          inputContainerStyle={{ borderBottomColor: theme.colors.text }}
        />
      ))}
    </>
  );
};

// Add useStyles
const useStyles = makeStyles((theme) => ({
    labelStyle: {
        color: theme.colors.text,
        fontWeight: 'normal', // RNEUI default is bold, make it normal if needed
        textAlign: 'left',
    },
    inputStyle: {
        textAlign: 'left',
    },
}));

export default DailyGoalsInput;
---------- END DailyGoalsInput.tsx ----------


---------- DailyProgress.tsx ----------
// src/components/DailyProgress.tsx
// components/DailyProgress.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, useTheme, makeStyles } from '@rneui/themed'; // Import makeStyles
import { t } from '../localization/i18n';

interface DailyProgressProps {
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
  goals: {
    calories?: number;
    protein?: number;
    carbs?: number;
    fat?: number;
  };
}

const DailyProgress: React.FC<DailyProgressProps> = ({
  calories,
  protein,
  carbs,
  fat,
  goals,
}) => {
  const { theme } = useTheme();
  const styles = useStyles(); // Use styles

  const calculateProgress = (current: number, goal?: number) => {
    if (!goal || goal <= 0) return 0;
    return Math.min(current / goal, 1);
  };

  const renderProgressBar = (labelKey: 'calories' | 'protein' | 'carbs' | 'fat', current: number, goal: number | undefined, color: string) => {
      const progress = calculateProgress(current, goal);
      const labelText = t(`dailyProgress.${labelKey}`);
      return (
          <View style={styles.macroContainer} key={labelKey}>
              <View style={styles.labelContainer}>
                    <Text style={[styles.macroLabel, {color: theme.colors.text}]}>{labelText}:</Text>
                    <Text style={[styles.macroValue, {color: theme.colors.text}]}>
                        {`${Math.round(current)} / ${goal || 0}`}
                    </Text>
              </View>
              <View style={styles.progressBarContainer}>
                  <View style={[styles.progressBar, { width: `${progress * 100}%`, backgroundColor: color }]} />
              </View>
          </View>
      )
  }

  return (
    <View style={styles.container}>
        {renderProgressBar('calories', calories, goals.calories, theme.colors.primary)}
        {renderProgressBar('protein', protein, goals.protein, theme.colors.success)}
        {renderProgressBar('carbs', carbs, goals.carbs, theme.colors.warning)}
        {renderProgressBar('fat', fat, goals.fat, theme.colors.error)}
    </View>
  );
};

// Update useStyles for text alignment
const useStyles = makeStyles((theme) => ({
  container: {
    marginBottom: 20,
    padding: 10,
    borderRadius: 8,
  },
  macroContainer: {
    marginBottom: 10,
  },
  labelContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 5,
  },
  macroLabel: {
    fontWeight: 'bold',
    textAlign: 'left',
  },
  macroValue: {
    textAlign: 'right',
  },
  progressBarContainer: {
      backgroundColor: theme.colors.grey5,
      borderRadius: 5,
      height: 10
  },
  progressBar: {
    height: 10,
    borderRadius: 5,
  },
}));

export default DailyProgress;
---------- END DailyProgress.tsx ----------


---------- DataManagementButtons.tsx ----------
// src/components/DataManagementButtons.tsx
// src/components/DataManagementButtons.tsx
import React, { useState } from "react";
import { Alert, Platform } from "react-native";
import { Button, Icon } from "@rneui/themed";
import * as DocumentPicker from "expo-document-picker";
import * as FileSystem from "expo-file-system";
import * as Sharing from 'expo-sharing';
import { formatDateISO } from "../utils/dateUtils";
import {
  clearAllData,
  loadDailyEntries,
  saveDailyEntries,
  loadFoods,
  saveFoods,
  loadSettings,
  saveSettings
} from "../services/storageService";
import ConfirmationModal from "./ConfirmationModal";
import { DailyEntry } from "../types/dailyEntry";
import { Food } from "../types/food";
import { Settings } from "../types/settings";
import { useTheme } from "@rneui/themed";
import { t } from '../localization/i18n';

interface DataManagementButtonsProps {
  onDataOperation: () => void;
}

const DataManagementButtons: React.FC<DataManagementButtonsProps> = ({
    onDataOperation
}) => {
  const [isConfirmationVisible, setIsConfirmationVisible] = useState(false);
  const [confirmationText, setConfirmationText] = useState("");
  const { theme } = useTheme();

  const handleExportData = async () => {
    try {
      const dailyEntries = await loadDailyEntries();
      const { items: foodItems } = await loadFoods(); // Correctly destructure to get the array of food items
      const settings = await loadSettings();
      
      const exportData = { dailyEntries, foods: foodItems, settings }; // Use the foodItems array
      
      const exportDataString = JSON.stringify(exportData, null, 2);
      const formattedDate = formatDateISO(new Date());
      const fileName = `macro_data_${formattedDate}.json`;
      const fileUri = FileSystem.documentDirectory + fileName;
      await FileSystem.writeAsStringAsync(fileUri, exportDataString, { encoding: FileSystem.EncodingType.UTF8, });
      if (!(await Sharing.isAvailableAsync())) {
        Alert.alert(t('dataManagement.exportError'), t('dataManagement.exportErrorNoSharing'));
        return;
      }
      await Sharing.shareAsync(fileUri, { mimeType: 'application/json', dialogTitle: t('dataManagement.exportData'), UTI: 'public.json' });
    } catch (error: any) {
      console.error("Export Error:", error);
      Alert.alert(t('dataManagement.exportFailed'), error.message || t('dataManagement.exportFailedMessage'));
    }
  };

  const handleImportData = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({ type: ["application/json", "public.json"], copyToCacheDirectory: true });
      if (result.canceled) { console.log(t('dataManagement.importCancelled')); return; }
      if (result.assets && result.assets.length > 0) {
        const file = result.assets[0];
        if (!file.name?.toLowerCase().endsWith(".json")) { Alert.alert(t('dataManagement.importInvalidFileType'), t('dataManagement.importInvalidFileTypeMessage')); return; }
        if (file.size && file.size > 10 * 1024 * 1024) { Alert.alert(t('dataManagement.importFileTooLarge'), t('dataManagement.importFileTooLargeMessage')); return; }
        const fileContent = await FileSystem.readAsStringAsync(file.uri, { encoding: FileSystem.EncodingType.UTF8, });
        try {
          const importedData = JSON.parse(fileContent);
          if ( typeof importedData !== 'object' || importedData === null || !importedData.hasOwnProperty("dailyEntries") || !Array.isArray(importedData.dailyEntries) || !importedData.hasOwnProperty("foods") || !Array.isArray(importedData.foods) || !importedData.hasOwnProperty("settings") || typeof importedData.settings !== 'object' ) {
            Alert.alert(t('dataManagement.importFailed'), t('dataManagement.importFailedInvalidStructure')); return;
          }
          await saveDailyEntries(importedData.dailyEntries as DailyEntry[]);
          await saveFoods(importedData.foods as Food[]);
          await saveSettings(importedData.settings as Settings);
          Alert.alert(t('dataManagement.importSuccessful'), t('dataManagement.importSuccessfulMessage'));
          onDataOperation();
        } catch (parseError) {
          console.error("JSON Parse Error during import:", parseError);
          Alert.alert(t('dataManagement.importFailed'), t('dataManagement.importFailedParseError')); return;
        }
      } else {
        Alert.alert(t('dataManagement.importFailed'), t('dataManagement.importFailedAccessError'));
      }
    } catch (error: any) {
      console.error("Import Error:", error);
      if (error.code === 'NO_PERMISSIONS') { Alert.alert(t('dataManagement.importFailed'), t('dataManagement.importFailedPermissionError')); }
      else { Alert.alert(t('dataManagement.importFailed'), error.message || t('dataManagement.importFailedUnknownError')); }
    }
  };

  const handleClearData = () => { setIsConfirmationVisible(true); };

  const confirmClearData = async () => {
    if (confirmationText.trim().toUpperCase() === "CLEAR DATA") {
      try {
        await clearAllData();
        Alert.alert(t('dataManagement.clearDataSuccess'), t('dataManagement.clearDataSuccessMessage'));
        onDataOperation();
      } catch (error: any) {
        console.error("Clear Data Error:", error);
        Alert.alert(t('dataManagement.clearDataFailed'), error.message || t('dataManagement.clearDataFailedMessage'));
      } finally {
        setConfirmationText(""); setIsConfirmationVisible(false);
      }
    } else {
      Alert.alert(t('dataManagement.clearConfirmationFailed'), t('dataManagement.clearConfirmationFailedMessage'));
    }
  };

  return (
    <>
      <Button
        title={t('dataManagement.exportData')}
        onPress={handleExportData}
        buttonStyle={{ marginBottom: 10, backgroundColor: theme.colors.primary }}
        icon={<Icon name="export" type="material-community" color="white" size={20} style={{ marginRight: 8 }} />}
      />
      <Button
        title={t('dataManagement.importData')}
        onPress={handleImportData}
        buttonStyle={{ marginBottom: 10, backgroundColor: theme.colors.primary }}
        icon={<Icon name="import" type="material-community" color="white" size={20} style={{ marginRight: 8 }} />}
      />
      <Button
        title={t('dataManagement.clearAllData')}
        onPress={handleClearData}
        color="error"
        buttonStyle={{ marginBottom: 10 }}
        icon={<Icon name="trash-can-outline" type="material-community" color="white" size={20} style={{ marginRight: 8 }} />}
      />
      <ConfirmationModal
        isVisible={isConfirmationVisible}
        onCancel={() => { setIsConfirmationVisible(false); setConfirmationText(""); }}
        onConfirm={confirmClearData}
        confirmationText={confirmationText}
        setConfirmationText={setConfirmationText}
        title={t('dataManagement.confirmClearTitle')}
        message={t('dataManagement.confirmClearMessage')}
        inputPlaceholder={t('dataManagement.confirmClearInputPlaceholder')}
      />
    </>
  );
};

export default DataManagementButtons;

---------- END DataManagementButtons.tsx ----------


---------- DateNavigator.tsx ----------
// src/components/DateNavigator.tsx
import React from 'react';
import { View, TouchableOpacity, StyleSheet } from 'react-native';
import { Button, Text, Icon as RNEIcon, useTheme, makeStyles } from '@rneui/themed';
import { parseISO, isValid } from 'date-fns';
import { formatDateReadableAsync } from '../utils/dateUtils'; // Import async version
import { t } from '../localization/i18n';
import i18n from '../localization/i18n';

interface DateNavigatorProps {
    selectedDate: string;
    onPreviousDay: () => void;
    onNextDay: () => void;
    onShowDatePicker: () => void;
    isSaving: boolean;
    isLoadingData: boolean;
}

const DateNavigator: React.FC<DateNavigatorProps> = ({
    selectedDate,
    onPreviousDay,
    onNextDay,
    onShowDatePicker,
    isSaving,
    isLoadingData,
}) => {
    const { theme } = useTheme();
    const styles = useStyles();
    const [displayDate, setDisplayDate] = React.useState(t('dateNavigator.invalidDate'));

    React.useEffect(() => {
        const updateDisplayDate = async () => {
            const parsedDate = parseISO(selectedDate);
            if (isValid(parsedDate)) {
                const formatted = await formatDateReadableAsync(parsedDate);
                setDisplayDate(formatted);
            } else {
                setDisplayDate(t('dateNavigator.invalidDate'));
            }
        };
        updateDisplayDate();
    }, [selectedDate, i18n.locale]); // Re-run when selectedDate or locale changes

    const isDisabled = isSaving || isLoadingData;

    return (
        <View style={styles.dateNavigation}>
            <Button
                type="clear"
                onPress={onPreviousDay}
                icon={<RNEIcon name="chevron-back-outline" type="ionicon" color={theme.colors.primary} size={28} />}
                buttonStyle={styles.navButton}
                disabled={isDisabled}
                disabledStyle={styles.disabledButton}
            />
            <TouchableOpacity onPress={onShowDatePicker} disabled={isDisabled}>
                <Text h4 h4Style={[styles.dateText, isDisabled && styles.disabledText]}>
                    {displayDate}
                </Text>
            </TouchableOpacity>
            <Button
                type="clear"
                onPress={onNextDay}
                icon={<RNEIcon name="chevron-forward-outline" type="ionicon" color={theme.colors.primary} size={28} />}
                buttonStyle={styles.navButton}
                disabled={isDisabled}
                disabledStyle={styles.disabledButton}
            />
        </View>
    );
};

const useStyles = makeStyles((theme) => ({
    dateNavigation: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
        paddingVertical: 10,
        paddingHorizontal: 10,
        backgroundColor: theme.colors.background,
    },
    navButton: {
        paddingHorizontal: 8,
    },
    dateText: {
        fontSize: 18,
        fontWeight: 'bold',
        color: theme.colors.text,
        textAlign: 'center',
        paddingVertical: 5,
    },
    disabledButton: {
        opacity: 0.5,
    },
    disabledText: {
        color: theme.colors.grey3,
    },
}));

export default DateNavigator;
---------- END DateNavigator.tsx ----------


---------- QuickAddItem.tsx ----------
// src/components/Entry/QuickAddItem.tsx
import React, { useMemo, useState } from "react";
import {
  View,
  TouchableOpacity,
  Pressable,
  ActivityIndicator,
} from "react-native";
import {
  ListItem,
  CheckBox,
  Input,
  Icon,
  Text,
  useTheme,
  makeStyles,
} from "@rneui/themed";
import { EstimatedFoodItem } from "../../types/macros";
import { Food } from "../../types/food";
import { isValidNumberInput } from "../../utils/validationUtils";
import { t } from "../../localization/i18n";
// import i18n from "../../localization/i18n"; // No longer needed here
import {
  calculateBaseFoodGrade,
  FoodGradeResult,
} from "../../utils/gradingUtils";
import { getFoodIconUrl } from "../../utils/iconUtils";


interface QuickAddItemProps {
  item: EstimatedFoodItem;
  index: number;
  isSelected: boolean;
  isEditingThisItem: boolean;
  isAnyItemEditing: boolean;
  isLoading?: boolean;
  foodIcons: { [foodName: string]: string | null };
  editedName: string;
  editedGrams: string;
  onToggleItem: (index: number) => void;
  onEditItem: (index: number) => void;
  onSaveEdit: () => void;
  onCancelEdit: () => void;
  onNameChange: (name: string) => void;
  onGramsChange: (grams: string) => void;
  onSaveToLibrary: (
    item: EstimatedFoodItem,
    setSavingState: (isSaving: boolean) => void
  ) => Promise<void>;
  foods: Food[];
}

const QuickAddItem: React.FC<QuickAddItemProps> = ({
  item,
  index,
  isSelected,
  isEditingThisItem,
  isAnyItemEditing,
  isLoading,
  foodIcons,
  editedName,
  editedGrams,
  onToggleItem,
  onEditItem,
  onSaveEdit,
  onCancelEdit,
  onNameChange,
  onGramsChange,
  onSaveToLibrary,
  foods,
}) => {
  const { theme } = useTheme();
  const styles = useStyles();
  const [isSavingToLibrary, setIsSavingToLibrary] = useState(false);

  const estimatedCalories = Math.round(
    (item.calories_per_100g / 100) * item.estimatedWeightGrams
  );

  const tempFoodForGrading: Food = useMemo(
    () => ({
      id: `temp-qa-${index}-${item.foodName}`,
      name: item.foodName,
      calories: item.calories_per_100g,
      protein: item.protein_per_100g,
      carbs: item.carbs_per_100g,
      fat: item.fat_per_100g,
    }),
    [
      item.foodName,
      item.calories_per_100g,
      item.protein_per_100g,
      item.carbs_per_100g,
      item.fat_per_100g,
      index,
    ]
  );

  const gradeResult: FoodGradeResult | null = useMemo(
    () => calculateBaseFoodGrade(tempFoodForGrading),
    [tempFoodForGrading]
  );

  const isInLibrary = useMemo(() => {
    return foods.some(food => food.name.toLowerCase() === item.foodName.toLowerCase());
  }, [foods, item.foodName]);

  const handleSaveToLibraryPress = async () => {
    if (isSavingToLibrary || isAnyItemEditing || isLoading) return;
    await onSaveToLibrary(item, setIsSavingToLibrary);
  };

  const renderFoodIcon = (foodName: string) => {
    // Check foodIcons state first, then call getFoodIconUrl (which handles its own caching and lang detection)
    const iconIdentifier = foodIcons[foodName] ?? getFoodIconUrl(foodName);
    if (iconIdentifier) {
      return <Text style={styles.foodIconEmoji}>{iconIdentifier}</Text>;
    }
    return (
      <View style={[styles.foodIconContainer, styles.iconPlaceholder]}>
        <Icon
          name="help-outline"
          type="material"
          size={22}
          color={theme.colors.grey3}
        />
      </View>
    );
  };

  const canPerformActions =
    !isAnyItemEditing && !isLoading && !isSavingToLibrary;

  return (
    <Pressable
      onPress={() => !isEditingThisItem && onToggleItem(index)}
      disabled={
        (isAnyItemEditing && !isEditingThisItem) ||
        isLoading ||
        isSavingToLibrary
      }
    >
      <ListItem
        bottomDivider
        containerStyle={[
          styles.quickAddItemContainer,
          isEditingThisItem && styles.quickAddItemEditing,
          isSelected && !isEditingThisItem && styles.quickAddItemSelected,
          ((isAnyItemEditing && !isEditingThisItem) ||
            isLoading ||
            isSavingToLibrary) &&
            styles.disabledItem,
        ]}
      >
        {isEditingThisItem ? (
          <View style={styles.quickAddEditView}>
            <View style={styles.editIconAndNameRow}>
              {renderFoodIcon(item.foodName)}
              {gradeResult && (
                <Text
                  style={[
                    styles.gradePill,
                    {
                      backgroundColor: gradeResult.color,
                      marginLeft: 0,
                      marginRight: 8,
                    },
                  ]}
                >
                  {gradeResult.letter}
                </Text>
              )}
              <Input
                value={editedName}
                onChangeText={onNameChange}
                placeholder={t("quickAddList.foodNamePlaceholder")}
                inputContainerStyle={styles.quickEditInputContainer}
                inputStyle={styles.quickEditInput}
                containerStyle={styles.quickEditNameContainer}
                autoFocus
                selectTextOnFocus
              />
            </View>
            <View style={styles.quickEditGramsRow}>
              <Input
                value={editedGrams}
                onChangeText={onGramsChange}
                placeholder={t("quickAddList.gramsPlaceholder")}
                keyboardType="numeric"
                inputContainerStyle={styles.quickEditInputContainer}
                inputStyle={styles.quickEditInput}
                containerStyle={styles.quickEditGramsContainer}
                rightIcon={<Text style={styles.quickEditUnitText}>g</Text>}
                errorMessage={
                  !isValidNumberInput(editedGrams) && editedGrams !== ""
                    ? t("quickAddList.errorInvalidGrams")
                    : ""
                }
                errorStyle={styles.inputError}
              />
              <TouchableOpacity
                onPress={onSaveEdit}
                style={styles.quickEditActionButton}
              >
                <Icon
                  name="checkmark-circle"
                  type="ionicon"
                  color={theme.colors.success}
                  size={28}
                />
              </TouchableOpacity>
              <TouchableOpacity
                onPress={onCancelEdit}
                style={styles.quickEditActionButton}
              >
                <Icon
                  name="close-circle"
                  type="ionicon"
                  color={theme.colors.error}
                  size={28}
                />
              </TouchableOpacity>
            </View>
          </View>
        ) : (
          <>
            <CheckBox
              checked={isSelected}
              onPress={() => onToggleItem(index)}
              containerStyle={styles.quickAddCheckbox}
              checkedColor={theme.colors.primary}
              disabled={!canPerformActions}
              size={22}
            />
            {renderFoodIcon(item.foodName)}
            <ListItem.Content>
              <View style={styles.titleAndGradeContainer}>
                {gradeResult && (
                  <Text
                    style={[
                      styles.gradePill,
                      { backgroundColor: gradeResult.color },
                    ]}
                  >
                    {gradeResult.letter}
                  </Text>
                )}
                <ListItem.Title
                  style={styles.quickAddItemTitle}
                  numberOfLines={1}
                  ellipsizeMode="tail"
                >
                  {item.foodName}
                </ListItem.Title>
              </View>
              <ListItem.Subtitle style={styles.quickAddItemSubtitle}>
                {`Est: ${Math.round(
                  item.estimatedWeightGrams
                )}g â€¢ ~${estimatedCalories} kcal`}
              </ListItem.Subtitle>
            </ListItem.Content>
            <View style={styles.actionButtonsContainer}>
              {isSavingToLibrary ? (
                <ActivityIndicator
                  size="small"
                  color={theme.colors.primary}
                  style={styles.actionIconPadding}
                />
              ) : (
                <TouchableOpacity
                  onPress={handleSaveToLibraryPress}
                  disabled={!canPerformActions}
                  style={styles.actionIconPadding}
                >
                  <Icon
                    name={isInLibrary ? "bookmark" : "bookmark-plus-outline"}
                    type="material-community"
                    size={22}
                    color={
                      canPerformActions
                        ? theme.colors.primary
                        : theme.colors.grey3
                    }
                  />
                </TouchableOpacity>
              )}
              <TouchableOpacity
                onPress={() => onEditItem(index)}
                disabled={!canPerformActions}
                style={styles.actionIconPadding}
              >
                <Icon
                  name="edit"
                  type="material"
                  size={22}
                  color={
                    canPerformActions ? theme.colors.grey1 : theme.colors.grey3
                  }
                />
              </TouchableOpacity>
            </View>
          </>
        )}
      </ListItem>
    </Pressable>
  );
};

const useStyles = makeStyles((theme) => ({
  quickAddItemContainer: {
    paddingVertical: 8,
    paddingHorizontal: 8,
    backgroundColor: theme.colors.background,
    borderBottomColor: theme.colors.divider,
    flexDirection: "row",
    alignItems: "center",
    minHeight: 65,
  },
  quickAddItemSelected: {
    backgroundColor: theme.colors.successLight,
    borderLeftWidth: 4,
    borderLeftColor: theme.colors.success,
  },
  quickAddItemEditing: {
    backgroundColor: theme.colors.background,
    paddingVertical: 12,
    paddingHorizontal: 10,
    borderWidth: 1.5,
    borderColor: theme.colors.primary,
    borderRadius: 8,
    marginVertical: 6,
    marginHorizontal: 2,
    shadowColor: theme.colors.black,
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.15,
    shadowRadius: 2.5,
    elevation: 4,
  },
  disabledItem: {
    opacity: 0.6,
  },
  quickAddCheckbox: {
    padding: 0,
    margin: 0,
    marginRight: 10,
    marginLeft: 0,
    backgroundColor: "transparent",
    borderWidth: 0,
  },
  foodIconContainer: {
    width: 38,
    height: 38,
    marginRight: 10,
    borderRadius: 6,
    alignItems: "center",
    justifyContent: "center",
    overflow: "hidden",
  },
  foodIconEmoji: {
    fontSize: 26,
    width: 38,
    height: 38,
    marginRight: 10,
    textAlign: 'center',
    textAlignVertical: 'center',
  },
  iconPlaceholder: {
    backgroundColor: theme.colors.grey5,
  },
  titleAndGradeContainer: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 2,
  },
  gradePill: {
    fontSize: 11,
    fontWeight: "bold",
    color: theme.colors.white,
    paddingHorizontal: 5,
    paddingVertical: 1,
    borderRadius: 6,
    marginRight: 6,
    minWidth: 18,
    textAlign: "center",
    overflow: "hidden",
  },
  quickAddItemTitle: {
    fontWeight: "600",
    color: theme.colors.text,
    fontSize: 15,
    textAlign: "left",
    flexShrink: 1,
  },
  quickAddItemSubtitle: {
    color: theme.colors.secondary,
    fontSize: 12.5,
    textAlign: "left",
  },
  actionButtonsContainer: {
    flexDirection: "row",
    alignItems: "center",
    marginLeft: 8,
  },
  actionIconPadding: {
    paddingVertical: 8,
    paddingHorizontal: 6,
  },
  quickAddEditView: {
    flex: 1,
  },
  editIconAndNameRow: {
    flexDirection: "row",
    alignItems: "center",
    marginBottom: 8,
  },
  quickEditInputContainer: {
    borderBottomWidth: 1,
    borderBottomColor: theme.colors.primary,
    height: 38,
    paddingHorizontal: 0,
  },
  quickEditInput: {
    fontSize: 15,
    color: theme.colors.text,
    paddingVertical: 0,
    textAlign: "left",
  },
  quickEditNameContainer: {
    flex: 1,
    paddingHorizontal: 0,
  },
  quickEditGramsRow: {
    flexDirection: "row",
    alignItems: "center",
    marginTop: 5,
  },
  quickEditGramsContainer: {
    flex: 1,
    paddingHorizontal: 0,
    marginRight: 10,
  },
  quickEditUnitText: {
    color: theme.colors.grey2,
    fontSize: 14,
    fontWeight: "500",
    paddingRight: 5,
  },
  quickEditActionButton: {
    paddingHorizontal: 8,
    paddingVertical: 5,
  },
  inputError: {
    color: theme.colors.error,
    fontSize: 11,
    marginVertical: 0,
    marginLeft: 2,
    height: 14,
    textAlign: "left",
  },
}));

export default QuickAddItem;
---------- END QuickAddItem.tsx ----------


---------- FoodFormFields.tsx ----------
// src/components/FoodFormFields.tsx
import React from 'react';
import { Input, makeStyles, useTheme, Text } from '@rneui/themed'; // Add Text
import { MaterialCommunityIcons } from '@expo/vector-icons';
import { Food } from '../types/food';
import { t } from '../localization/i18n';

type FoodFormValues = Partial<Omit<Food, 'id'>>;

interface FoodFormFieldsProps {
    values: FoodFormValues;
    errors: { [key: string]: string };
    onInputChange: (key: keyof Omit<Food, 'id'>, value: string, isEdit: boolean) => void;
    isEditing: boolean;
    disabled: boolean;
}

const FoodFormFields: React.FC<FoodFormFieldsProps> = ({
    values,
    errors,
    onInputChange,
    isEditing,
    disabled,
}) => {
    const { theme } = useTheme();
    const styles = useStyles();

    const getValue = (key: keyof Omit<Food, 'id'>): string => {
         const val = values[key];
         if (typeof val === 'number') {
              if (val === 0 && !isEditing) return "";
              return String(val);
         }
         return String(val ?? "");
    };

    const getErrorText = (fieldKey: keyof Omit<Food, 'id'>) => {
        const errorKey = errors[fieldKey];
        if (!errorKey) return "";
        // Assuming error keys in en.json map to field names + specific error type
        // e.g., foodFormFields.errorNameRequired, foodFormFields.errorNonNegative
        // This might need adjustment based on how specific your error keys are.
        if (fieldKey === 'name' && errorKey === 'Name is required') return t('foodFormFields.errorNameRequired');
        if (['calories', 'protein', 'carbs', 'fat'].includes(fieldKey) && errorKey === 'Must be a non-negative number') {
            return t('foodFormFields.errorNonNegative');
        }
        return errorKey; // Fallback to the raw error key if no specific translation found
    };

    return (
        <>
            <Input
                label={<Text style={styles.labelStyle}>{t('foodFormFields.foodName')}</Text>}
                value={getValue("name")}
                onChangeText={(text) => onInputChange("name", text, isEditing)}
                errorMessage={getErrorText("name")}
                errorStyle={styles.errorStyle}
                inputContainerStyle={styles.inputContainerStyle}
                inputStyle={styles.inputStyle}
                leftIcon={<MaterialCommunityIcons name="food-apple" size={24} color={errors.name ? theme.colors.error : theme.colors.grey1} />}
                disabled={disabled}
                autoCapitalize="words"
            />
            <Input
                label={<Text style={styles.labelStyle}>{t('foodFormFields.calories')}</Text>}
                keyboardType="numeric" value={getValue("calories")}
                onChangeText={(text) => onInputChange("calories", text, isEditing)}
                errorMessage={getErrorText("calories")}
                errorStyle={styles.errorStyle}
                inputContainerStyle={styles.inputContainerStyle}
                inputStyle={styles.inputStyle}
                leftIcon={<MaterialCommunityIcons name="fire" size={24} color={errors.calories ? theme.colors.error : theme.colors.grey1} />}
                disabled={disabled}
            />
            <Input
                label={<Text style={styles.labelStyle}>{t('foodFormFields.protein')}</Text>}
                keyboardType="numeric" value={getValue("protein")}
                onChangeText={(text) => onInputChange("protein", text, isEditing)}
                errorMessage={getErrorText("protein")}
                errorStyle={styles.errorStyle}
                inputContainerStyle={styles.inputContainerStyle}
                inputStyle={styles.inputStyle}
                leftIcon={<MaterialCommunityIcons name="food-drumstick" size={24} color={errors.protein ? theme.colors.error : theme.colors.grey1} />}
                disabled={disabled}
            />
            <Input
                label={<Text style={styles.labelStyle}>{t('foodFormFields.carbs')}</Text>}
                keyboardType="numeric" value={getValue("carbs")}
                onChangeText={(text) => onInputChange("carbs", text, isEditing)}
                errorMessage={getErrorText("carbs")}
                errorStyle={styles.errorStyle}
                inputContainerStyle={styles.inputContainerStyle}
                inputStyle={styles.inputStyle}
                leftIcon={<MaterialCommunityIcons name="bread-slice" size={24} color={errors.carbs ? theme.colors.error : theme.colors.grey1} />}
                disabled={disabled}
            />
            <Input
                label={<Text style={styles.labelStyle}>{t('foodFormFields.fat')}</Text>}
                keyboardType="numeric" value={getValue("fat")}
                onChangeText={(text) => onInputChange("fat", text, isEditing)}
                errorMessage={getErrorText("fat")}
                errorStyle={styles.errorStyle}
                inputContainerStyle={styles.inputContainerStyle}
                inputStyle={styles.inputStyle}
                leftIcon={<MaterialCommunityIcons name="oil" size={24} color={errors.fat ? theme.colors.error : theme.colors.grey1} />}
                disabled={disabled}
            />
        </>
    );
};

const useStyles = makeStyles((theme) => ({
    labelStyle: { color: theme.colors.text, fontWeight: '500', marginBottom: 2, fontSize: 14, textAlign: 'left' },
    inputContainerStyle: { borderBottomWidth: 1, borderBottomColor: theme.colors.grey4, marginBottom: 5, paddingBottom: 2, },
    inputStyle: { color: theme.colors.text, marginLeft: 10, fontSize: 16, textAlign: 'left' },
    errorStyle: { color: theme.colors.error, textAlign: 'left' }
}));

export default FoodFormFields;
---------- END FoodFormFields.tsx ----------


---------- FoodItem.tsx ----------
// src/components/FoodItem.tsx
import React, { forwardRef, useCallback, memo, useMemo, useEffect } from "react";
import { StyleSheet, View, TouchableOpacity } from "react-native";
import { ListItem, Icon as RNEIcon, useTheme, Button, makeStyles, Text } from "@rneui/themed";
import { Food } from "../types/food";
import Toast from "react-native-toast-message";
import { t } from '../localization/i18n';
// import i18n from "../localization/i18n"; // No longer needed here
import { calculateBaseFoodGrade, FoodGradeResult } from "../utils/gradingUtils";
import { getFoodIconUrl } from "../utils/iconUtils";


interface FoodItemProps {
  food: Food;
  onEdit: (food: Food) => void;
  onDelete: (foodId: string) => void;
  onUndoDelete: (food: Food) => void;
  onQuickAdd: (food: Food) => void;
  onShare: (food: Food) => void;
  foodIconUrl: string | null; 
  setFoodIconForName: (name: string, icon: string | null) => void;
}

const FoodItem = memo(forwardRef<any, FoodItemProps>(
  ({ food, onEdit, onDelete, onUndoDelete, onQuickAdd, onShare, foodIconUrl, setFoodIconForName }, ref) => {
    const { theme } = useTheme();
    const styles = useStyles();

    const iconIdentifier = useMemo(() => {
        if (foodIconUrl !== undefined) return foodIconUrl; 
        return getFoodIconUrl(food.name); // No locale needed
    }, [food.name, foodIconUrl]);

    useEffect(() => {
        if (food.name && iconIdentifier !== undefined && foodIconUrl === undefined) {
            setFoodIconForName(food.name, iconIdentifier);
        }
    }, [food.name, iconIdentifier, foodIconUrl, setFoodIconForName]);


    const gradeResult: FoodGradeResult | null = useMemo(() => {
        return calculateBaseFoodGrade(food);
    }, [food]);

    const handleUndo = useCallback(() => {
         onUndoDelete(food);
    }, [food, onUndoDelete]);

    const handleDelete = useCallback(() => {
      onDelete(food.id);
       Toast.show({
            type: 'info',
            text1: t('foodListScreen.foodDeleted', { foodName: food.name }),
            text2: t('dailyEntryScreen.undo'), 
            position: 'bottom',
            visibilityTime: 4000,
            onPress: handleUndo,
            bottomOffset: 80,
        });
    }, [food.id, food.name, onDelete, handleUndo, t]);


    const renderIcon = () => {
        if (iconIdentifier) {
            return <Text style={styles.foodIconEmoji}>{iconIdentifier}</Text>;
        } else {
            return (
                <View style={[styles.foodIconPlaceholderView]}>
                    <RNEIcon name="help-outline" type="material" size={22} color={theme.colors.grey3} />
                </View>
            );
        }
    };

    return (
      <ListItem.Swipeable
        ref={ref}
        bottomDivider
        leftContent={(reset) => (
          <Button title={t('foodListScreen.edit')} onPress={() => { onEdit(food); reset(); }} icon={{ name: "edit", color: theme.colors.white }} buttonStyle={styles.swipeButtonEdit} titleStyle={styles.swipeButtonTitle} />
        )}
        rightContent={(reset) => (
          <Button title={t('foodListScreen.delete')} onPress={() => { handleDelete(); reset(); }} icon={{ name: "delete", color: theme.colors.white }} buttonStyle={styles.swipeButtonDelete} titleStyle={styles.swipeButtonTitle} />
        )}
        containerStyle={styles.listItemContainer}
      >
        {renderIcon()}
        <ListItem.Content>
          <View style={styles.titleContainer}>
            {gradeResult && (
                <Text style={[styles.gradePill, { backgroundColor: gradeResult.color }]}>
                    {gradeResult.letter}
                </Text>
            )}
            <ListItem.Title style={styles.title}>
                {food.name}
            </ListItem.Title>
          </View>
          <ListItem.Subtitle style={styles.subtitle}>
            {`100g: Cal: ${Math.round(food.calories)} P: ${Math.round(food.protein)} C: ${Math.round(food.carbs)} F: ${Math.round(food.fat)}`}
          </ListItem.Subtitle>
        </ListItem.Content>
        <TouchableOpacity onPress={() => onShare(food)} style={styles.actionButton} hitSlop={{ top: 10, bottom: 10, left: 5, right: 5 }}>
            <RNEIcon name="share-variant-outline" type="material-community" color={theme.colors.primary} size={24} />
        </TouchableOpacity>
        <TouchableOpacity onPress={() => onQuickAdd(food)} style={styles.actionButton} hitSlop={{ top: 10, bottom: 10, left: 5, right: 5 }}>
            <RNEIcon name="add-circle-outline" type="ionicon" color={theme.colors.primary} size={26} />
        </TouchableOpacity>
        <ListItem.Chevron color={theme.colors.grey3} />
      </ListItem.Swipeable>
    );
  }
));

const useStyles = makeStyles((theme) => ({
    listItemContainer: { backgroundColor: theme.colors.background, paddingVertical: 12, paddingHorizontal: 15, borderBottomColor: theme.colors.divider, },
    titleContainer: { flexDirection: 'row', alignItems: 'center', marginBottom: 3, },
    gradePill: {
        fontSize: 12,
        fontWeight: 'bold',
        color: theme.colors.white, 
        paddingHorizontal: 6,
        paddingVertical: 2,
        borderRadius: 8,
        marginRight: 8,
        minWidth: 20, 
        textAlign: 'center',
        overflow: 'hidden', 
    },
    title: { color: theme.colors.text, fontWeight: "600", fontSize: 16, flexShrink: 1, textAlign: 'left', }, 
    subtitle: { color: theme.colors.secondary, fontSize: 13, marginTop: 2, textAlign: 'left', },
    swipeButtonEdit: { minHeight: "100%", backgroundColor: theme.colors.warning, justifyContent: 'center', alignItems: 'center', },
    swipeButtonDelete: { minHeight: "100%", backgroundColor: theme.colors.error, justifyContent: 'center', alignItems: 'center', },
    swipeButtonTitle: { color: theme.colors.white, fontWeight: 'bold', fontSize: 15, },
    foodIconEmoji: {
        fontSize: 28,
        width: 40,
        height: 40,
        marginRight: 15,
        textAlign: 'center',
        textAlignVertical: 'center',
    },
    foodIconPlaceholderView: {
        width: 40, 
        height: 40, 
        marginRight: 15, 
        borderRadius: 8, 
        alignItems: 'center', 
        justifyContent: 'center',
        backgroundColor: theme.colors.grey5,
    },
    actionButton: { 
        paddingHorizontal: 8,
        justifyContent: 'center',
        alignItems: 'center',
        marginLeft: 5,
    },
}));

export default FoodItem;
---------- END FoodItem.tsx ----------


---------- QuickAddList.tsx ----------
// src/components/QuickAddList.tsx
import React from 'react';
import {
    View,
    FlatList,
    ActivityIndicator,
} from 'react-native';
import {
    Icon,
    Text,
    useTheme,
    makeStyles,
} from '@rneui/themed';
import { EstimatedFoodItem } from '../types/macros';
import { Food } from '../types/food'; // Import Food type
import { t } from '../localization/i18n';
import QuickAddItem from './Entry/QuickAddItem';

interface QuickAddListProps {
    items: EstimatedFoodItem[];
    selectedIndices: Set<number>;
    editingIndex: number | null;
    editedName: string;
    editedGrams: string;
    onToggleItem: (index: number) => void;
    onEditItem: (index: number) => void;
    onSaveEdit: () => void;
    onCancelEdit: () => void;
    onNameChange: (name: string) => void;
    onGramsChange: (grams: string) => void;
    style?: object;
    isLoading?: boolean;
    foodIcons: { [foodName: string]: string | null | undefined };
    onSaveItemToLibrary: (item: EstimatedFoodItem, setSavingState: (isSaving: boolean) => void) => Promise<void>;
    foods: Food[]; // Add foods prop
}

const QuickAddList: React.FC<QuickAddListProps> = ({
    items,
    selectedIndices,
    editingIndex,
    editedName,
    editedGrams,
    onToggleItem,
    onEditItem,
    onSaveEdit,
    onCancelEdit,
    onNameChange,
    onGramsChange,
    style,
    isLoading,
    foodIcons,
    onSaveItemToLibrary,
    foods, // Destructure foods
}) => {
    const { theme } = useTheme();
    const styles = useStyles();

    const renderItem = ({ item, index }: { item: EstimatedFoodItem; index: number }) => {
        const isSelected = selectedIndices.has(index);
        const isEditingThisItem = editingIndex === index;
        const isAnyItemEditing = editingIndex !== null;

        return (
            <QuickAddItem
                item={item}
                index={index}
                isSelected={isSelected}
                isEditingThisItem={isEditingThisItem}
                isAnyItemEditing={isAnyItemEditing}
                isLoading={isLoading}
                foodIcons={foodIcons}
                editedName={isEditingThisItem ? editedName : ''}
                editedGrams={isEditingThisItem ? editedGrams : ''}
                onToggleItem={onToggleItem}
                onEditItem={onEditItem}
                onSaveEdit={onSaveEdit}
                onCancelEdit={onCancelEdit}
                onNameChange={onNameChange}
                onGramsChange={onGramsChange}
                onSaveToLibrary={onSaveItemToLibrary}
                foods={foods} // Pass foods to QuickAddItem
            />
        );
    };

    if (isLoading && items.length === 0) {
         return (
             <View style={styles.centeredContent}>
                 <ActivityIndicator size="large" color={theme.colors.primary} />
                 <Text style={styles.loadingText}>{t('quickAddList.analyzing')}</Text>
             </View>
         );
    }

    return (
        <FlatList
            data={items}
            keyExtractor={(item, index) => `quickadd-${index}-${item.foodName}-${item.estimatedWeightGrams}`}
            renderItem={renderItem}
            ListEmptyComponent={
                !isLoading ? (
                    <View style={styles.emptyListContainer}>
                        <Icon name="image-search-outline" type="material-community" size={48} color={theme.colors.grey3} />
                        <Text style={styles.emptyListText}>{t('quickAddList.emptyMessage')}</Text>
                        <Text style={styles.emptyListSubText}>{t('quickAddList.emptyHint')}</Text>
                    </View>
                ) : null
            }
            style={[styles.listDefaults, style]}
            extraData={{ selectedIndices, editingIndex, foodIcons, isLoading, editedName, editedGrams, foodsLength: foods.length }}
            keyboardShouldPersistTaps="handled"
            contentContainerStyle={items.length === 0 && !isLoading ? styles.listContentContainerEmpty : {paddingBottom: 10}}
        />
    );
};

const useStyles = makeStyles((theme) => ({
    listDefaults: {},
    listContentContainerEmpty: { flexGrow: 1, justifyContent: 'center', },
    emptyListContainer: {
        alignItems: "center",
        justifyContent: 'center',
        paddingVertical: 40,
        paddingHorizontal: 20,
        flexGrow: 1,
    },
    emptyListText: {
        color: theme.colors.grey2,
        fontSize: 16,
        textAlign: "center",
        marginTop: 15,
        fontWeight: '500',
    },
    emptyListSubText: {
        fontSize: 14,
        color: theme.colors.grey3,
        textAlign: "center",
        marginTop: 8,
    },
    centeredContent: {
        flex: 1,
        alignItems: 'center',
        justifyContent: 'center',
        padding: 20,
        minHeight: 200,
    },
    loadingText: {
        marginTop: 12,
        color: theme.colors.text,
        fontSize: 16,
        fontWeight: "500",
    },
}));

export default QuickAddList;
---------- END QuickAddList.tsx ----------


---------- StatisticsChart.tsx ----------
// src/components/StatisticsChart.tsx
import React from "react";
import { View, StyleSheet, Platform } from "react-native";
import { WebView } from "react-native-webview";
import { Statistics, MacroType, macros as macroKeys } from "../types/settings";
import { useTheme } from "@rneui/themed";
import { t } from '../localization/i18n';
import i18n from '../localization/i18n'; // Import i18n for locale
import * as Localization from 'expo-localization'; // Import Localization

// Declare uPlot as a global variable for TypeScript, as it's loaded via CDN in the WebView
declare const uPlot: any;

// Local interface for uPlot Series configuration to help TypeScript
interface uPlotSeriesConfig {
  stroke?: string;
  width?: number;
  label?: string;
  points?: { show?: boolean; size?: number; fill?: string; stroke?: string; };
  dash?: number[];
  // Add other series properties if you use them
}

interface StatisticsChartProps {
  statistics: Statistics;
}

const StatisticsChart: React.FC<StatisticsChartProps> = ({ statistics }) => {
  const { theme } = useTheme();

  const getChartTitle = (macro: MacroType): string => {
    switch(macro) {
        case 'calories': return t('dailyProgress.calories');
        case 'protein': return t('dailyProgress.protein');
        case 'carbs': return t('dailyProgress.carbs');
        case 'fat': return t('dailyProgress.fat');
        default:
            const exhaustiveCheck: never = macro;
            return exhaustiveCheck;
    }
  };

  const chartHeightInHTML = 250;
  const chartVerticalMarginInHTML = 20;
  const totalEstimatedWebViewHeight = macroKeys.length * (chartHeightInHTML + chartVerticalMarginInHTML) + 40; // Extra padding for safety

  const generateChartHTML = () => {
    const chartData = (macroKeys as readonly MacroType[]).reduce((acc, macro) => {
      acc[macro] = statistics[macro].map((series) =>
        series.map((item) => ({ x: item.x / 1000, y: item.y })) // Ensure x is in seconds
      );
      return acc;
    }, {} as { [key in MacroType]: { x: number; y: number }[][] });

    const textColor = theme.colors.text;
    const gridColor = theme.colors.grey5;
    const fontFamily = Platform.OS === 'ios' ? "System" : "sans-serif";

    const lineColors = {
      calories: theme.colors.primary, protein: theme.colors.success,
      carbs: theme.colors.warning, fat: theme.colors.error,
    };

    return `
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
            <title>Macro Charts</title>
            <style>
                body { font-family: ${fontFamily}; margin: 0; padding: 0; background-color: ${theme.colors.background}; color: ${textColor}; overflow-x: hidden; }
                .chart-container { width: 95%; height: ${chartHeightInHTML}px; margin: ${chartVerticalMarginInHTML / 2}px auto; }
                .no-data-message { display: flex; align-items: center; justify-content: center; height: 100%; text-align: center; color: ${textColor}; font-size: 14px; }
                .u-legend .u-series > td { min-width: 50px; } /* Ensure legend items have some width */
            </style>
            <link rel="stylesheet" href="https://unpkg.com/uplot@1.6.27/dist/uPlot.min.css">
            <script src="https://unpkg.com/uplot@1.6.27/dist/uPlot.iife.min.js"></script>
        </head>
        <body>
            ${(macroKeys as readonly MacroType[]).map((macro) => {
                const currentMacroData = chartData[macro];
                const chartTitle = getChartTitle(macro);
                const isCalories = macro === "calories";

                const seriesConfig: uPlotSeriesConfig[] = [
                    {}, // For X-axis (time)
                    { // Intake series
                        stroke: lineColors[macro] || theme.colors.primary,
                        width: 2,
                        label: isCalories ? t('statisticsChart.intake') : chartTitle,
                        points: { show: false }
                    }
                ];
                if (isCalories) {
                    seriesConfig.push({ // Goal series for calories
                        stroke: "red",
                        width: 1.5,
                        dash: [10, 5],
                        label: t('statisticsChart.goal'),
                        points: { show: false }
                    });
                }

                return `
                <div id="${macro}-chart" class="chart-container">
                    <div class="no-data-message">${t("statisticsChart.noData", { chartTitle: chartTitle })}</div>
                </div>
                <script>
                    (function() {
                        const chartElement = document.getElementById('${macro}-chart');
                        try {
                            const dataForChart = ${JSON.stringify(currentMacroData)};
                            console.log('--- uPlot Init for ${macro} ---');
                            console.log('Data For Chart (${macro}):', JSON.stringify(dataForChart));
                            
                            let xValues = [];
                            let yValuesIntake = [];
                            let yValuesGoal = [];
                            let canRender = false;

                            if (dataForChart && dataForChart.length > 0 && dataForChart[0] && Array.isArray(dataForChart[0]) && dataForChart[0].length >= 1) { // Need at least 1 point to attempt render, uPlot handles single points
                                xValues = dataForChart[0].map(d => d.x);
                                yValuesIntake = dataForChart[0].map(d => d.y);
                                canRender = true; 
                                
                                if (${isCalories} && dataForChart.length > 1 && dataForChart[1] && Array.isArray(dataForChart[1])) {
                                    // Align goal data to intake's xValues
                                    const tempGoalMap = new Map(dataForChart[1].map(p => [p.x, p.y]));
                                    yValuesGoal = xValues.map(x => tempGoalMap.get(x) === undefined ? null : tempGoalMap.get(x));
                                } else if (${isCalories}) {
                                    yValuesGoal = new Array(xValues.length).fill(null); // Ensure goal array exists if no data
                                }
                            }

                            console.log('Can Render (${macro}):', canRender);
                            console.log('X Values (${macro}):', JSON.stringify(xValues));
                            console.log('Y Intake (${macro}):', JSON.stringify(yValuesIntake));
                            if (${isCalories}) {
                                console.log('Y Goal (${macro}):', JSON.stringify(yValuesGoal));
                            }

                            if (canRender) {
                                chartElement.innerHTML = ''; // Clear "no data" message
                                const uPlotInstanceData = ${isCalories} ? [xValues, yValuesIntake, yValuesGoal] : [xValues, yValuesIntake];
                                
                                const opts = {
                                    title: "${chartTitle}",
                                    width: chartElement.offsetWidth,
                                    height: ${chartHeightInHTML},
                                    tzDate: ts => uPlot.tzDate(new Date(ts * 1000), '${Localization.getCalendars()?.[0]?.timeZone || 'UTC'}'),
                                    scales: { x: { time: true }, y: { range: (self, min, max) => [0, Math.max(10, max * 1.1)] } }, // y-axis starts at 0, ensure some height even for small values
                                    axes: [
                                        { stroke: "${textColor}", font: "12px ${fontFamily}", grid: { stroke: "${gridColor}", width: 1 }, ticks: { stroke: "${gridColor}", width: 1 } },
                                        { stroke: "${textColor}", font: "12px ${fontFamily}", grid: { stroke: "${gridColor}", width: 1 }, ticks: { stroke: "${gridColor}", width: 1 }, values: (self, ticks) => ticks.map(rawValue => Math.round(rawValue)) }
                                    ],
                                    series: ${JSON.stringify(seriesConfig)},
                                    cursor: { drag: { setScale: false }, focus: { prox: 30 }, points: { size: 6, fill: (self, i) => self.series[i]._stroke, stroke: (self, i) => self.series[i]._stroke } },
                                    ${isCalories ? `
                                    hooks: {
                                        draw: [
                                            (u) => {
                                                const { ctx, data } = u;
                                                if (!data || data.length < 3 || !data[0] || !data[1] || !data[2]) return; // Need all three series for calories (x, intake, goal)
                                                if (!u.series[1] || !u.series[1].show || !u.series[2] || !u.series[2].show) return;

                                                const ts = data[0];
                                                const intake = data[1];
                                                const goal = data[2];

                                                if (ts.length < 2) return; // Need at least two points to draw an area

                                                ctx.save();
                                                ctx.fillStyle = "rgba(255, 0, 0, 0.15)";
                                                
                                                let currentSegment = [];

                                                for (let i = 0; i < ts.length; i++) {
                                                    if (intake[i] != null && goal[i] != null && intake[i] > goal[i]) {
                                                        currentSegment.push({ x: ts[i], intakeY: intake[i], goalY: goal[i] });
                                                    } else {
                                                        if (currentSegment.length > 0) {
                                                            // Draw filled segment
                                                            ctx.beginPath();
                                                            ctx.moveTo(u.valToPos(currentSegment[0].x, "x", true), u.valToPos(currentSegment[0].goalY, "y", true));
                                                            currentSegment.forEach(pt => ctx.lineTo(u.valToPos(pt.x, "x", true), u.valToPos(pt.intakeY, "y", true)));
                                                            for (let k = currentSegment.length - 1; k >= 0; k--) {
                                                                ctx.lineTo(u.valToPos(currentSegment[k].x, "x", true), u.valToPos(currentSegment[k].goalY, "y", true));
                                                            }
                                                            ctx.closePath();
                                                            ctx.fill();
                                                            currentSegment = [];
                                                        }
                                                    }
                                                }
                                                // Draw any remaining segment
                                                if (currentSegment.length > 0) {
                                                    ctx.beginPath();
                                                    ctx.moveTo(u.valToPos(currentSegment[0].x, "x", true), u.valToPos(currentSegment[0].goalY, "y", true));
                                                    currentSegment.forEach(pt => ctx.lineTo(u.valToPos(pt.x, "x", true), u.valToPos(pt.intakeY, "y", true)));
                                                    for (let k = currentSegment.length - 1; k >= 0; k--) {
                                                        ctx.lineTo(u.valToPos(currentSegment[k].x, "x", true), u.valToPos(currentSegment[k].goalY, "y", true));
                                                    }
                                                    ctx.closePath();
                                                    ctx.fill();
                                                }
                                                ctx.restore();
                                            }
                                        ]
                                    }` : ''}
                                };
                                console.log('uPlot opts for ${macro}:', JSON.stringify(opts.series));
                                console.log('uPlot data for ${macro}:', JSON.stringify(uPlotInstanceData));
                                new uPlot(opts, uPlotInstanceData, chartElement);
                                console.log('--- uPlot instance CREATED for ${macro} ---');
                            } else {
                                console.log('--- Condition to render uPlot NOT MET for ${macro} ---');
                            }
                        } catch (e) {
                            console.error('--- ERROR in uPlot script for ${macro} ---', e.message, e.stack);
                            chartElement.innerHTML = '<div class="no-data-message" style="color:red;">Chart Error: ' + e.message + '</div>';
                        }
                    })();
                </script>
            `;}).join("")}
        </body>
        </html>
        `;
  };

  return (
    <View style={[styles.webViewContainer, { height: totalEstimatedWebViewHeight }]}>
      <WebView
        originWhitelist={["*"]}
        source={{ html: generateChartHTML(), baseUrl: Platform.OS === 'android' ? 'file:///android_asset/' : '' }} // baseUrl for Android
        style={styles.webView}
        scalesPageToFit={Platform.OS === 'android'}
        scrollEnabled={false}
        javaScriptEnabled={true}
        domStorageEnabled={true}
        onError={(syntheticEvent) => {
          const {nativeEvent} = syntheticEvent;
          console.warn('WebView error: ', nativeEvent);
        }}
        onHttpError={(syntheticEvent) => { // Useful for 404s on resources like uPlot CSS/JS if CDN fails
            const {nativeEvent} = syntheticEvent;
            console.warn('WebView HTTP error: ', nativeEvent.url, nativeEvent.statusCode, nativeEvent.description);
        }}
        // Log messages from WebView's console.log to React Native console
        onMessage={(event) => {
            console.log("WebView Message:", event.nativeEvent.data);
        }}
        // Inject JavaScript to bridge console.log, console.error, etc.
        // Note: This basic bridge might not capture all nuances or complex objects perfectly.
        injectedJavaScript={`
            (function() {
                const originalConsoleLog = console.log;
                const originalConsoleError = console.error;
                const originalConsoleWarn = console.warn;
                const originalConsoleInfo = console.info;
                const originalConsoleDebug = console.debug;

                const rnBridgePost = (type, args) => {
                    const message = args.map(arg => {
                        if (typeof arg === 'object' || typeof arg === 'function') {
                            try {
                                return JSON.stringify(arg);
                            } catch (e) {
                                return '[Unserializable Object]';
                            }
                        }
                        return String(arg);
                    }).join(' ');
                    window.ReactNativeWebView.postMessage(JSON.stringify({ type: 'CONSOLE', level: type, message: message }));
                };

                console.log = function() { originalConsoleLog.apply(console, arguments); rnBridgePost('LOG', Array.from(arguments)); };
                console.error = function() { originalConsoleError.apply(console, arguments); rnBridgePost('ERROR', Array.from(arguments)); };
                console.warn = function() { originalConsoleWarn.apply(console, arguments); rnBridgePost('WARN', Array.from(arguments)); };
                console.info = function() { originalConsoleInfo.apply(console, arguments); rnBridgePost('INFO', Array.from(arguments)); };
                console.debug = function() { originalConsoleDebug.apply(console, arguments); rnBridgePost('DEBUG', Array.from(arguments)); };
                window.onerror = function(message, source, lineno, colno, error) {
                    rnBridgePost('GLOBAL_ERROR', [message, 'at', source + ':' + lineno + ':' + colno, error ? error.stack : '']);
                    return false; // Let default handler run.
                };
            })();
            true; // note: this is required, or you'll sometimes get silent failures
        `}
        key={`stat-chart-${theme.mode}-${i18n.locale}-${JSON.stringify(statistics).length}`}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  webViewContainer: {
    width: "100%",
    marginTop: 10,
  },
  webView: {
    flex: 1,
    backgroundColor: 'transparent',
  },
});

export default StatisticsChart;
---------- END StatisticsChart.tsx ----------


---------- ThemeSwitch.tsx ----------
// src/components/ThemeSwitch.tsx
// components/ThemeSwitch.tsx
import React from "react";
import { ListItem, Switch, useTheme } from "@rneui/themed";
import { t } from '../localization/i18n';

interface ThemeSwitchProps {
  currentTheme: 'light' | 'dark' | 'system';
  onToggle: (theme: 'light' | 'dark' | 'system') => void;
}

const ThemeSwitch: React.FC<ThemeSwitchProps> = ({ currentTheme, onToggle }) => {
  const { theme } = useTheme();

  return (
    <ListItem
      bottomDivider
      containerStyle={{ backgroundColor: theme.colors.background }}
    >
      <ListItem.Content>
        <ListItem.Title style={{ color: theme.colors.text, textAlign: 'left' }}>
          {t('themeSwitch.darkMode')}
        </ListItem.Title>
      </ListItem.Content>
      <Switch
        value={currentTheme === 'dark'}
        onValueChange={(newValue) => {
          onToggle(newValue ? 'dark' : 'light');
        }}
      />
    </ListItem>
  );
};

export default ThemeSwitch;
---------- END ThemeSwitch.tsx ----------


---------- i18n.ts ----------
// src/localization/i18n.ts
import * as Localization from 'expo-localization';
import { I18n } from 'i18n-js';
import en from './languages/en.json';
import ru from './languages/ru.json';
import he from './languages/he.json';
import { Platform, I18nManager } from 'react-native';
// Import specific date-fns locales statically
import { enUS, ru as ruLocale, he as heLocale } from 'date-fns/locale';

const translations = {
  en,
  ru,
  he,
};

const i18n = new I18n(translations);

// --- Helper Type Generation for Translation Keys ---

// Helper type to recursively generate dot-notation paths including intermediate paths
type Paths<T> = T extends object ? {
    [K in keyof T]: K extends string ? 
        T[K] extends any[] ? `${K}` : // If it's an array, the key itself is a valid path to the array
        `${K}` | `${K}.${Paths<T[K]>}` 
        : never;
}[keyof T] : never;

// Flattens the union type generated by Paths (removes trailing dots)
type FlattenPath<T extends string> =
    T extends `${infer Head}.${infer Tail}` ?
        Tail extends '' ? Head : `${Head}.${FlattenPath<Tail>}` :
    T;

// Final type representing all valid translation keys
export type TranslationKey = FlattenPath<Paths<typeof en>>;

// --- End Helper Type Generation ---


// Set initial locale and handle RTL
export const setLocale = (locale: string) => {
  const languageTag = locale.split('-')[0];
  i18n.locale = languageTag;
  i18n.defaultLocale = 'en';

  const isRTL = languageTag === 'he';
  if (Platform.OS !== 'web' && I18nManager.isRTL !== isRTL) {
    I18nManager.forceRTL(isRTL);
    console.log(`RTL forced to: ${isRTL} for locale: ${languageTag}. App restart/reload may be needed for full layout update.`);
  } else if (Platform.OS === 'web') {
      document.documentElement.dir = isRTL ? 'rtl' : 'ltr';
  }
};

const deviceLocale = Localization.getLocales()?.[0]?.languageTag || 'en-US';
setLocale(deviceLocale);

// Updated t function with generic type for better type safety with `returnObjects: true`
export function t<TResult = string>(scope: TranslationKey, options?: any): TResult {
  return i18n.t(scope as string, { ...options, locale: i18n.locale }) as TResult;
}

// Function to get date-fns locale (unchanged)
export const getDateFnLocale = async () => {
  const currentLocale = i18n.locale.split('-')[0];
  switch (currentLocale) {
    case 'ru':
      return ruLocale;
    case 'he':
      return heLocale;
    case 'en':
    default:
      return enUS;
  }
};

export default i18n;
---------- END i18n.ts ----------


---------- en.json ----------
{
  "app": {
    "initializing": "Initializing...",
    "name": "MacrosVisionAI",
    "alertButtons": {
      "later": "Later",
      "restartNow": "Restart Now"
    }
  },
  "settingsScreen": {
    "title": "Settings",
    "account": {
      "title": "Account"
    },
    "general": {
      "title": "General"
    },
    "dailyGoals": {
      "title": "Daily Goals"
    },
    "goals": {
      "estimateButton": "Estimate Goals"
    },
    "statistics": {
      "title": "Statistics"
    },
    "dataManagement": {
      "title": "Data Management"
    },
    "language": {
      "title": "Language",
      "system": "System Default",
      "english": "English",
      "russian": "Russian",
      "hebrew": "Hebrew",
      "restartMessage": "Language changed. Restart the app for full effect."
    }
  },
  "accountSettings": {
    "coinBalance": "Coin Balance",
    "addTestCoins": "Add 10 Coins (Test)",
    "testButtonWarning": "Note: The \"Add Coins\" button is for testing/development only and should be removed or secured for production releases.",
    "notApplicable": "N/A",
    "errorLoadCoins": "Could not load coin balance",
    "errorAddCoins": "Failed to Add Coins",
    "coinsAdded": "Coins Added!"
  },
  "themeSwitch": {
    "darkMode": "Dark Mode"
  },
  "dailyGoalsInput": {
    "caloriesGoal": "Calories Goal",
    "proteinGoal": "Protein Goal",
    "carbsGoal": "Carbs Goal",
    "fatGoal": "Fat Goal"
  },
  "dataManagement": {
    "exportData": "Export Data",
    "importData": "Import Data",
    "clearAllData": "Clear All Data",
    "exportError": "Sharing Error",
    "exportErrorNoSharing": "Sharing is not available on your platform.",
    "exportFailed": "Export Failed",
    "exportFailedMessage": "An error occurred while exporting data.",
    "importCancelled": "Import cancelled by user.",
    "importInvalidFileType": "Invalid File Type",
    "importInvalidFileTypeMessage": "Please select a valid '.json' file.",
    "importFileTooLarge": "File Too Large",
    "importFileTooLargeMessage": "The selected file is too large (max 10MB).",
    "importFailed": "Import Failed",
    "importFailedInvalidStructure": "The imported file has an invalid structure or is missing required data (dailyEntries, foods, settings).",
    "importFailedParseError": "The imported file is not valid JSON or has corrupted content.",
    "importFailedAccessError": "Could not access the selected file.",
    "importFailedPermissionError": "Storage permissions are required to import files.",
    "importFailedUnknownError": "An unknown error occurred during import.",
    "importSuccessful": "Import Successful",
    "importSuccessfulMessage": "Data imported and saved successfully.",
    "clearDataSuccess": "Data Cleared",
    "clearDataSuccessMessage": "All application data has been successfully cleared.",
    "clearDataFailed": "Clear Data Failed",
    "clearDataFailedMessage": "Failed to clear data.",
    "confirmClearTitle": "Confirm Clear All Data",
    "confirmClearMessage": "This action is irreversible and will delete all entries, foods, and settings.\n\nEnter \"CLEAR DATA\" to proceed.",
    "confirmClearInputPlaceholder": "Enter \"CLEAR DATA\"",
    "clearConfirmationFailed": "Confirmation Failed",
    "clearConfirmationFailedMessage": "Incorrect confirmation text entered. Data was not cleared.",
    "dataReloaded": "Data reloaded."
  },
  "confirmationModal": {
    "confirm": "Confirm",
    "cancel": "Cancel",
    "defaultTitle": "Confirm Action",
    "defaultMessage": "Are you sure you want to perform this action?",
    "enterTextPlaceholder": "Enter confirmation text",
    "restartRequiredTitle": "Restart Required"
  },
  "dailyEntryScreen": {
    "tabTitle": "Daily Entry",
    "todaysEntries": "Today's Entries",
    "saving": "Saving...",
    "loadingEntries": "Loading Entries...",
    "noEntries": "No entries recorded for this day.",
    "noEntriesHint": "Tap '+' to add your first meal.",
    "entryAdded": "Entry added",
    "entryUpdated": "Entry updated",
    "itemRemoved": "%{itemName} removed",
    "undo": "Tap here to undo",
    "entryRestored": "Entry restored!",
    "itemsAdded": "%{count} item(s) added",
    "toDateFormat": "to %{date}",
    "errorLoad": "Load Error",
    "errorLoadMessage": "Failed to load necessary data.",
    "errorSave": "Save Error",
    "errorSaveMessage": "Could not save changes. Please try again.",
    "errorInvalidDate": "Invalid Date",
    "errorInvalidDateMessage": "Selected date is not valid.",
    "errorEditEntry": "Edit Error",
    "errorEditEntryMessage": "Error preparing entry for edit.",
    "errorAddMultiple": "Add Multiple Error",
    "errorAddMultipleMessage": "Failed to add multiple items.",
    "invalidEntryData": "Invalid Entry Data",
    "edit": "Edit",
    "delete": "Delete"
  },
  "foodListScreen": {
    "tabTitle": "Foods",
    "searchPlaceholder": "Search Your Food Library...",
    "loadingFoods": "Loading Foods...",
    "emptyLibrary": "Your food library is empty.",
    "emptyLibraryHint": "Tap '+' to add your first food item!",
    "noResults": "No foods found matching \"%{searchTerm}\"",
    "errorLoad": "Error",
    "errorLoadMessage": "Failed to load food list.",
    "foodAdded": "%{foodName} added",
    "foodUpdated": "%{foodName} updated",
    "foodDeleted": "%{foodName} deleted",
    "foodRestored": "%{foodName} restored",
    "errorCreate": "Error",
    "errorCreateMessage": "Failed to create food.",
    "errorUpdate": "Error",
    "errorUpdateMessage": "Failed to update food.",
    "errorDelete": "Delete Error",
    "errorDeleteMessage": "Failed to delete food from storage. Restored item.",
    "fixErrors": "Please fix errors",
    "edit": "Edit",
    "delete": "Delete",
    "shareFoodTitle": "Share %{foodName}",
    "shareErrorTitle": "Share Error",
    "shareErrorMessage": "Could not share food item.",
    "deepLinkErrorTitle": "Error Opening Link",
    "deepLinkInvalidData": "The food data from the link is invalid.",
    "deepLinkParseError": "Could not read food data from the link."
  },
  "addEntryModal": {
    "titleAdd": "Add Entry",
    "titleEdit": "Edit Entry",
    "titleQuickAddSelect": "Select Items to Add",
    "titleQuickAddEdit": "Edit Item",
    "titleQuickAddAnalyzing": "Analyzing...",
    "searchPlaceholder": "Search Foods...",
    "recent": "Recent",
    "noResults": "No foods found matching \"%{searchTerm}\".",
    "emptyLibraryMessage": "Your food library is empty. Tap below to add your first food item!",
    "noQuickAddResults": "No food items found in the image.",
    "amount": "Amount",
    "grams": "Grams",
    "autoAi": "Auto (AI)",
    "quickAddServing": "Quick Add:",
    "lastUsedServing": "Last: %{grams}g",
    "gramsPlaceholder": "Enter grams (e.g., 150)",
    "gramsPlaceholderEdit": "Update grams",
    "gramsError": "Enter a valid number",
    "autoPlaceholder": "Describe quantity (e.g., 1 cup cooked)",
    "buttonAdd": "Add",
    "buttonUpdate": "Update",
    "buttonBack": "Back",
    "buttonAddSelected": "Add %{count}",
    "buttonLoading": "Loading...",
    "quickAddHeader": "Select Items from Image",
    "quickAddHeaderEdit": "Editing Item Details",
    "alertInputMissing": "Input Missing",
    "alertInputMissingMessage": "Please select a food and enter a quantity description.",
    "alertGramsEstimated": "Grams Estimated",
    "alertGramsEstimatedMessage": "Estimated %{grams}g for %{foodName}",
    "alertFoodNotSelected": "Food Not Selected",
    "alertFoodNotSelectedMessage": "Please select a food item.",
    "alertInvalidAmount": "Invalid Amount",
    "alertInvalidAmountMessage": "Please enter a valid positive number for grams.",
    "alertQuickAddPermission": "Permission Required",
    "alertQuickAddCameraPermission": "Camera access needed.",
    "alertQuickAddGalleryPermission": "Gallery access needed.",
    "alertQuickAddUserCancelled": "User cancelled",
    "alertQuickAddCouldNotSelect": "Could not select image.",
    "alertQuickAddError": "Error",
    "alertQuickAddErrorMessage": "An unexpected error occurred.",
    "alertQuickAddFinishEditing": "Finish Editing",
    "alertQuickAddFinishEditingSaveOrCancel": "Please save or cancel the current edit first.",
    "alertQuickAddFromImageTitle": "Quick Add from Image",
    "alertQuickAddFromImageMessage": "Identify multiple foods from an image.",
    "alertQuickAddInvalidName": "Invalid Name",
    "alertQuickAddInvalidNameMessage": "Food name cannot be empty.",
    "alertQuickAddInvalidGrams": "Invalid Grams",
    "alertQuickAddInvalidGramsMessage": "Please enter a valid positive number.",
    "alertQuickAddNoItemsSelected": "No Items Selected",
    "alertQuickAddNoItemsSelectedMessage": "Select items to add.",
    "alertQuickAddNothingToAdd": "Nothing to Add",
    "alertQuickAddNothingToAddMessage": "No valid items were selected or prepared.",
    "alertQuickAddErrorPreparing": "Error",
    "alertQuickAddErrorPreparingMessage": "Could not prepare items to add.",
    "camera": "Camera",
    "gallery": "Gallery",
    "cancel": "Cancel",
    "addNewFoodButton": "Add New Food",
    "alertOverwriteFoodTitle": "Food Exists",
    "alertOverwriteFoodMessage": "A food named \"%{foodName}\" already exists. Overwrite with new macros?",
    "overwrite": "Overwrite",
    "toastFoodSavedToLibrary": "\"%{foodName}\" saved to library.",
    "toastFoodUpdatedInLibrary": "\"%{foodName}\" updated in library.",
    "toastErrorSavingToLibrary": "Error saving food to library."
  },
  "addFoodModal": {
    "titleAdd": "Add New Food",
    "titleEdit": "Edit Food",
    "buttonAdd": "Add",
    "buttonUpdate": "Update",
    "getFromImage": "Get from Image",
    "ingredientsOptional": "Ingredients (Optional)",
    "ingredientsPlaceholder": "e.g.\n100g Chicken Breast\n50g Rice\n1 tbsp Olive Oil",
    "backToManual": "Back to Manual Input",
    "aiCalculateRecipe": "Calculate with AI (Recipe/Text)",
    "aiGetFromIngredients": "Get Macros from Ingredients",
    "aiGetFromNameOnly": "Get Macros from Name Only",
    "barcodeComingSoon": "Barcode Input (Coming Soon)",
    "alertInputNeeded": "Input Needed",
    "alertInputNeededMessage": "Please enter a food name or ingredients to analyze.",
    "macrosEstimatedText": "Macros estimated from text.",
    "foodIdentified": "Food Identified!",
    "foodIdentifiedMessage": "Identified as %{foodName}. Macros estimated.",
    "errorGetImage": "Get Image",
    "errorGetImageMessage": "Choose a source for the food image:",
    "errorCamera": "Camera Error",
    "errorGallery": "Gallery Error",
    "errorPermission": "Permission Required",
    "errorCameraPermission": "Camera access needed."
  },
  "foodFormFields": {
    "foodName": "Food Name",
    "calories": "Calories (per 100g)",
    "protein": "Protein (per 100g)",
    "carbs": "Carbs (per 100g)",
    "fat": "Fat (per 100g)",
    "errorNameRequired": "Name is required",
    "errorNonNegative": "Must be a non-negative number"
  },
  "quickAddList": {
    "foodNamePlaceholder": "Food Name",
    "gramsPlaceholder": "Grams",
    "errorInvalidGrams": "Invalid",
    "analyzing": "Analyzing...",
    "emptyMessage": "No identifiable foods found in the image.",
    "emptyHint": "Try a different image or add manually."
  },
  "dailyProgress": {
    "calories": "Calories",
    "protein": "Protein",
    "carbs": "Carbs",
    "fat": "Fat"
  },
  "dateNavigator": {
    "invalidDate": "Invalid Date"
  },
  "utils": {
    "macros": {
      "alertAiErrorRecipe": "AI Error (Recipe)",
      "alertAnalysisFailedSingle": "Analysis Failed (Single Item)",
      "alertQuickAddFailedMulti": "Quick Add Failed (Multi-Item)",
      "alertImageReadError": "Image Read Error",
      "alertImageReadErrorMessage": "Failed to read image file.",
      "errorGetMacrosRecipe": "Failed to get macros for recipe: %{error}",
      "errorImageAnalysis": "Image analysis failed: %{error}",
      "errorCouldNotAnalyze": "Could not analyze image: %{error}",
      "errorInvalidResponseMultiple": "Invalid response format from server for multiple items."
    },
    "units": {
      "alertAiEstimationFailed": "AI Estimation Failed",
      "errorCouldNotEstimateGrams": "Could not estimate grams: %{error}"
    },
    "image": {
      "alertCompressionError": "Compression Error",
      "alertCompressionErrorMessage": "Could not process the image for compression.",
      "errorFailedToRead": "Failed to read image file: %{error}"
    }
  },
  "backendService": {
    "errorInvalidClientId": "Invalid client ID format.",
    "errorRequestFailedParse": "Backend request failed (Status %{status}), failed to parse response.",
    "errorRequestFailedDetailFormat": "Backend error (Status %{status}), unexpected detail format.",
    "errorRequestFailedWithServerMsg": "Backend request failed (Status %{status}). Server response: %{response}",
    "errorAuthFailed": "Authentication failed. Invalid Client ID.",
    "errorPermissionDenied": "Permission denied.",
    "errorNotFound": "Resource not found.",
    "errorTooManyRequests": "Too many requests. Please try again later.",
    "errorInsufficientCoins": "Insufficient coins for this action.",
    "errorNetwork": "Failed to communicate with the backend.",
    "errorNetworkTimeout": "The request timed out. Please try again.",
    "errorNetworkConnection": " Please check your network connection.",
    "errorNetworkDetails": " Details: %{error}",
    "errorNetworkUnknown": " An unknown network error occurred.",
    "errorEstimateGramsUnexpectedResponse": "Failed to get grams estimation due to unexpected response.",
    "errorAddCoinsPositive": "Amount to add must be positive."
  },
  "statisticsChart": {
    "intake": "Intake",
    "goal": "Goal",
    "noData": "No data available to display chart for %{chartTitle}."
  },
  "questionnaireScreen": {
    "title": "Estimate Your Goals",
    "ageLabel": "Age (years)",
    "agePlaceholder": "e.g., 30",
    "sexLabel": "Sex",
    "sex": {
      "select": "Select Sex...",
      "male": "Male",
      "female": "Female"
    },
    "heightLabel": "Height",
    "heightPlaceholder": "e.g., 175",
    "weightLabel": "Weight",
    "weightPlaceholder": "e.g., 70",
    "activityLevelLabel": "Activity Level",
    "activityLevel": {
      "select": "Select Activity Level...",
      "sedentary": "Sedentary (little or no exercise)",
      "light": "Light (exercise 1-3 days/week)",
      "moderate": "Moderate (exercise 3-5 days/week)",
      "active": "Active (exercise 6-7 days/week)",
      "veryActive": "Very Active (hard exercise or physical job)"
    },
    "primaryGoalLabel": "Primary Goal",
    "primaryGoal": {
      "select": "Select Primary Goal...",
      "loseWeight": "Lose Weight",
      "maintainWeight": "Maintain Weight",
      "gainMuscle": "Gain Muscle"
    },
    "goalIntensityLabel": "Goal Intensity",
    "goalIntensity": {
      "select": "Select Intensity...",
      "mild": "Mild",
      "moderate": "Moderate",
      "aggressive": "Aggressive"
    },
    "calculateButton": "Calculate & Save Goals",
    "validation": {
      "invalidAge": "Enter a valid age (1-120).",
      "selectSex": "Please select your sex.",
      "invalidHeight": "Enter a valid height (50-250 cm).",
      "invalidWeight": "Enter a valid weight (20-300 kg).",
      "selectActivityLevel": "Please select your activity level.",
      "selectPrimaryGoal": "Please select your primary goal.",
      "selectGoalIntensity": "Please select your goal intensity.",
      "fixErrors": "Please fix the errors above."
    },
    "error": {
      "calculationFailedTitle": "Calculation Error",
      "calculationFailedMessage": "Could not calculate goals. Please check your inputs.",
      "genericSaveTitle": "Save Error",
      "genericSaveMessage": "Could not save the estimated goals. Please try again."
    },
    "toast": {
      "goalsCalculated": "Goals calculated and saved!",
      "minCaloriesAdjustedTitle": "Calories Adjusted",
      "minCaloriesAdjustedMessage": "Your calorie goal was adjusted to a minimum of %{calories} kcal."
    }
  },
  "foodIconTags": {
    "apple": ["apple", "red apple", "green apple", "gala", "fuji", "granny smith", "apples"],
    "banana": ["banana", "plantain", "bananas"],
    "grapes": ["grape", "grapes"],
    "strawberry": ["strawberry", "strawberries"],
    "blueberry": ["blueberry", "blueberries"],
    "orange": ["orange", "mandarin", "tangerine", "clementine", "oranges"],
    "lemonLime": ["lemon", "lime", "lemons"],
    "watermelon": ["watermelon"],
    "pineapple": ["pineapple"],
    "mango": ["mango", "mangoes"],
    "kiwi": ["kiwi", "kiwifruit"],
    "peachNectarine": ["peach", "nectarine", "peaches"],
    "cherry": ["cherry", "cherries"],
    "pear": ["pear", "pears"],
    "avocado": ["avocado", "avocados"],
    "coconut": ["coconut", "coconuts"],
    "tomato": ["tomato", "tomatoes", "roma tomato", "cherry tomato", "heirloom tomato"],
    "carrot": ["carrot", "carrots"],
    "broccoli": ["broccoli", "broccolini"],
    "leafyGreen": ["lettuce", "spinach", "kale", "greens", "leafy green", "romaine", "arugula", "swiss chard", "collard greens"],
    "cucumber": ["cucumber", "cucumbers", "pickle", "pickles", "gherkin"],
    "pepperGeneral": ["pepper", "chili", "chilli", "jalapeno", "capsicum", "pimiento"],
    "bellPepper": ["bell pepper", "green pepper", "red pepper", "yellow pepper", "orange pepper"],
    "corn": ["corn", "maize", "sweet corn", "corn on the cob"],
    "potato": ["potato", "potatoes", "sweet potato", "yam", "russet", "red potato", "yukon gold"],
    "onion": ["onion", "shallot", "spring onion", "scallion", "red onion", "yellow onion", "white onion", "onions"],
    "garlic": ["garlic", "garlic clove"],
    "eggplant": ["eggplant", "aubergine"],
    "mushroom": ["mushroom", "mushrooms", "portobello", "shiitake", "champignon", "cremini", "oyster mushroom"],
    "poultry": ["chicken", "chicken breast", "chicken thigh", "chicken leg", "drumstick", "turkey", "duck", "poultry", "roast chicken", "grilled chicken"],
    "redMeat": ["beef", "steak", "mince", "ground beef", "pork", "lamb", "veal", "red meat", "patty", "roast beef", "pork chop", "loin"],
    "bacon": ["bacon", "pancetta"],
    "processedMeat": ["ham", "sausage", "hot dog", "frankfurter", "chorizo", "salami", "pepperoni", "bologna", "bratwurst", "processed meat"],
    "fish": ["fish", "salmon", "tuna", "cod", "tilapia", "mackerel", "sardine", "halibut", "white fish", "trout", "sea bass", "grilled fish", "baked fish"],
    "shrimpPrawn": ["shrimp", "prawn", "prawns", "shellfish"],
    "lobster": ["lobster", "crayfish", "shellfish"],
    "crab": ["crab", "shellfish"],
    "sushi": ["sushi", "sashimi", "raw fish", "nigiri", "maki", "uramaki"],
    "egg": ["egg", "eggs", "scrambled eggs", "fried egg", "omelette", "boiled egg", "poached egg"],
    "milk": ["milk", "dairy milk", "cow milk", "soy milk", "almond milk", "oat milk", "plant milk", "rice milk", "coconut milk", "goat milk"],
    "cheese": ["cheese", "cheddar", "mozzarella", "parmesan", "gouda", "brie", "feta", "cottage cheese", "swiss cheese", "provolone", "blue cheese", "goat cheese", "cream cheese"],
    "butter": ["butter", "margarine"],
    "iceCream": ["ice cream", "gelato", "sorbet", "frozen yogurt", "sherbet"],
    "yogurt": ["yogurt", "yoghurt", "greek yogurt", "plain yogurt", "flavored yogurt", "dairy"],
    "bread": ["bread", "toast", "bagel", "croissant", "bun", "roll", "sourdough", "whole wheat bread", "white bread", "rye bread", "multigrain bread", "baguette"],
    "rice": ["rice", "white rice", "brown rice", "basmati rice", "jasmine rice", "wild rice", "grain"],
    "pasta": ["pasta", "spaghetti", "macaroni", "noodles", "fettuccine", "lasagna", "ramen", "penne", "linguine"],
    "cerealOats": ["cereal", "oats", "oatmeal", "granola", "muesli", "porridge", "corn flakes", "bran flakes"],
    "otherGrains": ["quinoa", "couscous", "barley", "bulgur", "farro", "spelt", "millet", "ancient grain"],
    "flatbread": ["tortilla", "wrap", "pita", "naan", "flatbread", "chapati", "roti"],
    "beansLegumes": ["beans", "black beans", "kidney beans", "chickpeas", "garbanzo beans", "lentils", "peas", "legume", "edamame", "soybeans", "lima beans", "pinto beans"],
    "peanut": ["peanut", "peanuts", "peanut butter"],
    "nuts": ["nuts", "almond", "walnut", "cashew", "pecan", "pistachio", "hazelnut", "brazil nut", "macadamia nut", "mixed nuts"],
    "seeds": ["seeds", "sunflower seeds", "pumpkin seeds", "chia seeds", "flax seeds", "sesame seeds", "hemp seeds"],
    "donut": ["donut", "doughnut", "pastry", "fritter"],
    "cookie": ["cookie", "biscuit", "shortbread", "macaroon"],
    "chocolate": ["chocolate", "chocolate bar", "dark chocolate", "milk chocolate", "white chocolate", "cocoa", "cacao"],
    "cake": ["cake", "cupcake", "muffin", "brownie", "cheesecake", "pound cake"],
    "candy": ["candy", "sweets", "gummy", "lollipop", "jelly beans", "taffy", "fudge", "marshmallow"],
    "popcorn": ["popcorn"],
    "pretzel": ["pretzel", "pretzels"],
    "friesChips": ["fries", "french fries", "chips", "potato chips", "crisps", "potato wedges", "sweet potato fries"],
    "coffee": ["coffee", "espresso", "latte", "cappuccino", "americano", "mocha", "cold brew"],
    "tea": ["tea", "green tea", "black tea", "herbal tea", "chai", "oolong tea", "white tea"],
    "softDrinkJuice": ["soda", "coke", "pepsi", "soft drink", "juice", "orange juice", "apple juice", "smoothie", "protein shake", "lemonade", "iced tea (sweetened)"],
    "water": ["water", "bottled water", "mineral water", "sparkling water", "still water"],
    "wine": ["wine", "red wine", "white wine", "rosÃ© wine", "sparkling wine", "champagne", "alcohol"],
    "beer": ["beer", "lager", "ale", "stout", "ipa", "pilsner", "craft beer", "alcohol"],
    "cocktail": ["cocktail", "spirit", "liquor", "vodka", "gin", "rum", "whiskey", "tequila", "margarita", "martini", "alcohol"],
    "pizza": ["pizza", "margherita pizza", "pepperoni pizza", "hawaiian pizza", "vegetarian pizza", "deep dish pizza"],
    "burger": ["burger", "hamburger", "cheeseburger", "veggie burger", "chicken burger", "slider"],
    "tacoBurrito": ["taco", "burrito", "quesadilla", "fajita", "enchilada", "mexican food"],
    "sandwich": ["sandwich", "sub", "blt", "club sandwich", "panini", "grilled cheese", "wrap sandwich"],
    "soupStew": ["soup", "stew", "broth", "chowder", "pho", "consomme", "minestrone", "chili con carne"],
    "salad": ["salad", "caesar salad", "greek salad", "garden salad", "cobb salad", "fruit salad", "pasta salad", "potato salad"],
    "noodleDish": ["ramen noodles", "pho noodles", "noodle soup", "pad thai", "chow mein", "lo mein", "soba", "udon"],
    "genericFruit": ["fruit", "tropical fruit", "stone fruit", "citrus fruit", "berries"],
    "genericVegetable": ["vegetable", "veg", "root vegetable", "cruciferous", "greens"],
    "genericMeal": ["food", "meal", "dish", "plate", "entrÃ©e", "main course", "snack", "lunch", "dinner", "breakfast", "generic food", "cooked food", "leftovers"],
    "unknownFood": ["unknown", "unidentified"]
  }
}
---------- END en.json ----------


---------- he.json ----------
{
  "app": {
    "initializing": "×ž××ª×—×œ...",
    "name": "MacrosVisionAI",
    "alertButtons": {
      "later": "××—×¨ ×›×š",
      "restartNow": "×”×¤×¢×œ ×ž×—×“×© ×›×¢×ª"
    }
  },
  "settingsScreen": {
    "title": "×”×’×“×¨×•×ª",
    "account": {
      "title": "×—×©×‘×•×Ÿ"
    },
    "general": {
      "title": "×›×œ×œ×™"
    },
    "dailyGoals": {
      "title": "×™×¢×“×™× ×™×•×ž×™×™×"
    },
    "goals": {
      "estimateButton": "×”×¢×¨×›×ª ×™×¢×“×™×"
    },
    "statistics": {
      "title": "×¡×˜×˜×™×¡×˜×™×§×”"
    },
    "dataManagement": {
      "title": "× ×™×”×•×œ × ×ª×•× ×™×"
    },
    "language": {
      "title": "×©×¤×”",
      "system": "×‘×¨×™×¨×ª ×ž×—×“×œ ×©×œ ×”×ž×¢×¨×›×ª",
      "english": "×× ×’×œ×™×ª",
      "russian": "×¨×•×¡×™×ª",
      "hebrew": "×¢×‘×¨×™×ª",
      "restartMessage": "×”×©×¤×” ×©×•× ×ª×”. ×”×¤×¢×œ ×ž×—×“×© ××ª ×”××¤×œ×™×§×¦×™×” ×œ×”×©×¤×¢×” ×ž×œ××”."
    }
  },
  "accountSettings": {
    "coinBalance": "×ž××–×Ÿ ×ž×˜×‘×¢×•×ª",
    "addTestCoins": "×”×•×¡×£ 10 ×ž×˜×‘×¢×•×ª (×‘×“×™×§×”)",
    "testButtonWarning": "×”×¢×¨×”: ×›×¤×ª×•×¨ \"×”×•×¡×£ ×ž×˜×‘×¢×•×ª\" ×ž×™×•×¢×“ ×œ×‘×“×™×§×”/×¤×™×ª×•×— ×‘×œ×‘×“ ×•×™×© ×œ×”×¡×™×¨×• ××• ×œ××‘×˜×—×• ×‘×’×¨×¡××•×ª ×™×™×¦×•×¨.",
    "notApplicable": "×œ× ×–×ž×™×Ÿ",
    "errorLoadCoins": "×œ× × ×™×ª×Ÿ ×”×™×” ×œ×˜×¢×•×Ÿ ××ª ×ž××–×Ÿ ×”×ž×˜×‘×¢×•×ª",
    "errorAddCoins": "× ×›×©×œ ×‘×”×•×¡×¤×ª ×ž×˜×‘×¢×•×ª",
    "coinsAdded": "×ž×˜×‘×¢×•×ª × ×•×¡×¤×•!"
  },
  "themeSwitch": {
    "darkMode": "×ž×¦×‘ ×›×”×”"
  },
  "dailyGoalsInput": {
    "caloriesGoal": "×™×¢×“ ×§×œ×•×¨×™×•×ª",
    "proteinGoal": "×™×¢×“ ×—×œ×‘×•×Ÿ",
    "carbsGoal": "×™×¢×“ ×¤×—×ž×™×ž×•×ª",
    "fatGoal": "×™×¢×“ ×©×•×ž×Ÿ"
  },
  "dataManagement": {
    "exportData": "×™×™×¦×•× × ×ª×•× ×™×",
    "importData": "×™×™×‘×•× × ×ª×•× ×™×",
    "clearAllData": "× ×§×” ××ª ×›×œ ×”× ×ª×•× ×™×",
    "exportError": "×©×’×™××ª ×©×™×ª×•×£",
    "exportErrorNoSharing": "×©×™×ª×•×£ ××™× ×• ×–×ž×™×Ÿ ×‘×¤×œ×˜×¤×•×¨×ž×” ×©×œ×š.",
    "exportFailed": "×”×™×™×¦×•× × ×›×©×œ",
    "exportFailedMessage": "××™×¨×¢×” ×©×’×™××” ×‘×¢×ª ×™×™×¦×•× × ×ª×•× ×™×.",
    "importCancelled": "×”×™×™×‘×•× ×‘×•×˜×œ ×¢×œ ×™×“×™ ×”×ž×©×ª×ž×©.",
    "importInvalidFileType": "×¡×•×’ ×§×•×‘×¥ ×œ× ×—×•×§×™",
    "importInvalidFileTypeMessage": "×× × ×‘×—×¨ ×§×•×‘×¥ '.json' ×—×•×§×™.",
    "importFileTooLarge": "×”×§×•×‘×¥ ×’×“×•×œ ×ž×“×™",
    "importFileTooLargeMessage": "×”×§×•×‘×¥ ×©× ×‘×—×¨ ×’×“×•×œ ×ž×“×™ (×ž×§×¡×™×ž×•× 10MB).",
    "importFailed": "×”×™×™×‘×•× × ×›×©×œ",
    "importFailedInvalidStructure": "×œ×§×•×‘×¥ ×”×ž×™×•×‘× ×™×© ×ž×‘× ×” ×œ× ×—×•×§×™ ××• ×©×—×¡×¨×™× ×‘×• × ×ª×•× ×™× × ×“×¨×©×™× (dailyEntries, foods, settings).",
    "importFailedParseError": "×”×§×•×‘×¥ ×”×ž×™×•×‘× ××™× ×• JSON ×—×•×§×™ ××• ×©×ª×•×›× ×• ×¤×’×•×.",
    "importFailedAccessError": "×œ× × ×™×ª×Ÿ ×”×™×” ×œ×’×©×ª ×œ×§×•×‘×¥ ×©× ×‘×—×¨.",
    "importFailedPermissionError": "× ×“×¨×©×•×ª ×”×¨×©××•×ª ××—×¡×•×Ÿ ×œ×™×™×‘×•× ×§×‘×¦×™×.",
    "importFailedUnknownError": "××™×¨×¢×” ×©×’×™××” ×œ× ×™×“×•×¢×” ×‘×ž×”×œ×š ×”×™×™×‘×•×.",
    "importSuccessful": "×”×™×™×‘×•× ×”×•×©×œ× ×‘×”×¦×œ×—×”",
    "importSuccessfulMessage": "×”× ×ª×•× ×™× ×™×•×‘××• ×•× ×©×ž×¨×• ×‘×”×¦×œ×—×”.",
    "clearDataSuccess": "×”× ×ª×•× ×™× × ×•×§×•",
    "clearDataSuccessMessage": "×›×œ × ×ª×•× ×™ ×”×™×™×©×•× × ×•×§×• ×‘×”×¦×œ×—×”.",
    "clearDataFailed": "× ×™×§×•×™ ×”× ×ª×•× ×™× × ×›×©×œ",
    "clearDataFailedMessage": "× ×™×§×•×™ ×”× ×ª×•× ×™× × ×›×©×œ.",
    "confirmClearTitle": "××©×¨ × ×™×§×•×™ ×›×œ ×”× ×ª×•× ×™×",
    "confirmClearMessage": "×¤×¢×•×œ×” ×–×• ××™× ×” ×”×¤×™×›×” ×•×ª×ž×—×§ ××ª ×›×œ ×”×¨×©×•×ž×•×ª, ×”×ž××›×œ×™× ×•×”×”×’×“×¨×•×ª.\n\n×”×–×Ÿ \"CLEAR DATA\" ×›×“×™ ×œ×”×ž×©×™×š.",
    "confirmClearInputPlaceholder": "×”×–×Ÿ \"CLEAR DATA\"",
    "clearConfirmationFailed": "×”××™×©×•×¨ × ×›×©×œ",
    "clearConfirmationFailedMessage": "×”×•×–×Ÿ ×˜×§×¡×˜ ××™×©×•×¨ ×©×’×•×™. ×”× ×ª×•× ×™× ×œ× × ×•×§×•.",
    "dataReloaded": "×”× ×ª×•× ×™× × ×˜×¢× ×• ×ž×—×“×©."
  },
  "confirmationModal": {
    "confirm": "××©×¨",
    "cancel": "×‘×™×˜×•×œ",
    "defaultTitle": "××©×¨ ×¤×¢×•×œ×”",
    "defaultMessage": "×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ×‘×¦×¢ ×¤×¢×•×œ×” ×–×•?",
    "enterTextPlaceholder": "×”×–×Ÿ ×˜×§×¡×˜ ××™×©×•×¨",
    "restartRequiredTitle": "× ×“×¨×©×ª ×”×¤×¢×œ×” ×ž×—×“×©"
  },
  "dailyEntryScreen": {
    "tabTitle": "×™×•×ž×Ÿ ×™×•×ž×™",
    "todaysEntries": "×¨×©×•×ž×•×ª ×œ×”×™×•×",
    "saving": "×©×•×ž×¨...",
    "loadingEntries": "×˜×•×¢×Ÿ ×¨×©×•×ž×•×ª...",
    "noEntries": "××™×Ÿ ×¨×©×•×ž×•×ª ×ž×ª×•×¢×“×•×ª ×œ×™×•× ×–×”.",
    "noEntriesHint": "×”×§×© '+' ×›×“×™ ×œ×”×•×¡×™×£ ××ª ×”××¨×•×—×” ×”×¨××©×•× ×” ×©×œ×š.",
    "entryAdded": "×¨×©×•×ž×” × ×•×¡×¤×”",
    "entryUpdated": "×¨×©×•×ž×” ×¢×•×“×›× ×”",
    "itemRemoved": "%{itemName} ×”×•×¡×¨",
    "undo": "×”×§×© ×›××Ÿ ×œ×‘×™×˜×•×œ",
    "entryRestored": "×”×¨×©×•×ž×” ×©×•×—×–×¨×”!",
    "itemsAdded": "%{count} ×¤×¨×™×˜(×™×) × ×•×¡×¤×•",
    "toDateFormat": "×œ×ª××¨×™×š %{date}",
    "errorLoad": "×©×’×™××ª ×˜×¢×™× ×”",
    "errorLoadMessage": "×˜×¢×™× ×ª ×”× ×ª×•× ×™× ×”×“×¨×•×©×™× × ×›×©×œ×”.",
    "errorSave": "×©×’×™××ª ×©×ž×™×¨×”",
    "errorSaveMessage": "×œ× × ×™×ª×Ÿ ×œ×©×ž×•×¨ ×©×™× ×•×™×™×. ×× × × ×¡×” ×©×•×‘.",
    "errorInvalidDate": "×ª××¨×™×š ×œ× ×—×•×§×™",
    "errorInvalidDateMessage": "×”×ª××¨×™×š ×©× ×‘×—×¨ ××™× ×• ×—×•×§×™.",
    "errorEditEntry": "×©×’×™××ª ×¢×¨×™×›×”",
    "errorEditEntryMessage": "×©×’×™××” ×‘×”×›× ×ª ×¨×©×•×ž×” ×œ×¢×¨×™×›×”.",
    "errorAddMultiple": "×©×’×™××” ×‘×”×•×¡×¤×” ×ž×¨×•×‘×”",
    "errorAddMultipleMessage": "× ×›×©×œ ×‘×”×•×¡×¤×ª ×ž×¡×¤×¨ ×¤×¨×™×˜×™×.",
    "invalidEntryData": "× ×ª×•× ×™ ×¨×©×•×ž×” ×œ× ×—×•×§×™×™×",
    "edit": "×¢×¨×•×š",
    "delete": "×ž×—×§"
  },
  "foodListScreen": {
    "tabTitle": "×ž××›×œ×™×",
    "searchPlaceholder": "×—×¤×© ×‘×¡×¤×¨×™×™×ª ×”×ž××›×œ×™× ×©×œ×š...",
    "loadingFoods": "×˜×•×¢×Ÿ ×ž××›×œ×™×...",
    "emptyLibrary": "×¡×¤×¨×™×™×ª ×”×ž××›×œ×™× ×©×œ×š ×¨×™×§×”.",
    "emptyLibraryHint": "×”×§×© '+' ×›×“×™ ×œ×”×•×¡×™×£ ××ª ×¤×¨×™×˜ ×”×ž×–×•×Ÿ ×”×¨××©×•×Ÿ ×©×œ×š!",
    "noResults": "×œ× × ×ž×¦××• ×ž××›×œ×™× ×”×ª×•××ž×™× ×œ-\"%{searchTerm}\"",
    "errorLoad": "×©×’×™××”",
    "errorLoadMessage": "×˜×¢×™× ×ª ×¨×©×™×ž×ª ×”×ž××›×œ×™× × ×›×©×œ×”.",
    "foodAdded": "%{foodName} × ×•×¡×£",
    "foodUpdated": "%{foodName} ×¢×•×“×›×Ÿ",
    "foodDeleted": "%{foodName} × ×ž×—×§",
    "foodRestored": "%{foodName} ×©×•×—×–×¨",
    "errorCreate": "×©×’×™××”",
    "errorCreateMessage": "×™×¦×™×¨×ª ×”×ž××›×œ × ×›×©×œ×”.",
    "errorUpdate": "×©×’×™××”",
    "errorUpdateMessage": "×¢×“×›×•×Ÿ ×”×ž××›×œ × ×›×©×œ.",
    "errorDelete": "×©×’×™××ª ×ž×—×™×§×”",
    "errorDeleteMessage": "×ž×—×™×§×ª ×”×ž××›×œ ×ž×”××—×¡×•×Ÿ × ×›×©×œ×”. ×”×¤×¨×™×˜ ×©×•×—×–×¨.",
    "fixErrors": "×× × ×ª×§×Ÿ ×©×’×™××•×ª",
    "edit": "×¢×¨×•×š",
    "delete": "×ž×—×§",
    "shareFoodTitle": "×©×ª×£ ××ª %{foodName}",
    "shareErrorTitle": "×©×’×™××ª ×©×™×ª×•×£",
    "shareErrorMessage": "×œ× × ×™×ª×Ÿ ×”×™×” ×œ×©×ª×£ ××ª ×¤×¨×™×˜ ×”×ž×–×•×Ÿ.",
    "deepLinkErrorTitle": "×©×’×™××” ×‘×¤×ª×™×—×ª ×”×§×™×©×•×¨",
    "deepLinkInvalidData": "× ×ª×•× ×™ ×”×ž×–×•×Ÿ ×ž×”×§×™×©×•×¨ ××™× × ×—×•×§×™×™×.",
    "deepLinkParseError": "×œ× × ×™×ª×Ÿ ×”×™×” ×œ×§×¨×•× ××ª × ×ª×•× ×™ ×”×ž×–×•×Ÿ ×ž×”×§×™×©×•×¨."
  },
  "addEntryModal": {
    "titleAdd": "×”×•×¡×£ ×¨×©×•×ž×”",
    "titleEdit": "×¢×¨×•×š ×¨×©×•×ž×”",
    "titleQuickAddSelect": "×‘×—×¨ ×¤×¨×™×˜×™× ×œ×”×•×¡×¤×”",
    "titleQuickAddEdit": "×¢×¨×•×š ×¤×¨×™×˜",
    "titleQuickAddAnalyzing": "×ž× ×ª×—...",
    "searchPlaceholder": "×—×¤×© ×ž××›×œ×™×...",
    "recent": "××—×¨×•× ×™×",
    "noResults": "×œ× × ×ž×¦××• ×ž××›×œ×™× ×”×ª×•××ž×™× ×œ-\"%{searchTerm}\".",
    "emptyLibraryMessage": "×¡×¤×¨×™×™×ª ×”×ž××›×œ×™× ×©×œ×š ×¨×™×§×”. ×œ×—×¥ ×œ×ž×˜×” ×œ×”×•×¡×¤×ª ×”×ž××›×œ ×”×¨××©×•×Ÿ ×©×œ×š!",
    "noQuickAddResults": "×œ× × ×ž×¦××• ×¤×¨×™×˜×™ ×ž×–×•×Ÿ ×‘×ª×ž×•× ×”.",
    "amount": "×›×ž×•×ª",
    "grams": "×’×¨×",
    "autoAi": "××•×˜×•×ž×˜×™ (AI)",
    "quickAddServing": "×”×•×¡×¤×” ×ž×”×™×¨×”:",
    "lastUsedServing": "××—×¨×•×Ÿ: %{grams}×’",
    "gramsPlaceholder": "×”×–×Ÿ ×’×¨×ž×™× (×œ×ž×©×œ, 150)",
    "gramsPlaceholderEdit": "×¢×“×›×Ÿ ×’×¨×ž×™×",
    "gramsError": "×”×–×Ÿ ×ž×¡×¤×¨ ×—×•×§×™",
    "autoPlaceholder": "×ª××¨ ×›×ž×•×ª (×œ×ž×©×œ, 1 ×›×•×¡ ×ž×‘×•×©×œ)",
    "buttonAdd": "×”×•×¡×£",
    "buttonUpdate": "×¢×“×›×Ÿ",
    "buttonBack": "×—×–×•×¨",
    "buttonAddSelected": "×”×•×¡×£ %{count}",
    "buttonLoading": "×˜×•×¢×Ÿ...",
    "quickAddHeader": "×‘×—×¨ ×¤×¨×™×˜×™× ×ž×”×ª×ž×•× ×”",
    "quickAddHeaderEdit": "×¢×¨×™×›×ª ×¤×¨×˜×™ ×¤×¨×™×˜",
    "alertInputMissing": "×§×œ×˜ ×—×¡×¨",
    "alertInputMissingMessage": "×× × ×‘×—×¨ ×ž××›×œ ×•×”×–×Ÿ ×ª×™××•×¨ ×›×ž×•×ª.",
    "alertGramsEstimated": "×’×¨×ž×™× ×”×•×¢×¨×›×•",
    "alertGramsEstimatedMessage": "×”×•×¢×¨×›×• %{grams} ×’×¨× ×¢×‘×•×¨ %{foodName}",
    "alertFoodNotSelected": "×ž××›×œ ×œ× × ×‘×—×¨",
    "alertFoodNotSelectedMessage": "×× × ×‘×—×¨ ×¤×¨×™×˜ ×ž×–×•×Ÿ.",
    "alertInvalidAmount": "×›×ž×•×ª ×œ× ×—×•×§×™×ª",
    "alertInvalidAmountMessage": "×× × ×”×–×Ÿ ×ž×¡×¤×¨ ×—×™×•×‘×™ ×—×•×§×™ ×¢×‘×•×¨ ×’×¨×ž×™×.",
    "alertQuickAddPermission": "× ×“×¨×©×ª ×”×¨×©××”",
    "alertQuickAddCameraPermission": "× ×“×¨×©×ª ×’×™×©×” ×œ×ž×¦×œ×ž×”.",
    "alertQuickAddGalleryPermission": "× ×“×¨×©×ª ×’×™×©×” ×œ×’×œ×¨×™×”.",
    "alertQuickAddUserCancelled": "×‘×•×˜×œ ×¢×œ ×™×“×™ ×”×ž×©×ª×ž×©",
    "alertQuickAddCouldNotSelect": "×œ× × ×™×ª×Ÿ ×œ×‘×—×•×¨ ×ª×ž×•× ×”.",
    "alertQuickAddError": "×©×’×™××”",
    "alertQuickAddErrorMessage": "××™×¨×¢×” ×©×’×™××” ×‘×œ×ª×™ ×¦×¤×•×™×”.",
    "alertQuickAddFinishEditing": "×¡×™×™× ×¢×¨×™×›×”",
    "alertQuickAddFinishEditingSaveOrCancel": "×× × ×©×ž×•×¨ ××• ×‘×˜×œ ××ª ×”×¢×¨×™×›×” ×”× ×•×›×—×™×ª ×ª×—×™×œ×”.",
    "alertQuickAddFromImageTitle": "×”×•×¡×¤×” ×ž×”×™×¨×” ×ž×ª×ž×•× ×”",
    "alertQuickAddFromImageMessage": "×–×”×” ×ž×¡×¤×¨ ×ž××›×œ×™× ×ž×ª×ž×•× ×”.",
    "alertQuickAddInvalidName": "×©× ×œ× ×—×•×§×™",
    "alertQuickAddInvalidNameMessage": "×©× ×”×ž××›×œ ××™× ×• ×™×›×•×œ ×œ×”×™×•×ª ×¨×™×§.",
    "alertQuickAddInvalidGrams": "×’×¨×ž×™× ×œ× ×—×•×§×™×™×",
    "alertQuickAddInvalidGramsMessage": "×× × ×”×–×Ÿ ×ž×¡×¤×¨ ×—×™×•×‘×™ ×—×•×§×™.",
    "alertQuickAddNoItemsSelected": "×œ× × ×‘×—×¨×• ×¤×¨×™×˜×™×",
    "alertQuickAddNoItemsSelectedMessage": "×‘×—×¨ ×¤×¨×™×˜×™× ×œ×”×•×¡×¤×”.",
    "alertQuickAddNothingToAdd": "××™×Ÿ ×ž×” ×œ×”×•×¡×™×£",
    "alertQuickAddNothingToAddMessage": "×œ× × ×‘×—×¨×• ××• ×”×•×›× ×• ×¤×¨×™×˜×™× ×—×•×§×™×™×.",
    "alertQuickAddErrorPreparing": "×©×’×™××”",
    "alertQuickAddErrorPreparingMessage": "×œ× × ×™×ª×Ÿ ×”×™×” ×œ×”×›×™×Ÿ ×¤×¨×™×˜×™× ×œ×”×•×¡×¤×”.",
    "camera": "×ž×¦×œ×ž×”",
    "gallery": "×’×œ×¨×™×”",
    "cancel": "×‘×™×˜×•×œ",
    "addNewFoodButton": "×”×•×¡×£ ×ž××›×œ ×—×“×©",
    "alertOverwriteFoodTitle": "×ž××›×œ ×§×™×™×",
    "alertOverwriteFoodMessage": "×ž××›×œ ×‘×©× \"%{foodName}\" ×›×‘×¨ ×§×™×™×. ×”×× ×œ×”×—×œ×™×£ ×¢× ×”× ×ª×•× ×™× ×”×—×“×©×™×?",
    "overwrite": "×”×—×œ×£",
    "toastFoodSavedToLibrary": "\"%{foodName}\" × ×©×ž×¨ ×œ×¡×¤×¨×™×™×”.",
    "toastFoodUpdatedInLibrary": "\"%{foodName}\" ×¢×•×“×›×Ÿ ×‘×¡×¤×¨×™×™×”.",
    "toastErrorSavingToLibrary": "×©×’×™××” ×‘×©×ž×™×¨×ª ×”×ž××›×œ ×œ×¡×¤×¨×™×™×”."
  },
  "addFoodModal": {
    "titleAdd": "×”×•×¡×£ ×ž××›×œ ×—×“×©",
    "titleEdit": "×¢×¨×•×š ×ž××›×œ",
    "buttonAdd": "×”×•×¡×£",
    "buttonUpdate": "×¢×“×›×Ÿ",
    "getFromImage": "×§×‘×œ ×ž×ª×ž×•× ×”",
    "ingredientsOptional": "×¨×›×™×‘×™× (××•×¤×¦×™×•× ×œ×™)",
    "ingredientsPlaceholder": "×œ×ž×©×œ\n100×’ ×—×–×” ×¢×•×£\n50×’ ××•×¨×–\n1 ×›×£ ×©×ž×Ÿ ×–×™×ª",
    "backToManual": "×—×–×¨×” ×œ×”×–× ×” ×™×“× ×™×ª",
    "aiCalculateRecipe": "×—×©×‘ ×¢× AI (×ž×ª×›×•×Ÿ/×˜×§×¡×˜)",
    "aiGetFromIngredients": "×§×‘×œ ×ž××§×¨×•××™× ×ž×¨×›×™×‘×™×",
    "aiGetFromNameOnly": "×§×‘×œ ×ž××§×¨×•××™× ×ž×©× ×‘×œ×‘×“",
    "barcodeComingSoon": "×”×–× ×ª ×‘×¨×§×•×“ (×‘×§×¨×•×‘)",
    "alertInputNeeded": "× ×“×¨×© ×§×œ×˜",
    "alertInputNeededMessage": "×× × ×”×–×Ÿ ×©× ×ž××›×œ ××• ×¨×›×™×‘×™× ×œ× ×™×ª×•×—.",
    "macrosEstimatedText": "×ž××§×¨×•××™× ×”×•×¢×¨×›×• ×ž×˜×§×¡×˜.",
    "foodIdentified": "×ž××›×œ ×–×•×”×”!",
    "foodIdentifiedMessage": "×–×•×”×” ×›-%{foodName}. ×ž××§×¨×•××™× ×”×•×¢×¨×›×•.",
    "errorGetImage": "×§×‘×œ ×ª×ž×•× ×”",
    "errorGetImageMessage": "×‘×—×¨ ×ž×§×•×¨ ×œ×ª×ž×•× ×ª ×”×ž××›×œ:",
    "errorCamera": "×©×’×™××ª ×ž×¦×œ×ž×”",
    "errorGallery": "×©×’×™××ª ×’×œ×¨×™×”",
    "errorPermission": "× ×“×¨×©×ª ×”×¨×©××”",
    "errorCameraPermission": "× ×“×¨×©×ª ×’×™×©×” ×œ×ž×¦×œ×ž×”."
  },
  "foodFormFields": {
    "foodName": "×©× ×”×ž××›×œ",
    "calories": "×§×œ×•×¨×™×•×ª (×œ-100 ×’×¨×)",
    "protein": "×—×œ×‘×•×Ÿ (×œ-100 ×’×¨×)",
    "carbs": "×¤×—×ž×™×ž×•×ª (×œ-100 ×’×¨×)",
    "fat": "×©×•×ž×Ÿ (×œ-100 ×’×¨×)",
    "errorNameRequired": "×©× ×”×•× ×©×“×” ×—×•×‘×”",
    "errorNonNegative": "×—×™×™×‘ ×œ×”×™×•×ª ×ž×¡×¤×¨ ××™-×©×œ×™×œ×™"
  },
  "quickAddList": {
    "foodNamePlaceholder": "×©× ×”×ž××›×œ",
    "gramsPlaceholder": "×’×¨×ž×™×",
    "errorInvalidGrams": "×œ× ×—×•×§×™",
    "analyzing": "×ž× ×ª×—...",
    "emptyMessage": "×œ× × ×ž×¦××• ×ž××›×œ×™× ×”× ×™×ª× ×™× ×œ×–×™×”×•×™ ×‘×ª×ž×•× ×”.",
    "emptyHint": "× ×¡×” ×ª×ž×•× ×” ××—×¨×ª ××• ×”×•×¡×£ ×™×“× ×™×ª."
  },
  "dailyProgress": {
    "calories": "×§×œ×•×¨×™×•×ª",
    "protein": "×—×œ×‘×•×Ÿ",
    "carbs": "×¤×—×ž×™×ž×•×ª",
    "fat": "×©×•×ž×Ÿ"
  },
  "dateNavigator": {
    "invalidDate": "×ª××¨×™×š ×œ× ×—×•×§×™"
  },
  "utils": {
    "macros": {
      "alertAiErrorRecipe": "×©×’×™××ª AI (×ž×ª×›×•×Ÿ)",
      "alertAnalysisFailedSingle": "× ×™×ª×•×— × ×›×©×œ (×¤×¨×™×˜ ×™×—×™×“)",
      "alertQuickAddFailedMulti": "×”×•×¡×¤×” ×ž×”×™×¨×” × ×›×©×œ×” (×ž×¡×¤×¨ ×¤×¨×™×˜×™×)",
      "alertImageReadError": "×©×’×™××ª ×§×¨×™××ª ×ª×ž×•× ×”",
      "alertImageReadErrorMessage": "×§×¨×™××ª ×§×•×‘×¥ ×”×ª×ž×•× ×” × ×›×©×œ×”.",
      "errorGetMacrosRecipe": "×§×‘×œ×ª ×ž××§×¨×•××™× ×œ×ž×ª×›×•×Ÿ × ×›×©×œ×”: %{error}",
      "errorImageAnalysis": "× ×™×ª×•×— ×”×ª×ž×•× ×” × ×›×©×œ: %{error}",
      "errorCouldNotAnalyze": "×œ× × ×™×ª×Ÿ ×”×™×” ×œ× ×ª×— ××ª ×”×ª×ž×•× ×”: %{error}",
      "errorInvalidResponseMultiple": "×¤×•×¨×ž×˜ ×ª×’×•×‘×” ×œ× ×—×•×§×™ ×ž×”×©×¨×ª ×¢×‘×•×¨ ×ž×¡×¤×¨ ×¤×¨×™×˜×™×."
    },
    "units": {
      "alertAiEstimationFailed": "×”×¢×¨×›×ª AI × ×›×©×œ×”",
      "errorCouldNotEstimateGrams": "×œ× × ×™×ª×Ÿ ×”×™×” ×œ×”×¢×¨×™×š ×’×¨×ž×™×: %{error}"
    },
    "image": {
      "alertCompressionError": "×©×’×™××ª ×“×—×™×¡×”",
      "alertCompressionErrorMessage": "×œ× × ×™×ª×Ÿ ×”×™×” ×œ×¢×‘×“ ××ª ×”×ª×ž×•× ×” ×œ×“×—×™×¡×”.",
      "errorFailedToRead": "×§×¨×™××ª ×§×•×‘×¥ ×”×ª×ž×•× ×” × ×›×©×œ×”: %{error}"
    }
  },
  "backendService": {
    "errorInvalidClientId": "×¤×•×¨×ž×˜ ×ž×–×”×” ×œ×§×•×— ×œ× ×—×•×§×™.",
    "errorRequestFailedParse": "×‘×§×©×” ×œ×©×¨×ª × ×›×©×œ×” (×¡×˜×˜×•×¡ %{status}), ×¤×¢× ×•×— ×”×ª×’×•×‘×” × ×›×©×œ.",
    "errorRequestFailedDetailFormat": "×©×’×™××ª ×©×¨×ª (×¡×˜×˜×•×¡ %{status}), ×¤×•×¨×ž×˜ ×¤×¨×˜×™× ×œ× ×¦×¤×•×™.",
    "errorRequestFailedWithServerMsg": "×‘×§×©×” ×œ×©×¨×ª × ×›×©×œ×” (×¡×˜×˜×•×¡ %{status}). ×ª×’×•×‘×ª ×”×©×¨×ª: %{response}",
    "errorAuthFailed": "×”××™×ž×•×ª × ×›×©×œ. ×ž×–×”×” ×œ×§×•×— ×œ× ×—×•×§×™.",
    "errorPermissionDenied": "×”×’×™×©×” × ×“×—×ª×”.",
    "errorNotFound": "×”×ž×©××‘ ×œ× × ×ž×¦×.",
    "errorTooManyRequests": "×™×•×ª×¨ ×ž×“×™ ×‘×§×©×•×ª. ×× × × ×¡×” ×©×•×‘ ×ž××•×—×¨ ×™×•×ª×¨.",
    "errorInsufficientCoins": "××™×Ÿ ×ž×¡×¤×™×§ ×ž×˜×‘×¢×•×ª ×œ×¤×¢×•×œ×” ×–×•.",
    "errorNetwork": "×”×ª×§×©×•×¨×ª ×¢× ×”×©×¨×ª × ×›×©×œ×”.",
    "errorNetworkTimeout": "×–×ž×Ÿ ×”×‘×§×©×” ×¤×’. ×× × × ×¡×” ×©×•×‘.",
    "errorNetworkConnection": " ×× × ×‘×“×•×§ ××ª ×—×™×‘×•×¨ ×”×¨×©×ª ×©×œ×š.",
    "errorNetworkDetails": " ×¤×¨×˜×™×: %{error}",
    "errorNetworkUnknown": " ××™×¨×¢×” ×©×’×™××ª ×¨×©×ª ×œ× ×™×“×•×¢×”.",
    "errorEstimateGramsUnexpectedResponse": "×§×‘×œ×ª ×”×¢×¨×›×ª ×’×¨×ž×™× × ×›×©×œ×” ×¢×§×‘ ×¤×•×¨×ž×˜ ×ª×’×•×‘×” ×œ× ×¦×¤×•×™.",
    "errorAddCoinsPositive": "×”×¡×›×•× ×œ×”×•×¡×¤×” ×—×™×™×‘ ×œ×”×™×•×ª ×—×™×•×‘×™."
  },
  "statisticsChart": {
    "intake": "×¦×¨×™×›×”",
    "goal": "×™×¢×“",
    "noData": "××™×Ÿ × ×ª×•× ×™× ×–×ž×™× ×™× ×œ×”×¦×’×ª ×ª×¨×©×™× ×¢×‘×•×¨ %{chartTitle}."
  },
  "questionnaireScreen": {
    "title": "×”×¢×¨×›×ª ×”×™×¢×“×™× ×©×œ×š",
    "ageLabel": "×’×™×œ (×©× ×™×)",
    "agePlaceholder": "×œ×“×•×’×ž×”, 30",
    "sexLabel": "×ž×™×Ÿ",
    "sex": {
      "select": "×‘×—×¨ ×ž×™×Ÿ...",
      "male": "×–×›×¨",
      "female": "× ×§×‘×”"
    },
    "heightLabel": "×’×•×‘×”",
    "heightPlaceholder": "×œ×“×•×’×ž×”, 175",
    "weightLabel": "×ž×©×§×œ",
    "weightPlaceholder": "×œ×“×•×’×ž×”, 70",
    "activityLevelLabel": "×¨×ž×ª ×¤×¢×™×œ×•×ª",
    "activityLevel": {
      "select": "×‘×—×¨ ×¨×ž×ª ×¤×¢×™×œ×•×ª...",
      "sedentary": "×™×•×©×‘× ×™ (×ž×¢×˜ ××• ×œ×œ× ×¤×¢×™×œ×•×ª ×’×•×¤× ×™×ª)",
      "light": "×§×œ (×¤×¢×™×œ×•×ª 1-3 ×™×ž×™× ×‘×©×‘×•×¢)",
      "moderate": "×‘×™× ×•× ×™ (×¤×¢×™×œ×•×ª 3-5 ×™×ž×™× ×‘×©×‘×•×¢)",
      "active": "×¤×¢×™×œ (×¤×¢×™×œ×•×ª 6-7 ×™×ž×™× ×‘×©×‘×•×¢)",
      "veryActive": "×¤×¢×™×œ ×ž××•×“ (×¤×¢×™×œ×•×ª ×ž××•×ž×¦×ª ××• ×¢×‘×•×“×” ×¤×™×–×™×ª)"
    },
    "primaryGoalLabel": "×ž×˜×¨×” ×¢×™×§×¨×™×ª",
    "primaryGoal": {
      "select": "×‘×—×¨ ×ž×˜×¨×” ×¢×™×§×¨×™×ª...",
      "loseWeight": "×™×¨×™×“×” ×‘×ž×©×§×œ",
      "maintainWeight": "×©×ž×™×¨×” ×¢×œ ×”×ž×©×§×œ",
      "gainMuscle": "×¢×œ×™×™×” ×‘×ž×¡×ª ×©×¨×™×¨"
    },
    "goalIntensityLabel": "×¢×¦×™×ž×•×ª ×”×ž×˜×¨×”",
    "goalIntensity": {
      "select": "×‘×—×¨ ×¢×¦×™×ž×•×ª...",
      "mild": "×ž×ª×•× ×”",
      "moderate": "×‘×™× ×•× ×™×ª",
      "aggressive": "××’×¨×¡×™×‘×™×ª"
    },
    "calculateButton": "×—×©×‘ ×•×©×ž×•×¨ ×™×¢×“×™×",
    "validation": {
      "invalidAge": "×”×–×Ÿ ×’×™×œ ×ª×§×™×Ÿ (1-120).",
      "selectSex": "×× × ×‘×—×¨ ××ª ×ž×™× ×š.",
      "invalidHeight": "×”×–×Ÿ ×’×•×‘×” ×ª×§×™×Ÿ (50-250 ×¡\"×ž).",
      "invalidWeight": "×”×–×Ÿ ×ž×©×§×œ ×ª×§×™×Ÿ (20-300 ×§\"×’).",
      "selectActivityLevel": "×× × ×‘×—×¨ ××ª ×¨×ž×ª ×”×¤×¢×™×œ×•×ª ×©×œ×š.",
      "selectPrimaryGoal": "×× × ×‘×—×¨ ××ª ×”×ž×˜×¨×” ×”×¢×™×§×¨×™×ª ×©×œ×š.",
      "selectGoalIntensity": "×× × ×‘×—×¨ ××ª ×¢×¦×™×ž×•×ª ×”×ž×˜×¨×” ×©×œ×š.",
      "fixErrors": "×× × ×ª×§×Ÿ ××ª ×”×©×’×™××•×ª ×œ×ž×¢×œ×”."
    },
    "error": {
      "calculationFailedTitle": "×©×’×™××ª ×—×™×©×•×‘",
      "calculationFailedMessage": "×œ× × ×™×ª×Ÿ ×”×™×” ×œ×—×©×‘ ××ª ×”×™×¢×“×™×. ×× × ×‘×“×•×§ ××ª ×”×§×œ×˜ ×©×œ×š.",
      "genericSaveTitle": "×©×’×™××ª ×©×ž×™×¨×”",
      "genericSaveMessage": "×œ× × ×™×ª×Ÿ ×”×™×” ×œ×©×ž×•×¨ ××ª ×”×™×¢×“×™× ×”×ž×•×¢×¨×›×™×. ×× × × ×¡×” ×©×•×‘."
    },
    "toast": {
      "goalsCalculated": "×”×™×¢×“×™× ×—×•×©×‘×• ×•× ×©×ž×¨×•!",
      "minCaloriesAdjustedTitle": "×”×§×œ×•×¨×™×•×ª ×¢×•×“×›× ×•",
      "minCaloriesAdjustedMessage": "×™×¢×“ ×”×§×œ×•×¨×™×•×ª ×©×œ×š ×¢×•×“×›×Ÿ ×œ×ž×™× ×™×ž×•× ×©×œ %{calories} ×§×§\"×œ."
    }
  },
  "foodIconTags": {
    "apple": ["×ª×¤×•×—", "×ª×¤×•×— ×¢×¥", "×ª×¤×•×— ××“×•×", "×ª×¤×•×— ×™×¨×•×§", "×’××œ×”", "×¤×•×’'×™", "×’×¨× ×™ ×¡×ž×™×ª", "×ª×¤×•×—×™×"],
    "banana": ["×‘× × ×”", "×‘× × ×•×ª"],
    "grapes": ["×¢× ×‘", "×¢× ×‘×™×"],
    "strawberry": ["×ª×•×ª", "×ª×•×ª ×©×“×”", "×ª×•×ª×™×"],
    "blueberry": ["××•×›×ž× ×™×ª", "××•×›×ž× ×™×•×ª"],
    "orange": ["×ª×¤×•×–", "×ž× ×“×¨×™× ×”", "×§×œ×ž× ×˜×™× ×”", "×ª×¤×•×–×™×"],
    "lemonLime": ["×œ×™×ž×•×Ÿ", "×œ×™×™×", "×œ×™×ž×•× ×™×"],
    "watermelon": ["××‘×˜×™×—"],
    "pineapple": ["×× × ×¡"],
    "mango": ["×ž× ×’×•"],
    "kiwi": ["×§×™×•×•×™"],
    "peachNectarine": ["××¤×¨×¡×§", "× ×§×˜×¨×™× ×”", "××¤×¨×¡×§×™×"],
    "cherry": ["×“×•×‘×“×‘×Ÿ", "×“×•×‘×“×‘× ×™×", "×’×•×“×’×“×Ÿ"],
    "pear": ["××’×¡", "××’×¡×™×"],
    "avocado": ["××‘×•×§×“×•"],
    "coconut": ["×§×•×§×•×¡"],
    "tomato": ["×¢×’×‘× ×™×”", "×¢×’×‘× ×™×•×ª", "×¢×’×‘× ×™×™×ª ×©×¨×™", "×¢×’×‘× ×™×™×ª ×ª×ž×¨"],
    "carrot": ["×’×–×¨", "×’×–×¨×™×"],
    "broccoli": ["×‘×¨×•×§×•×œ×™"],
    "leafyGreen": ["×—×¡×”", "×ª×¨×“", "×§×™×™×œ", "×¢×œ×™× ×™×¨×•×§×™×", "×¨×•×ž×™×ª", "××•×¨×•×’×•×œ×”", "×ž× ×’×•×œ×“", "×¢×œ×™ ×‘×™×™×‘×™"],
    "cucumber": ["×ž×œ×¤×¤×•×Ÿ", "×ž×œ×¤×¤×•× ×™×", "×—×ž×•×¥", "×—×ž×•×¦×™×", "×§×¤×•× ××˜×”"],
    "pepperGeneral": ["×¤×œ×¤×œ", "×¦'×™×œ×™", "×—×¨×™×£", "×—×œ×¤×™× ×™×•", "×©×™×¤×§×”"],
    "bellPepper": ["×’×ž×‘×”", "×¤×œ×¤×œ ×™×¨×•×§", "×¤×œ×¤×œ ××“×•×", "×¤×œ×¤×œ ×¦×”×•×‘", "×¤×œ×¤×œ ×›×ª×•×"],
    "corn": ["×ª×™×¨×¡", "×§×œ×—×™ ×ª×™×¨×¡"],
    "potato": ["×ª×¤×•×— ××“×ž×”", "×ª×¤×•×—×™ ××“×ž×”", "×‘×˜×˜×”", "×™××", "×ª×¤×•×“"],
    "onion": ["×‘×¦×œ", "×©××œ×•×˜", "×‘×¦×œ ×™×¨×•×§", "×‘×¦×œ×™×", "×¢×™×¨×™×ª"],
    "garlic": ["×©×•×", "×©×Ÿ ×©×•×"],
    "eggplant": ["×—×¦×™×œ", "×—×¦×™×œ×™×"],
    "mushroom": ["×¤×˜×¨×™×™×”", "×¤×˜×¨×™×•×ª", "×¤×•×¨×˜×•×‘×œ×•", "×©×™×˜××§×™", "×©×ž×¤×™× ×™×•×Ÿ", "×™×¨×“×Ÿ"],
    "poultry": ["×¢×•×£", "×—×–×” ×¢×•×£", "×›×¨×¢ ×¢×•×£", "×©×•×§ ×¢×•×£", "×¤×•×œ×§×¢", "×”×•×“×•", "×‘×¨×•×•×–", "×¢×•×£ ×‘×’×¨×™×œ", "×¢×•×£ ×¦×œ×•×™", "×¤×¨×’×™×ª"],
    "redMeat": ["×‘×§×¨", "×¡×˜×™×™×§", "×‘×©×¨ ×˜×—×•×Ÿ", "×§×¦×™×¦×”", "×—×–×™×¨", "×˜×œ×”", "×¢×’×œ", "×‘×©×¨ ××“×•×", "×¦×œ×¢×•×ª", "×× ×˜×¨×™×§×•×˜", "×¡×™× ×˜×”"],
    "bacon": ["×‘×™×™×§×•×Ÿ", "×¤× ×¦'×˜×”"],
    "processedMeat": ["× ×§× ×™×§", "× ×§× ×™×§×™×”", "×¤×¡×˜×¨×ž×”", "×§×‘× ×•×¡", "×¡×œ×ž×™", "×¤×¤×¨×•× ×™", "×‘×©×¨ ×ž×¢×•×‘×“", "×”××"],
    "fish": ["×“×’", "×¡×œ×ž×•×Ÿ", "×˜×•× ×”", "×‘×§×œ×”", "××ž× ×•×Ÿ", "×ž×§×¨×œ", "×¡×¨×“×™×Ÿ", "×”×œ×™×‘×•×˜", "×“×’ ×œ×‘×Ÿ", "×¤×•×¨×œ", "×“×’ ×‘×’×¨×™×œ", "×“×’ ××¤×•×™", "×œ×‘×¨×§", "×ž×•×¡×¨"],
    "shrimpPrawn": ["×©×¨×™×ž×¤×¡", "×—×¡×™×œ×•×Ÿ", "×¤×™×¨×•×ª ×™×", "×¤×¨×•×•×Ÿ"],
    "lobster": ["×œ×•×‘×¡×˜×¨", "×¡×¨×˜×Ÿ × ×”×¨×•×ª", "×¤×™×¨×•×ª ×™×"],
    "crab": ["×¡×¨×˜×Ÿ", "×¤×™×¨×•×ª ×™×"],
    "sushi": ["×¡×•×©×™", "×¡×©×™×ž×™", "×“×’ × ×", "× ×™×’×™×¨×™", "×ž××§×™", "×¨×•×œ"],
    "egg": ["×‘×™×¦×”", "×‘×™×¦×™×", "×‘×™×¦×” ×ž×§×•×©×§×©×ª", "×‘×™×¦×ª ×¢×™×Ÿ", "××•×ž×œ×˜", "×‘×™×¦×” ×§×©×”", "×—×‘×™×ª×”"],
    "milk": ["×—×œ×‘", "×—×œ×‘ ×¤×¨×”", "×—×œ×‘ ×¡×•×™×”", "×—×œ×‘ ×©×§×“×™×", "×—×œ×‘ ×©×™×‘×•×œ×ª ×©×•×¢×œ", "×—×œ×‘ ×¦×ž×—×™", "×—×œ×‘ ××•×¨×–", "×—×œ×‘ ×§×•×§×•×¡", "×—×œ×‘ ×¢×™×–×™×"],
    "cheese": ["×’×‘×™× ×”", "×¦'×“×¨", "×ž×•×¦×¨×œ×”", "×¤×¨×ž×–×Ÿ", "×’××•×“×”", "×‘×¨×™", "×¤×˜×”", "×§×•×˜×’'", "×’×‘×™× ×” ×©×•×•×™×¦×¨×™×ª", "×’×‘×™× ×” ×›×—×•×œ×”", "×’×‘×™× ×ª ×¢×™×–×™×", "×’×‘×™× ×ª ×©×ž× ×ª", "×¦×¤×ª×™×ª", "×‘×•×œ×’×¨×™×ª"],
    "butter": ["×—×ž××”", "×ž×¨×’×¨×™× ×”"],
    "iceCream": ["×’×œ×™×“×”", "×’'×œ××˜×•", "×¡×•×¨×‘×”", "×™×•×’×•×¨×˜ ×§×¤×•×", "××¨×˜×™×§"],
    "yogurt": ["×™×•×’×•×¨×˜", "×™×•×’×•×¨×˜ ×™×•×•× ×™", "×™×•×’×•×¨×˜ ×˜×‘×¢×™", "×ž×¢×“×Ÿ ×—×œ×‘", "×œ×‘×Ÿ", "××©×œ"],
    "bread": ["×œ×—×", "×˜×•×¡×˜", "×‘×™×™×’×œ", "×§×¨×•××¡×•×Ÿ", "×œ×—×ž× ×™×”", "×’×œ×™×œ", "×œ×—× ×ž×—×ž×¦×ª", "×œ×—× ×ž×œ×", "×œ×—× ×œ×‘×Ÿ", "×œ×—× ×©×™×¤×•×Ÿ", "×‘××’×˜", "×—×œ×”"],
    "rice": ["××•×¨×–", "××•×¨×– ×œ×‘×Ÿ", "××•×¨×– ×—×•×", "××•×¨×– ×‘×¡×ž×˜×™", "××•×¨×– ×™×¡×ž×™×Ÿ", "××•×¨×– ×‘×¨", "×“×’×Ÿ", "××•×¨×– ×ž×œ×"],
    "pasta": ["×¤×¡×˜×”", "×¡×¤×’×˜×™", "×ž×§×¨×•× ×™", "××˜×¨×™×•×ª", "×¤×˜×•×¦'×™× ×™", "×œ×–× ×™×”", "×¨××ž×Ÿ", "×¤× ×”", "×¨×‘×™×•×œ×™"],
    "cerealOats": ["×“×’× ×™ ×‘×•×§×¨", "×©×™×‘×•×œ×ª ×©×•×¢×œ", "×“×™×™×¡×”", "×’×¨× ×•×œ×”", "×ž×•×–×œ×™", "×§×•×¨× ×¤×œ×§×¡", "×‘×¨× ×¤×œ×§×¡"],
    "otherGrains": ["×§×™× ×•××”", "×§×•×¡×§×•×¡", "×©×¢×•×¨×”", "×‘×•×¨×’×•×œ", "×¤××¨×•", "×›×•×¡×ž×™×Ÿ", "×“×•×—×Ÿ", "×’×¨×™×¡×™×"],
    "flatbread": ["×˜×•×¨×˜×™×”", "×œ××¤×”", "×¤×™×ª×”", "× ××Ÿ", "×¦'×¤××˜×™", "×¨×•×˜×™", "×ž×¦×”"],
    "beansLegumes": ["×©×¢×•×¢×™×ª", "×©×¢×•×¢×™×ª ×©×—×•×¨×”", "×©×¢×•×¢×™×ª ××“×•×ž×”", "×—×•×ž×•×¡", "×’×¨×’×¨×™ ×—×•×ž×•×¡", "×¢×“×©×™×", "××¤×•× ×”", "×§×˜× ×™×•×ª", "××“×ž×ž×”", "×¤×•×œ×™ ×¡×•×™×”", "×¤×•×œ"],
    "peanut": ["×‘×•×˜×Ÿ", "×‘×•×˜× ×™×", "×—×ž××ª ×‘×•×˜× ×™×"],
    "nuts": ["××’×•×–×™×", "×©×§×“", "××’×•×– ×ž×œ×š", "×§×©×™×•", "×¤×§××Ÿ", "×¤×™×¡×˜×•×§", "××’×•×– ×œ×•×–", "××’×•×– ×‘×¨×–×™×œ", "××’×•×–×™ ×ž×§×“×ž×™×”", "×¢×¨×ž×•× ×™×"],
    "seeds": ["×–×¨×¢×™×", "×’×¨×¢×™× ×™ ×—×ž× ×™×”", "×’×¨×¢×™× ×™ ×“×œ×¢×ª", "×–×¨×¢×™ ×¦'×™×”", "×–×¨×¢×™ ×¤×©×ª×Ÿ", "×©×•×ž×©×•×", "×–×¨×¢×™ ×”×ž×¤", "×’×¨×¢×™× ×™×"],
    "donut": ["×¡×•×¤×’× ×™×”", "×“×•× ××˜", "×ž××¤×”"],
    "cookie": ["×¢×•×’×™×”", "×‘×™×¡×§×•×•×™×˜", "×ž×§×¨×•×Ÿ", "×¢×•×’×™×•×ª"],
    "chocolate": ["×©×•×§×•×œ×“", "×—×˜×™×£ ×©×•×§×•×œ×“", "×©×•×§×•×œ×“ ×ž×¨×™×¨", "×©×•×§×•×œ×“ ×—×œ×‘", "×©×•×§×•×œ×“ ×œ×‘×Ÿ", "×§×§××•"],
    "cake": ["×¢×•×’×”", "×§××¤×§×™×™×§", "×ž××¤×™×Ÿ", "×‘×¨××•× ×™", "×¢×•×’×ª ×’×‘×™× ×”", "×¨×•×œ×“×”"],
    "candy": ["×ž×ž×ª×§", "×ž×ž×ª×§×™×", "×¡×•×›×¨×™×”", "×¡×•×›×¨×™×•×ª ×’×•×ž×™", "×¡×•×›×¨×™×” ×¢×œ ×ž×§×œ", "×ž×¨×©×ž×œ×•", "×˜×•×¤×™"],
    "popcorn": ["×¤×•×¤×§×•×¨×Ÿ"],
    "pretzel": ["×‘×™×™×’×œ×”", "×¤×¨×¢×¦×œ"],
    "friesChips": ["×¦'×™×¤×¡", "×˜×•×’× ×™×", "×ª×¤×•×¦'×™×¤×¡", "×—×˜×™×£ ×ª×¤×•×—×™ ××“×ž×”", "×¤×•×˜×˜×•"],
    "coffee": ["×§×¤×”", "××¡×¤×¨×¡×•", "×œ××˜×”", "×§×¤×•×¦'×™× ×•", "××ž×¨×™×§× ×•", "×ž×•×§×”", "×§×¤×” ×§×¨", "× ×¡ ×§×¤×”"],
    "tea": ["×ª×”", "×ª×” ×™×¨×•×§", "×ª×” ×©×—×•×¨", "×ª×” ×¦×ž×—×™×", "×¦'××™", "×—×œ×™×˜×ª ×¦×ž×—×™×"],
    "softDrinkJuice": ["×ž×©×§×” ×§×œ", "×§×•×œ×”", "×¡×•×“×”", "×ž×™×¥", "×ž×™×¥ ×ª×¤×•×–×™×", "×ž×™×¥ ×ª×¤×•×—×™×", "×©×™×™×§", "×©×™×™×§ ×—×œ×‘×•×Ÿ", "×œ×™×ž×•× ×“×”", "××™×™×¡ ×˜×™", "×ž×©×§×” ×ž×•×’×–"],
    "water": ["×ž×™×", "×ž×™× ×ž×™× ×¨×œ×™×™×", "×¡×•×“×” (×ž×™×)"],
    "wine": ["×™×™×Ÿ", "×™×™×Ÿ ××“×•×", "×™×™×Ÿ ×œ×‘×Ÿ", "×¨×•×–×”", "×™×™×Ÿ ×ž×‘×¢×‘×¢", "×©×ž×¤× ×™×”", "××œ×›×•×”×•×œ"],
    "beer": ["×‘×™×¨×”", "×œ××’×¨", "××™×™×œ", "×¡×˜××•×˜", "××œ×›×•×”×•×œ"],
    "cocktail": ["×§×•×§×˜×™×™×œ", "×ž×©×§×” ×—×¨×™×£", "×œ×™×§×¨", "×•×•×“×§×”", "×’'×™×Ÿ", "×¨×•×", "×•×•×™×¡×§×™", "×˜×§×™×œ×”", "×ž×¨×’×¨×™×˜×”", "××œ×›×•×”×•×œ"],
    "pizza": ["×¤×™×¦×”", "×¤×™×¦×” ×ž×¨×’×¨×™×˜×”", "×¤×™×¦×” ×¤×¤×¨×•× ×™"],
    "burger": ["×”×ž×‘×•×¨×’×¨", "×‘×•×¨×’×¨", "×¦'×™×–×‘×•×¨×’×¨", "×‘×•×¨×’×¨ ×¦×ž×—×•× ×™", "×§×¦×™×¦×ª ×”×ž×‘×•×¨×’×¨"],
    "tacoBurrito": ["×˜××§×•", "×‘×•×¨×™×˜×•", "×§×¡××“×™×™×”", "×¤Ø§Ù‡×™×˜×”", "×× ×¦'×™×œ×“×”", "××•×›×œ ×ž×§×¡×™×§× ×™"],
    "sandwich": ["×›×¨×™×š", "×¡× ×“×•×•×™×¥'", "×˜×•×¡×˜", "×‘××’×˜"],
    "soupStew": ["×ž×¨×§", "× ×–×™×“", "×¦×™×¨", "×¦'××•×“×¨", "×¤×•", "×ž×¨×§ ×™×¨×§×•×ª", "×ž×¨×§ ×¢×•×£"],
    "salad": ["×¡×œ×˜", "×¡×œ×˜ ×§×™×¡×¨", "×¡×œ×˜ ×™×•×•× ×™", "×¡×œ×˜ ×™×¨×§×•×ª", "×¡×œ×˜ ×¤×™×¨×•×ª", "×¡×œ×˜ ×˜×•× ×”"],
    "noodleDish": ["×¨××ž×Ÿ", "××˜×¨×™×•×ª ×¤×•", "×ž×¨×§ ××˜×¨×™×•×ª", "×¤××“ ×ª××™", "× ×•×“×œ×¡ ×ž×•×§×¤×¥", "××˜×¨×™×•×ª ××•×¨×–", "××˜×¨×™×•×ª ×‘×™×¦×™×"],
    "genericFruit": ["×¤×¨×™", "×¤×™×¨×•×ª", "×¤×™×¨×•×ª ×™×¢×¨", "×¤×™×¨×•×ª ×”×“×¨", "×¤×™×¨×•×ª ×˜×¨×•×¤×™×™×"],
    "genericVegetable": ["×™×¨×§", "×™×¨×§×•×ª", "×™×¨×§×•×ª ×©×•×¨×©", "×™×¨×§×•×ª ×¢×œ×™×", "×™×¨×•×§×™×"],
    "genericMeal": ["××•×›×œ", "××¨×•×—×”", "×ž× ×”", "×¦×œ×—×ª", "×ž× ×” ×¢×™×§×¨×™×ª", "×—×˜×™×£", "××¨×•×—×ª ×¦×”×¨×™×™×", "××¨×•×—×ª ×¢×¨×‘", "××¨×•×—×ª ×‘×•×§×¨", "××•×›×œ ×›×œ×œ×™", "××•×›×œ ×ž×‘×•×©×œ", "×©××¨×™×•×ª", "×ª×‘×©×™×œ"],
    "unknownFood": ["×œ× ×™×“×•×¢", "×œ× ×ž×–×•×”×”", "××—×¨"]
  }
}
---------- END he.json ----------


---------- ru.json ----------
{
  "app": {
    "initializing": "Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ...",
    "name": "MacrosVisionAI",
    "alertButtons": {
      "later": "ÐŸÐ¾Ð·Ð¶Ðµ",
      "restartNow": "ÐŸÐµÑ€ÐµÐ·Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚ÑŒ ÑÐµÐ¹Ñ‡Ð°Ñ"
    }
  },
  "settingsScreen": {
    "title": "ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸",
    "account": {
      "title": "ÐÐºÐºÐ°ÑƒÐ½Ñ‚"
    },
    "general": {
      "title": "ÐžÐ±Ñ‰Ð¸Ðµ"
    },
    "dailyGoals": {
      "title": "Ð”Ð½ÐµÐ²Ð½Ñ‹Ðµ Ñ†ÐµÐ»Ð¸"
    },
    "goals": {
      "estimateButton": "Ð Ð°ÑÑÑ‡Ð¸Ñ‚Ð°Ñ‚ÑŒ Ñ†ÐµÐ»Ð¸"
    },
    "statistics": {
      "title": "Ð¡Ñ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÐ°"
    },
    "dataManagement": {
      "title": "Ð£Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ð¼Ð¸"
    },
    "language": {
      "title": "Ð¯Ð·Ñ‹Ðº",
      "system": "Ð¡Ð¸ÑÑ‚ÐµÐ¼Ð½Ñ‹Ð¹",
      "english": "ÐÐ½Ð³Ð»Ð¸Ð¹ÑÐºÐ¸Ð¹",
      "russian": "Ð ÑƒÑÑÐºÐ¸Ð¹",
      "hebrew": "Ð˜Ð²Ñ€Ð¸Ñ‚",
      "restartMessage": "Ð¯Ð·Ñ‹Ðº Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½. ÐŸÐµÑ€ÐµÐ·Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚Ðµ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð´Ð»Ñ Ð¿Ð¾Ð»Ð½Ð¾Ð³Ð¾ ÑÑ„Ñ„ÐµÐºÑ‚Ð°."
    }
  },
  "accountSettings": {
    "coinBalance": "Ð‘Ð°Ð»Ð°Ð½Ñ Ð¼Ð¾Ð½ÐµÑ‚",
    "addTestCoins": "Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ 10 Ð¼Ð¾Ð½ÐµÑ‚ (Ð¢ÐµÑÑ‚)",
    "testButtonWarning": "ÐŸÑ€Ð¸Ð¼ÐµÑ‡Ð°Ð½Ð¸Ðµ: ÐšÐ½Ð¾Ð¿ÐºÐ° \"Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð¼Ð¾Ð½ÐµÑ‚Ñ‹\" Ð¿Ñ€ÐµÐ´Ð½Ð°Ð·Ð½Ð°Ñ‡ÐµÐ½Ð° Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð´Ð»Ñ Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ/Ñ€Ð°Ð·Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸ Ð¸ Ð´Ð¾Ð»Ð¶Ð½Ð° Ð±Ñ‹Ñ‚ÑŒ ÑƒÐ´Ð°Ð»ÐµÐ½Ð° Ð¸Ð»Ð¸ Ð·Ð°Ñ‰Ð¸Ñ‰ÐµÐ½Ð° Ð² Ñ€ÐµÐ»Ð¸Ð·Ð½Ñ‹Ñ… Ð²ÐµÑ€ÑÐ¸ÑÑ….",
    "notApplicable": "Ð/Ð”",
    "errorLoadCoins": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð·Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚ÑŒ Ð±Ð°Ð»Ð°Ð½Ñ Ð¼Ð¾Ð½ÐµÑ‚",
    "errorAddCoins": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð´Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð¼Ð¾Ð½ÐµÑ‚Ñ‹",
    "coinsAdded": "ÐœÐ¾Ð½ÐµÑ‚Ñ‹ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ñ‹!"
  },
  "themeSwitch": {
    "darkMode": "Ð¢ÐµÐ¼Ð½Ñ‹Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼"
  },
  "dailyGoalsInput": {
    "caloriesGoal": "Ð¦ÐµÐ»ÑŒ ÐºÐ°Ð»Ð¾Ñ€Ð¸Ð¹",
    "proteinGoal": "Ð¦ÐµÐ»ÑŒ Ð±ÐµÐ»ÐºÐ¾Ð²",
    "carbsGoal": "Ð¦ÐµÐ»ÑŒ ÑƒÐ³Ð»ÐµÐ²Ð¾Ð´Ð¾Ð²",
    "fatGoal": "Ð¦ÐµÐ»ÑŒ Ð¶Ð¸Ñ€Ð¾Ð²"
  },
  "dataManagement": {
    "exportData": "Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ…",
    "importData": "Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ…",
    "clearAllData": "ÐžÑ‡Ð¸ÑÑ‚Ð¸Ñ‚ÑŒ Ð²ÑÐµ Ð´Ð°Ð½Ð½Ñ‹Ðµ",
    "exportError": "ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐºÑÐ¿Ð¾Ñ€Ñ‚Ð°",
    "exportErrorNoSharing": "Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚ Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½ Ð½Ð° Ð²Ð°ÑˆÐµÐ¹ Ð¿Ð»Ð°Ñ‚Ñ„Ð¾Ñ€Ð¼Ðµ.",
    "exportFailed": "Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚ Ð½Ðµ ÑƒÐ´Ð°Ð»ÑÑ",
    "exportFailedMessage": "ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ ÑÐºÑÐ¿Ð¾Ñ€Ñ‚Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ….",
    "importCancelled": "Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚ Ð¾Ñ‚Ð¼ÐµÐ½ÐµÐ½ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¼.",
    "importInvalidFileType": "ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ñ‚Ð¸Ð¿ Ñ„Ð°Ð¹Ð»Ð°",
    "importInvalidFileTypeMessage": "ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð²Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹ Ñ„Ð°Ð¹Ð» '.json'.",
    "importFileTooLarge": "Ð¤Ð°Ð¹Ð» ÑÐ»Ð¸ÑˆÐºÐ¾Ð¼ Ð±Ð¾Ð»ÑŒÑˆÐ¾Ð¹",
    "importFileTooLargeMessage": "Ð’Ñ‹Ð±Ñ€Ð°Ð½Ð½Ñ‹Ð¹ Ñ„Ð°Ð¹Ð» ÑÐ»Ð¸ÑˆÐºÐ¾Ð¼ Ð±Ð¾Ð»ÑŒÑˆÐ¾Ð¹ (Ð¼Ð°ÐºÑ. 10 ÐœÐ‘).",
    "importFailed": "Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚ Ð½Ðµ ÑƒÐ´Ð°Ð»ÑÑ",
    "importFailedInvalidStructure": "Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ñ„Ð°Ð¹Ð» Ð¸Ð¼ÐµÐµÑ‚ Ð½ÐµÐ²ÐµÑ€Ð½ÑƒÑŽ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ñƒ Ð¸Ð»Ð¸ Ð¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ð²ÑƒÑŽÑ‚ Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ (dailyEntries, foods, settings).",
    "importFailedParseError": "Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ñ„Ð°Ð¹Ð» Ð½Ðµ ÑÐ²Ð»ÑÐµÑ‚ÑÑ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¼ JSON Ð¸Ð»Ð¸ Ð¸Ð¼ÐµÐµÑ‚ Ð¿Ð¾Ð²Ñ€ÐµÐ¶Ð´ÐµÐ½Ð½Ð¾Ðµ ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ð¾Ðµ.",
    "importFailedAccessError": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð´Ð¾ÑÑ‚ÑƒÐ¿ Ðº Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð½Ð¾Ð¼Ñƒ Ñ„Ð°Ð¹Ð»Ñƒ.",
    "importFailedPermissionError": "Ð”Ð»Ñ Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚Ð° Ñ„Ð°Ð¹Ð»Ð¾Ð² Ñ‚Ñ€ÐµÐ±ÑƒÑŽÑ‚ÑÑ Ñ€Ð°Ð·Ñ€ÐµÑˆÐµÐ½Ð¸Ñ Ð½Ð° Ð´Ð¾ÑÑ‚ÑƒÐ¿ Ðº Ñ…Ñ€Ð°Ð½Ð¸Ð»Ð¸Ñ‰Ñƒ.",
    "importFailedUnknownError": "Ð’Ð¾ Ð²Ñ€ÐµÐ¼Ñ Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚Ð° Ð¿Ñ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð½ÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ð°Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ°.",
    "importSuccessful": "Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚ ÑƒÑÐ¿ÐµÑˆÐµÐ½",
    "importSuccessfulMessage": "Ð”Ð°Ð½Ð½Ñ‹Ðµ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ñ‹ Ð¸ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ñ‹.",
    "clearDataSuccess": "Ð”Ð°Ð½Ð½Ñ‹Ðµ Ð¾Ñ‡Ð¸Ñ‰ÐµÐ½Ñ‹",
    "clearDataSuccessMessage": "Ð’ÑÐµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ Ð±Ñ‹Ð»Ð¸ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð¾Ñ‡Ð¸Ñ‰ÐµÐ½Ñ‹.",
    "clearDataFailed": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¾Ñ‡Ð¸ÑÑ‚Ð¸Ñ‚ÑŒ Ð´Ð°Ð½Ð½Ñ‹Ðµ",
    "clearDataFailedMessage": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¾Ñ‡Ð¸ÑÑ‚Ð¸Ñ‚ÑŒ Ð´Ð°Ð½Ð½Ñ‹Ðµ.",
    "confirmClearTitle": "ÐŸÐ¾Ð´Ñ‚Ð²ÐµÑ€Ð´Ð¸Ñ‚ÑŒ Ð¾Ñ‡Ð¸ÑÑ‚ÐºÑƒ Ð²ÑÐµÑ… Ð´Ð°Ð½Ð½Ñ‹Ñ…",
    "confirmClearMessage": "Ð­Ñ‚Ð¾ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ Ð½ÐµÐ¾Ð±Ñ€Ð°Ñ‚Ð¸Ð¼Ð¾ Ð¸ ÑƒÐ´Ð°Ð»Ð¸Ñ‚ Ð²ÑÐµ Ð·Ð°Ð¿Ð¸ÑÐ¸, Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ñ‹ Ð¸ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸.\n\nÐ’Ð²ÐµÐ´Ð¸Ñ‚Ðµ \"CLEAR DATA\" Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð´Ð¾Ð»Ð¶ÐµÐ½Ð¸Ñ.",
    "confirmClearInputPlaceholder": "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ \"CLEAR DATA\"",
    "clearConfirmationFailed": "ÐŸÐ¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ðµ Ð½Ðµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ",
    "clearConfirmationFailedMessage": "Ð’Ð²ÐµÐ´ÐµÐ½ Ð½ÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ñ‚ÐµÐºÑÑ‚ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ñ. Ð”Ð°Ð½Ð½Ñ‹Ðµ Ð½Ðµ Ð±Ñ‹Ð»Ð¸ Ð¾Ñ‡Ð¸Ñ‰ÐµÐ½Ñ‹.",
    "dataReloaded": "Ð”Ð°Ð½Ð½Ñ‹Ðµ Ð¿ÐµÑ€ÐµÐ·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ñ‹."
  },
  "confirmationModal": {
    "confirm": "ÐŸÐ¾Ð´Ñ‚Ð²ÐµÑ€Ð´Ð¸Ñ‚ÑŒ",
    "cancel": "ÐžÑ‚Ð¼ÐµÐ½Ð°",
    "defaultTitle": "ÐŸÐ¾Ð´Ñ‚Ð²ÐµÑ€Ð´Ð¸Ñ‚Ðµ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ",
    "defaultMessage": "Ð’Ñ‹ ÑƒÐ²ÐµÑ€ÐµÐ½Ñ‹, Ñ‡Ñ‚Ð¾ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ Ð²Ñ‹Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÑŒ ÑÑ‚Ð¾ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ?",
    "enterTextPlaceholder": "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ñ‚ÐµÐºÑÑ‚ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ñ",
    "restartRequiredTitle": "Ð¢Ñ€ÐµÐ±ÑƒÐµÑ‚ÑÑ Ð¿ÐµÑ€ÐµÐ·Ð°Ð¿ÑƒÑÐº"
  },
  "dailyEntryScreen": {
    "tabTitle": "Ð”Ð½ÐµÐ²Ð½Ð¸Ðº",
    "todaysEntries": "Ð—Ð°Ð¿Ð¸ÑÐ¸ Ð·Ð° ÑÐµÐ³Ð¾Ð´Ð½Ñ",
    "saving": "Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ðµ...",
    "loadingEntries": "Ð—Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° Ð·Ð°Ð¿Ð¸ÑÐµÐ¹...",
    "noEntries": "Ð—Ð°Ð¿Ð¸ÑÐµÐ¹ Ð·Ð° ÑÑ‚Ð¾Ñ‚ Ð´ÐµÐ½ÑŒ Ð½ÐµÑ‚.",
    "noEntriesHint": "ÐÐ°Ð¶Ð¼Ð¸Ñ‚Ðµ '+', Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð´Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð¿ÐµÑ€Ð²ÑƒÑŽ Ð·Ð°Ð¿Ð¸ÑÑŒ Ð¾ ÐµÐ´Ðµ.",
    "entryAdded": "Ð—Ð°Ð¿Ð¸ÑÑŒ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð°",
    "entryUpdated": "Ð—Ð°Ð¿Ð¸ÑÑŒ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð°",
    "itemRemoved": "%{itemName} ÑƒÐ´Ð°Ð»ÐµÐ½Ð¾",
    "undo": "ÐÐ°Ð¶Ð¼Ð¸Ñ‚Ðµ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¾Ñ‚Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ",
    "entryRestored": "Ð—Ð°Ð¿Ð¸ÑÑŒ Ð²Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð°!",
    "itemsAdded": "%{count} ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚(Ð¾Ð²) Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¾",
    "toDateFormat": "Ðº %{date}",
    "errorLoad": "ÐžÑˆÐ¸Ð±ÐºÐ° Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸",
    "errorLoadMessage": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð·Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚ÑŒ Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ.",
    "errorSave": "ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ñ",
    "errorSaveMessage": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ ÑÐ¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ. ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¿Ð¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ ÐµÑ‰Ðµ Ñ€Ð°Ð·.",
    "errorInvalidDate": "ÐÐµÐ²ÐµÑ€Ð½Ð°Ñ Ð´Ð°Ñ‚Ð°",
    "errorInvalidDateMessage": "Ð’Ñ‹Ð±Ñ€Ð°Ð½Ð½Ð°Ñ Ð´Ð°Ñ‚Ð° Ð½ÐµÐ´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð°.",
    "errorEditEntry": "ÐžÑˆÐ¸Ð±ÐºÐ° Ñ€ÐµÐ´Ð°ÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ",
    "errorEditEntryMessage": "ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ð¾Ð´Ð³Ð¾Ñ‚Ð¾Ð²ÐºÐ¸ Ð·Ð°Ð¿Ð¸ÑÐ¸ Ðº Ñ€ÐµÐ´Ð°ÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸ÑŽ.",
    "errorAddMultiple": "ÐžÑˆÐ¸Ð±ÐºÐ° Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¸Ñ…",
    "errorAddMultipleMessage": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð´Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¾ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð².",
    "invalidEntryData": "ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð·Ð°Ð¿Ð¸ÑÐ¸",
    "edit": "Ð˜Ð·Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ",
    "delete": "Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ"
  },
  "foodListScreen": {
    "tabTitle": "ÐŸÑ€Ð¾Ð´ÑƒÐºÑ‚Ñ‹",
    "searchPlaceholder": "ÐŸÐ¾Ð¸ÑÐº Ð² Ð²Ð°ÑˆÐµÐ¹ Ð±Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÐºÐµ Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ð¾Ð²...",
    "loadingFoods": "Ð—Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ð¾Ð²...",
    "emptyLibrary": "Ð’Ð°ÑˆÐ° Ð±Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÐºÐ° Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ð¾Ð² Ð¿ÑƒÑÑ‚Ð°.",
    "emptyLibraryHint": "ÐÐ°Ð¶Ð¼Ð¸Ñ‚Ðµ '+', Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð´Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð¿ÐµÑ€Ð²Ñ‹Ð¹ Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚!",
    "noResults": "ÐŸÑ€Ð¾Ð´ÑƒÐºÑ‚Ñ‹, ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²ÑƒÑŽÑ‰Ð¸Ðµ \"%{searchTerm}\", Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ñ‹",
    "errorLoad": "ÐžÑˆÐ¸Ð±ÐºÐ°",
    "errorLoadMessage": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð·Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚ÑŒ ÑÐ¿Ð¸ÑÐ¾Ðº Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ð¾Ð².",
    "foodAdded": "%{foodName} Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¾",
    "foodUpdated": "%{foodName} Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾",
    "foodDeleted": "%{foodName} ÑƒÐ´Ð°Ð»ÐµÐ½Ð¾",
    "foodRestored": "%{foodName} Ð²Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾",
    "errorCreate": "ÐžÑˆÐ¸Ð±ÐºÐ°",
    "errorCreateMessage": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ ÑÐ¾Ð·Ð´Ð°Ñ‚ÑŒ Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚.",
    "errorUpdate": "ÐžÑˆÐ¸Ð±ÐºÐ°",
    "errorUpdateMessage": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¾Ð±Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚.",
    "errorDelete": "ÐžÑˆÐ¸Ð±ÐºÐ° ÑƒÐ´Ð°Ð»ÐµÐ½Ð¸Ñ",
    "errorDeleteMessage": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ ÑƒÐ´Ð°Ð»Ð¸Ñ‚ÑŒ Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚ Ð¸Ð· Ñ…Ñ€Ð°Ð½Ð¸Ð»Ð¸Ñ‰Ð°. Ð­Ð»ÐµÐ¼ÐµÐ½Ñ‚ Ð²Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½.",
    "fixErrors": "ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¸ÑÐ¿Ñ€Ð°Ð²ÑŒÑ‚Ðµ Ð¾ÑˆÐ¸Ð±ÐºÐ¸",
    "edit": "Ð˜Ð·Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ",
    "delete": "Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ",
    "shareFoodTitle": "ÐŸÐ¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ %{foodName}",
    "shareErrorTitle": "ÐžÑˆÐ¸Ð±ÐºÐ°",
    "shareErrorMessage": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ð¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ð¾Ð¼.",
    "deepLinkErrorTitle": "ÐžÑˆÐ¸Ð±ÐºÐ° Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚Ð¸Ñ ÑÑÑ‹Ð»ÐºÐ¸",
    "deepLinkInvalidData": "Ð”Ð°Ð½Ð½Ñ‹Ðµ Ð¾ Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ðµ Ð¸Ð· ÑÑÑ‹Ð»ÐºÐ¸ Ð½ÐµÐ´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹.",
    "deepLinkParseError": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ñ‚ÑŒ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¾ Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ðµ Ð¸Ð· ÑÑÑ‹Ð»ÐºÐ¸."
  },
  "addEntryModal": {
    "titleAdd": "Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð·Ð°Ð¿Ð¸ÑÑŒ",
    "titleEdit": "Ð˜Ð·Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ Ð·Ð°Ð¿Ð¸ÑÑŒ",
    "titleQuickAddSelect": "Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ‹ Ð´Ð»Ñ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ",
    "titleQuickAddEdit": "Ð˜Ð·Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚",
    "titleQuickAddAnalyzing": "ÐÐ½Ð°Ð»Ð¸Ð·...",
    "searchPlaceholder": "ÐŸÐ¾Ð¸ÑÐº Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ð¾Ð²...",
    "recent": "ÐÐµÐ´Ð°Ð²Ð½Ð¸Ðµ",
    "noResults": "ÐŸÑ€Ð¾Ð´ÑƒÐºÑ‚Ñ‹, ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²ÑƒÑŽÑ‰Ð¸Ðµ \"%{searchTerm}\", Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ñ‹.",
    "emptyLibraryMessage": "Ð’Ð°ÑˆÐ° Ð±Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÐºÐ° Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ð¾Ð² Ð¿ÑƒÑÑ‚Ð°. ÐÐ°Ð¶Ð¼Ð¸Ñ‚Ðµ Ð½Ð¸Ð¶Ðµ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð´Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð¿ÐµÑ€Ð²Ñ‹Ð¹ Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚!",
    "noQuickAddResults": "ÐÐ° Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ð¸ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾ Ð¿Ð¸Ñ‰ÐµÐ²Ñ‹Ñ… Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ð¾Ð².",
    "amount": "ÐšÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾",
    "grams": "Ð“Ñ€Ð°Ð¼Ð¼Ñ‹",
    "autoAi": "ÐÐ²Ñ‚Ð¾ (Ð˜Ð˜)",
    "quickAddServing": "Ð‘Ñ‹ÑÑ‚Ñ€Ð¾Ðµ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ:",
    "lastUsedServing": "ÐŸÑ€ÐµÐ´.: %{grams}Ð³",
    "gramsPlaceholder": "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð³Ñ€Ð°Ð¼Ð¼Ñ‹ (Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€, 150)",
    "gramsPlaceholderEdit": "ÐžÐ±Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ð³Ñ€Ð°Ð¼Ð¼Ñ‹",
    "gramsError": "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾Ðµ Ñ‡Ð¸ÑÐ»Ð¾",
    "autoPlaceholder": "ÐžÐ¿Ð¸ÑˆÐ¸Ñ‚Ðµ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ (Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€, 1 Ñ‡Ð°ÑˆÐºÐ° Ð¿Ñ€Ð¸Ð³Ð¾Ñ‚Ð¾Ð²Ð»ÐµÐ½Ð½Ð¾Ð³Ð¾)",
    "buttonAdd": "Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ",
    "buttonUpdate": "ÐžÐ±Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ",
    "buttonBack": "ÐÐ°Ð·Ð°Ð´",
    "buttonAddSelected": "Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ %{count}",
    "buttonLoading": "Ð—Ð°Ð³Ñ€ÑƒÐ·ÐºÐ°...",
    "quickAddHeader": "Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ‹ Ñ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ",
    "quickAddHeaderEdit": "Ð ÐµÐ´Ð°ÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ ÑÐ²ÐµÐ´ÐµÐ½Ð¸Ð¹ Ð¾Ð± ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ðµ",
    "alertInputMissing": "ÐžÑ‚ÑÑƒÑ‚ÑÑ‚Ð²ÑƒÐµÑ‚ Ð²Ð²Ð¾Ð´",
    "alertInputMissingMessage": "ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð²Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚ Ð¸ Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð°.",
    "alertGramsEstimated": "Ð“Ñ€Ð°Ð¼Ð¼Ñ‹ Ð¾Ñ†ÐµÐ½ÐµÐ½Ñ‹",
    "alertGramsEstimatedMessage": "ÐžÑ†ÐµÐ½ÐµÐ½Ð¾ %{grams}Ð³ Ð´Ð»Ñ %{foodName}",
    "alertFoodNotSelected": "ÐŸÑ€Ð¾Ð´ÑƒÐºÑ‚ Ð½Ðµ Ð²Ñ‹Ð±Ñ€Ð°Ð½",
    "alertFoodNotSelectedMessage": "ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð²Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚.",
    "alertInvalidAmount": "ÐÐµÐ²ÐµÑ€Ð½Ð¾Ðµ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾",
    "alertInvalidAmountMessage": "ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾Ðµ Ð¿Ð¾Ð»Ð¾Ð¶Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾Ðµ Ñ‡Ð¸ÑÐ»Ð¾ Ð´Ð»Ñ Ð³Ñ€Ð°Ð¼Ð¼Ð¾Ð².",
    "alertQuickAddPermission": "Ð¢Ñ€ÐµÐ±ÑƒÐµÑ‚ÑÑ Ñ€Ð°Ð·Ñ€ÐµÑˆÐµÐ½Ð¸Ðµ",
    "alertQuickAddCameraPermission": "ÐÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼ Ð´Ð¾ÑÑ‚ÑƒÐ¿ Ðº ÐºÐ°Ð¼ÐµÑ€Ðµ.",
    "alertQuickAddGalleryPermission": "ÐÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼ Ð´Ð¾ÑÑ‚ÑƒÐ¿ Ðº Ð³Ð°Ð»ÐµÑ€ÐµÐµ.",
    "alertQuickAddUserCancelled": "ÐžÑ‚Ð¼ÐµÐ½ÐµÐ½Ð¾ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¼",
    "alertQuickAddCouldNotSelect": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð²Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ.",
    "alertQuickAddError": "ÐžÑˆÐ¸Ð±ÐºÐ°",
    "alertQuickAddErrorMessage": "ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð½ÐµÐ¿Ñ€ÐµÐ´Ð²Ð¸Ð´ÐµÐ½Ð½Ð°Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ°.",
    "alertQuickAddFinishEditing": "Ð—Ð°Ð²ÐµÑ€ÑˆÐ¸Ñ‚Ðµ Ñ€ÐµÐ´Ð°ÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ",
    "alertQuickAddFinishEditingSaveOrCancel": "ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, ÑÐ½Ð°Ñ‡Ð°Ð»Ð° ÑÐ¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚Ðµ Ð¸Ð»Ð¸ Ð¾Ñ‚Ð¼ÐµÐ½Ð¸Ñ‚Ðµ Ñ‚ÐµÐºÑƒÑ‰ÐµÐµ Ñ€ÐµÐ´Ð°ÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ.",
    "alertQuickAddFromImageTitle": "Ð‘Ñ‹ÑÑ‚Ñ€Ð¾Ðµ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ñ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ",
    "alertQuickAddFromImageMessage": "ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»Ð¸Ñ‚Ðµ Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ð¾Ð² Ñ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ.",
    "alertQuickAddInvalidName": "ÐÐµÐ²ÐµÑ€Ð½Ð¾Ðµ Ð¸Ð¼Ñ",
    "alertQuickAddInvalidNameMessage": "ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ð° Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑ‚ Ð±Ñ‹Ñ‚ÑŒ Ð¿ÑƒÑÑ‚Ñ‹Ð¼.",
    "alertQuickAddInvalidGrams": "ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ðµ Ð³Ñ€Ð°Ð¼Ð¼Ñ‹",
    "alertQuickAddInvalidGramsMessage": "ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾Ðµ Ð¿Ð¾Ð»Ð¾Ð¶Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾Ðµ Ñ‡Ð¸ÑÐ»Ð¾.",
    "alertQuickAddNoItemsSelected": "Ð­Ð»ÐµÐ¼ÐµÐ½Ñ‚Ñ‹ Ð½Ðµ Ð²Ñ‹Ð±Ñ€Ð°Ð½Ñ‹",
    "alertQuickAddNoItemsSelectedMessage": "Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ‹ Ð´Ð»Ñ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ.",
    "alertQuickAddNothingToAdd": "ÐÐµÑ‡ÐµÐ³Ð¾ Ð´Ð¾Ð±Ð°Ð²Ð»ÑÑ‚ÑŒ",
    "alertQuickAddNothingToAddMessage": "ÐÐµ Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð¾ Ð¸Ð»Ð¸ Ð½Ðµ Ð¿Ð¾Ð´Ð³Ð¾Ñ‚Ð¾Ð²Ð»ÐµÐ½Ð¾ Ð½Ð¸ Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾Ð³Ð¾ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°.",
    "alertQuickAddErrorPreparing": "ÐžÑˆÐ¸Ð±ÐºÐ°",
    "alertQuickAddErrorPreparingMessage": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ð¾Ð´Ð³Ð¾Ñ‚Ð¾Ð²Ð¸Ñ‚ÑŒ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ñ‹ Ð´Ð»Ñ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ.",
    "camera": "ÐšÐ°Ð¼ÐµÑ€Ð°",
    "gallery": "Ð“Ð°Ð»ÐµÑ€ÐµÑ",
    "cancel": "ÐžÑ‚Ð¼ÐµÐ½Ð°",
    "addNewFoodButton": "Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð½Ð¾Ð²Ñ‹Ð¹ Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚",
    "alertOverwriteFoodTitle": "ÐŸÑ€Ð¾Ð´ÑƒÐºÑ‚ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÐµÑ‚",
    "alertOverwriteFoodMessage": "ÐŸÑ€Ð¾Ð´ÑƒÐºÑ‚ Ñ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼ \"%{foodName}\" ÑƒÐ¶Ðµ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÐµÑ‚. ÐŸÐµÑ€ÐµÐ·Ð°Ð¿Ð¸ÑÐ°Ñ‚ÑŒ Ð½Ð¾Ð²Ñ‹Ð¼Ð¸ Ð´Ð°Ð½Ð½Ñ‹Ð¼Ð¸?",
    "overwrite": "ÐŸÐµÑ€ÐµÐ·Ð°Ð¿Ð¸ÑÐ°Ñ‚ÑŒ",
    "toastFoodSavedToLibrary": "\"%{foodName}\" ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¾ Ð² Ð±Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÐºÑƒ.",
    "toastFoodUpdatedInLibrary": "\"%{foodName}\" Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾ Ð² Ð±Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÐºÐµ.",
    "toastErrorSavingToLibrary": "ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ñ Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ð° Ð² Ð±Ð¸Ð±Ð»Ð¸Ð¾Ñ‚ÐµÐºÑƒ."
  },
  "addFoodModal": {
    "titleAdd": "Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð½Ð¾Ð²Ñ‹Ð¹ Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚",
    "titleEdit": "Ð˜Ð·Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚",
    "buttonAdd": "Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ",
    "buttonUpdate": "ÐžÐ±Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ",
    "getFromImage": "ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ",
    "ingredientsOptional": "Ð˜Ð½Ð³Ñ€ÐµÐ´Ð¸ÐµÐ½Ñ‚Ñ‹ (Ð½ÐµÐ¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ð¾)",
    "ingredientsPlaceholder": "Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€\n100Ð³ ÐºÑƒÑ€Ð¸Ð½Ð¾Ð¹ Ð³Ñ€ÑƒÐ´ÐºÐ¸\n50Ð³ Ñ€Ð¸ÑÐ°\n1 ÑÑ‚.Ð». Ð¾Ð»Ð¸Ð²ÐºÐ¾Ð²Ð¾Ð³Ð¾ Ð¼Ð°ÑÐ»Ð°",
    "backToManual": "ÐÐ°Ð·Ð°Ð´ Ðº Ñ€ÑƒÑ‡Ð½Ð¾Ð¼Ñƒ Ð²Ð²Ð¾Ð´Ñƒ",
    "aiCalculateRecipe": "Ð Ð°ÑÑÑ‡Ð¸Ñ‚Ð°Ñ‚ÑŒ Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ Ð˜Ð˜ (Ð ÐµÑ†ÐµÐ¿Ñ‚/Ð¢ÐµÐºÑÑ‚)",
    "aiGetFromIngredients": "ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð¼Ð°ÐºÑ€Ð¾ÑÑ‹ Ð¸Ð· Ð¸Ð½Ð³Ñ€ÐµÐ´Ð¸ÐµÐ½Ñ‚Ð¾Ð²",
    "aiGetFromNameOnly": "ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð¼Ð°ÐºÑ€Ð¾ÑÑ‹ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¿Ð¾ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÑŽ",
    "barcodeComingSoon": "Ð’Ð²Ð¾Ð´ ÑˆÑ‚Ñ€Ð¸Ñ…-ÐºÐ¾Ð´Ð° (ÑÐºÐ¾Ñ€Ð¾)",
    "alertInputNeeded": "Ð¢Ñ€ÐµÐ±ÑƒÐµÑ‚ÑÑ Ð²Ð²Ð¾Ð´",
    "alertInputNeededMessage": "ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ð° Ð¸Ð»Ð¸ Ð¸Ð½Ð³Ñ€ÐµÐ´Ð¸ÐµÐ½Ñ‚Ñ‹ Ð´Ð»Ñ Ð°Ð½Ð°Ð»Ð¸Ð·Ð°.",
    "macrosEstimatedText": "ÐœÐ°ÐºÑ€Ð¾ÑÑ‹ Ð¾Ñ†ÐµÐ½ÐµÐ½Ñ‹ Ð¿Ð¾ Ñ‚ÐµÐºÑÑ‚Ñƒ.",
    "foodIdentified": "ÐŸÑ€Ð¾Ð´ÑƒÐºÑ‚ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½!",
    "foodIdentifiedMessage": "ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¾ ÐºÐ°Ðº %{foodName}. ÐœÐ°ÐºÑ€Ð¾ÑÑ‹ Ð¾Ñ†ÐµÐ½ÐµÐ½Ñ‹.",
    "errorGetImage": "ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ",
    "errorGetImageMessage": "Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¸ÑÑ‚Ð¾Ñ‡Ð½Ð¸Ðº Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ð°:",
    "errorCamera": "ÐžÑˆÐ¸Ð±ÐºÐ° ÐºÐ°Ð¼ÐµÑ€Ñ‹",
    "errorGallery": "ÐžÑˆÐ¸Ð±ÐºÐ° Ð³Ð°Ð»ÐµÑ€ÐµÐ¸",
    "errorPermission": "Ð¢Ñ€ÐµÐ±ÑƒÐµÑ‚ÑÑ Ñ€Ð°Ð·Ñ€ÐµÑˆÐµÐ½Ð¸Ðµ",
    "errorCameraPermission": "ÐÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼ Ð´Ð¾ÑÑ‚ÑƒÐ¿ Ðº ÐºÐ°Ð¼ÐµÑ€Ðµ."
  },
  "foodFormFields": {
    "foodName": "ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ð°",
    "calories": "ÐšÐ°Ð»Ð¾Ñ€Ð¸Ð¸ (Ð½Ð° 100Ð³)",
    "protein": "Ð‘ÐµÐ»ÐºÐ¸ (Ð½Ð° 100Ð³)",
    "carbs": "Ð£Ð³Ð»ÐµÐ²Ð¾Ð´Ñ‹ (Ð½Ð° 100Ð³)",
    "fat": "Ð–Ð¸Ñ€Ñ‹ (Ð½Ð° 100Ð³)",
    "errorNameRequired": "ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ð¾",
    "errorNonNegative": "Ð”Ð¾Ð»Ð¶Ð½Ð¾ Ð±Ñ‹Ñ‚ÑŒ Ð½ÐµÐ¾Ñ‚Ñ€Ð¸Ñ†Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¼ Ñ‡Ð¸ÑÐ»Ð¾Ð¼"
  },
  "quickAddList": {
    "foodNamePlaceholder": "ÐÐ°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ð°",
    "gramsPlaceholder": "Ð“Ñ€Ð°Ð¼Ð¼Ñ‹",
    "errorInvalidGrams": "ÐÐµÐ²ÐµÑ€Ð½Ð¾",
    "analyzing": "ÐÐ½Ð°Ð»Ð¸Ð·...",
    "emptyMessage": "ÐÐ° Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ð¸ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾ Ð¾Ð¿Ð¾Ð·Ð½Ð°Ð²Ð°ÐµÐ¼Ñ‹Ñ… Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ð¾Ð².",
    "emptyHint": "ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð´Ñ€ÑƒÐ³Ð¾Ðµ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ Ð¸Ð»Ð¸ Ð´Ð¾Ð±Ð°Ð²ÑŒÑ‚Ðµ Ð²Ñ€ÑƒÑ‡Ð½ÑƒÑŽ."
  },
  "dailyProgress": {
    "calories": "ÐšÐ°Ð»Ð¾Ñ€Ð¸Ð¸",
    "protein": "Ð‘ÐµÐ»ÐºÐ¸",
    "carbs": "Ð£Ð³Ð»ÐµÐ²Ð¾Ð´Ñ‹",
    "fat": "Ð–Ð¸Ñ€Ñ‹"
  },
  "dateNavigator": {
    "invalidDate": "ÐÐµÐ²ÐµÑ€Ð½Ð°Ñ Ð´Ð°Ñ‚Ð°"
  },
  "utils": {
    "macros": {
      "alertAiErrorRecipe": "ÐžÑˆÐ¸Ð±ÐºÐ° Ð˜Ð˜ (Ð ÐµÑ†ÐµÐ¿Ñ‚)",
      "alertAnalysisFailedSingle": "ÐžÑˆÐ¸Ð±ÐºÐ° Ð°Ð½Ð°Ð»Ð¸Ð·Ð° (ÐžÐ´Ð¸Ð½ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚)",
      "alertQuickAddFailedMulti": "ÐžÑˆÐ¸Ð±ÐºÐ° Ð±Ñ‹ÑÑ‚Ñ€Ð¾Ð³Ð¾ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ (ÐÐµÑÐºÐ¾Ð»ÑŒÐºÐ¾ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð²)",
      "alertImageReadError": "ÐžÑˆÐ¸Ð±ÐºÐ° Ñ‡Ñ‚ÐµÐ½Ð¸Ñ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ",
      "alertImageReadErrorMessage": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ñ‚ÑŒ Ñ„Ð°Ð¹Ð» Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ.",
      "errorGetMacrosRecipe": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð¼Ð°ÐºÑ€Ð¾ÑÑ‹ Ð´Ð»Ñ Ñ€ÐµÑ†ÐµÐ¿Ñ‚Ð°: %{error}",
      "errorImageAnalysis": "ÐžÑˆÐ¸Ð±ÐºÐ° Ð°Ð½Ð°Ð»Ð¸Ð·Ð° Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ: %{error}",
      "errorCouldNotAnalyze": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ñ€Ð¾Ð°Ð½Ð°Ð»Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ: %{error}",
      "errorInvalidResponseMultiple": "ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚ Ð¾Ñ‚Ð²ÐµÑ‚Ð° Ð¾Ñ‚ ÑÐµÑ€Ð²ÐµÑ€Ð° Ð´Ð»Ñ Ð½ÐµÑÐºÐ¾Ð»ÑŒÐºÐ¸Ñ… ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð²."
    },
    "units": {
      "alertAiEstimationFailed": "ÐžÑˆÐ¸Ð±ÐºÐ° Ð¾Ñ†ÐµÐ½ÐºÐ¸ Ð˜Ð˜",
      "errorCouldNotEstimateGrams": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¾Ñ†ÐµÐ½Ð¸Ñ‚ÑŒ Ð³Ñ€Ð°Ð¼Ð¼Ñ‹: %{error}"
    },
    "image": {
      "alertCompressionError": "ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐ¶Ð°Ñ‚Ð¸Ñ",
      "alertCompressionErrorMessage": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ñ‚ÑŒ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ Ð´Ð»Ñ ÑÐ¶Ð°Ñ‚Ð¸Ñ.",
      "errorFailedToRead": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ñ‚ÑŒ Ñ„Ð°Ð¹Ð» Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ: %{error}"
    }
  },
  "backendService": {
    "errorInvalidClientId": "ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚ Ð¸Ð´ÐµÐ½Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ‚Ð¾Ñ€Ð° ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð°.",
    "errorRequestFailedParse": "Ð—Ð°Ð¿Ñ€Ð¾Ñ Ðº Ð±ÑÐºÐµÐ½Ð´Ñƒ Ð½Ðµ ÑƒÐ´Ð°Ð»ÑÑ (Ð¡Ñ‚Ð°Ñ‚ÑƒÑ %{status}), Ð½Ðµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ñ€Ð°Ð·Ð¾Ð±Ñ€Ð°Ñ‚ÑŒ Ð¾Ñ‚Ð²ÐµÑ‚.",
    "errorRequestFailedDetailFormat": "ÐžÑˆÐ¸Ð±ÐºÐ° Ð±ÑÐºÐµÐ½Ð´Ð° (Ð¡Ñ‚Ð°Ñ‚ÑƒÑ %{status}), Ð½ÐµÐ¾Ð¶Ð¸Ð´Ð°Ð½Ð½Ñ‹Ð¹ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚ Ð´ÐµÑ‚Ð°Ð»ÐµÐ¹.",
    "errorRequestFailedWithServerMsg": "Ð—Ð°Ð¿Ñ€Ð¾Ñ Ðº Ð±ÑÐºÐµÐ½Ð´Ñƒ Ð½Ðµ ÑƒÐ´Ð°Ð»ÑÑ (Ð¡Ñ‚Ð°Ñ‚ÑƒÑ %{status}). ÐžÑ‚Ð²ÐµÑ‚ ÑÐµÑ€Ð²ÐµÑ€Ð°: %{response}",
    "errorAuthFailed": "ÐÑƒÑ‚ÐµÐ½Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸Ñ Ð½Ðµ ÑƒÐ´Ð°Ð»Ð°ÑÑŒ. ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð¸Ð´ÐµÐ½Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ‚Ð¾Ñ€ ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð°.",
    "errorPermissionDenied": "Ð”Ð¾ÑÑ‚ÑƒÐ¿ Ð·Ð°Ð¿Ñ€ÐµÑ‰ÐµÐ½.",
    "errorNotFound": "Ð ÐµÑÑƒÑ€Ñ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½.",
    "errorTooManyRequests": "Ð¡Ð»Ð¸ÑˆÐºÐ¾Ð¼ Ð¼Ð½Ð¾Ð³Ð¾ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ¾Ð². ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¿Ð¾Ð²Ñ‚Ð¾Ñ€Ð¸Ñ‚Ðµ Ð¿Ð¾Ð¿Ñ‹Ñ‚ÐºÑƒ Ð¿Ð¾Ð·Ð¶Ðµ.",
    "errorInsufficientCoins": "ÐÐµÐ´Ð¾ÑÑ‚Ð°Ñ‚Ð¾Ñ‡Ð½Ð¾ Ð¼Ð¾Ð½ÐµÑ‚ Ð´Ð»Ñ ÑÑ‚Ð¾Ð³Ð¾ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ.",
    "errorNetwork": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ ÑÐ²ÑÐ·Ð°Ñ‚ÑŒÑÑ Ñ Ð±ÑÐºÐµÐ½Ð´Ð¾Ð¼.",
    "errorNetworkTimeout": "Ð’Ñ€ÐµÐ¼Ñ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ° Ð¸ÑÑ‚ÐµÐºÐ»Ð¾. ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¿Ð¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ ÐµÑ‰Ðµ Ñ€Ð°Ð·.",
    "errorNetworkConnection": " ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑŒÑ‚Ðµ Ð²Ð°ÑˆÐµ ÑÐµÑ‚ÐµÐ²Ð¾Ðµ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ.",
    "errorNetworkDetails": " Ð”ÐµÑ‚Ð°Ð»Ð¸: %{error}",
    "errorNetworkUnknown": " ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð½ÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ð°Ñ ÑÐµÑ‚ÐµÐ²Ð°Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ°.",
    "errorEstimateGramsUnexpectedResponse": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð¾Ñ†ÐµÐ½ÐºÑƒ Ð³Ñ€Ð°Ð¼Ð¼Ð¾Ð² Ð¸Ð·-Ð·Ð° Ð½ÐµÐ¾Ð¶Ð¸Ð´Ð°Ð½Ð½Ð¾Ð³Ð¾ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ð° Ð¾Ñ‚Ð²ÐµÑ‚Ð°.",
    "errorAddCoinsPositive": "Ð¡ÑƒÐ¼Ð¼Ð° Ð´Ð»Ñ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ Ð´Ð¾Ð»Ð¶Ð½Ð° Ð±Ñ‹Ñ‚ÑŒ Ð¿Ð¾Ð»Ð¾Ð¶Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾Ð¹."
  },
  "statisticsChart": {
    "intake": "ÐŸÐ¾Ñ‚Ñ€ÐµÐ±Ð»ÐµÐ½Ð¸Ðµ",
    "goal": "Ð¦ÐµÐ»ÑŒ",
    "noData": "ÐÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð´Ð»Ñ Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ Ð³Ñ€Ð°Ñ„Ð¸ÐºÐ° Ð´Ð»Ñ %{chartTitle}."
  },
  "questionnaireScreen": {
    "title": "ÐžÑ†ÐµÐ½ÐºÐ° Ð²Ð°ÑˆÐ¸Ñ… Ñ†ÐµÐ»ÐµÐ¹",
    "ageLabel": "Ð’Ð¾Ð·Ñ€Ð°ÑÑ‚ (Ð»ÐµÑ‚)",
    "agePlaceholder": "Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€, 30",
    "sexLabel": "ÐŸÐ¾Ð»",
    "sex": {
      "select": "Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¿Ð¾Ð»...",
      "male": "ÐœÑƒÐ¶ÑÐºÐ¾Ð¹",
      "female": "Ð–ÐµÐ½ÑÐºÐ¸Ð¹"
    },
    "heightLabel": "Ð Ð¾ÑÑ‚",
    "heightPlaceholder": "Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€, 175",
    "weightLabel": "Ð’ÐµÑ",
    "weightPlaceholder": "Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€, 70",
    "activityLevelLabel": "Ð£Ñ€Ð¾Ð²ÐµÐ½ÑŒ Ð°ÐºÑ‚Ð¸Ð²Ð½Ð¾ÑÑ‚Ð¸",
    "activityLevel": {
      "select": "Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ ÑƒÑ€Ð¾Ð²ÐµÐ½ÑŒ Ð°ÐºÑ‚Ð¸Ð²Ð½Ð¾ÑÑ‚Ð¸...",
      "sedentary": "Ð¡Ð¸Ð´ÑÑ‡Ð¸Ð¹ (Ð¼Ð°Ð»Ð¾ Ð¸Ð»Ð¸ Ð½ÐµÑ‚ ÑƒÐ¿Ñ€Ð°Ð¶Ð½ÐµÐ½Ð¸Ð¹)",
      "light": "Ð›ÐµÐ³ÐºÐ¸Ð¹ (ÑƒÐ¿Ñ€Ð°Ð¶Ð½ÐµÐ½Ð¸Ñ 1-3 Ñ€Ð°Ð·Ð°/Ð½ÐµÐ´)",
      "moderate": "Ð£Ð¼ÐµÑ€ÐµÐ½Ð½Ñ‹Ð¹ (ÑƒÐ¿Ñ€Ð°Ð¶Ð½ÐµÐ½Ð¸Ñ 3-5 Ñ€Ð°Ð·/Ð½ÐµÐ´)",
      "active": "ÐÐºÑ‚Ð¸Ð²Ð½Ñ‹Ð¹ (ÑƒÐ¿Ñ€Ð°Ð¶Ð½ÐµÐ½Ð¸Ñ 6-7 Ñ€Ð°Ð·/Ð½ÐµÐ´)",
      "veryActive": "ÐžÑ‡ÐµÐ½ÑŒ Ð°ÐºÑ‚Ð¸Ð²Ð½Ñ‹Ð¹ (Ñ‚ÑÐ¶ÐµÐ»Ñ‹Ðµ ÑƒÐ¿Ñ€Ð°Ð¶Ð½ÐµÐ½Ð¸Ñ Ð¸Ð»Ð¸ Ñ„Ð¸Ð·Ð¸Ñ‡ÐµÑÐºÐ°Ñ Ñ€Ð°Ð±Ð¾Ñ‚Ð°)"
    },
    "primaryGoalLabel": "ÐžÑÐ½Ð¾Ð²Ð½Ð°Ñ Ñ†ÐµÐ»ÑŒ",
    "primaryGoal": {
      "select": "Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¾ÑÐ½Ð¾Ð²Ð½ÑƒÑŽ Ñ†ÐµÐ»ÑŒ...",
      "loseWeight": "Ð¡Ð±Ñ€Ð¾ÑÐ¸Ñ‚ÑŒ Ð²ÐµÑ",
      "maintainWeight": "ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°Ñ‚ÑŒ Ð²ÐµÑ",
      "gainMuscle": "ÐÐ°Ð±Ñ€Ð°Ñ‚ÑŒ Ð¼Ñ‹ÑˆÐµÑ‡Ð½ÑƒÑŽ Ð¼Ð°ÑÑÑƒ"
    },
    "goalIntensityLabel": "Ð˜Ð½Ñ‚ÐµÐ½ÑÐ¸Ð²Ð½Ð¾ÑÑ‚ÑŒ Ñ†ÐµÐ»Ð¸",
    "goalIntensity": {
      "select": "Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¸Ð½Ñ‚ÐµÐ½ÑÐ¸Ð²Ð½Ð¾ÑÑ‚ÑŒ...",
      "mild": "Ð›ÐµÐ³ÐºÐ°Ñ",
      "moderate": "Ð£Ð¼ÐµÑ€ÐµÐ½Ð½Ð°Ñ",
      "aggressive": "ÐÐ³Ñ€ÐµÑÑÐ¸Ð²Ð½Ð°Ñ"
    },
    "calculateButton": "Ð Ð°ÑÑÑ‡Ð¸Ñ‚Ð°Ñ‚ÑŒ Ð¸ ÑÐ¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ Ñ†ÐµÐ»Ð¸",
    "validation": {
      "invalidAge": "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹ Ð²Ð¾Ð·Ñ€Ð°ÑÑ‚ (1-120).",
      "selectSex": "ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð²Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð²Ð°Ñˆ Ð¿Ð¾Ð».",
      "invalidHeight": "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹ Ñ€Ð¾ÑÑ‚ (50-250 ÑÐ¼).",
      "invalidWeight": "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹ Ð²ÐµÑ (20-300 ÐºÐ³).",
      "selectActivityLevel": "ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð²Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð²Ð°Ñˆ ÑƒÑ€Ð¾Ð²ÐµÐ½ÑŒ Ð°ÐºÑ‚Ð¸Ð²Ð½Ð¾ÑÑ‚Ð¸.",
      "selectPrimaryGoal": "ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð²Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð²Ð°ÑˆÑƒ Ð¾ÑÐ½Ð¾Ð²Ð½ÑƒÑŽ Ñ†ÐµÐ»ÑŒ.",
      "selectGoalIntensity": "ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð²Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¸Ð½Ñ‚ÐµÐ½ÑÐ¸Ð²Ð½Ð¾ÑÑ‚ÑŒ Ñ†ÐµÐ»Ð¸.",
      "fixErrors": "ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¸ÑÐ¿Ñ€Ð°Ð²ÑŒÑ‚Ðµ Ð¾ÑˆÐ¸Ð±ÐºÐ¸ Ð²Ñ‹ÑˆÐµ."
    },
    "error": {
      "calculationFailedTitle": "ÐžÑˆÐ¸Ð±ÐºÐ° Ñ€Ð°ÑÑ‡ÐµÑ‚Ð°",
      "calculationFailedMessage": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ñ€Ð°ÑÑÑ‡Ð¸Ñ‚Ð°Ñ‚ÑŒ Ñ†ÐµÐ»Ð¸. ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑŒÑ‚Ðµ Ð²Ð²ÐµÐ´ÐµÐ½Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ.",
      "genericSaveTitle": "ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ñ",
      "genericSaveMessage": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ ÑÐ¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ Ñ€Ð°ÑÑÑ‡Ð¸Ñ‚Ð°Ð½Ð½Ñ‹Ðµ Ñ†ÐµÐ»Ð¸. ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¿Ð¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ ÐµÑ‰Ðµ Ñ€Ð°Ð·."
    },
    "toast": {
      "goalsCalculated": "Ð¦ÐµÐ»Ð¸ Ñ€Ð°ÑÑÑ‡Ð¸Ñ‚Ð°Ð½Ñ‹ Ð¸ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ñ‹!",
      "minCaloriesAdjustedTitle": "ÐšÐ°Ð»Ð¾Ñ€Ð¸Ð¸ ÑÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ñ‹",
      "minCaloriesAdjustedMessage": "Ð’Ð°ÑˆÐ° Ñ†ÐµÐ»ÑŒ Ð¿Ð¾ ÐºÐ°Ð»Ð¾Ñ€Ð¸ÑÐ¼ Ð±Ñ‹Ð»Ð° ÑÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð° Ð´Ð¾ Ð¼Ð¸Ð½Ð¸Ð¼ÑƒÐ¼Ð° Ð² %{calories} ÐºÐºÐ°Ð»."
    }
  },
  "foodIconTags": {
    "apple": ["ÑÐ±Ð»Ð¾ÐºÐ¾", "ÐºÑ€Ð°ÑÐ½Ð¾Ðµ ÑÐ±Ð»Ð¾ÐºÐ¾", "Ð·ÐµÐ»ÐµÐ½Ð¾Ðµ ÑÐ±Ð»Ð¾ÐºÐ¾", "Ð³Ð°Ð»Ð°", "Ñ„ÑƒÐ´Ð¶Ð¸", "Ð³Ñ€ÐµÐ½Ð½Ð¸ ÑÐ¼Ð¸Ñ‚", "ÑÐ±Ð»Ð¾ÐºÐ¸"],
    "banana": ["Ð±Ð°Ð½Ð°Ð½", "Ð±Ð°Ð½Ð°Ð½Ñ‹"],
    "grapes": ["Ð²Ð¸Ð½Ð¾Ð³Ñ€Ð°Ð´"],
    "strawberry": ["ÐºÐ»ÑƒÐ±Ð½Ð¸ÐºÐ°", "Ð·ÐµÐ¼Ð»ÑÐ½Ð¸ÐºÐ°"],
    "blueberry": ["Ð³Ð¾Ð»ÑƒÐ±Ð¸ÐºÐ°", "Ñ‡ÐµÑ€Ð½Ð¸ÐºÐ°"],
    "orange": ["Ð°Ð¿ÐµÐ»ÑŒÑÐ¸Ð½", "Ð¼Ð°Ð½Ð´Ð°Ñ€Ð¸Ð½", "ÐºÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¸Ð½", "Ð°Ð¿ÐµÐ»ÑŒÑÐ¸Ð½Ñ‹"],
    "lemonLime": ["Ð»Ð¸Ð¼Ð¾Ð½", "Ð»Ð°Ð¹Ð¼", "Ð»Ð¸Ð¼Ð¾Ð½Ñ‹"],
    "watermelon": ["Ð°Ñ€Ð±ÑƒÐ·"],
    "pineapple": ["Ð°Ð½Ð°Ð½Ð°Ñ"],
    "mango": ["Ð¼Ð°Ð½Ð³Ð¾"],
    "kiwi": ["ÐºÐ¸Ð²Ð¸"],
    "peachNectarine": ["Ð¿ÐµÑ€ÑÐ¸Ðº", "Ð½ÐµÐºÑ‚Ð°Ñ€Ð¸Ð½", "Ð¿ÐµÑ€ÑÐ¸ÐºÐ¸"],
    "cherry": ["Ð²Ð¸ÑˆÐ½Ñ", "Ñ‡ÐµÑ€ÐµÑˆÐ½Ñ"],
    "pear": ["Ð³Ñ€ÑƒÑˆÐ°", "Ð³Ñ€ÑƒÑˆÐ¸"],
    "avocado": ["Ð°Ð²Ð¾ÐºÐ°Ð´Ð¾"],
    "coconut": ["ÐºÐ¾ÐºÐ¾Ñ", "ÐºÐ¾ÐºÐ¾ÑÑ‹"],
    "tomato": ["Ð¿Ð¾Ð¼Ð¸Ð´Ð¾Ñ€", "Ñ‚Ð¾Ð¼Ð°Ñ‚", "Ð¿Ð¾Ð¼Ð¸Ð´Ð¾Ñ€Ñ‹", "Ñ‚Ð¾Ð¼Ð°Ñ‚Ñ‹", "Ñ‡ÐµÑ€Ñ€Ð¸", "ÑÐ»Ð¸Ð²ÐºÐ°"],
    "carrot": ["Ð¼Ð¾Ñ€ÐºÐ¾Ð²ÑŒ", "Ð¼Ð¾Ñ€ÐºÐ¾Ð²ÐºÐ°"],
    "broccoli": ["Ð±Ñ€Ð¾ÐºÐºÐ¾Ð»Ð¸"],
    "leafyGreen": ["ÑÐ°Ð»Ð°Ñ‚", "ÑˆÐ¿Ð¸Ð½Ð°Ñ‚", "ÐºÐ°Ð¿ÑƒÑÑ‚Ð° ÐºÐ°Ð»Ðµ", "Ð·ÐµÐ»ÐµÐ½ÑŒ", "Ð»Ð¸ÑÑ‚Ð¾Ð²Ð°Ñ Ð·ÐµÐ»ÐµÐ½ÑŒ", "Ñ€ÑƒÐºÐºÐ¾Ð»Ð°", "Ð¼Ð°Ð½Ð³Ð¾Ð»ÑŒÐ´", "Ð°Ð¹ÑÐ±ÐµÑ€Ð³"],
    "cucumber": ["Ð¾Ð³ÑƒÑ€ÐµÑ†", "Ð¾Ð³ÑƒÑ€Ñ†Ñ‹", "ÑÐ¾Ð»ÐµÐ½Ñ‹Ð¹ Ð¾Ð³ÑƒÑ€ÐµÑ†", "Ð¼Ð°Ñ€Ð¸Ð½Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ð¾Ð³ÑƒÑ€ÐµÑ†", "ÐºÐ¾Ñ€Ð½Ð¸ÑˆÐ¾Ð½"],
    "pepperGeneral": ["Ð¿ÐµÑ€ÐµÑ†", "Ñ‡Ð¸Ð»Ð¸", "Ñ…Ð°Ð»Ð°Ð¿ÐµÐ½ÑŒÐ¾", "Ð¿Ð°Ð¿Ñ€Ð¸ÐºÐ°", "Ð¾ÑÑ‚Ñ€Ñ‹Ð¹ Ð¿ÐµÑ€ÐµÑ†"],
    "bellPepper": ["ÑÐ»Ð°Ð´ÐºÐ¸Ð¹ Ð¿ÐµÑ€ÐµÑ†", "Ð±Ð¾Ð»Ð³Ð°Ñ€ÑÐºÐ¸Ð¹ Ð¿ÐµÑ€ÐµÑ†", "Ð·ÐµÐ»ÐµÐ½Ñ‹Ð¹ Ð¿ÐµÑ€ÐµÑ†", "ÐºÑ€Ð°ÑÐ½Ñ‹Ð¹ Ð¿ÐµÑ€ÐµÑ†", "Ð¶ÐµÐ»Ñ‚Ñ‹Ð¹ Ð¿ÐµÑ€ÐµÑ†", "Ð¾Ñ€Ð°Ð½Ð¶ÐµÐ²Ñ‹Ð¹ Ð¿ÐµÑ€ÐµÑ†"],
    "corn": ["ÐºÑƒÐºÑƒÑ€ÑƒÐ·Ð°", "Ð·ÐµÑ€Ð½Ð¾ ÐºÑƒÐºÑƒÑ€ÑƒÐ·Ñ‹", "ÐºÑƒÐºÑƒÑ€ÑƒÐ·Ð½Ñ‹Ð¹ Ð¿Ð¾Ñ‡Ð°Ñ‚Ð¾Ðº"],
    "potato": ["ÐºÐ°Ñ€Ñ‚Ð¾Ñ„ÐµÐ»ÑŒ", "ÐºÐ°Ñ€Ñ‚Ð¾ÑˆÐºÐ°", "Ð±Ð°Ñ‚Ð°Ñ‚", "ÑÐ¼Ñ"],
    "onion": ["Ð»ÑƒÐº", "Ñ€ÐµÐ¿Ñ‡Ð°Ñ‚Ñ‹Ð¹ Ð»ÑƒÐº", "Ð·ÐµÐ»ÐµÐ½Ñ‹Ð¹ Ð»ÑƒÐº", "Ð»ÑƒÐº-ÑˆÐ°Ð»Ð¾Ñ‚", "Ð¿Ð¾Ñ€ÐµÐ¹"],
    "garlic": ["Ñ‡ÐµÑÐ½Ð¾Ðº", "Ð·ÑƒÐ±Ñ‡Ð¸Ðº Ñ‡ÐµÑÐ½Ð¾ÐºÐ°"],
    "eggplant": ["Ð±Ð°ÐºÐ»Ð°Ð¶Ð°Ð½", "Ð±Ð°ÐºÐ»Ð°Ð¶Ð°Ð½Ñ‹"],
    "mushroom": ["Ð³Ñ€Ð¸Ð±", "Ð³Ñ€Ð¸Ð±Ñ‹", "ÑˆÐ°Ð¼Ð¿Ð¸Ð½ÑŒÐ¾Ð½", "Ð¿Ð¾Ñ€Ñ‚Ð¾Ð±ÐµÐ»Ð»Ð¾", "ÑˆÐ¸Ð¸Ñ‚Ð°ÐºÐµ", "Ð²ÐµÑˆÐµÐ½ÐºÐ°", "Ð±ÐµÐ»Ñ‹Ð¹ Ð³Ñ€Ð¸Ð±", "Ð»Ð¸ÑÐ¸Ñ‡ÐºÐ°"],
    "poultry": ["ÐºÑƒÑ€Ð¸Ñ†Ð°", "ÐºÑƒÑ€Ð¸Ð½Ð°Ñ Ð³Ñ€ÑƒÐ´ÐºÐ°", "ÐºÑƒÑ€Ð¸Ð½Ð¾Ðµ Ð±ÐµÐ´Ñ€Ð¾", "ÐºÑƒÑ€Ð¸Ð½Ð°Ñ Ð½Ð¾Ð¶ÐºÐ°", "Ð¸Ð½Ð´ÐµÐ¹ÐºÐ°", "ÑƒÑ‚ÐºÐ°", "Ð¿Ñ‚Ð¸Ñ†Ð°", "Ð¶Ð°Ñ€ÐµÐ½Ð°Ñ ÐºÑƒÑ€Ð¸Ñ†Ð°", "ÐºÑƒÑ€Ð¸Ñ†Ð° Ð³Ñ€Ð¸Ð»ÑŒ", "Ñ„Ð¸Ð»Ðµ ÐºÑƒÑ€Ð¸Ñ†Ñ‹"],
    "redMeat": ["Ð³Ð¾Ð²ÑÐ´Ð¸Ð½Ð°", "ÑÑ‚ÐµÐ¹Ðº", "Ñ„Ð°Ñ€Ñˆ", "ÑÐ²Ð¸Ð½Ð¸Ð½Ð°", "Ð±Ð°Ñ€Ð°Ð½Ð¸Ð½Ð°", "Ñ‚ÐµÐ»ÑÑ‚Ð¸Ð½Ð°", "ÐºÑ€Ð°ÑÐ½Ð¾Ðµ Ð¼ÑÑÐ¾", "ÐºÐ¾Ñ‚Ð»ÐµÑ‚Ð°", "Ð¶Ð°Ñ€ÐºÐ¾Ðµ", "ÑÐ²Ð¸Ð½Ð°Ñ Ð¾Ñ‚Ð±Ð¸Ð²Ð½Ð°Ñ", "Ð²Ñ‹Ñ€ÐµÐ·ÐºÐ°"],
    "bacon": ["Ð±ÐµÐºÐ¾Ð½", "Ð³Ñ€ÑƒÐ´Ð¸Ð½ÐºÐ°"],
    "processedMeat": ["Ð²ÐµÑ‚Ñ‡Ð¸Ð½Ð°", "ÐºÐ¾Ð»Ð±Ð°ÑÐ°", "ÑÐ¾ÑÐ¸ÑÐºÐ°", "ÑÐ°Ñ€Ð´ÐµÐ»ÑŒÐºÐ°", "Ñ‡Ð¾Ñ€Ð¸Ð·Ð¾", "ÑÐ°Ð»ÑÐ¼Ð¸", "Ð¿ÐµÐ¿Ð¿ÐµÑ€Ð¾Ð½Ð¸", "ÑÐµÑ€Ð²ÐµÐ»Ð°Ñ‚", "Ð¼ÑÑÐ½Ñ‹Ðµ Ð´ÐµÐ»Ð¸ÐºÐ°Ñ‚ÐµÑÑ‹", "Ð±ÑƒÐ¶ÐµÐ½Ð¸Ð½Ð°"],
    "fish": ["Ñ€Ñ‹Ð±Ð°", "Ð»Ð¾ÑÐ¾ÑÑŒ", "Ñ‚ÑƒÐ½ÐµÑ†", "Ñ‚Ñ€ÐµÑÐºÐ°", "Ñ‚Ð¸Ð»Ð°Ð¿Ð¸Ñ", "ÑÐºÑƒÐ¼Ð±Ñ€Ð¸Ñ", "ÑÐµÐ»ÑŒÐ´ÑŒ", "ÑÐ°Ñ€Ð´Ð¸Ð½Ð°", "Ð¿Ð°Ð»Ñ‚ÑƒÑ", "Ð±ÐµÐ»Ð°Ñ Ñ€Ñ‹Ð±Ð°", "Ñ„Ð¾Ñ€ÐµÐ»ÑŒ", "Ð¼Ð¾Ñ€ÑÐºÐ¾Ð¹ Ð¾ÐºÑƒÐ½ÑŒ", "Ð¶Ð°Ñ€ÐµÐ½Ð°Ñ Ñ€Ñ‹Ð±Ð°", "Ð·Ð°Ð¿ÐµÑ‡ÐµÐ½Ð½Ð°Ñ Ñ€Ñ‹Ð±Ð°", "Ñ…ÐµÐº", "Ð¼Ð¸Ð½Ñ‚Ð°Ð¹"],
    "shrimpPrawn": ["ÐºÑ€ÐµÐ²ÐµÑ‚ÐºÐ°", "ÐºÑ€ÐµÐ²ÐµÑ‚ÐºÐ¸", "Ð¼Ð¾Ñ€ÐµÐ¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ñ‹", "ÐºÐ¾Ñ€Ð¾Ð»ÐµÐ²ÑÐºÐ°Ñ ÐºÑ€ÐµÐ²ÐµÑ‚ÐºÐ°"],
    "lobster": ["Ð»Ð¾Ð±ÑÑ‚ÐµÑ€", "Ð¾Ð¼Ð°Ñ€", "Ñ€Ð°Ðº", "Ð¼Ð¾Ñ€ÐµÐ¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ñ‹"],
    "crab": ["ÐºÑ€Ð°Ð±", "Ð¼Ð¾Ñ€ÐµÐ¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ñ‹", "ÐºÑ€Ð°Ð±Ð¾Ð²Ð¾Ðµ Ð¼ÑÑÐ¾"],
    "sushi": ["ÑÑƒÑˆÐ¸", "Ñ€Ð¾Ð»Ð»Ñ‹", "ÑÐ°ÑˆÐ¸Ð¼Ð¸", "ÑÑ‹Ñ€Ð°Ñ Ñ€Ñ‹Ð±Ð°", "Ð½Ð¸Ð³Ð¸Ñ€Ð¸", "Ð¼Ð°ÐºÐ¸", "Ð¤Ð¸Ð»Ð°Ð´ÐµÐ»ÑŒÑ„Ð¸Ñ", "ÐšÐ°Ð»Ð¸Ñ„Ð¾Ñ€Ð½Ð¸Ñ"],
    "egg": ["ÑÐ¹Ñ†Ð¾", "ÑÐ¹Ñ†Ð°", "ÑÐ¸Ñ‡Ð½Ð¸Ñ†Ð°", "Ð¾Ð¼Ð»ÐµÑ‚", "Ð²Ð°Ñ€ÐµÐ½Ð¾Ðµ ÑÐ¹Ñ†Ð¾", "ÑÐ¹Ñ†Ð¾ Ð¿Ð°ÑˆÐ¾Ñ‚"],
    "milk": ["Ð¼Ð¾Ð»Ð¾ÐºÐ¾", "ÐºÐ¾Ñ€Ð¾Ð²ÑŒÐµ Ð¼Ð¾Ð»Ð¾ÐºÐ¾", "ÑÐ¾ÐµÐ²Ð¾Ðµ Ð¼Ð¾Ð»Ð¾ÐºÐ¾", "Ð¼Ð¸Ð½Ð´Ð°Ð»ÑŒÐ½Ð¾Ðµ Ð¼Ð¾Ð»Ð¾ÐºÐ¾", "Ð¾Ð²ÑÑÐ½Ð¾Ðµ Ð¼Ð¾Ð»Ð¾ÐºÐ¾", "Ñ€Ð°ÑÑ‚Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾Ðµ Ð¼Ð¾Ð»Ð¾ÐºÐ¾", "Ñ€Ð¸ÑÐ¾Ð²Ð¾Ðµ Ð¼Ð¾Ð»Ð¾ÐºÐ¾", "ÐºÐ¾ÐºÐ¾ÑÐ¾Ð²Ð¾Ðµ Ð¼Ð¾Ð»Ð¾ÐºÐ¾", "ÐºÐ¾Ð·ÑŒÐµ Ð¼Ð¾Ð»Ð¾ÐºÐ¾", "ÐºÐµÑ„Ð¸Ñ€", "Ñ€ÑÐ¶ÐµÐ½ÐºÐ°", "Ð¿Ñ€Ð¾ÑÑ‚Ð¾ÐºÐ²Ð°ÑˆÐ°"],
    "cheese": ["ÑÑ‹Ñ€", "Ñ‡ÐµÐ´Ð´ÐµÑ€", "Ð¼Ð¾Ñ†Ð°Ñ€ÐµÐ»Ð»Ð°", "Ð¿Ð°Ñ€Ð¼ÐµÐ·Ð°Ð½", "Ð³Ð°ÑƒÐ´Ð°", "Ð±Ñ€Ð¸", "Ñ„ÐµÑ‚Ð°", "Ñ‚Ð²Ð¾Ñ€Ð¾Ð³", "ÑˆÐ²ÐµÐ¹Ñ†Ð°Ñ€ÑÐºÐ¸Ð¹ ÑÑ‹Ñ€", "Ð¿Ñ€Ð¾Ð²Ð¾Ð»Ð¾Ð½Ðµ", "Ð³Ð¾Ð»ÑƒÐ±Ð¾Ð¹ ÑÑ‹Ñ€", "ÐºÐ¾Ð·Ð¸Ð¹ ÑÑ‹Ñ€", "ÑÐ»Ð¸Ð²Ð¾Ñ‡Ð½Ñ‹Ð¹ ÑÑ‹Ñ€", "Ñ€Ð¾ÑÑÐ¸Ð¹ÑÐºÐ¸Ð¹ ÑÑ‹Ñ€", "Ð°Ð´Ñ‹Ð³ÐµÐ¹ÑÐºÐ¸Ð¹ ÑÑ‹Ñ€"],
    "butter": ["Ð¼Ð°ÑÐ»Ð¾ ÑÐ»Ð¸Ð²Ð¾Ñ‡Ð½Ð¾Ðµ", "Ð¼Ð°Ñ€Ð³Ð°Ñ€Ð¸Ð½", "ÑÐ¿Ñ€ÐµÐ´"],
    "iceCream": ["Ð¼Ð¾Ñ€Ð¾Ð¶ÐµÐ½Ð¾Ðµ", "Ð´Ð¶ÐµÐ»Ð°Ñ‚Ð¾", "ÑÐ¾Ñ€Ð±ÐµÑ‚", "Ð·Ð°Ð¼Ð¾Ñ€Ð¾Ð¶ÐµÐ½Ð½Ñ‹Ð¹ Ð¹Ð¾Ð³ÑƒÑ€Ñ‚", "Ð¿Ð»Ð¾Ð¼Ð±Ð¸Ñ€", "ÑÑÐºÐ¸Ð¼Ð¾"],
    "yogurt": ["Ð¹Ð¾Ð³ÑƒÑ€Ñ‚", "Ð³Ñ€ÐµÑ‡ÐµÑÐºÐ¸Ð¹ Ð¹Ð¾Ð³ÑƒÑ€Ñ‚", "Ð½Ð°Ñ‚ÑƒÑ€Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¹Ð¾Ð³ÑƒÑ€Ñ‚", "Ð¿Ð¸Ñ‚ÑŒÐµÐ²Ð¾Ð¹ Ð¹Ð¾Ð³ÑƒÑ€Ñ‚", "Ð±Ð¸Ð¾Ð¹Ð¾Ð³ÑƒÑ€Ñ‚"],
    "bread": ["Ñ…Ð»ÐµÐ±", "Ñ‚Ð¾ÑÑ‚", "Ð±ÑƒÐ±Ð»Ð¸Ðº", "ÐºÑ€ÑƒÐ°ÑÑÐ°Ð½", "Ð±ÑƒÐ»ÐºÐ°", "Ð±ÑƒÐ»Ð¾Ñ‡ÐºÐ°", "Ð»Ð°Ð²Ð°Ñˆ", "Ñ†ÐµÐ»ÑŒÐ½Ð¾Ð·ÐµÑ€Ð½Ð¾Ð²Ð¾Ð¹ Ñ…Ð»ÐµÐ±", "Ð±ÐµÐ»Ñ‹Ð¹ Ñ…Ð»ÐµÐ±", "Ñ€Ð¶Ð°Ð½Ð¾Ð¹ Ñ…Ð»ÐµÐ±", "Ð±Ð°Ð³ÐµÑ‚", "Ð±Ð°Ñ‚Ð¾Ð½", "Ñ‡Ð¸Ð°Ð±Ð°Ñ‚Ñ‚Ð°"],
    "rice": ["Ñ€Ð¸Ñ", "Ð±ÐµÐ»Ñ‹Ð¹ Ñ€Ð¸Ñ", "ÐºÐ¾Ñ€Ð¸Ñ‡Ð½ÐµÐ²Ñ‹Ð¹ Ñ€Ð¸Ñ", "Ñ€Ð¸Ñ Ð±Ð°ÑÐ¼Ð°Ñ‚Ð¸", "Ñ€Ð¸Ñ Ð¶Ð°Ñë¯¼", "Ð´Ð¸ÐºÐ¸Ð¹ Ñ€Ð¸Ñ", "ÐºÑ€ÑƒÐ¿Ð°", "Ð±ÑƒÑ€Ñ‹Ð¹ Ñ€Ð¸Ñ"],
    "pasta": ["Ð¼Ð°ÐºÐ°Ñ€Ð¾Ð½Ñ‹", "Ð¿Ð°ÑÑ‚Ð°", "ÑÐ¿Ð°Ð³ÐµÑ‚Ñ‚Ð¸", "Ð»Ð°Ð¿ÑˆÐ°", "Ñ„ÐµÑ‚ÑƒÑ‡Ð¸Ð½Ð¸", "Ð»Ð°Ð·Ð°Ð½ÑŒÑ", "Ñ€Ð°Ð¼ÐµÐ½", "Ð²ÐµÑ€Ð¼Ð¸ÑˆÐµÐ»ÑŒ", "Ñ€Ð¾Ð¶ÐºÐ¸", "Ð¿ÐµÑ€ÑŒÑ"],
    "cerealOats": ["Ñ…Ð»Ð¾Ð¿ÑŒÑ", "Ð¾Ð²ÑÑÐ½ÐºÐ°", "Ð¾Ð²ÑÑÐ½Ñ‹Ðµ Ñ…Ð»Ð¾Ð¿ÑŒÑ", "Ð³Ñ€Ð°Ð½Ð¾Ð»Ð°", "Ð¼ÑŽÑÐ»Ð¸", "ÐºÐ°ÑˆÐ°", "ÐºÑƒÐºÑƒÑ€ÑƒÐ·Ð½Ñ‹Ðµ Ñ…Ð»Ð¾Ð¿ÑŒÑ", "Ð³Ñ€ÐµÑ‡ÐºÐ°"],
    "otherGrains": ["ÐºÐ¸Ð½Ð¾Ð°", "ÐºÑƒÑ-ÐºÑƒÑ", "ÑÑ‡Ð¼ÐµÐ½ÑŒ", "Ð±ÑƒÐ»Ð³ÑƒÑ€", "Ð¿Ð¾Ð»Ð±Ð°", "Ð¿ÑˆÐµÐ½Ð¾", "ÐºÑ€ÑƒÐ¿Ñ‹", "Ð¿ÐµÑ€Ð»Ð¾Ð²ÐºÐ°"],
    "flatbread": ["Ñ‚Ð¾Ñ€Ñ‚Ð¸Ð»ÑŒÑ", "Ð»Ð°Ð²Ð°Ñˆ", "Ð¿Ð¸Ñ‚Ð°", "Ð½Ð°Ð°Ð½", "Ð»ÐµÐ¿ÐµÑˆÐºÐ°", "Ñ‡Ð°Ð¿Ð°Ñ‚Ð¸", "Ñ€Ð¾Ñ‚Ð¸", "Ð¼Ð°Ñ†Ð°"],
    "beansLegumes": ["Ñ„Ð°ÑÐ¾Ð»ÑŒ", "Ñ‡ÐµÑ€Ð½Ð°Ñ Ñ„Ð°ÑÐ¾Ð»ÑŒ", "ÐºÑ€Ð°ÑÐ½Ð°Ñ Ñ„Ð°ÑÐ¾Ð»ÑŒ", "Ð½ÑƒÑ‚", "Ñ‡ÐµÑ‡ÐµÐ²Ð¸Ñ†Ð°", "Ð³Ð¾Ñ€Ð¾Ñ…", "Ð±Ð¾Ð±Ð¾Ð²Ñ‹Ðµ", "ÑÐ´Ð°Ð¼Ð°Ð¼Ðµ", "ÑÐ¾ÐµÐ²Ñ‹Ðµ Ð±Ð¾Ð±Ñ‹", "Ð¼Ð°Ñˆ"],
    "peanut": ["Ð°Ñ€Ð°Ñ…Ð¸Ñ", "Ð°Ñ€Ð°Ñ…Ð¸ÑÐ¾Ð²Ð°Ñ Ð¿Ð°ÑÑ‚Ð°", "Ð·ÐµÐ¼Ð»ÑÐ½Ð¾Ð¹ Ð¾Ñ€ÐµÑ…"],
    "nuts": ["Ð¾Ñ€ÐµÑ…Ð¸", "Ð¼Ð¸Ð½Ð´Ð°Ð»ÑŒ", "Ð³Ñ€ÐµÑ†ÐºÐ¸Ð¹ Ð¾Ñ€ÐµÑ…", "ÐºÐµÑˆÑŒÑŽ", "Ð¿ÐµÐºÐ°Ð½", "Ñ„Ð¸ÑÑ‚Ð°ÑˆÐºÐ¸", "Ñ„ÑƒÐ½Ð´ÑƒÐº", "Ð±Ñ€Ð°Ð·Ð¸Ð»ÑŒÑÐºÐ¸Ð¹ Ð¾Ñ€ÐµÑ…", "Ð¼Ð°ÐºÐ°Ð´Ð°Ð¼Ð¸Ñ", "ÑÐ¼ÐµÑÑŒ Ð¾Ñ€ÐµÑ…Ð¾Ð²", "ÐºÐµÐ´Ñ€Ð¾Ð²Ñ‹Ð¹ Ð¾Ñ€ÐµÑ…"],
    "seeds": ["ÑÐµÐ¼ÐµÑ‡ÐºÐ¸", "ÑÐµÐ¼ÐµÐ½Ð° Ð¿Ð¾Ð´ÑÐ¾Ð»Ð½ÐµÑ‡Ð½Ð¸ÐºÐ°", "Ñ‚Ñ‹ÐºÐ²ÐµÐ½Ð½Ñ‹Ðµ ÑÐµÐ¼ÐµÑ‡ÐºÐ¸", "ÑÐµÐ¼ÐµÐ½Ð° Ñ‡Ð¸Ð°", "ÑÐµÐ¼ÐµÐ½Ð° Ð»ÑŒÐ½Ð°", "ÐºÑƒÐ½Ð¶ÑƒÑ‚", "ÐºÐ¾Ð½Ð¾Ð¿Ð»ÑÐ½Ñ‹Ðµ ÑÐµÐ¼ÐµÐ½Ð°"],
    "donut": ["Ð¿Ð¾Ð½Ñ‡Ð¸Ðº", "Ð¿Ñ‹ÑˆÐºÐ°", "Ð²Ñ‹Ð¿ÐµÑ‡ÐºÐ°", "Ð´Ð¾Ð½Ð°Ñ‚"],
    "cookie": ["Ð¿ÐµÑ‡ÐµÐ½ÑŒÐµ", "Ð±Ð¸ÑÐºÐ²Ð¸Ñ‚", "Ð³Ð°Ð»ÐµÑ‚Ð°", "Ð¼Ð°ÐºÐ°Ñ€ÑƒÐ½", "Ð¾Ð²ÑÑÐ½Ð¾Ðµ Ð¿ÐµÑ‡ÐµÐ½ÑŒÐµ", "Ð¿Ñ€ÑÐ½Ð¸Ðº"],
    "chocolate": ["ÑˆÐ¾ÐºÐ¾Ð»Ð°Ð´", "ÑˆÐ¾ÐºÐ¾Ð»Ð°Ð´Ð½Ð°Ñ Ð¿Ð»Ð¸Ñ‚ÐºÐ°", "Ñ‚ÐµÐ¼Ð½Ñ‹Ð¹ ÑˆÐ¾ÐºÐ¾Ð»Ð°Ð´", "Ð¼Ð¾Ð»Ð¾Ñ‡Ð½Ñ‹Ð¹ ÑˆÐ¾ÐºÐ¾Ð»Ð°Ð´", "Ð±ÐµÐ»Ñ‹Ð¹ ÑˆÐ¾ÐºÐ¾Ð»Ð°Ð´", "ÐºÐ°ÐºÐ°Ð¾", "ÑˆÐ¾ÐºÐ¾Ð»Ð°Ð´ÐºÐ°"],
    "cake": ["Ñ‚Ð¾Ñ€Ñ‚", "Ð¿Ð¸Ñ€Ð¾Ð¶Ð½Ð¾Ðµ", "ÐºÐµÐºÑ", "Ð¼Ð°Ñ„Ñ„Ð¸Ð½", "Ð±Ñ€Ð°ÑƒÐ½Ð¸", "Ñ‡Ð¸Ð·ÐºÐµÐ¹Ðº", "Ñ€ÑƒÐ»ÐµÑ‚"],
    "candy": ["ÐºÐ¾Ð½Ñ„ÐµÑ‚Ð°", "ÐºÐ¾Ð½Ñ„ÐµÑ‚Ñ‹", "ÑÐ»Ð°Ð´Ð¾ÑÑ‚Ð¸", "Ð»ÐµÐ´ÐµÐ½ÐµÑ†", "Ð¼Ð°Ñ€Ð¼ÐµÐ»Ð°Ð´", "Ð¸Ñ€Ð¸Ñ", "Ð·ÐµÑ„Ð¸Ñ€", "Ð¿Ð°ÑÑ‚Ð¸Ð»Ð°", "ÐºÐ°Ñ€Ð°Ð¼ÐµÐ»ÑŒ"],
    "popcorn": ["Ð¿Ð¾Ð¿ÐºÐ¾Ñ€Ð½", "Ð²Ð¾Ð·Ð´ÑƒÑˆÐ½Ð°Ñ ÐºÑƒÐºÑƒÑ€ÑƒÐ·Ð°"],
    "pretzel": ["ÐºÑ€ÐµÐ½Ð´ÐµÐ»ÑŒ", "ÑÐ¾Ð»Ð¾Ð¼ÐºÐ°", "Ð±Ñ€ÐµÑ†ÐµÐ»ÑŒ"],
    "friesChips": ["ÐºÐ°Ñ€Ñ‚Ð¾Ñ„ÐµÐ»ÑŒ Ñ„Ñ€Ð¸", "ÐºÐ°Ñ€Ñ‚Ð¾ÑˆÐºÐ° Ñ„Ñ€Ð¸", "Ñ‡Ð¸Ð¿ÑÑ‹", "ÐºÐ°Ñ€Ñ‚Ð¾Ñ„ÐµÐ»ÑŒÐ½Ñ‹Ðµ Ñ‡Ð¸Ð¿ÑÑ‹", "ÐºÐ°Ñ€Ñ‚Ð¾Ñ„ÐµÐ»ÑŒÐ½Ñ‹Ðµ Ð´Ð¾Ð»ÑŒÐºÐ¸", "Ð½Ð°Ð³Ð³ÐµÑ‚ÑÑ‹ (ÐºÐ°Ñ€Ñ‚Ð¾Ñ„ÐµÐ»ÑŒÐ½Ñ‹Ðµ)"],
    "coffee": ["ÐºÐ¾Ñ„Ðµ", "ÑÑÐ¿Ñ€ÐµÑÑÐ¾", "Ð»Ð°Ñ‚Ñ‚Ðµ", "ÐºÐ°Ð¿ÑƒÑ‡Ð¸Ð½Ð¾", "Ð°Ð¼ÐµÑ€Ð¸ÐºÐ°Ð½Ð¾", "Ð¼Ð¾ÐºÐºÐ¾", "Ñ…Ð¾Ð»Ð¾Ð´Ð½Ñ‹Ð¹ ÐºÐ¾Ñ„Ðµ", "Ñ€Ð°ÑÑ‚Ð²Ð¾Ñ€Ð¸Ð¼Ñ‹Ð¹ ÐºÐ¾Ñ„Ðµ"],
    "tea": ["Ñ‡Ð°Ð¹", "Ð·ÐµÐ»ÐµÐ½Ñ‹Ð¹ Ñ‡Ð°Ð¹", "Ñ‡ÐµÑ€Ð½Ñ‹Ð¹ Ñ‡Ð°Ð¹", "Ñ‚Ñ€Ð°Ð²ÑÐ½Ð¾Ð¹ Ñ‡Ð°Ð¹", "Ñ‡Ð°Ð¹ Ð¼Ð°ÑÐ°Ð»Ð°", "ÑƒÐ»ÑƒÐ½", "Ð±ÐµÐ»Ñ‹Ð¹ Ñ‡Ð°Ð¹", "ÐºÐ°Ñ€ÐºÐ°Ð´Ðµ", "Ð¿ÑƒÑÑ€"],
    "softDrinkJuice": ["Ð³Ð°Ð·Ð¸Ñ€Ð¾Ð²ÐºÐ°", "Ð»Ð¸Ð¼Ð¾Ð½Ð°Ð´", "ÐºÐ¾Ð»Ð°", "Ð¿ÐµÐ¿ÑÐ¸", "Ð±ÐµÐ·Ð°Ð»ÐºÐ¾Ð³Ð¾Ð»ÑŒÐ½Ñ‹Ð¹ Ð½Ð°Ð¿Ð¸Ñ‚Ð¾Ðº", "ÑÐ¾Ðº", "Ð°Ð¿ÐµÐ»ÑŒÑÐ¸Ð½Ð¾Ð²Ñ‹Ð¹ ÑÐ¾Ðº", "ÑÐ±Ð»Ð¾Ñ‡Ð½Ñ‹Ð¹ ÑÐ¾Ðº", "ÑÐ¼ÑƒÐ·Ð¸", "Ð¿Ñ€Ð¾Ñ‚ÐµÐ¸Ð½Ð¾Ð²Ñ‹Ð¹ ÐºÐ¾ÐºÑ‚ÐµÐ¹Ð»ÑŒ", "Ñ…Ð¾Ð»Ð¾Ð´Ð½Ñ‹Ð¹ Ñ‡Ð°Ð¹ (ÑÐ»Ð°Ð´ÐºÐ¸Ð¹)", "Ð¼Ð¾Ñ€Ñ", "ÐºÐ¾Ð¼Ð¿Ð¾Ñ‚"],
    "water": ["Ð²Ð¾Ð´Ð°", "Ð±ÑƒÑ‚Ð¸Ð»Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð°Ñ Ð²Ð¾Ð´Ð°", "Ð¼Ð¸Ð½ÐµÑ€Ð°Ð»ÑŒÐ½Ð°Ñ Ð²Ð¾Ð´Ð°", "Ð³Ð°Ð·Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð°Ñ Ð²Ð¾Ð´Ð°", "Ð½ÐµÐ³Ð°Ð·Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð°Ñ Ð²Ð¾Ð´Ð°", "Ð¿Ð¸Ñ‚ÑŒÐµÐ²Ð°Ñ Ð²Ð¾Ð´Ð°"],
    "wine": ["Ð²Ð¸Ð½Ð¾", "ÐºÑ€Ð°ÑÐ½Ð¾Ðµ Ð²Ð¸Ð½Ð¾", "Ð±ÐµÐ»Ð¾Ðµ Ð²Ð¸Ð½Ð¾", "Ñ€Ð¾Ð·Ð¾Ð²Ð¾Ðµ Ð²Ð¸Ð½Ð¾", "Ð¸Ð³Ñ€Ð¸ÑÑ‚Ð¾Ðµ Ð²Ð¸Ð½Ð¾", "ÑˆÐ°Ð¼Ð¿Ð°Ð½ÑÐºÐ¾Ðµ", "Ð°Ð»ÐºÐ¾Ð³Ð¾Ð»ÑŒ"],
    "beer": ["Ð¿Ð¸Ð²Ð¾", "Ð»Ð°Ð³ÐµÑ€", "ÑÐ»ÑŒ", "ÑÑ‚Ð°ÑƒÑ‚", "Ð°Ð»ÐºÐ¾Ð³Ð¾Ð»ÑŒ", "ÐºÑ€Ð°Ñ„Ñ‚Ð¾Ð²Ð¾Ðµ Ð¿Ð¸Ð²Ð¾"],
    "cocktail": ["ÐºÐ¾ÐºÑ‚ÐµÐ¹Ð»ÑŒ", "ÑÐ¿Ð¸Ñ€Ñ‚Ð½Ð¾Ðµ", "Ð»Ð¸ÐºÐµÑ€", "Ð²Ð¾Ð´ÐºÐ°", "Ð´Ð¶Ð¸Ð½", "Ñ€Ð¾Ð¼", "Ð²Ð¸ÑÐºÐ¸", "Ñ‚ÐµÐºÐ¸Ð»Ð°", "Ð¼Ð°Ñ€Ð³Ð°Ñ€Ð¸Ñ‚Ð°", "Ð¼Ð°Ñ€Ñ‚Ð¸Ð½Ð¸", "Ð°Ð»ÐºÐ¾Ð³Ð¾Ð»ÑŒ", "Ð½Ð°Ð¿Ð¸Ñ‚Ð¾Ðº Ð°Ð»ÐºÐ¾Ð³Ð¾Ð»ÑŒÐ½Ñ‹Ð¹"],
    "pizza": ["Ð¿Ð¸Ñ†Ñ†Ð°", "Ð¼Ð°Ñ€Ð³Ð°Ñ€Ð¸Ñ‚Ð°", "Ð¿ÐµÐ¿Ð¿ÐµÑ€Ð¾Ð½Ð¸", "Ð³Ð°Ð²Ð°Ð¹ÑÐºÐ°Ñ Ð¿Ð¸Ñ†Ñ†Ð°"],
    "burger": ["Ð±ÑƒÑ€Ð³ÐµÑ€", "Ð³Ð°Ð¼Ð±ÑƒÑ€Ð³ÐµÑ€", "Ñ‡Ð¸Ð·Ð±ÑƒÑ€Ð³ÐµÑ€", "Ð²ÐµÐ³ÐµÑ‚Ð°Ñ€Ð¸Ð°Ð½ÑÐºÐ¸Ð¹ Ð±ÑƒÑ€Ð³ÐµÑ€", "ÐºÑƒÑ€Ð¸Ð½Ñ‹Ð¹ Ð±ÑƒÑ€Ð³ÐµÑ€", "ÑÑÐ½Ð´Ð²Ð¸Ñ‡ Ñ ÐºÐ¾Ñ‚Ð»ÐµÑ‚Ð¾Ð¹"],
    "tacoBurrito": ["Ñ‚Ð°ÐºÐ¾", "Ð±ÑƒÑ€Ñ€Ð¸Ñ‚Ð¾", "ÐºÐµÑÐ°Ð´Ð¸Ð»ÑŒÑ", "Ñ„Ð°Ñ…Ð¸Ñ‚Ð°", "ÑÐ½Ñ‡Ð¸Ð»Ð°Ð´Ð°", "Ð¼ÐµÐºÑÐ¸ÐºÐ°Ð½ÑÐºÐ°Ñ ÐµÐ´Ð°", "ÑˆÐ°ÑƒÑ€Ð¼Ð°"],
    "sandwich": ["ÑÑÐ½Ð´Ð²Ð¸Ñ‡", "Ð±ÑƒÑ‚ÐµÑ€Ð±Ñ€Ð¾Ð´", "Ð¿Ð°Ð½Ð¸Ð½Ð¸", "Ð³Ð¾Ñ€ÑÑ‡Ð¸Ð¹ Ð±ÑƒÑ‚ÐµÑ€Ð±Ñ€Ð¾Ð´", "Ñ‚Ð¾ÑÑ‚ Ñ Ð½Ð°Ñ‡Ð¸Ð½ÐºÐ¾Ð¹", "ÐºÐ»Ð°Ð± ÑÑÐ½Ð´Ð²Ð¸Ñ‡"],
    "soupStew": ["ÑÑƒÐ¿", "Ñ€Ð°Ð³Ñƒ", "Ð±ÑƒÐ»ÑŒÐ¾Ð½", "Ð¿Ð¾Ñ…Ð»ÐµÐ±ÐºÐ°", "Ð±Ð¾Ñ€Ñ‰", "Ñ‰Ð¸", "ÑÐ¾Ð»ÑÐ½ÐºÐ°", "Ð³ÑƒÐ»ÑÑˆ", "Ñ…Ð°Ñ€Ñ‡Ð¾", "ÑƒÑ…Ð°"],
    "salad": ["ÑÐ°Ð»Ð°Ñ‚", "Ñ†ÐµÐ·Ð°Ñ€ÑŒ", "Ð³Ñ€ÐµÑ‡ÐµÑÐºÐ¸Ð¹ ÑÐ°Ð»Ð°Ñ‚", "Ð¾Ð²Ð¾Ñ‰Ð½Ð¾Ð¹ ÑÐ°Ð»Ð°Ñ‚", "Ñ„Ñ€ÑƒÐºÑ‚Ð¾Ð²Ñ‹Ð¹ ÑÐ°Ð»Ð°Ñ‚", "Ð¾Ð»Ð¸Ð²ÑŒÐµ", "Ð²Ð¸Ð½ÐµÐ³Ñ€ÐµÑ‚", "ÑÐ°Ð»Ð°Ñ‚ Ñ Ñ‚ÑƒÐ½Ñ†Ð¾Ð¼"],
    "noodleDish": ["Ð»Ð°Ð¿ÑˆÐ° Ñ€Ð°Ð¼ÐµÐ½", "ÑÑƒÐ¿ Ñ„Ð¾", "ÑÑƒÐ¿ Ñ Ð»Ð°Ð¿ÑˆÐ¾Ð¹", "Ð¿Ð°Ð´ Ñ‚Ð°Ð¹", "Ð²Ð¾Ðº", "ÑƒÐ´Ð¾Ð½", "ÑÐ¾Ð±Ð°", "Ñ„ÑƒÐ½Ñ‡Ð¾Ð·Ð°"],
    "genericFruit": ["Ñ„Ñ€ÑƒÐºÑ‚", "Ñ„Ñ€ÑƒÐºÑ‚Ñ‹", "ÑÐ³Ð¾Ð´Ð°", "ÑÐ³Ð¾Ð´Ñ‹", "Ñ†Ð¸Ñ‚Ñ€ÑƒÑ", "Ñ†Ð¸Ñ‚Ñ€ÑƒÑÐ¾Ð²Ñ‹Ðµ", "ÑÐºÐ·Ð¾Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸Ð¹ Ñ„Ñ€ÑƒÐºÑ‚"],
    "genericVegetable": ["Ð¾Ð²Ð¾Ñ‰", "Ð¾Ð²Ð¾Ñ‰Ð¸", "ÐºÐ¾Ñ€Ð½ÐµÐ¿Ð»Ð¾Ð´", "Ð·ÐµÐ»ÐµÐ½ÑŒ Ð»Ð¸ÑÑ‚Ð¾Ð²Ð°Ñ", "Ð¾Ð³Ð¾Ñ€Ð¾Ð´Ð½Ñ‹Ðµ Ð¾Ð²Ð¾Ñ‰Ð¸"],
    "genericMeal": ["ÐµÐ´Ð°", "Ð±Ð»ÑŽÐ´Ð¾", "Ð¾Ð±ÐµÐ´", "ÑƒÐ¶Ð¸Ð½", "Ð·Ð°Ð²Ñ‚Ñ€Ð°Ðº", "Ð¿ÐµÑ€ÐµÐºÑƒÑ", "Ð³Ð¾Ñ‚Ð¾Ð²Ð¾Ðµ Ð±Ð»ÑŽÐ´Ð¾", "Ð¾ÑÑ‚Ð°Ñ‚ÐºÐ¸ ÐµÐ´Ñ‹", "Ð¿Ð¸Ñ‰Ð°", "ÐºÑƒÑˆÐ°Ð½ÑŒÐµ", "Ñ‚Ñ€Ð°Ð¿ÐµÐ·Ð°"],
    "unknownFood": ["Ð½ÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ð¾", "Ð½ÐµÐ¾Ð¿Ð¾Ð·Ð½Ð°Ð½Ð¾", "Ð´Ñ€ÑƒÐ³Ð¾Ðµ", "Ð¿Ñ€Ð¾Ñ‡ÐµÐµ"]
  }
}
---------- END ru.json ----------


---------- AppNavigator.tsx ----------
// src/navigation/AppNavigator.tsx
// navigation/AppNavigator.tsx
import React, { useState, useCallback } from 'react';
import { Platform, I18nManager } from 'react-native';
import { createBottomTabNavigator, BottomTabNavigationProp } from '@react-navigation/bottom-tabs';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { Icon, useTheme } from '@rneui/themed';
import DailyEntryScreen from '../screens/DailyEntryScreen';
import FoodListScreen from '../screens/FoodListScreen';
import SettingsScreen from '../screens/SettingsScreen';
import QuestionnaireScreen from '../screens/QuestionnaireScreen'; // Import new screen
import { LanguageCode, Settings } from '../types/settings';
import i18n, { t } from '../localization/i18n';
import { Food, SharedFoodData } from '../types/food'; // Import Food and SharedFoodData types

// Define ParamList for the Tab Navigator
export type MainTabParamList = {
  DailyEntryRoute: { quickAddFood?: Food }; // For DailyEntryScreen, can receive quickAddFood
  FoodListRoute: { openAddFoodModal?: boolean, foodData?: string };   // For FoodListScreen, can receive foodData string from deep link
  SettingsStackRoute: undefined;             // For the Settings Stack
};

// Define ParamList for the Settings Stack
export type SettingsStackParamList = {
  SettingsHome: undefined;
  Questionnaire: undefined;
};


const Tab = createBottomTabNavigator<MainTabParamList>();
const SettingsStackNav = createNativeStackNavigator<SettingsStackParamList>();

interface AppNavigatorProps {
  onThemeChange: (theme: 'light' | 'dark' | 'system') => void;
  onLocaleChange: (locale: LanguageCode) => void;
  // No longer needs onDataOperation here, as handleFoodChange serves this purpose internally
}

// Props for the SettingsStackNavigatorComponent
interface SettingsStackProps {
  onThemeChange: (theme: 'light' | 'dark' | 'system') => void;
  onLocaleChange: (locale: LanguageCode) => void;
  onDataOperation: () => void; // This will be handleFoodChange from AppNavigator
}


// Settings Stack Navigator
function SettingsStackNavigatorComponent({ onThemeChange, onLocaleChange, onDataOperation }: SettingsStackProps) {
  const { theme } = useTheme();
  return (
    <SettingsStackNav.Navigator
      screenOptions={{
        headerStyle: { backgroundColor: theme.colors.background },
        headerTitleStyle: { color: theme.colors.text },
        headerTintColor: theme.colors.primary,
        headerTitleAlign: Platform.OS === 'ios' ? 'center' : 'center',
      }}
    >
      <SettingsStackNav.Screen name="SettingsHome" options={{ title: t('settingsScreen.title') }}>
        {() => <SettingsScreen onThemeChange={onThemeChange} onLocaleChange={onLocaleChange} onDataOperation={onDataOperation} />}
      </SettingsStackNav.Screen>
      <SettingsStackNav.Screen name="Questionnaire" options={{ title: t('questionnaireScreen.title') }}>
        {() => <QuestionnaireScreen />}
      </SettingsStackNav.Screen>
    </SettingsStackNav.Navigator>
  );
}


const AppNavigator: React.FC<AppNavigatorProps> = ({ onThemeChange, onLocaleChange }) => {
  const { theme } = useTheme();
  const [foodListRefresh, setFoodListRefresh] = useState(false);

  const handleFoodChange = useCallback(() => {
    setFoodListRefresh(prev => !prev);
  }, []);

  // Use static route names for consistency
  const dailyEntryRouteName: keyof MainTabParamList = 'DailyEntryRoute';
  const foodListRouteName: keyof MainTabParamList = 'FoodListRoute';
  const settingsStackRouteName: keyof MainTabParamList = 'SettingsStackRoute';


  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        tabBarIcon: ({ focused, color, size }) => {
          let iconName: string = '';
          let type: string = 'ionicon'; // Default type

          if (route.name === dailyEntryRouteName) {
            iconName = focused ? 'calendar' : 'calendar-outline';
          } else if (route.name === foodListRouteName) {
            iconName = focused ? 'fast-food' : 'fast-food-outline';
          } else if (route.name === settingsStackRouteName) { 
            iconName = focused ? 'settings' : 'settings-outline';
          }
          return <Icon name={iconName} type={type} size={size} color={color} />;
        },
        tabBarActiveTintColor: theme.colors.primary,
        tabBarInactiveTintColor: theme.colors.secondary,
        headerShown: false, 
        tabBarStyle: {
          backgroundColor: theme.colors.background,
          borderTopColor: theme.colors.divider,
        },
        tabBarLabelStyle: {
          fontWeight: 'bold',
        }
      })}
    >
      <Tab.Screen
        name={dailyEntryRouteName}
        options={{ title: t('dailyEntryScreen.tabTitle') }}
      >
        {() => <DailyEntryScreen key={`${foodListRefresh}-${i18n.locale}`} />}
      </Tab.Screen>
      <Tab.Screen
        name={foodListRouteName}
        options={{ title: t('foodListScreen.tabTitle') }}
      >
        {() => <FoodListScreen onFoodChange={handleFoodChange} key={`${foodListRefresh}-${i18n.locale}`} />}
      </Tab.Screen>
      <Tab.Screen
        name={settingsStackRouteName} 
        options={{ title: t('settingsScreen.title') }} 
      >
        {() => <SettingsStackNavigatorComponent 
                  onThemeChange={onThemeChange} 
                  onLocaleChange={onLocaleChange} 
                  onDataOperation={handleFoodChange} // Pass handleFoodChange here
                />}
      </Tab.Screen>
    </Tab.Navigator>
  );
};

export default AppNavigator;

---------- END AppNavigator.tsx ----------


---------- DailyEntryScreen.tsx ----------
// src/screens/DailyEntryScreen.tsx
import React, { useState, useEffect, useCallback, useMemo, useRef } from "react";
import { View, FlatList, Alert, Platform, StyleSheet, ActivityIndicator, I18nManager } from "react-native";
import { DailyEntry, DailyEntryItem } from "../types/dailyEntry";
import { Food } from "../types/food";
import { getFoods, createFood, updateFood as updateFoodService } from "../services/foodService";
import { saveDailyEntries, loadDailyEntries, loadSettings } from "../services/storageService";
import { getTodayDateString, formatDateISO, formatDateReadableAsync } from "../utils/dateUtils";
// isValidNumberInput is not directly used in this file after changes
import DailyProgress from "../components/DailyProgress";
import { Text, FAB, makeStyles, useTheme, Divider, Icon as RNEIcon } from "@rneui/themed";
import DateTimePicker, { DateTimePickerEvent } from "@react-native-community/datetimepicker";
import { addDays, subDays, parseISO, formatISO, isValid } from "date-fns";
import { SafeAreaView } from "react-native-safe-area-context";
import AddEntryModal from "../components/AddEntryModal/AddEntryModal";
import "react-native-get-random-values";
import Toast from "react-native-toast-message";
import { useFocusEffect, useNavigation, useRoute, RouteProp } from "@react-navigation/native";
import { getFoodIconUrl } from "../utils/iconUtils";
import DateNavigator from "../components/DateNavigator";
import DailyEntryListItem from "../components/DailyEntryListItem";
import { t } from '../localization/i18n';
import i18n from '../localization/i18n';
import { Settings as AppSettings } from "../types/settings";
import { BottomTabNavigationProp } from '@react-navigation/bottom-tabs';
import { MainTabParamList } from "../navigation/AppNavigator";

type DailyEntryScreenNavigationProp = BottomTabNavigationProp<MainTabParamList, 'DailyEntryRoute'>;
type DailyEntryScreenRouteProp = RouteProp<MainTabParamList, 'DailyEntryRoute'>;

const DailyEntryScreen: React.FC = () => {
  const [dailyEntries, setDailyEntries] = useState<DailyEntry[]>([]);
  const [selectedDate, setSelectedDate] = useState<string>(getTodayDateString());
  const [foods, setFoods] = useState<Food[]>([]);
  
  const [isOverlayVisible, setIsOverlayVisible] = useState(false);
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [dailyGoals, setDailyGoals] = useState<AppSettings['dailyGoals']>({ calories: 2000, protein: 150, carbs: 200, fat: 70 });
  
  const [editIndex, setEditIndex] = useState<number | null>(null); // This is reversedIndex
  const [initialGramsForEdit, setInitialGramsForEdit] = useState<string | undefined>(undefined);
  const [foodForEditModal, setFoodForEditModal] = useState<Food | null>(null);

  const [foodIcons, setFoodIcons] = useState<{ [foodName: string]: string | null; }>({});
  const [isLoadingData, setIsLoadingData] = useState(true);
  const [isSaving, setIsSaving] = useState(false);
  const [readableDate, setReadableDate] = useState('');
  const [pendingQuickAddFood, setPendingQuickAddFood] = useState<Food | null>(null);

  const { theme } = useTheme();
  const styles = useStyles();

  const navigation = useNavigation<DailyEntryScreenNavigationProp>();
  const route = useRoute<DailyEntryScreenRouteProp>();

  useEffect(() => {
    const updateDateForToast = async () => {
      const parsedDate = parseISO(selectedDate);
      if (isValid(parsedDate)) {
        const formatted = await formatDateReadableAsync(parsedDate);
        setReadableDate(formatted);
      } else {
        setReadableDate(t('dateNavigator.invalidDate'));
      }
    };
    updateDateForToast();
  }, [selectedDate, i18n.locale, t]);

  const resolveAndSetIcon = useCallback((foodName: string) => {
    if (!foodName) return;
    if (foodIcons[foodName] === undefined) {
      const icon = getFoodIconUrl(foodName);
      setFoodIcons(prev => ({ ...prev, [foodName]: icon }));
    }
  }, [foodIcons]);

  const triggerIconPrefetch = useCallback((entries: DailyEntry[], currentSelectedDate: string) => {
    const uniqueFoodNames = new Set<string>();
    entries.forEach(entry => { 
      if (entry.date === currentSelectedDate && entry.items) { 
        entry.items.forEach(item => { 
          if (item.food?.name) uniqueFoodNames.add(item.food.name); 
        }); 
      } 
    });

    if (uniqueFoodNames.size > 0) {
      const newIconsStateBatch: { [key: string]: string | null } = {};
      Array.from(uniqueFoodNames).forEach(name => {
        if (foodIcons[name] === undefined) {
           newIconsStateBatch[name] = getFoodIconUrl(name);
        }
      });
      if (Object.keys(newIconsStateBatch).length > 0) {
          setFoodIcons(prev => ({ ...prev, ...newIconsStateBatch }));
      }
    }
  }, [foodIcons]);

  const loadData = useCallback(async () => {
    setIsLoadingData(true);
    try {
      const [foodsResult, loadedEntries, loadedSettings] = await Promise.all([
        getFoods(),
        loadDailyEntries(),
        loadSettings(),
      ]);

      const loadedFoodsArray = foodsResult.items;

      setDailyGoals(loadedSettings?.dailyGoals ?? { calories: 2000, protein: 150, carbs: 200, fat: 70 });
      loadedFoodsArray.sort((a, b) => a.name.localeCompare(b.name));
      setFoods(loadedFoodsArray);
      setDailyEntries(loadedEntries);
      triggerIconPrefetch(loadedEntries, selectedDate);
    } catch (error) {
      console.error("Error in DailyEntryScreen loadData:", error);
      Alert.alert(t('dailyEntryScreen.errorLoad'), t('dailyEntryScreen.errorLoadMessage'));
      setFoods([]); setDailyEntries([]); setDailyGoals({ calories: 0, protein: 0, carbs: 0, fat: 0 });
    } finally {
      setIsLoadingData(false);
    }
  }, [selectedDate, triggerIconPrefetch, t]);

  useEffect(() => {
    const quickAddFoodParam = route.params?.quickAddFood;
    if (quickAddFoodParam) {
      setPendingQuickAddFood(quickAddFoodParam);
      navigation.setParams({ quickAddFood: undefined }); 
    }
  }, [route.params, navigation]);

  useEffect(() => {
    if (pendingQuickAddFood && !isLoadingData && !isOverlayVisible && foods.length > 0) {
      const foodExistsInLibrary = foods.find(f => f.id === pendingQuickAddFood.id);
      const foodToUse = foodExistsInLibrary || pendingQuickAddFood;
  
      setFoodForEditModal(foodToUse);
      setInitialGramsForEdit("");    
      setEditIndex(null);            
  
      if (foodToUse.name) resolveAndSetIcon(foodToUse.name);
      setIsOverlayVisible(true);      
      setPendingQuickAddFood(null);   
    }
  }, [pendingQuickAddFood, isLoadingData, isOverlayVisible, foods, resolveAndSetIcon]);

  useFocusEffect(
    useCallback(() => {
      loadData();
      return () => {};
    }, [loadData]) 
  );

  const currentEntryItems = useMemo(() => {
    const entry = dailyEntries.find((e) => e.date === selectedDate);
    return entry ? [...entry.items].reverse() : [];
  }, [dailyEntries, selectedDate]);

  const getOriginalIndex = useCallback((reversedIndex: number): number => {
    const entry = dailyEntries.find((e) => e.date === selectedDate);
    if (!entry || reversedIndex < 0 || reversedIndex >= entry.items.length) return -1;
    return entry.items.length - 1 - reversedIndex;
  }, [dailyEntries, selectedDate]);

  const updateAndSaveEntries = useCallback(async (updaterOrNewEntries: DailyEntry[] | ((prevEntries: DailyEntry[]) => DailyEntry[])) => {
    setIsSaving(true);
    const previousEntriesState = dailyEntries; // Capture current state for potential rollback

    let newEntriesForStateAndSave: DailyEntry[];
    if (typeof updaterOrNewEntries === 'function') {
        newEntriesForStateAndSave = updaterOrNewEntries(previousEntriesState);
    } else {
        newEntriesForStateAndSave = updaterOrNewEntries;
    }

    setDailyEntries(newEntriesForStateAndSave); // Update React state

    try {
      await saveDailyEntries(newEntriesForStateAndSave); // Save the determined new state
    } catch (error) {
      Alert.alert(t('dailyEntryScreen.errorSave'), t('dailyEntryScreen.errorSaveMessage'));
      setDailyEntries(previousEntriesState); // Rollback React state
    } finally {
      setIsSaving(false);
    }
  }, [dailyEntries, t]); // Added dailyEntries as it's used to get previousEntriesState

  const handleSingleEntryActionFinal = useCallback(async (foodToAdd: Food, gramsToAdd: number) => {
    if (isSaving) return;
    const entryItem: DailyEntryItem = { food: foodToAdd, grams: gramsToAdd };
    const isEditingThisAction = editIndex !== null;
    
    await updateAndSaveEntries((prevDailyEntries) => {
        const existingEntryIndex = prevDailyEntries.findIndex((entry) => entry.date === selectedDate);
        let updatedEntriesArray: DailyEntry[];
        if (existingEntryIndex > -1) {
            const existingEntry = prevDailyEntries[existingEntryIndex];
            let updatedItems: DailyEntryItem[];
            if (isEditingThisAction && editIndex !== null) { // Ensure editIndex is not null
                const originalEditIndex = getOriginalIndex(editIndex);
                if (originalEditIndex === -1) {
                    console.error("Edit error: original index not found for reversed index:", editIndex);
                    return prevDailyEntries; // Return previous state if error
                }
                updatedItems = existingEntry.items.map((item, index) => index === originalEditIndex ? entryItem : item);
            } else {
                updatedItems = [entryItem, ...(existingEntry.items ?? [])];
            }
            const updatedEntry = { ...existingEntry, items: updatedItems };
            updatedEntriesArray = prevDailyEntries.map((entry, index) => index === existingEntryIndex ? updatedEntry : entry);
        } else {
            if (isEditingThisAction) {
                console.error("Edit error: entry to edit not found for date:", selectedDate);
                return prevDailyEntries; // Return previous state if error
            }
            const newDailyEntry: DailyEntry = { date: selectedDate, items: [entryItem] };
            updatedEntriesArray = [...prevDailyEntries, newDailyEntry];
            updatedEntriesArray.sort((a, b) => a.date.localeCompare(b.date));
        }
        return updatedEntriesArray;
    });

    if (foodToAdd?.name) resolveAndSetIcon(foodToAdd.name);
    
    setIsOverlayVisible(false);
    setEditIndex(null);
    setInitialGramsForEdit(undefined);
    setFoodForEditModal(null);

    Toast.show({ type: "success", text1: t(isEditingThisAction ? 'dailyEntryScreen.entryUpdated' : 'dailyEntryScreen.entryAdded'), position: "bottom", visibilityTime: 2000, });
  }, [ isSaving, editIndex, selectedDate, getOriginalIndex, updateAndSaveEntries, resolveAndSetIcon, t ]);


  const handleAddMultipleEntriesFinal = useCallback(async (entriesToAdd: { food: Food; grams: number }[]) => {
    if (isSaving) return;
    try {
      if (!entriesToAdd || entriesToAdd.length === 0) return;
      const newItems: DailyEntryItem[] = entriesToAdd.map((entry) => ({ food: entry.food, grams: entry.grams }));
      
      await updateAndSaveEntries((prevDailyEntries) => {
          const existingEntryIndex = prevDailyEntries.findIndex((entry) => entry.date === selectedDate);
          let updatedEntriesArray: DailyEntry[];
          if (existingEntryIndex > -1) {
            const existingEntry = prevDailyEntries[existingEntryIndex];
            const updatedItems = [...newItems, ...(existingEntry.items ?? [])];
            const updatedEntry = { ...existingEntry, items: updatedItems };
            updatedEntriesArray = prevDailyEntries.map((entry, index) => index === existingEntryIndex ? updatedEntry : entry);
          } else {
            const newDailyEntry: DailyEntry = { date: selectedDate, items: newItems };
            updatedEntriesArray = [...prevDailyEntries, newDailyEntry];
            updatedEntriesArray.sort((a, b) => a.date.localeCompare(b.date));
          }
          return updatedEntriesArray;
      });

      newItems.forEach(item => { if (item.food?.name) resolveAndSetIcon(item.food.name); });
      
      Toast.show({ type: "success", text1: t('dailyEntryScreen.itemsAdded', { count: entriesToAdd.length }), text2: t('dailyEntryScreen.toDateFormat', { date: readableDate }), position: "bottom", visibilityTime: 3000, });
      
      setIsOverlayVisible(false); 
      setEditIndex(null);
      setInitialGramsForEdit(undefined);
      setFoodForEditModal(null);
    } catch (error) { Alert.alert(t('dailyEntryScreen.errorAddMultiple'), t('dailyEntryScreen.errorAddMultipleMessage')); setIsOverlayVisible(false); }
  }, [selectedDate, isSaving, updateAndSaveEntries, readableDate, resolveAndSetIcon, t]);


  const handleUndoRemoveEntry = useCallback(async (itemToRestore: DailyEntryItem, entryDate: string, originalIndexToRestoreAt: number) => {
    if (isSaving) return;
    Toast.hide(); 
    await updateAndSaveEntries((prevDailyEntries) => {
        const entryIdx = prevDailyEntries.findIndex(e => e.date === entryDate);
        let finalEntries: DailyEntry[];
        if (entryIdx > -1) {
            const entryToUpdate = prevDailyEntries[entryIdx];
            const currentItems = [...entryToUpdate.items];
            currentItems.splice(originalIndexToRestoreAt, 0, itemToRestore);
            const restoredEntry = { ...entryToUpdate, items: currentItems };
            finalEntries = prevDailyEntries.map((entry, i) => i === entryIdx ? restoredEntry : entry);
        } else {
            const newDailyEntry: DailyEntry = { date: entryDate, items: [itemToRestore] };
            finalEntries = [...prevDailyEntries, newDailyEntry];
            finalEntries.sort((a, b) => a.date.localeCompare(b.date));
        }
        return finalEntries;
    });
    Toast.show({ type: "success", text1: t('dailyEntryScreen.entryRestored'), visibilityTime: 1500, position: "bottom" });
  }, [isSaving, updateAndSaveEntries, t]);

  const undoHandlerRef = useRef(handleUndoRemoveEntry);
  useEffect(() => { undoHandlerRef.current = handleUndoRemoveEntry; }, [handleUndoRemoveEntry]);

  const handleRemoveEntry = useCallback(async (reversedItemIndex: number) => {
    if (isSaving) return;
    const originalItemIndex = getOriginalIndex(reversedItemIndex);
    if (originalItemIndex === -1) {
      console.error("handleRemoveEntry: Original index not found for reversed index:", reversedItemIndex);
      return;
    }

    const entryForToast = dailyEntries.find((e) => e.date === selectedDate);
    const itemToRemoveForToast = entryForToast?.items[originalItemIndex];

    if (!itemToRemoveForToast) {
      console.error("handleRemoveEntry: Item to remove not found in current state for Toast.");
      return;
    }

    await updateAndSaveEntries((prevDailyEntries) => {
      const currentEntryIndex = prevDailyEntries.findIndex((e) => e.date === selectedDate);
      if (currentEntryIndex === -1) {
        console.warn("handleRemoveEntry (updater): Entry not found for date:", selectedDate);
        return prevDailyEntries;
      }
      const currentEntry = prevDailyEntries[currentEntryIndex];
      if (originalItemIndex < 0 || originalItemIndex >= currentEntry.items.length) {
        console.warn("handleRemoveEntry (updater): Original item index out of bounds.");
        return prevDailyEntries;
      }
      
      const updatedItems = currentEntry.items.filter((_, i) => i !== originalItemIndex);
      
      if (updatedItems.length === 0) {
        return prevDailyEntries.filter((entry) => entry.date !== selectedDate);
      } else {
        const updatedEntry = { ...currentEntry, items: updatedItems };
        return prevDailyEntries.map((entry, i) => i === currentEntryIndex ? updatedEntry : entry);
      }
    });

    Toast.show({
        type: "info",
        text1: t('dailyEntryScreen.itemRemoved', { itemName: itemToRemoveForToast.food.name }),
        text2: t('dailyEntryScreen.undo'),
        position: "bottom",
        bottomOffset: 80,
        visibilityTime: 4000,
        onPress: () => undoHandlerRef.current(itemToRemoveForToast, selectedDate, originalItemIndex),
    });
  }, [dailyEntries, selectedDate, isSaving, getOriginalIndex, updateAndSaveEntries, t]);


  const toggleOverlay = useCallback((itemToEdit: DailyEntryItem | null = null, reversedItemIndex: number | null = null) => {
    if (isSaving) return;
    
    if (itemToEdit && reversedItemIndex !== null) {
      setFoodForEditModal(itemToEdit.food); 
      setInitialGramsForEdit(String(itemToEdit.grams));
      setEditIndex(reversedItemIndex); // Store reversedIndex
      if (itemToEdit.food.name) resolveAndSetIcon(itemToEdit.food.name); 
    } else {
      setFoodForEditModal(null);
      setInitialGramsForEdit(undefined);
      setEditIndex(null);
    }
    setIsOverlayVisible((current) => !current);
  }, [isSaving, resolveAndSetIcon]);

  const handleAddNewFoodRequestFromModal = useCallback(() => {
    if (isSaving) return;
    setIsOverlayVisible(false); 
    setFoodForEditModal(null);
    setInitialGramsForEdit(undefined);
    setEditIndex(null);
    navigation.navigate('FoodListRoute', { openAddFoodModal: true });
  }, [isSaving, navigation]);


  const handleCommitFoodItemToMainLibrary = useCallback(async (
    foodData: Omit<Food, 'id'> | Food,
    isUpdate: boolean
  ): Promise<Food | null> => {
    if (isSaving) return null;
    setIsSaving(true);
    try {
      let committedFood: Food;
      if (isUpdate && 'id' in foodData) { // Ensure it's a Food object for update
        committedFood = await updateFoodService(foodData as Food);
        setFoods(prevFoods =>
          prevFoods.map(f => (f.id === committedFood.id ? committedFood : f)).sort((a, b) => a.name.localeCompare(b.name))
        );
      } else if (!isUpdate && !('id' in foodData)) { // Ensure it's Omit<Food, 'id'> for create
        committedFood = await createFood(foodData as Omit<Food, 'id'>);
        setFoods(prevFoods => [...prevFoods, committedFood].sort((a, b) => a.name.localeCompare(b.name)));
      } else {
        throw new Error("Invalid data for commitFoodItemToMainLibrary");
      }
      if(committedFood.name) resolveAndSetIcon(committedFood.name);
      return committedFood;
    } catch (error) {
      console.error("Error committing food to library:", error);
      Alert.alert( t('foodListScreen.errorLoad'), error instanceof Error ? error.message : t(isUpdate ? 'foodListScreen.errorUpdateMessage' : 'foodListScreen.errorCreateMessage') );
      return null;
    } finally {
      setIsSaving(false);
    }
  }, [isSaving, resolveAndSetIcon, t]);


  const handleEditEntryViaModal = (item: DailyEntryItem, reversedIndex: number) => toggleOverlay(item, reversedIndex);

  const handleDateChange = useCallback((event: DateTimePickerEvent, selectedDateValue?: Date) => {
    const isAndroidDismiss = Platform.OS === "android" && event.type === "dismissed";
    setShowDatePicker(Platform.OS === "ios"); // Keep open on iOS until done
    if (!isAndroidDismiss && event.type === "set" && selectedDateValue) {
      if (isValid(selectedDateValue)) {
        const formattedDate = formatISO(selectedDateValue, { representation: "date" });
        if (formattedDate !== selectedDate) {
           setSelectedDate(formattedDate);
           setEditIndex(null); // Reset edit index when date changes
        }
      } else {
        Alert.alert(t('dailyEntryScreen.errorInvalidDate'), t('dailyEntryScreen.errorInvalidDateMessage'));
      }
    }
    // For Android, dismiss after selection or if explicitly dismissed
    if (Platform.OS === "android") {
        setShowDatePicker(false);
    }
  }, [selectedDate, t]);

  const handlePreviousDay = useCallback(() => {
    if (isSaving || isLoadingData) return;
    try {
      const currentDateObj = parseISO(selectedDate);
      if (!isValid(currentDateObj)) {
          console.warn("PreviousDay: Invalid current selectedDate:", selectedDate);
          return;
      }
      const newDate = subDays(currentDateObj, 1);
      const newDateString = formatISO(newDate, { representation: "date" });
      setSelectedDate(newDateString);
      setEditIndex(null);
    } catch (e) { console.error("DateNav Error (Prev):", e); }
  }, [selectedDate, isSaving, isLoadingData]);

  const handleNextDay = useCallback(() => {
    if (isSaving || isLoadingData) return;
    try {
      const currentDateObj = parseISO(selectedDate);
      if (!isValid(currentDateObj)) {
          console.warn("NextDay: Invalid current selectedDate:", selectedDate);
          return;
      }
      const newDate = addDays(currentDateObj, 1);
      const newDateString = formatISO(newDate, { representation: "date" });
      setSelectedDate(newDateString);
      setEditIndex(null);
    } catch (e) { console.error("DateNav Error (Next):", e); }
  }, [selectedDate, isSaving, isLoadingData]);

  const calculateTotals = useMemo(() => {
    const currentOriginalEntry = dailyEntries.find((entry) => entry.date === selectedDate);
    let totals = { totalCalories: 0, totalProtein: 0, totalCarbs: 0, totalFat: 0 };
    if (currentOriginalEntry) {
      currentOriginalEntry.items.forEach((item) => {
        if (item.food && typeof item.food.calories === "number" && typeof item.food.protein === "number" && typeof item.food.carbs === "number" && typeof item.food.fat === "number" && typeof item.grams === "number" && item.grams > 0) {
          const factor = item.grams / 100; totals.totalCalories += item.food.calories * factor; totals.totalProtein += item.food.protein * factor; totals.totalCarbs += item.food.carbs * factor; totals.totalFat += item.food.fat * factor;
        }
      });
    } return { totalCalories: Math.round(totals.totalCalories), totalProtein: Math.round(totals.totalProtein), totalCarbs: Math.round(totals.totalCarbs), totalFat: Math.round(totals.totalFat), };
  }, [dailyEntries, selectedDate]);

  return (
    <SafeAreaView style={styles.container} edges={["top", "left", "right"]}>
      <DateNavigator selectedDate={selectedDate} onPreviousDay={handlePreviousDay} onNextDay={handleNextDay} onShowDatePicker={() => !isSaving && !isLoadingData && setShowDatePicker(true)} isSaving={isSaving} isLoadingData={isLoadingData} />
      {showDatePicker && (<DateTimePicker value={isValid(parseISO(selectedDate)) ? parseISO(selectedDate) : new Date()} mode="date" display={Platform.OS === "ios" ? "spinner" : "default"} onChange={handleDateChange} />)}
      <View style={styles.progressContainer}><DailyProgress calories={calculateTotals.totalCalories} protein={calculateTotals.totalProtein} carbs={calculateTotals.totalCarbs} fat={calculateTotals.totalFat} goals={dailyGoals} /></View>
      <Divider style={styles.divider} />
      {isSaving && (<View style={styles.savingIndicator}><ActivityIndicator size="small" color={theme.colors.primary} /><Text style={styles.savingText}>{t('dailyEntryScreen.saving')}</Text></View>)}
      <Text style={styles.sectionTitle}>{t('dailyEntryScreen.todaysEntries')}</Text>
      {isLoadingData ? (<View style={styles.centeredLoader}><ActivityIndicator size="large" color={theme.colors.primary} /><Text style={styles.loadingText}>{t('dailyEntryScreen.loadingEntries')}</Text></View>
      ) : (
        <FlatList
          data={currentEntryItems}
          keyExtractor={(item, index) => `entry-${item?.food?.id ?? "unknown"}-${getOriginalIndex(index)}-${item?.grams ?? index}-${selectedDate}-${index}`}
          renderItem={({ item, index }) => (
            <DailyEntryListItem
              item={item}
              reversedIndex={index} // This is the index in the reversed currentEntryItems
              foodIcons={foodIcons}
              setFoodIcons={setFoodIcons}
              onEdit={handleEditEntryViaModal}
              onRemove={handleRemoveEntry}
              isSaving={isSaving}
              dailyGoals={dailyGoals} />
          )}
          ListEmptyComponent={<View style={styles.emptyListContainer}><RNEIcon name="reader-outline" type="ionicon" size={50} color={theme.colors.grey3} /><Text style={styles.emptyListText}>{t('dailyEntryScreen.noEntries')}</Text><Text style={styles.emptyListSubText}>{t('dailyEntryScreen.noEntriesHint')}</Text></View>}
          initialNumToRender={10}
          maxToRenderPerBatch={5}
          windowSize={11}
          contentContainerStyle={styles.listContentContainer}
          keyboardShouldPersistTaps="handled"
          extraData={{ foodIcons, isSaving, dailyGoals, selectedDate, itemsLength: currentEntryItems.length }}
        />
      )}
      <FAB icon={<RNEIcon name="add" color="white" />} color={theme.colors.primary} onPress={() => !isSaving && toggleOverlay()} placement="right" size="large" style={styles.fab} disabled={isSaving || isLoadingData} />
      
      {isOverlayVisible && (
          <AddEntryModal
            isVisible={isOverlayVisible}
            toggleOverlay={toggleOverlay}
            handleAddEntry={handleSingleEntryActionFinal}
            handleAddMultipleEntries={handleAddMultipleEntriesFinal}
            foods={foods} 
            isEditMode={editIndex !== null} // isEditMode depends on editIndex (which is a reversed index)
            initialGrams={initialGramsForEdit}
            initialSelectedFoodForEdit={foodForEditModal}
            onAddNewFoodRequest={handleAddNewFoodRequestFromModal}
            onCommitFoodToLibrary={handleCommitFoodItemToMainLibrary}
            dailyGoals={dailyGoals}
          />
      )}
    </SafeAreaView>
  );
};

const useStyles = makeStyles((theme) => ({
  container: { flex: 1, backgroundColor: theme.colors.background },
  progressContainer: { paddingHorizontal: 15, paddingTop: 10 },
  divider: { marginVertical: 0, height: StyleSheet.hairlineWidth, backgroundColor: theme.colors.divider, },
  sectionTitle: { marginTop: 15, marginBottom: 10, paddingHorizontal: 15, fontWeight: "bold", fontSize: 18, color: theme.colors.text, textAlign: I18nManager.isRTL ? 'right' : 'left' },
  fab: { position: "absolute", margin: 16, right: I18nManager.isRTL ? undefined : 10, left: I18nManager.isRTL ? 10 : undefined, bottom: 10 },
  emptyListContainer: { flex: 1, alignItems: "center", justifyContent: "center", padding: 30, marginTop: 50, },
  emptyListText: { fontSize: 17, color: theme.colors.grey2, textAlign: "center", marginTop: 15, },
  emptyListSubText: { fontSize: 14, color: theme.colors.grey3, textAlign: "center", marginTop: 8, },
  centeredLoader: { flex: 1, justifyContent: "center", alignItems: "center", paddingBottom: 50, },
  loadingText: { marginTop: 10, color: theme.colors.grey2, fontSize: 16 },
  savingIndicator: { flexDirection: "row", alignItems: "center", justifyContent: "center", paddingVertical: 5, backgroundColor: theme.colors.grey5, },
  savingText: { marginLeft: 8, color: theme.colors.primary, fontSize: 14, fontStyle: "italic", },
  listContentContainer: { paddingBottom: 80 },
}));

export default DailyEntryScreen;
---------- END DailyEntryScreen.tsx ----------


---------- FoodListScreen.tsx ----------
// src/screens/FoodListScreen.tsx
import React, { useState, useEffect, useCallback, useMemo, useRef } from "react";
import { View, FlatList, Alert, Platform, ActivityIndicator, StyleSheet, I18nManager, Share } from "react-native";
import { createFood, getFoods, updateFood, deleteFood } from "../services/foodService";
import { Food, SharedFoodData } from "../types/food";
import { isNotEmpty } from "../utils/validationUtils";
import FoodItem from "../components/FoodItem";
import { Button, SearchBar, useTheme, makeStyles, Text, Icon as RNEIcon } from "@rneui/themed";
import { FAB } from "@rneui/base";
import { SafeAreaView } from "react-native-safe-area-context";
import AddFoodModal from "../components/AddFoodModal";
import Toast from "react-native-toast-message";
import { useFocusEffect, useNavigation, useRoute, RouteProp } from "@react-navigation/native";
import { getFoodIconUrl } from "../utils/iconUtils"; // Removed clearLocalIconCache
import { t } from '../localization/i18n';
import { BottomTabNavigationProp } from '@react-navigation/bottom-tabs';
import { MainTabParamList } from "../navigation/AppNavigator";
import Constants from 'expo-constants';

if (typeof atob === 'undefined') {
  global.atob = (str: string): string => Buffer.from(str, 'base64').toString('binary');
}
if (typeof btoa === 'undefined') {
  global.btoa = (str: string): string => Buffer.from(str, 'binary').toString('base64');
}

interface FoodListScreenProps { onFoodChange?: () => void; }

const PAGE_SIZE = 20;

type FoodListScreenNavigationProp = BottomTabNavigationProp<MainTabParamList, 'FoodListRoute'>;
type FoodListScreenRouteProp = RouteProp<MainTabParamList, 'FoodListRoute'>;

const getBackendShareBaseUrl = (): string => {
    const envUrl = process.env.EXPO_PUBLIC_BACKEND_URL_PRODUCTION;
    const appJsonUrl = Constants.expoConfig?.extra?.env?.BACKEND_URL_PRODUCTION;
    let chosenUrl: string;

    if (envUrl) {
        chosenUrl = envUrl;
    } else if (appJsonUrl) {
        chosenUrl = appJsonUrl;
    } else {
        chosenUrl = "https://macros-vision-ai.xyz";
        console.warn(
            `Share Link WARNING: Production backend URL is not configured. Falling back to default: ${chosenUrl}.`
        );
    }
    return String(chosenUrl).replace(/\/api\/v1$/, '').replace(/\/$/, '');
};

const FoodListScreen: React.FC<FoodListScreenProps> = ({ onFoodChange }) => {
    const [foods, setFoods] = useState<Food[]>([]);
    const [foodIcons, setFoodIcons] = useState<{ [foodName: string]: string | null }>({});
    const [offset, setOffset] = useState(0);
    const [totalFoods, setTotalFoods] = useState(0);
    const [isLoading, setIsLoading] = useState(true);
    const [isLoadingMore, setIsLoadingMore] = useState(false);
    const [isOverlayVisible, setIsOverlayVisible] = useState(false);
    const [search, setSearch] = useState("");
    const [newFood, setNewFood] = useState<Omit<Food, "id">>({ name: "", calories: 0, protein: 0, carbs: 0, fat: 0, });
    const [editFood, setEditFood] = useState<Food | null>(null);
    const [errors, setErrors] = useState<{ [key: string]: string }>({});
    const [isSaving, setIsSaving] = useState(false);

    const { theme } = useTheme();
    const styles = useStyles();
    const flatListRef = useRef<FlatList<Food>>(null);
    const prevSearchTermRef = useRef<string>(search.trim());
    const isFirstRunRef = useRef(true);

    const route = useRoute<FoodListScreenRouteProp>();
    const navigation = useNavigation<FoodListScreenNavigationProp>();

    const resolveAndSetFoodIcon = useCallback((foodName: string) => {
        if (foodName && foodIcons[foodName] === undefined) { 
            const icon = getFoodIconUrl(foodName);
            setFoodIcons(prev => ({ ...prev, [foodName]: icon }));
        }
    }, [foodIcons]);

    const triggerIconPrefetch = useCallback((foodsToFetch: Food[]) => {
        if (!foodsToFetch || foodsToFetch.length === 0) return;
        const newIcons: { [key: string]: string | null } = {};
        foodsToFetch.forEach(food => {
            if (food.name && foodIcons[food.name] === undefined) {
                newIcons[food.name] = getFoodIconUrl(food.name);
            }
        });
        if (Object.keys(newIcons).length > 0) {
            setFoodIcons(prev => ({ ...prev, ...newIcons }));
        }
    }, [foodIcons]);


    const doFetchFoods = useCallback(async (
        isInitialOrNewSearch: boolean, termToFetch: string, currentOffset: number,
        currentFoodsLength: number, currentTotalFoods: number, currentIsLoadingMore: boolean
    ) => {
        if (!isInitialOrNewSearch && (currentIsLoadingMore || (currentFoodsLength >= currentTotalFoods && currentTotalFoods > 0))) {
            return;
        }
        const offsetForThisFetch = isInitialOrNewSearch ? 0 : currentOffset;
        if (isInitialOrNewSearch) setIsLoading(true); else setIsLoadingMore(true);

        try {
            const { items: newItemsFromApi, total: totalFromApi } = await getFoods(offsetForThisFetch, PAGE_SIZE, termToFetch);
            if (isInitialOrNewSearch) {
                flatListRef.current?.scrollToOffset({ animated: false, offset: 0 });
                setFoods(newItemsFromApi);
            } else {
                setFoods(prevFoods => {
                    const existingIds = new Set(prevFoods.map(f => f.id));
                    const uniqueNewItems = newItemsFromApi.filter(item => !existingIds.has(item.id));
                    return [...prevFoods, ...uniqueNewItems];
                });
            }
            setTotalFoods(totalFromApi);
            setOffset(offsetForThisFetch + newItemsFromApi.length);
            triggerIconPrefetch(newItemsFromApi);
        } catch (error) {
            Alert.alert(t('foodListScreen.errorLoad'), t('foodListScreen.errorLoadMessage'));
            if (isInitialOrNewSearch) { setFoods([]); setTotalFoods(0); setOffset(0); }
        } finally {
            if (isInitialOrNewSearch) setIsLoading(false); else setIsLoadingMore(false);
        }
    }, [triggerIconPrefetch, t]);

    const toggleOverlay = useCallback((foodToEdit?: Food) => {
        if (isSaving) return;
        if (foodToEdit) {
            setEditFood({ ...foodToEdit });
            setNewFood({ name: "", calories: 0, protein: 0, carbs: 0, fat: 0 });
        } else {
            setEditFood(null);
            setNewFood({ name: "", calories: 0, protein: 0, carbs: 0, fat: 0 });
        }
        setErrors({});
        setIsOverlayVisible(prev => !prev);
    }, [isSaving]);

    useFocusEffect(
        useCallback(() => {
            // Cache clearing removed from here for production
            // console.log("FoodListScreen useFocusEffect: Icon cache is now active.");

            const currentTrimmedSearch = search.trim();
            if (isFirstRunRef.current || prevSearchTermRef.current !== currentTrimmedSearch) {
                doFetchFoods(true, currentTrimmedSearch, offset, foods.length, totalFoods, isLoadingMore);
                isFirstRunRef.current = false;
                prevSearchTermRef.current = currentTrimmedSearch;
            }

            const params = route.params;
            if (params) {
                if (params.openAddFoodModal && !isOverlayVisible) {
                    toggleOverlay();
                    navigation.setParams({ openAddFoodModal: undefined });
                }
                if (params.foodData && typeof params.foodData === 'string') {
                    try {
                        let b64 = params.foodData.replace(/-/g, '+').replace(/_/g, '/');
                        const binaryString = atob(b64);
                        const utf8Bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            utf8Bytes[i] = binaryString.charCodeAt(i);
                        }
                        const decodedJson = new TextDecoder().decode(utf8Bytes);
                        const sharedFood: SharedFoodData = JSON.parse(decodedJson);

                        if (sharedFood && typeof sharedFood.name === 'string') {
                            setNewFood({
                                name: sharedFood.name, calories: sharedFood.calories, protein: sharedFood.protein,
                                carbs: sharedFood.carbs, fat: sharedFood.fat,
                            });
                            setEditFood(null);
                            setIsOverlayVisible(true); 
                        } else {
                            console.warn("Parsed shared food data is invalid:", sharedFood);
                            Alert.alert(t('foodListScreen.deepLinkErrorTitle'), t('foodListScreen.deepLinkInvalidData'));
                        }
                    } catch (e) {
                        console.error("Error parsing shared food data from deep link:", e);
                        Alert.alert(t('foodListScreen.deepLinkErrorTitle'), t('foodListScreen.deepLinkParseError'));
                    } finally {
                        navigation.setParams({ foodData: undefined });
                    }
                }
            }
        }, [search, route.params, isOverlayVisible, offset, foods.length, totalFoods, isLoadingMore, doFetchFoods, toggleOverlay, navigation, t])
    );

    const updateSearch = useCallback((text: string) => setSearch(text), []);
    const handleClearSearch = useCallback(() => setSearch(''), []);

    const handleLoadMore = () => {
        if (!isLoading && !isLoadingMore && (foods.length < totalFoods)) {
            doFetchFoods(false, search.trim(), offset, foods.length, totalFoods, isLoadingMore);
        }
    };
    
    const handleQuickAdd = useCallback((foodToQuickAdd: Food) => {
        navigation.navigate('DailyEntryRoute', { quickAddFood: foodToQuickAdd });
    }, [navigation]);

    const validateFood = (foodToValidate: Omit<Food, "id"> | Food): { [key: string]: string } | null => {
        const newErrors: { [key: string]: string } = {};
        if (!isNotEmpty(foodToValidate.name)) newErrors.name = "Name is required";
        if (isNaN(foodToValidate.calories) || foodToValidate.calories < 0) newErrors.calories = "Must be a non-negative number";
        if (isNaN(foodToValidate.protein) || foodToValidate.protein < 0) newErrors.protein = "Must be a non-negative number";
        if (isNaN(foodToValidate.carbs) || foodToValidate.carbs < 0) newErrors.carbs = "Must be a non-negative number";
        if (isNaN(foodToValidate.fat) || foodToValidate.fat < 0) newErrors.fat = "Must be a non-negative number";
        return Object.keys(newErrors).length === 0 ? null : newErrors;
    };

    const handleCreateFood = async () => {
        const trimmedFood = { ...newFood, name: newFood.name.trim() };
        const validationErrors = validateFood(trimmedFood);
        if (validationErrors) { setErrors(validationErrors); Toast.show({ type: 'error', text1: t('foodListScreen.fixErrors'), position: 'bottom' }); return; }
        setErrors({}); setIsSaving(true);
        try {
            const created = await createFood(trimmedFood);
            setIsOverlayVisible(false); 
            onFoodChange?.(); 
            doFetchFoods(true, search.trim(), 0, 0, 0, false); 
            Toast.show({ type: 'success', text1: t('foodListScreen.foodAdded', { foodName: created.name }), position: 'bottom' });
            setNewFood({ name: "", calories: 0, protein: 0, carbs: 0, fat: 0 });
        } catch (error: any) { Alert.alert(t('foodListScreen.errorCreate'), error.message || t('foodListScreen.errorCreateMessage'));
        } finally { setIsSaving(false); }
    };

    const handleUpdateFood = async () => {
        if (!editFood) return;
        const trimmedFood = { ...editFood, name: editFood.name.trim() };
        const validationErrors = validateFood(trimmedFood);
        if (validationErrors) { setErrors(validationErrors); Toast.show({ type: 'error', text1: t('foodListScreen.fixErrors'), position: 'bottom' }); return; }
        setErrors({}); setIsSaving(true);
        try {
            const updated = await updateFood(trimmedFood);
            setIsOverlayVisible(false); 
            onFoodChange?.(); 
            doFetchFoods(true, search.trim(), 0, 0, 0, false); 
            Toast.show({ type: 'success', text1: t('foodListScreen.foodUpdated', { foodName: updated.name }), position: 'bottom' });
            setEditFood(null);
        } catch (error: any) { Alert.alert(t('foodListScreen.errorUpdate'), error.message || t('foodListScreen.errorUpdateMessage'));
        } finally { setIsSaving(false); }
    };

    const handleDeleteFood = async (foodId: string) => {
        const foodToDelete = foods.find((f) => f.id === foodId); if (!foodToDelete) return;
        try {
            await deleteFood(foodId);
            onFoodChange?.();
            if (foodToDelete.name && foodIcons[foodToDelete.name] !== undefined) { 
                setFoodIcons(prev => { const newIcons = { ...prev }; delete newIcons[foodToDelete.name]; return newIcons; });
            }
            doFetchFoods(true, search.trim(), 0, 0, 0, false); 
        } catch (error) {
            Alert.alert(t('foodListScreen.errorDelete'), t('foodListScreen.errorDeleteMessage'));
            doFetchFoods(true, search.trim(), 0, 0, 0, false); 
        }
    };

    const handleUndoDeleteFood = useCallback(async (food: Food) => {
        Toast.hide();
        doFetchFoods(true, search.trim(), 0, 0, 0, false); 
        Toast.show({ type: 'info', text1: t('foodListScreen.foodRestored', { foodName: food.name }), text2: "List refreshed.", position: 'bottom', visibilityTime: 2000 });
    }, [search, doFetchFoods, t]); 

    const handleShareFood = useCallback(async (foodToShare: Food) => {
        const foodDataPayload: SharedFoodData = {
            name: foodToShare.name, calories: foodToShare.calories, protein: foodToShare.protein,
            carbs: foodToShare.carbs, fat: foodToShare.fat,
        };
        try {
            const jsonString = JSON.stringify(foodDataPayload);
            const utf8Bytes = new TextEncoder().encode(jsonString);
            let binaryString = '';
            utf8Bytes.forEach((byte) => { binaryString += String.fromCharCode(byte); });
            
            const base64Data = btoa(binaryString)
                                 .replace(/\+/g, '-')
                                 .replace(/\//g, '_');
            
            const backendBaseUrl = getBackendShareBaseUrl();
            const shareUrl = `${backendBaseUrl}/share/food?data=${base64Data}`;
            
            await Share.share({ message: shareUrl, title: t('foodListScreen.shareFoodTitle', {foodName: foodToShare.name}), });
        } catch (error) {
            console.error("Error sharing food:", error);
            Alert.alert(t('foodListScreen.shareErrorTitle'), t('foodListScreen.shareErrorMessage'));
        }
    }, [t]);

    const handleInputChange = useCallback((key: keyof Omit<Food, "id">, value: string, isEdit: boolean) => {
        const numericKeys: (keyof Omit<Food, "id">)[] = ['calories', 'protein', 'carbs', 'fat'];
        let processedValue: string | number = value;
    
        if (numericKeys.includes(key)) {
            if (value === "" || value === ".") {
                processedValue = value;
            } else {
                const cleaned = value.replace(/[^0-9.]/g, "").replace(/(\..*)\./g, "$1");
                if (cleaned === "" || !isNaN(parseFloat(cleaned))) {
                    processedValue = cleaned;
                } else {
                    return; 
                }
            }
        }
    
        const updateState = (prevState: any) => {
            let finalValue: string | number;
            if (numericKeys.includes(key)) {
                finalValue = (processedValue === "" || processedValue === ".") ? 0 : parseFloat(processedValue as string);
                if (isNaN(finalValue)) finalValue = 0;
            } else {
                finalValue = processedValue;
            }
            return { ...prevState, [key]: finalValue };
        };
    
        if (isEdit) {
            setEditFood(updateState);
        } else {
            setNewFood(updateState);
        }
    }, []);


    const renderFooter = () => isLoadingMore ? <View style={styles.footerLoader}><ActivityIndicator size="small" color={theme.colors.primary} /></View> : null;

    if (isLoading && foods.length === 0 && !isOverlayVisible) {
        return (
            <SafeAreaView style={styles.centeredLoader} edges={['top', 'left', 'right']}>
                <ActivityIndicator size="large" color={theme.colors.primary} />
                <Text style={styles.loadingText}>{t('foodListScreen.loadingFoods')}</Text>
            </SafeAreaView>
        );
    }

    return (
        <SafeAreaView style={styles.container} edges={['top', 'left', 'right']}>
            <SearchBar
                placeholder={t('foodListScreen.searchPlaceholder')}
                onChangeText={updateSearch}
                value={search}
                platform={Platform.OS === "ios" ? "ios" : "android"}
                containerStyle={styles.searchBarContainer}
                inputContainerStyle={styles.searchBarInputContainer}
                inputStyle={styles.searchInputStyle}
                onClear={handleClearSearch}
                showCancel={Platform.OS === 'ios' && search.length > 0}
                cancelButtonProps={{ color: theme.colors.primary }}
                showLoading={isLoading && search.trim().length > 0} 
            />
            <FlatList
                ref={flatListRef}
                data={foods}
                keyExtractor={(item) => item.id}
                renderItem={({ item }) => (
                    <FoodItem
                        food={item}
                        onEdit={() => toggleOverlay(item)}
                        onDelete={handleDeleteFood}
                        onUndoDelete={handleUndoDeleteFood}
                        onQuickAdd={handleQuickAdd}
                        onShare={handleShareFood}
                        foodIconUrl={foodIcons[item.name]} 
                        setFoodIconForName={resolveAndSetFoodIcon}
                        />
                )}
                ListEmptyComponent={
                    !isLoading ? (
                        <View style={styles.emptyListContainer}>
                            <RNEIcon name="nutrition-outline" type="ionicon" size={50} color={theme.colors.grey3} />
                            <Text style={styles.emptyListText}>
                                {search.trim() ? t('foodListScreen.noResults', { searchTerm: search.trim() }) : t('foodListScreen.emptyLibrary')}
                            </Text>
                            {!search.trim() && <Text style={styles.emptyListSubText}>{t('foodListScreen.emptyLibraryHint')}</Text>}
                        </View>
                    ) : null
                }
                contentContainerStyle={foods.length === 0 && !isLoading ? styles.listContentContainerEmpty : styles.listContentContainer}
                onEndReached={handleLoadMore}
                onEndReachedThreshold={0.5}
                ListFooterComponent={renderFooter}
                keyboardShouldPersistTaps="handled"
                extraData={{ foodIcons, isLoadingMore, isLoading, search, foodsLength: foods.length, totalFoods }}
            />
            <FAB
                icon={<RNEIcon name="add" color={theme.colors.white} />}
                color={theme.colors.primary}
                onPress={() => !isSaving && toggleOverlay()}
                placement="right"
                size="large"
                style={styles.fab}
                disabled={isSaving || isLoading}
            />
            <AddFoodModal
                isVisible={isOverlayVisible}
                toggleOverlay={() => !isSaving && setIsOverlayVisible(false)} 
                newFood={newFood}
                editFood={editFood}
                errors={errors}
                handleInputChange={handleInputChange}
                handleCreateFood={handleCreateFood}
                handleUpdateFood={handleUpdateFood}
                validateFood={validateFood}
                setErrors={setErrors}
            />
        </SafeAreaView>
    );
};

const useStyles = makeStyles((theme) => ({
    container: {
        flex: 1,
        backgroundColor: theme.colors.background,
    },
    centeredLoader: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: theme.colors.background,
    },
    loadingText: {
        marginTop: 15,
        color: theme.colors.grey1,
        fontSize: 16,
    },
    emptyListContainer: {
        flex: 1,
        alignItems: 'center',
        justifyContent: 'center',
        padding: 30,
        marginTop: 50,
    },
    emptyListText: {
        fontSize: 17,
        color: theme.colors.grey2,
        textAlign: 'center',
        marginTop: 15,
    },
    emptyListSubText: {
        fontSize: 14,
        color: theme.colors.grey3,
        textAlign: 'center',
        marginTop: 8,
    },
    searchBarContainer: {
        backgroundColor: theme.colors.background,
        borderBottomColor: theme.colors.divider,
        borderTopColor: theme.colors.background,
        borderBottomWidth: StyleSheet.hairlineWidth,
        paddingHorizontal: 10,
        paddingVertical: 8,
        marginBottom: 0,
    },
    searchBarInputContainer: {
        backgroundColor: theme.colors.searchBg || theme.colors.grey5,
        height: 40,
        borderRadius: 20,
    },
    searchInputStyle: {
        color: theme.colors.text,
        fontSize: 15,
        textAlign: I18nManager.isRTL ? 'right' : 'left',
    },
    listContentContainer: {
        paddingBottom: 80,
    },
    listContentContainerEmpty: {
        flexGrow: 1,
        justifyContent: 'center',
    },
    fab: {
        position: 'absolute',
        margin: 16,
        right: I18nManager.isRTL ? undefined : 10,
        left: I18nManager.isRTL ? 10 : undefined,
        bottom: 10,
    },
    footerLoader: {
        paddingVertical: 20,
        alignItems: 'center',
    },
}));

export default FoodListScreen;
---------- END FoodListScreen.tsx ----------


---------- QuestionnaireScreen.tsx ----------
// src/screens/QuestionnaireScreen.tsx
import React, { useState, useCallback, useMemo } from 'react';
import { View, ScrollView, Alert, StyleSheet, I18nManager, Platform } from 'react-native';
import { Input, Button, Text, useTheme, makeStyles, CheckBox } from '@rneui/themed';
import { Picker } from '@react-native-picker/picker';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { QuestionnaireFormData, Sex, ActivityLevel, PrimaryGoal, GoalIntensity, CalculatedGoals } from '../types/questionnaire';
import { MacroType, Settings } from '../types/settings';
import { loadSettings, saveSettings } from '../services/storageService';
import i18n, { t } from '../localization/i18n';
import Toast from 'react-native-toast-message';

type SettingsStackParamList = {
  SettingsScreen: undefined;
  QuestionnaireScreen: undefined;
};

type QuestionnaireNavigationProp = NativeStackNavigationProp<SettingsStackParamList, 'QuestionnaireScreen'>;

const QuestionnaireScreen: React.FC = () => {
  const { theme } = useTheme();
  const styles = useStyles();
  const navigation = useNavigation<QuestionnaireNavigationProp>();

  const [formData, setFormData] = useState<QuestionnaireFormData>({
    age: '',
    sex: '',
    height: '',
    weight: '',
    activityLevel: '',
    primaryGoal: '',
    goalIntensity: GoalIntensity.MODERATE, // Default intensity
  });

  const [errors, setErrors] = useState<Partial<Record<keyof QuestionnaireFormData, string>>>({});
  const [isCalculating, setIsCalculating] = useState(false);

  const activityLevelOptions = useMemo(() => [
    { label: t('questionnaireScreen.activityLevel.select'), value: '' },
    { label: t('questionnaireScreen.activityLevel.sedentary'), value: ActivityLevel.SEDENTARY },
    { label: t('questionnaireScreen.activityLevel.light'), value: ActivityLevel.LIGHT },
    { label: t('questionnaireScreen.activityLevel.moderate'), value: ActivityLevel.MODERATE },
    { label: t('questionnaireScreen.activityLevel.active'), value: ActivityLevel.ACTIVE },
    { label: t('questionnaireScreen.activityLevel.veryActive'), value: ActivityLevel.VERY_ACTIVE },
  ], [i18n.locale]);

  const sexOptions = useMemo(() => [
    { label: t('questionnaireScreen.sex.select'), value: '' },
    { label: t('questionnaireScreen.sex.male'), value: Sex.MALE },
    { label: t('questionnaireScreen.sex.female'), value: Sex.FEMALE },
  ], [i18n.locale]);

  const primaryGoalOptions = useMemo(() => [
    { label: t('questionnaireScreen.primaryGoal.select'), value: '' },
    { label: t('questionnaireScreen.primaryGoal.loseWeight'), value: PrimaryGoal.LOSE_WEIGHT },
    { label: t('questionnaireScreen.primaryGoal.maintainWeight'), value: PrimaryGoal.MAINTAIN_WEIGHT },
    { label: t('questionnaireScreen.primaryGoal.gainMuscle'), value: PrimaryGoal.GAIN_MUSCLE },
  ], [i18n.locale]);

  const goalIntensityOptions = useMemo(() => [
    { label: t('questionnaireScreen.goalIntensity.mild'), value: GoalIntensity.MILD },
    { label: t('questionnaireScreen.goalIntensity.moderate'), value: GoalIntensity.MODERATE },
    { label: t('questionnaireScreen.goalIntensity.aggressive'), value: GoalIntensity.AGGRESSIVE },
  ], [i18n.locale]);


  const handleInputChange = (field: keyof QuestionnaireFormData, value: any) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    if (errors[field]) {
      setErrors(prev => ({ ...prev, [field]: undefined }));
    }
  };

  const validateForm = (): boolean => {
    const newErrors: Partial<Record<keyof QuestionnaireFormData, string>> = {};
    const ageNum = parseFloat(formData.age);
    const heightNum = parseFloat(formData.height);
    const weightNum = parseFloat(formData.weight);

    if (!formData.age.trim() || isNaN(ageNum) || ageNum <= 0 || ageNum > 120) {
      newErrors.age = t('questionnaireScreen.validation.invalidAge');
    }
    if (formData.sex === '') {
      newErrors.sex = t('questionnaireScreen.validation.selectSex');
    }
    if (!formData.height.trim() || isNaN(heightNum) || heightNum <= 50 || heightNum > 250) {
      newErrors.height = t('questionnaireScreen.validation.invalidHeight');
    }
    if (!formData.weight.trim() || isNaN(weightNum) || weightNum <= 20 || weightNum > 300) {
      newErrors.weight = t('questionnaireScreen.validation.invalidWeight');
    }
    if (formData.activityLevel === '') {
      newErrors.activityLevel = t('questionnaireScreen.validation.selectActivityLevel');
    }
    if (formData.primaryGoal === '') {
      newErrors.primaryGoal = t('questionnaireScreen.validation.selectPrimaryGoal');
    }
    if (formData.primaryGoal !== PrimaryGoal.MAINTAIN_WEIGHT && !formData.goalIntensity) {
        newErrors.goalIntensity = t('questionnaireScreen.validation.selectGoalIntensity');
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const calculateGoals = (): CalculatedGoals | null => {
    const age = parseFloat(formData.age);
    const height = parseFloat(formData.height);
    const weight = parseFloat(formData.weight);

    // BMR (Mifflin-St Jeor)
    let bmr: number;
    if (formData.sex === Sex.MALE) {
      bmr = 10 * weight + 6.25 * height - 5 * age + 5;
    } else {
      bmr = 10 * weight + 6.25 * height - 5 * age - 161;
    }

    // TDEE
    let activityMultiplier = 1.2;
    switch (formData.activityLevel) {
      case ActivityLevel.SEDENTARY: activityMultiplier = 1.2; break;
      case ActivityLevel.LIGHT: activityMultiplier = 1.375; break;
      case ActivityLevel.MODERATE: activityMultiplier = 1.55; break;
      case ActivityLevel.ACTIVE: activityMultiplier = 1.725; break;
      case ActivityLevel.VERY_ACTIVE: activityMultiplier = 1.9; break;
    }
    const tdee = bmr * activityMultiplier;

    // Calorie Goal
    let calorieAdjustment = 0;
    if (formData.primaryGoal !== PrimaryGoal.MAINTAIN_WEIGHT) {
      switch (formData.goalIntensity) {
        case GoalIntensity.MILD: calorieAdjustment = (formData.primaryGoal === PrimaryGoal.LOSE_WEIGHT ? -300 : 250); break;
        case GoalIntensity.MODERATE: calorieAdjustment = (formData.primaryGoal === PrimaryGoal.LOSE_WEIGHT ? -500 : 400); break;
        case GoalIntensity.AGGRESSIVE: calorieAdjustment = (formData.primaryGoal === PrimaryGoal.LOSE_WEIGHT ? -700 : 600); break;
      }
    }
    let calorieGoal = tdee + calorieAdjustment;

    // Ensure calorie goal is not below minimums
    const minCalories = formData.sex === Sex.FEMALE ? 1200 : 1500;
    if (calorieGoal < minCalories) {
        calorieGoal = minCalories;
        Toast.show({ type: 'info', text1: t('questionnaireScreen.toast.minCaloriesAdjustedTitle'), text2: t('questionnaireScreen.toast.minCaloriesAdjustedMessage', { calories: minCalories }), position: 'bottom' });
    }
    if (formData.primaryGoal === PrimaryGoal.LOSE_WEIGHT && calorieGoal >= tdee) {
        calorieGoal = tdee - 100; // Ensure at least a small deficit
    }
    if (formData.primaryGoal === PrimaryGoal.GAIN_MUSCLE && calorieGoal <= tdee) {
        calorieGoal = tdee + 100; // Ensure at least a small surplus
    }


    // Macros
    let proteinPerKg = 1.8;
    if (formData.primaryGoal === PrimaryGoal.GAIN_MUSCLE) proteinPerKg = 2.0;
    if (age > 65) proteinPerKg = Math.max(1.2, proteinPerKg - 0.4); // Adjust for older adults

    const proteinGrams = proteinPerKg * weight;
    const proteinCalories = proteinGrams * 4;

    const fatPercentage = 0.25; // 25% of calories from fat
    const fatCalories = calorieGoal * fatPercentage;
    const fatGrams = fatCalories / 9;

    const carbCalories = calorieGoal - proteinCalories - fatCalories;
    const carbGrams = carbCalories / 4;

    return {
      calories: Math.round(calorieGoal),
      protein: Math.round(proteinGrams),
      carbs: Math.round(carbGrams),
      fat: Math.round(fatGrams),
    };
  };

  const handleSubmit = async () => {
    if (!validateForm()) {
      Toast.show({ type: 'error', text1: t('questionnaireScreen.validation.fixErrors'), position: 'bottom' });
      return;
    }
    setIsCalculating(true);
    try {
      const calculated = calculateGoals();
      if (calculated) {
        const currentSettings = await loadSettings();
        const updatedSettings: Settings = {
          ...currentSettings,
          dailyGoals: calculated,
        };
        await saveSettings(updatedSettings);
        Toast.show({ type: 'success', text1: t('questionnaireScreen.toast.goalsCalculated'), position: 'bottom' });
        navigation.goBack();
      } else {
        Alert.alert(t('questionnaireScreen.error.calculationFailedTitle'), t('questionnaireScreen.error.calculationFailedMessage'));
      }
    } catch (error) {
      console.error("Error saving estimated goals:", error);
      Alert.alert(t('questionnaireScreen.error.genericSaveTitle'), t('questionnaireScreen.error.genericSaveMessage'));
    } finally {
      setIsCalculating(false);
    }
  };

  const renderPicker = (
    label: string,
    selectedValue: string | number,
    onValueChange: (itemValue: any, itemIndex: number) => void,
    items: { label: string, value: string | number }[],
    error?: string
  ) => (
    <View style={styles.inputContainer}>
      <Text style={styles.label}>{label}</Text>
      <View style={[styles.pickerWrapper, error ? styles.errorBorder : {}]}>
        <Picker
          selectedValue={selectedValue}
          onValueChange={onValueChange}
          style={[styles.picker, Platform.OS === 'android' ? { color: theme.colors.text, backgroundColor: theme.colors.background } : {}]}
          itemStyle={[styles.pickerItem, Platform.OS === 'ios' ? {color: theme.colors.text} : {}]}
          dropdownIconColor={theme.colors.text}
        >
          {items.map(item => <Picker.Item key={item.value.toString()} label={item.label} value={item.value} />)}
        </Picker>
      </View>
      {error && <Text style={styles.errorText}>{error}</Text>}
    </View>
  );

  return (
    <ScrollView style={styles.container} contentContainerStyle={styles.scrollContentContainer} keyboardShouldPersistTaps="handled">
      <Text h4 style={styles.title}>{t('questionnaireScreen.title')}</Text>

      <Input
        label={t('questionnaireScreen.ageLabel')}
        placeholder={t('questionnaireScreen.agePlaceholder')}
        keyboardType="numeric"
        value={formData.age}
        onChangeText={val => handleInputChange('age', val)}
        errorMessage={errors.age}
        inputStyle={{ textAlign: I18nManager.isRTL ? 'right' : 'left', color: theme.colors.text}}
        labelStyle={styles.label}
        errorStyle={styles.errorText}
        containerStyle={styles.inputContainer}
      />

      {renderPicker(t('questionnaireScreen.sexLabel'), formData.sex, (val) => handleInputChange('sex', val), sexOptions, errors.sex)}

      <Input
        label={t('questionnaireScreen.heightLabel')}
        placeholder={t('questionnaireScreen.heightPlaceholder')}
        keyboardType="numeric"
        value={formData.height}
        onChangeText={val => handleInputChange('height', val)}
        errorMessage={errors.height}
        rightIcon={<Text style={styles.unitText}>cm</Text>}
        inputStyle={{ textAlign: I18nManager.isRTL ? 'right' : 'left', color: theme.colors.text}}
        labelStyle={styles.label}
        errorStyle={styles.errorText}
        containerStyle={styles.inputContainer}
      />

      <Input
        label={t('questionnaireScreen.weightLabel')}
        placeholder={t('questionnaireScreen.weightPlaceholder')}
        keyboardType="numeric"
        value={formData.weight}
        onChangeText={val => handleInputChange('weight', val)}
        errorMessage={errors.weight}
        rightIcon={<Text style={styles.unitText}>kg</Text>}
        inputStyle={{ textAlign: I18nManager.isRTL ? 'right' : 'left', color: theme.colors.text}}
        labelStyle={styles.label}
        errorStyle={styles.errorText}
        containerStyle={styles.inputContainer}
      />

      {renderPicker(t('questionnaireScreen.activityLevelLabel'), formData.activityLevel, (val) => handleInputChange('activityLevel', val), activityLevelOptions, errors.activityLevel)}
      {renderPicker(t('questionnaireScreen.primaryGoalLabel'), formData.primaryGoal, (val) => handleInputChange('primaryGoal', val), primaryGoalOptions, errors.primaryGoal)}

      {formData.primaryGoal && formData.primaryGoal !== PrimaryGoal.MAINTAIN_WEIGHT && (
        renderPicker(t('questionnaireScreen.goalIntensityLabel'), formData.goalIntensity || '', (val) => handleInputChange('goalIntensity', val), goalIntensityOptions, errors.goalIntensity)
      )}

      <Button
        title={t('questionnaireScreen.calculateButton')}
        onPress={handleSubmit}
        buttonStyle={styles.button}
        loading={isCalculating}
        disabled={isCalculating}
      />
    </ScrollView>
  );
};

const useStyles = makeStyles((theme) => ({
  container: {
    flex: 1,
    backgroundColor: theme.colors.background,
  },
  scrollContentContainer: {
    padding: 20,
    paddingBottom: 40,
  },
  title: {
    marginBottom: 20,
    textAlign: 'center',
    color: theme.colors.text,
  },
  inputContainer: {
    marginBottom: 15,
  },
  label: {
    color: theme.colors.grey1,
    fontWeight: 'bold',
    marginBottom: 5,
    fontSize: 16,
    textAlign: I18nManager.isRTL ? 'right' : 'left',
  },
  unitText: {
    color: theme.colors.grey2,
    fontSize: 16,
  },
  pickerWrapper: {
    borderColor: theme.colors.grey3,
    borderWidth: 1,
    borderRadius: 5,
    backgroundColor: theme.colors.background, // Ensure picker background matches
  },
  picker: {
    height: Platform.OS === 'ios' ? 120 : 50,
    width: '100%',
  },
  pickerItem: {
     // For iOS, text color is set here. Android uses picker's color prop.
     textAlign: I18nManager.isRTL ? 'right' : 'left',
  },
  errorText: {
    color: theme.colors.error,
    marginTop: 3,
    fontSize: 12,
    textAlign: I18nManager.isRTL ? 'right' : 'left',
  },
  errorBorder: {
    borderColor: theme.colors.error,
  },
  button: {
    marginTop: 20,
    backgroundColor: theme.colors.primary,
    borderRadius: 8,
  },
}));

export default QuestionnaireScreen;
---------- END QuestionnaireScreen.tsx ----------


---------- SettingsScreen.tsx ----------
// src/screens/SettingsScreen.tsx
import React, { useState, useEffect, useCallback } from "react";
import { View, ScrollView, Alert, StyleSheet, ActivityIndicator, Platform, I18nManager } from "react-native";
import { Text, makeStyles, Button, Icon, useTheme, ListItem } from "@rneui/themed";
import { Picker } from '@react-native-picker/picker';
import DailyGoalsInput from "../components/DailyGoalsInput";
import DataManagementButtons from "../components/DataManagementButtons";
import ThemeSwitch from "../components/ThemeSwitch";
import StatisticsChart from "../components/StatisticsChart";
import AccountSettings from "../components/AccountSettings";
import { loadSettings, saveSettings, loadDailyEntries } from "../services/storageService";
import { Settings, Statistics, MacroType, MacroData, LanguageCode, macros as macroKeysSetting } from "../types/settings";
import { parseISO, isValid, startOfDay } from "date-fns";
import { DailyEntry } from "../types/dailyEntry";
import { useFocusEffect, useNavigation } from "@react-navigation/native";
import { NativeStackNavigationProp } from "@react-navigation/native-stack"; // For navigation
// Removed: import { clearIconCache } from "../utils/iconUtils"; 
import Toast from "react-native-toast-message";
import { getUserStatus, addCoinsToUser, BackendError } from "../services/backendService";
import { t } from "../localization/i18n";
import i18n from '../localization/i18n';

interface SettingsScreenProps {
  onThemeChange: (theme: "light" | "dark" | "system") => void;
  onLocaleChange: (locale: LanguageCode) => void;
  onDataOperation: () => void; 
}

type SettingsStackParamList = {
  SettingsHome: undefined; 
  Questionnaire: undefined; 
};

type SettingsNavigationProp = NativeStackNavigationProp<SettingsStackParamList, 'SettingsHome'>;


const SettingsScreen: React.FC<SettingsScreenProps> = ({ onThemeChange, onLocaleChange, onDataOperation }) => {
  const [settings, setSettings] = useState<Settings>({
    theme: "system",
    language: "system",
    dailyGoals: { calories: 0, protein: 0, carbs: 0, fat: 0 },
    settingsHistory: [],
  });

  const [statistics, setStatistics] = useState<Statistics>({
    calories: [], protein: [], carbs: [], fat: [],
  });
  const [chartUpdateKey, setChartUpdateKey] = useState(0);
  // Removed: const [isClearingCache, setIsClearingCache] = useState(false);
  const [userCoins, setUserCoins] = useState<number | null>(null);
  const [isLoadingCoins, setIsLoadingCoins] = useState(false);
  const [isAddingCoins, setIsAddingCoins] = useState(false);
  const [isDataLoading, setIsDataLoading] = useState(true); 

  const { theme } = useTheme();
  const styles = useStyles();
  const navigation = useNavigation<SettingsNavigationProp>(); 

  const getStatisticsData = useCallback((
    dailyEntries: DailyEntry[],
    macro: MacroType,
    currentGoals: { [key in MacroType]: number }
  ): MacroData[][] => {
    const intakeDataMap = new Map<number, number>(); 
    const goalDataMap = new Map<number, number>();   

    dailyEntries.forEach((entry) => {
      try {
        const entryDate = parseISO(entry.date);
        if (!isValid(entryDate)) {
          console.warn(`Invalid date in getStatisticsData: ${entry.date}`);
          return;
        }
        const entryTimestamp = startOfDay(entryDate).getTime();

        let intakeValue = 0;
        if (entry.items && Array.isArray(entry.items)) {
          intakeValue = entry.items.reduce((total, item) => {
            if (item.food && typeof item.food[macro] === 'number' && typeof item.grams === 'number' && item.grams > 0) {
              return total + (item.food[macro] / 100) * item.grams;
            }
            return total;
          }, 0);
        }
        intakeDataMap.set(entryTimestamp, (intakeDataMap.get(entryTimestamp) || 0) + Math.round(intakeValue));

        if (macro === "calories") {
          const goalValue = currentGoals[macro] ?? 0;
           if (intakeDataMap.has(entryTimestamp)) {
             goalDataMap.set(entryTimestamp, Math.round(goalValue));
           }
        }
      } catch (parseError) {
        console.error(`Error processing entry ${entry.date} for statistics:`, parseError);
      }
    });

    const sortedTimestamps = Array.from(new Set([...intakeDataMap.keys(), ...goalDataMap.keys()])).sort((a,b) => a - b);
    
    const finalIntakeData: MacroData[] = sortedTimestamps.map(ts => ({
        x: ts,
        y: intakeDataMap.get(ts) || 0
    }));

    if (macro === "calories") {
        const finalGoalData: MacroData[] = sortedTimestamps.map(ts => ({
            x: ts,
            y: goalDataMap.get(ts) || currentGoals[macro] || 0
        }));
        return [finalIntakeData, finalGoalData];
    }
    return [finalIntakeData];
  }, []);


  const updateStatistics = useCallback(async (currentGoals: { [key in MacroType]: number }) => {
    console.log("SettingsScreen: Updating statistics with goals:", currentGoals);
    try {
        const loadedEntries = await loadDailyEntries();
        const updatedStats: Statistics = {
            calories: [], protein: [], carbs: [], fat: []
        };
        (macroKeysSetting as readonly MacroType[]).forEach(macro => {
            updatedStats[macro] = getStatisticsData(loadedEntries, macro, currentGoals);
        });
        setStatistics(updatedStats);
        setChartUpdateKey((prevKey) => prevKey + 1);
        console.log("SettingsScreen: Statistics updated.");
    } catch (error) {
        console.error("SettingsScreen: Failed to update statistics:", error);
    }
  }, [getStatisticsData]);

  const fetchUserStatus = useCallback(async () => {
    setIsLoadingCoins(true);
    try { const status = await getUserStatus(); setUserCoins(status.coins); }
    catch (error) {
      setUserCoins(null);
      Toast.show({ type: 'error', text1: t('accountSettings.errorLoadCoins'), text2: error instanceof BackendError ? error.message : t('backendService.errorNetworkConnection'), position: 'bottom', });
    }
    finally { setIsLoadingCoins(false); }
  }, []);

  useFocusEffect( useCallback(() => {
      let isActive = true;
      setIsDataLoading(true);
      const loadAndProcessData = async () => {
        try {
          const loadedSettings = await loadSettings();
          if (!isActive) return;
          setSettings(loadedSettings);
          navigation.setOptions({ title: t('settingsScreen.title') });
          await fetchUserStatus();
          await updateStatistics(loadedSettings.dailyGoals);
        } catch (error) {
          if (isActive) {
            Alert.alert(t('dailyEntryScreen.errorLoad'), t('dailyEntryScreen.errorLoadMessage'));
          }
        } finally {
          if (isActive) setIsDataLoading(false);
        }
      };
      loadAndProcessData();
      return () => { isActive = false; };
    }, [updateStatistics, fetchUserStatus, navigation]) 
  );

  const handleGoalChange = useCallback(async (goalType: MacroType, value: string) => {
    const numericValue = parseFloat(value);
    const validatedValue = isNaN(numericValue) || numericValue < 0 ? 0 : numericValue;

    setSettings((prevSettings) => {
      const updatedGoals = { ...prevSettings.dailyGoals, [goalType]: validatedValue };
      const updatedSettings: Settings = { ...prevSettings, dailyGoals: updatedGoals };
      
      saveSettings(updatedSettings)
        .then(() => {
          updateStatistics(updatedSettings.dailyGoals);
        })
        .catch((error) => {
          Alert.alert(t('dailyEntryScreen.errorSave'), t('dailyEntryScreen.errorSaveMessage'));
        });
      return updatedSettings;
    });
  }, [updateStatistics]);


  const localDataOperationHandler = useCallback(async () => {
    setIsDataLoading(true);
    try {
      const reloadedSettings = await loadSettings();
      setSettings(reloadedSettings);
      await updateStatistics(reloadedSettings.dailyGoals);
      await fetchUserStatus();
      onThemeChange(reloadedSettings.theme); 
      onLocaleChange(reloadedSettings.language); 
      
      onDataOperation(); 

      Toast.show({ type: 'info', text1: t('dataManagement.dataReloaded'), position: 'bottom'});
    }
    catch (error) { Alert.alert(t('dailyEntryScreen.errorLoad'), t('dailyEntryScreen.errorLoadMessage')); }
    finally { setIsDataLoading(false); }
  }, [updateStatistics, onThemeChange, onLocaleChange, fetchUserStatus, onDataOperation]);

    const handleAddTestCoins = useCallback(async () => {
        setIsAddingCoins(true);
        try { const amount = 10; const updatedStatus = await addCoinsToUser(amount); setUserCoins(updatedStatus.coins); Toast.show({ type: 'success', text1: t('accountSettings.coinsAdded'), text2: `${t('accountSettings.coinBalance')}: ${updatedStatus.coins}`, position: 'bottom' }); }
        catch (error) { Toast.show({ type: 'error', text1: t('accountSettings.errorAddCoins'), text2: error instanceof BackendError ? error.message : t('backendService.errorNetworkConnection'), position: 'bottom' }); }
        finally { setIsAddingCoins(false); }
    }, []);

  const handleLanguageChange = (newLanguage: LanguageCode) => {
    setSettings(prev => ({...prev, language: newLanguage}));
    onLocaleChange(newLanguage); 
  };

  const handleNavigateToQuestionnaire = () => {
    navigation.navigate('Questionnaire');
  };

  if (isDataLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text style={styles.loadingText}>{t('app.initializing')}</Text>
      </View>
    );
  }

  return (
    <ScrollView style={styles.container} contentContainerStyle={styles.scrollContentContainer} keyboardShouldPersistTaps="handled">
        <Text h3 style={styles.sectionTitle}>{t('settingsScreen.account.title')}</Text>
        <AccountSettings
             userCoins={userCoins}
             isLoadingCoins={isLoadingCoins}
             isAddingCoins={isAddingCoins}
             onAddTestCoins={handleAddTestCoins}
        />

        <Text h3 style={styles.sectionTitle}>{t('settingsScreen.general.title')}</Text>
        <ThemeSwitch currentTheme={settings.theme} onToggle={onThemeChange} />

        <ListItem bottomDivider containerStyle={{ backgroundColor: theme.colors.background }}>
            <ListItem.Content>
                <ListItem.Title style={styles.listItemTitle}>{t('settingsScreen.language.title')}</ListItem.Title>
            </ListItem.Content>
        </ListItem>
        <View style={Platform.OS === 'ios' ? {} : styles.pickerContainerAndroid}>
             <Picker
                selectedValue={settings.language}
                onValueChange={(itemValue) => handleLanguageChange(itemValue as LanguageCode)}
                style={[styles.pickerStyle, Platform.OS === 'android' ? { color: theme.colors.text, backgroundColor: theme.colors.background } : {}]}
                itemStyle={[styles.pickerItemStyle, Platform.OS === 'ios' ? { color: theme.colors.text } : {}]}
                dropdownIconColor={theme.colors.text}
            >
                <Picker.Item label={t('settingsScreen.language.system')} value="system" />
                <Picker.Item label={t('settingsScreen.language.english')} value="en" />
                <Picker.Item label={t('settingsScreen.language.russian')} value="ru" />
                <Picker.Item label={t('settingsScreen.language.hebrew')} value="he" />
            </Picker>
        </View>

        <View style={styles.sectionHeaderWithButton}>
            <Text h3 style={[styles.sectionTitle, styles.sectionTitleInline]}>{t('settingsScreen.dailyGoals.title')}</Text>
            <Button
                title={t('settingsScreen.goals.estimateButton')}
                type="outline"
                onPress={handleNavigateToQuestionnaire}
                buttonStyle={styles.estimateButton}
                titleStyle={styles.estimateButtonTitle}
                icon={<Icon name="calculator-variant" type="material-community" color={theme.colors.primary} size={18} />}
            />
        </View>
        <View style={styles.inputGroup}>
            <DailyGoalsInput dailyGoals={settings.dailyGoals} onGoalChange={handleGoalChange} />
        </View>

        <Text h3 style={styles.sectionTitle}>{t('settingsScreen.statistics.title')}</Text>
        <View style={styles.chartContainer}>
            <StatisticsChart statistics={statistics} key={`${chartUpdateKey}-${i18n.locale}-${theme.mode}`} />
        </View>

        <Text h3 style={styles.sectionTitle}>{t('settingsScreen.dataManagement.title')}</Text>
        <View style={styles.buttonGroup}>
            <DataManagementButtons onDataOperation={localDataOperationHandler} />
        </View>
    </ScrollView>
  );
};

const useStyles = makeStyles((theme) => ({
  container: { flex: 1, backgroundColor: theme.colors.background, },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: theme.colors.background,
  },
  loadingText: {
    marginTop: 10,
    color: theme.colors.text,
    fontSize: 16,
  },
  scrollContentContainer: { padding: 15, paddingBottom: 40, },
  sectionTitle: {
    color: theme.colors.text, marginTop: 25, marginBottom: 15, paddingLeft: 5,
    borderLeftWidth: 3, borderLeftColor: theme.colors.primary,
    textAlign: I18nManager.isRTL ? 'right' : 'left',
    fontSize: 20, fontWeight: 'bold',
  },
  sectionHeaderWithButton: {
    flexDirection: I18nManager.isRTL ? 'row-reverse' : 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginTop: 25,
    marginBottom: 10, 
  },
  sectionTitleInline: {
    marginTop: 0, 
    marginBottom: 0, 
    borderLeftWidth: 0, 
    paddingLeft: 0,
    flexShrink: 1,
  },
  estimateButton: {
    borderColor: theme.colors.primary,
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 20,
  },
  estimateButtonTitle: {
    color: theme.colors.primary,
    fontSize: 14,
    fontWeight: '600',
    marginLeft: I18nManager.isRTL ? 0 : 5,
    marginRight: I18nManager.isRTL ? 5 : 0,
  },
  listItemTitle: {
    color: theme.colors.text,
    textAlign: I18nManager.isRTL ? 'right' : 'left',
    fontWeight: '500',
  },
  inputGroup: { marginBottom: 10, paddingHorizontal: 5, },
  buttonGroup: { marginBottom: 10, paddingHorizontal: 5, },
  button: { marginBottom: 10, borderRadius: 8, },
  chartContainer: {
    marginBottom: 20,
  },
  pickerContainerAndroid: {
    backgroundColor: theme.colors.background,
    borderRadius: 8,
    borderWidth: 1,
    borderColor: theme.colors.divider,
    marginBottom: 10,
    marginTop: -5,
  },
  pickerStyle: {
    width: '100%',
    height: Platform.OS === 'ios' ? 120 : 50,
  },
  pickerItemStyle: {
    textAlign: I18nManager.isRTL ? 'right' : 'left',
  },
}));

export default SettingsScreen;
---------- END SettingsScreen.tsx ----------


---------- backendService.ts ----------
// src/services/backendService.ts
// ---------- src/services/backendService.ts ----------
import Constants from 'expo-constants';
import { getClientId } from './clientIDService';
import { EstimatedFoodItem, Macros, MacrosWithFoodName } from '../types/macros';
import { Platform } from 'react-native';
import uuid from 'react-native-uuid';
import i18n, { t } from '../localization/i18n'; // Import t and i18n

const getBackendUrl = (): string => {
    const envUrl = process.env.EXPO_PUBLIC_BACKEND_URL_PRODUCTION;
    if (envUrl) {
        console.log("Using Backend URL from EXPO_PUBLIC_BACKEND_URL:", envUrl);
        return envUrl.endsWith('/api/v1') ? envUrl : `${envUrl.replace(/\/$/, '')}/api/v1`;
    }
    const configUrl = Constants.expoConfig?.extra?.env?.BACKEND_URL_PRODUCTION;
    console.log(envUrl, configUrl);
    
    if (configUrl) {
        console.warn("Using Backend URL from app.json extra.env. Consider using build-time environment variables (EXPO_PUBLIC_*) for production.");
        return configUrl.endsWith('/api/v1') ? configUrl : `${configUrl.replace(/\/$/, '')}/api/v1`;
    }
    console.error("BACKEND_URL not found in environment variables or app.json extra.env. Using default DEVELOPMENT URL. THIS IS NOT FOR PRODUCTION.");
    const DEV_URL = 'http://192.168.1.15:8000';
    return `${DEV_URL}/api/v1`;
};

const BASE_URL = getBackendUrl();
console.log(`Backend Service Initialized. Base URL: ${BASE_URL}`);

interface GramsResponse { grams: number; }
// IconResponse removed as icons are handled locally
export interface UserStatus { client_id: string; coins: number; }
interface BackendErrorDetail { loc?: (string | number)[]; msg?: string; type?: string; }
interface BackendErrorResponse { detail?: string | BackendErrorDetail[]; }

export class BackendError extends Error {
    status: number; detail?: string | BackendErrorDetail[]; requestId?: string | null;
    constructor(message: string, status: number, detail?: string | BackendErrorDetail[], requestId?: string | null) {
        super(message); this.name = 'BackendError'; this.status = status; this.detail = detail; this.requestId = requestId;
    }
}

async function fetchBackend<T>( endpoint: string, options: RequestInit = {}, needsAuth: boolean = true ): Promise<T> {
    const cleanEndpoint = endpoint.startsWith('/') ? endpoint : `/${endpoint}`;
    const url = `${BASE_URL}${cleanEndpoint}`;
    const method = options.method || 'GET';
    let response: Response | null = null; let requestId: string | null = null;

    console.log(`[API Request] ${method} ${url} - Starting (Auth: ${needsAuth}, Locale: ${i18n.locale})`);

    const defaultHeaders: HeadersInit = {
        'Content-Type': 'application/json', 'Accept': 'application/json',
        'X-Platform': Platform.OS, 'Accept-Language': i18n.locale,
    };
    let authHeaders: HeadersInit = {};
    if (needsAuth) {
        const clientId = await getClientId();
        if (!uuid.validate(clientId)) {
             console.error(`[API Request] Invalid Client ID format detected: ${clientId}. Aborting request.`);
             throw new BackendError(t('backendService.errorInvalidClientId'), 400, "Invalid client ID format.");
        }
        authHeaders = { 'X-Client-ID': clientId };
        console.log(`[API Request] Adding X-Client-ID header.`);
    }
    const config: RequestInit = { ...options, headers: { ...defaultHeaders, ...authHeaders, ...options.headers, } };

     if (config.body && typeof config.body === 'string') {
          try {
              const bodyObj = JSON.parse(config.body);
              const bodyKeys = Object.keys(bodyObj);
              const bodyPreview = bodyKeys.length > 0 ? `{ keys: [${bodyKeys.join(', ')}] }` : '{}';
              console.log(`[API Request] ${method} ${url} - Body Preview: ${bodyPreview}`);
          } catch {
              console.log(`[API Request] ${method} ${url} - Body: (non-JSON or failed parse)`);
          }
     }

    try {
        response = await fetch(url, config);
        requestId = response.headers.get("X-Request-ID");
        const status = response.status; const contentType = response.headers.get("content-type");

        console.log(`[API Response] ${method} ${url} - Status: ${status}, Content-Type: ${contentType}, RequestID: ${requestId || 'N/A'}`);

        if (status === 204) {
             console.log(`[API Response] ${method} ${url} - Success (204 No Content)`);
             return null as T;
        }

        let responseBody: any; let isJson = false;
        try {
            if (contentType && contentType.includes("application/json")) {
                responseBody = await response.json();
                isJson = true;
            } else {
                responseBody = await response.text();
                console.log(`[API Response] ${method} ${url} - Received Text: ${responseBody.substring(0, 200)}...`);
            }
        } catch (parseError) {
            console.error(`[API Error] ${method} ${url} - Failed to parse response body (Status: ${status}):`, parseError);
            const rawText = await response.text().catch(() => '(Could not get raw text)');
            if (!response.ok) {
                throw new BackendError(t('backendService.errorRequestFailedParse', {status}), status, rawText, requestId);
            } else {
                console.warn(`[API Warning] ${method} ${url} - Status ${status} OK, but failed to parse response body.`);
                 return null as T;
            }
        }

        if (!response.ok) {
            let errorMessage = t('backendService.errorRequestFailedParse', {status}); 
            let errorDetail: string | BackendErrorDetail[] | undefined = undefined;

            if (isJson && responseBody) {
                 const errorData = responseBody as BackendErrorResponse;
                 if (typeof errorData.detail === 'string') {
                    errorMessage = errorData.detail; 
                    errorDetail = errorMessage;
                 } else if (Array.isArray(errorData.detail)) {
                     errorMessage = t('backendService.errorRequestFailedDetailFormat', {status}); 
                     errorDetail = errorData.detail;
                     console.warn(`[API Validation Error] ${method} ${url} - Details:`, JSON.stringify(errorDetail));
                 } else {
                      errorMessage = t('backendService.errorRequestFailedDetailFormat', {status});
                      errorDetail = JSON.stringify(responseBody);
                 }
            } else if (!isJson) {
                 errorMessage = t('backendService.errorRequestFailedWithServerMsg', {status, response: responseBody.substring(0,100)});
                 errorDetail = responseBody;
            }

            if (status === 401 && needsAuth) errorMessage = t('backendService.errorAuthFailed');
            if (status === 403) errorMessage = t('backendService.errorPermissionDenied');
            if (status === 404) errorMessage = t('backendService.errorNotFound');
            if (status === 429) errorMessage = t('backendService.errorTooManyRequests');
            if (status === 402) errorMessage = t('backendService.errorInsufficientCoins');

            console.error(`[API Error] ${method} ${url} - Status: ${status}, Message: "${errorMessage}", Detail:`, errorDetail);
            throw new BackendError(errorMessage, status, errorDetail, requestId);
        }

        console.log(`[API Response] ${method} ${url} - Success (Status: ${status})`);
        return responseBody as T;

    } catch (error) {
        const logRequestId = requestId ? ` (RequestID: ${requestId})` : '';
        if (error instanceof BackendError) throw error;

        console.error(`[API Network Error] ${method} ${url}${logRequestId} - Error:`, error);
        let networkErrorMessage = t('backendService.errorNetwork');
         if (error instanceof Error) {
             if (error.name === 'AbortError' || error.message.includes('timed out')) networkErrorMessage = t('backendService.errorNetworkTimeout');
             else if (error.message.includes('Network request failed')) networkErrorMessage += t('backendService.errorNetworkConnection');
             else networkErrorMessage += t('backendService.errorNetworkDetails', {error: error.message});
         } else networkErrorMessage += t('backendService.errorNetworkUnknown');
        throw new BackendError(networkErrorMessage, 0, networkErrorMessage, requestId);
    }
}

export const getUserStatus = async (): Promise<UserStatus> => {
    const clientId = await getClientId();
    return fetchBackend<UserStatus>(`/users/status/${clientId}`, {}, true);
};

export const getMacrosForRecipe = async (foodName: string, ingredients: string): Promise<Macros> => {
    const body = { food_name: foodName, ingredients };
    return fetchBackend<Macros>('/ai/macros_recipe', { method: 'POST', body: JSON.stringify(body), }, true);
};

export const getMacrosForImageSingle = async (image_base64: string, mime_type: string): Promise<MacrosWithFoodName> => {
    const body = { image_base64, mime_type };
    return fetchBackend<MacrosWithFoodName>('/ai/macros_image_single', { method: 'POST', body: JSON.stringify(body), }, true);
};

export const getMacrosForImageMultiple = async (image_base64: string, mime_type: string): Promise<EstimatedFoodItem[]> => {
    const body = { image_base64, mime_type };
    return fetchBackend<EstimatedFoodItem[]>('/ai/macros_image_multiple', { method: 'POST', body: JSON.stringify(body), }, true);
};

export const estimateGramsNaturalLanguage = async (foodName: string, quantityDescription: string): Promise<number> => {
    const body = { food_name: foodName, quantity_description: quantityDescription };
    const response = await fetchBackend<GramsResponse>('/ai/grams_natural_language', { method: 'POST', body: JSON.stringify(body), }, true);
    if (response === null || typeof response.grams !== 'number') {
        throw new BackendError(t('backendService.errorEstimateGramsUnexpectedResponse'), 500, "Invalid response format");
    }
    return response.grams;
};

// getFoodIcon function removed as icons are now handled locally

export const addCoinsToUser = async (amount: number): Promise<UserStatus> => {
    const clientId = await getClientId();
    const body = { amount };
    if (amount <= 0) throw new BackendError(t('backendService.errorAddCoinsPositive'), 400, "Amount must be positive.");
    return fetchBackend<UserStatus>(`/users/add_coins/${clientId}`, { method: 'POST', body: JSON.stringify(body), }, true);
};
---------- END backendService.ts ----------


---------- clientIDService.ts ----------
// src/services/clientIDService.ts
import AsyncStorage from '@react-native-async-storage/async-storage';
import uuid from 'react-native-uuid';

const CLIENT_ID_KEY = '@MacroTracker:clientId';
let currentClientId: string | null = null; // In-memory cache

export const getClientId = async (): Promise<string> => {
  if (currentClientId) {
    return currentClientId;
  }

  try {
    let clientId = await AsyncStorage.getItem(CLIENT_ID_KEY);
    if (!clientId) {
      clientId = uuid.v4() as string;
      console.log('Generated new client ID:', clientId);
      await AsyncStorage.setItem(CLIENT_ID_KEY, clientId);
    } else {
      console.log('Retrieved existing client ID:', clientId);
    }
    currentClientId = clientId;
    return clientId;
  } catch (error) {
    console.error('Error handling client ID:', error);
    // Fallback or throw error depending on desired behavior
    // For now, generating a temporary one if storage fails
    return uuid.v4() as string;
  }
};

// Optional: Function to clear ID for testing
export const clearClientId = async (): Promise<void> => {
    currentClientId = null;
    try {
        await AsyncStorage.removeItem(CLIENT_ID_KEY);
        console.log('Client ID cleared.');
    } catch (error) {
        console.error('Error clearing client ID:', error);
    }
};
---------- END clientIDService.ts ----------


---------- foodService.ts ----------
// src/services/foodService.ts
// services/foodService.ts
import { Food } from '../types/food';
import { saveFoods, loadFoods } from './storageService';
import 'react-native-get-random-values';
import { v4 as uuidv4 } from 'uuid';

export const createFood = async (foodData: Omit<Food, 'id'>): Promise<Food> => {
  const newFood: Food = {
    id: uuidv4(),
    ...foodData,
  };
  const { items: currentFoods } = await loadFoods(); // Load all foods to append
  currentFoods.push(newFood);
  await saveFoods(currentFoods);
  return newFood;
};

export const getFoods = async (
  offset: number = 0,
  limit?: number,
  searchTerm?: string // New parameter for searching
): Promise<{ items: Food[], total: number }> => {
  // Load all foods first. For a real backend, the backend would handle filtering and pagination.
  const { items: allFoodsFromStorage } = await loadFoods(); // This loads all items

  let filteredFoods = allFoodsFromStorage;

  if (searchTerm && searchTerm.trim() !== "") {
    const lowercasedSearchTerm = searchTerm.toLowerCase().trim();
    filteredFoods = allFoodsFromStorage.filter(food =>
      food.name.toLowerCase().includes(lowercasedSearchTerm)
    );
  }

  // After filtering (if any), then apply pagination
  const totalFiltered = filteredFoods.length;

  if (limit === undefined) {
    return { items: filteredFoods, total: totalFiltered };
  }

  const paginatedFoods = filteredFoods.slice(offset, offset + limit);
  return { items: paginatedFoods, total: totalFiltered };
};

export const updateFood = async (updatedFood: Food): Promise<Food> => {
  const { items: foods } = await loadFoods(); // Load all foods to find and update
  const index = foods.findIndex((f) => f.id === updatedFood.id);
  if (index === -1) {
    throw new Error('Food not found'); // Throw an error if not found
  }
  foods[index] = updatedFood;
  await saveFoods(foods);
  return updatedFood;
};

export const deleteFood = async (foodId: string): Promise<void> => {
  const { items: foods } = await loadFoods(); // Load all to filter
  const filteredFoods = foods.filter((f) => f.id !== foodId);
  await saveFoods(filteredFoods);
};
---------- END foodService.ts ----------


---------- storageService.ts ----------
// src/services/storageService.ts
// services/storageService.ts
import AsyncStorage from '@react-native-async-storage/async-storage';
import { DailyEntry } from '../types/dailyEntry';
import { Food } from '../types/food';
import { Settings, LanguageCode } from '../types/settings'; // Import LanguageCode
import { formatISO, parseISO } from 'date-fns';


const DAILY_ENTRIES_KEY = 'dailyEntries';
const FOODS_KEY = 'foods';
const SETTINGS_KEY = 'settings';
const RECENT_FOODS_KEY = 'recentFoods';
const LAST_USED_PORTIONS_KEY = 'lastUsedPortions'; // New key

export type LastUsedPortions = { [foodId: string]: number }; // Type for last used portions

export const saveDailyEntries = async (entries: DailyEntry[]): Promise<void> => {
  try {
    await AsyncStorage.setItem(DAILY_ENTRIES_KEY, JSON.stringify(entries));
  } catch (error) {
    console.error('Error saving daily entries:', error);
    throw error;
  }
};

export const loadDailyEntries = async (): Promise<DailyEntry[]> => {
  try {
    const entriesJson = await AsyncStorage.getItem(DAILY_ENTRIES_KEY);
    return entriesJson ? JSON.parse(entriesJson) : [];
  } catch (error) {
    console.error('Error loading daily entries:', error);
    return [];
  }
};

export const saveFoods = async (foods: Food[]): Promise<void> => {
  try {
    await AsyncStorage.setItem(FOODS_KEY, JSON.stringify(foods));
  } catch (error) {
    console.error('Error saving foods:', error);
    throw error; // Re-throw the error
  }
};

export const loadFoods = async (offset: number = 0, limit?: number): Promise<{ items: Food[], total: number }> => {
  try {
    const foodsJson = await AsyncStorage.getItem(FOODS_KEY);
    const allFoods: Food[] = foodsJson ? JSON.parse(foodsJson) : [];
    const total = allFoods.length;

    if (limit === undefined) {
      return { items: allFoods, total };
    }
    
    const paginatedFoods = allFoods.slice(offset, offset + limit);
    return { items: paginatedFoods, total };
  } catch (error) {
    console.error('Error loading foods:', error);
    return { items: [], total: 0 }; // Return an empty array and 0 total on error
  }
};



export const saveSettings = async (settings: Settings): Promise<void> => {
  try {
    await AsyncStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
  } catch (error) {
    console.error('Error saving settings:', error);
    throw error;
  }
};

export const loadSettings = async (): Promise<Settings> => {
  try {
    const settingsJson = await AsyncStorage.getItem(SETTINGS_KEY);
    const loadedSettings = settingsJson ? JSON.parse(settingsJson) : {};

    // Apply defaults and ensure structure
    const defaultSettings: Settings = {
      theme: 'system',
      language: 'system', // Default language
      dailyGoals: { calories: 2000, protein: 50, carbs: 200, fat: 70 },
      settingsHistory: [] // Ensure settingsHistory exists
    };


    return {
      ...defaultSettings, // Start with defaults
        ...loadedSettings, // Override with loaded values
        dailyGoals: {
          ...defaultSettings.dailyGoals,  //ensure no fields missing from daily goals
            ...(loadedSettings.dailyGoals || {}) // And override *those* with any loaded dailyGoals
        }
    };

  } catch (error: any) {
    console.error('Error loading settings:', error);

    if (error.message.includes('Row too big')) {
      console.warn('Detected oversized settings data. Clearing settings.');
      try {
        await AsyncStorage.removeItem(SETTINGS_KEY);
      } catch (clearError) {
        console.error('Error clearing oversized settings:', clearError);
      }
    }

    return {
      theme: 'system',
      language: 'system', // Default language on error
      dailyGoals: { calories: 2000, protein: 50, carbs: 200, fat: 70 },
      settingsHistory: []
    };
  }
};

export const clearAllData = async (): Promise<void> => {
  try {
    // Keep clientID, clear everything else
    const clientIdKey = '@MacroTracker:clientId';
    const clientId = await AsyncStorage.getItem(clientIdKey);
    
    await AsyncStorage.clear();
    
    if (clientId) {
        await AsyncStorage.setItem(clientIdKey, clientId);
    }
    console.log('Application data cleared (excluding Client ID).');
  } catch (error) {
    console.error('Error clearing data:', error);
    throw error;
  }
};

export const saveRecentFoods = async (foods: Food[]) => {
    try {
        await AsyncStorage.setItem(RECENT_FOODS_KEY, JSON.stringify(foods));
    } catch (error) {
        console.error('Error saving recent foods:', error);
        throw error;
    }
};

export const loadRecentFoods = async (): Promise<Food[]> => {
    try {
        const foodsJson = await AsyncStorage.getItem(RECENT_FOODS_KEY);
        return foodsJson ? JSON.parse(foodsJson) : [];
    } catch (error) {
        console.error('Error loading recent foods:', error);
        return [];
    }
};

export const saveLastUsedPortions = async (portions: LastUsedPortions): Promise<void> => {
    try {
        await AsyncStorage.setItem(LAST_USED_PORTIONS_KEY, JSON.stringify(portions));
    } catch (error) {
        console.error('Error saving last used portions:', error);
        throw error;
    }
};

export const loadLastUsedPortions = async (): Promise<LastUsedPortions> => {
    try {
        const portionsJson = await AsyncStorage.getItem(LAST_USED_PORTIONS_KEY);
        return portionsJson ? JSON.parse(portionsJson) : {};
    } catch (error) {
        console.error('Error loading last used portions:', error);
        return {};
    }
};
---------- END storageService.ts ----------


---------- dailyEntry.ts ----------
// types/dailyEntry.ts (Modified)
import { Food } from "./food";

export interface DailyEntryItem {
  food: Food;
  grams: number;
}

export interface DailyEntry {
  date: string; // YYYY-MM-DD format
  items: DailyEntryItem[];
  goals?: {  // Optional goals
    calories?: number;
    protein?: number;
    carbs?: number;
    fat?: number;
  };
}

export interface FoodItem { //No changes here.
    id: string;
    name: string;
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
  }
---------- END dailyEntry.ts ----------


---------- food.ts ----------
// types/food.ts
export interface Food {
  id: string;
  name: string;
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
}

// Data structure for sharing food items. ID is omitted.
export type SharedFoodData = Omit<Food, 'id'>;
---------- END food.ts ----------


---------- macros.ts ----------
// src/types/macros.ts

// Basic macro structure
export interface Macros {
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
  }
  
  // Macros structure including the identified food name
  export interface MacrosWithFoodName extends Macros {
    foodName: string;
  }
  
  /**
   * Represents a single food item estimated from an image,
   * including its name, estimated weight, and macros per 100g.
   * Matches the structure expected/returned by the backend service.
   */
  export interface EstimatedFoodItem {
    foodName: string;
    estimatedWeightGrams: number;
    calories_per_100g: number;
    protein_per_100g: number;
    carbs_per_100g: number;
    fat_per_100g: number;
  }
---------- END macros.ts ----------


---------- openRouterTypes.ts ----------
// src/utils/types.ts

// =====================================
// Consolidated OpenRouter Type Definitions
// =====================================

// --- Content Parts (for multi-modal input like images) ---
export type OpenRouterContentPart =
  | { type: "text"; text: string }
  | { type: "image_url"; image_url: { url: string; detail?: "low" | "high" | "auto" } };

// --- Message Structure ---
// Allows content to be a simple string OR an array of content parts for vision models
export interface OpenRouterMessage {
  role: "user" | "assistant" | "system";
  content: string | OpenRouterContentPart[]; // Consolidated definition
  name?: string; // Optional name field
}

// --- Choice Structure (within the response) ---
// This structure aligns with standard Chat Completion APIs (like OpenAI/OpenRouter)
export interface OpenRouterChatChoice {
  index: number;
  message: OpenRouterMessage; // Contains the actual message content and role
  logprobs?: any | null; // Optional log probabilities (use a specific type if known)
  finish_reason: string | null; // Can be null sometimes
  // text?: string; // Usually the content is inside message.content, keep optional if some models return it differently
}

// --- API Usage Information ---
export interface OpenRouterUsage {
  prompt_tokens: number;
  completion_tokens: number;
  total_tokens: number;
}

// --- Main Chat Completion Response Structure ---
// Consolidates the fields from both previous declarations
export interface OpenRouterChatCompletionResponse {
  id: string;
  object: string; // Typically "chat.completion"
  created: number; // Timestamp
  model: string; // Model used
  choices: OpenRouterChatChoice[]; // Array of choices using the defined structure
  usage?: OpenRouterUsage; // Usage information is often optional
  // Add any other relevant fields you might encounter from OpenRouter
  // system_fingerprint?: string; // Example optional field
}


// =====================================
// Removed Redundant/Conflicting Declarations:
// =====================================

/*
// REMOVED - Duplicate/Outdated OpenRouterMessage
export interface OpenRouterMessage {
  role: "user" | "assistant" | "system"; // Add system role
  content: string;
}

// REMOVED - Less standard choice structure (often message.content is used instead of top-level text)
export interface OpenRouterChoice {
  text: any; // 'any' is vague, content is usually in message
  message: OpenRouterMessage; // This duplicates content info if 'text' is also present
  finish_reason?: string;
  index?: number;
}

// REMOVED - Duplicate/Simpler OpenRouterChatCompletionResponse
export interface OpenRouterChatCompletionResponse {
  choices: OpenRouterChoice[]; // Used the less standard choice type
  id?: string;
  created?: number;
  model?: string;
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
}
*/
---------- END openRouterTypes.ts ----------


---------- questionnaire.ts ----------
// src/types/questionnaire.ts
export enum Sex {
    MALE = 'male',
    FEMALE = 'female',
  }
  
  export enum ActivityLevel {
    SEDENTARY = 'sedentary',
    LIGHT = 'light',
    MODERATE = 'moderate',
    ACTIVE = 'active',
    VERY_ACTIVE = 'very_active',
  }
  
  export enum PrimaryGoal {
    LOSE_WEIGHT = 'lose_weight',
    MAINTAIN_WEIGHT = 'maintain_weight',
    GAIN_MUSCLE = 'gain_muscle',
  }
  
  export enum GoalIntensity {
    MILD = 'mild',
    MODERATE = 'moderate',
    AGGRESSIVE = 'aggressive',
  }
  
  export interface QuestionnaireFormData {
    age: string;
    sex: Sex | ''; // Allow empty initial state for Picker
    height: string; // cm
    weight: string; // kg
    activityLevel: ActivityLevel | ''; // Allow empty initial state
    primaryGoal: PrimaryGoal | ''; // Allow empty initial state
    goalIntensity?: GoalIntensity;
  }
  
  export interface CalculatedGoals {
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
  }
---------- END questionnaire.ts ----------


---------- settings.ts ----------
// src/types/settings.ts
// types/settings.ts
export const macros = ["calories", "protein", "carbs", "fat"] as const;
export type MacroType = (typeof macros)[number];

export type LanguageCode = 'en' | 'ru' | 'he' | 'system';

export interface MacroData {
  x: number; // Timestamp
  y: number; // Macro value
}

export interface Statistics {
  calories: MacroData[][];
  protein: MacroData[][];
  carbs: MacroData[][];
  fat: MacroData[][];
}

export interface Settings {
  theme: "light" | "dark" | "system";
  language: LanguageCode;
  dailyGoals: {
    [key in MacroType]: number;
  };
  settingsHistory?: { date: number; dailyGoals: { [key in MacroType]: number } }[];
}

export interface SettingsScreenProps {
  onThemeChange: (theme: "light" | "dark" | "system") => void;
  onLocaleChange: (locale: LanguageCode) => void; // Added for language change
}
---------- END settings.ts ----------


---------- dateUtils.ts ----------
// src/utils/dateUtils.ts
// utils/dateUtils.ts
import { format, parseISO, formatISO, isValid } from 'date-fns';
import { getDateFnLocale } from '../localization/i18n'; // Import for locale

/**
 * Formats a Date object, timestamp (number), or ISO date string (YYYY-MM-DD)
 * into a standard YYYY-MM-DD string representation.
 * Returns an empty string if the input is invalid.
 * @param dateInput - The date to format (Date object, timestamp number, or 'YYYY-MM-DD' string).
 * @returns The formatted date string 'YYYY-MM-DD' or empty string on error.
 */
export const formatDateISO = (dateInput: number | string | Date): string => {
    try {
        let dateObj: Date;
        if (dateInput instanceof Date) dateObj = dateInput;
        else if (typeof dateInput === 'string') dateObj = parseISO(dateInput);
        else if (typeof dateInput === 'number') dateObj = new Date(dateInput);
        else throw new Error("Invalid input type");

        if (!isValid(dateObj)) throw new Error("Invalid date value");
        return formatISO(dateObj, { representation: 'date' });
    } catch (error) {
        console.error("Error in formatDateISO:", error, "Input:", dateInput);
        return "";
    }
};

/**
 * Asynchronously formats a Date object, timestamp (number), or ISO date string (YYYY-MM-DD)
 * into a human-readable format (e.g., "MMMM dd, yyyy") using the current app locale.
 * Returns 'Invalid Date' if the input is invalid.
 * @param dateInput - The date to format (Date object, timestamp number, or 'YYYY-MM-DD' string).
 * @returns The formatted readable date string or 'Invalid Date' on error.
 */
export const formatDateReadableAsync = async (dateInput: number | string | Date): Promise<string> => {
    try {
        let dateObj: Date;
        if (dateInput instanceof Date) dateObj = dateInput;
        else if (typeof dateInput === 'string') dateObj = parseISO(dateInput);
        else if (typeof dateInput === 'number') dateObj = new Date(dateInput);
        else throw new Error("Invalid input type");

        if (!isValid(dateObj)) throw new Error("Invalid date value");

        const locale = await getDateFnLocale(); // Get date-fns locale
        return format(dateObj, 'MMMM dd, yyyy', { locale });
    } catch (error) {
         console.error("Error in formatDateReadableAsync:", error, "Input:", dateInput);
         return 'Invalid Date'; // Fallback for display
    }
};

/**
 * Gets today's date as a standard YYYY-MM-DD string.
 * @returns Today's date in 'YYYY-MM-DD' format.
 */
export const getTodayDateString = (): string => {
  return formatISO(new Date(), { representation: 'date' });
};
---------- END dateUtils.ts ----------


---------- foodIconMatcher.ts ----------
// src/utils/foodIconMatcher.ts
import { foodIconDefinitions } from '../assets/food_icons/iconDefinitions';
import i18n, { t, TranslationKey } from '../localization/i18n';
import { LanguageCode } from '../types/settings';

const normalizeFoodNameForMatching = (name: string): string => {
    return name.toLowerCase()
        .replace(/[()",.&'/#!$%^*;:{}=_`~?]/g, '')
        .trim();
};

const getNormalizedWords = (name: string): string[] => {
    const normalizedName = normalizeFoodNameForMatching(name);
    const commonFilterWords = ['and', 'with', 'of', 'a', 'the', 'in', 'on', 'for', 'g', 'ml', 'Ð³Ñ€', 'Ð¼Ð»'];
    return normalizedName
        .split(/\s+/)
        .filter(word => word.length > 1 && !commonFilterWords.includes(word.toLowerCase()));
};

/**
 * Finds the best matching icon for a given food name based on localized tags.
 * @param foodName The name of the food.
 * @param foodNameLocale The detected language of the foodName string (e.g., 'en', 'ru', 'he').
 * @returns An emoji string for the icon, or null if no good match is found.
 */
export const findBestIcon = (foodName: string, foodNameLocale: LanguageCode): string | null => {
    if (!foodName || foodName.trim() === '') {
        return null;
    }

    const normalizedFoodNameQuery = normalizeFoodNameForMatching(foodName);
    const foodNameWords = getNormalizedWords(foodName);

    // console.log(`[findBestIcon START] Food: "${foodName}", NormQuery: "${normalizedFoodNameQuery}", Words: [${foodNameWords.join(', ')}], FoodNameLocale: ${foodNameLocale}`);

    let bestMatch: { icon: string; score: number; priority: number } | null = null;

    for (const definition of foodIconDefinitions) {
        let currentScore = 0;
        let matchFoundInDefinition = false;
        const fullTagKey = `foodIconTags.${definition.tagKey}` as TranslationKey;
        let localizedTags: string[] = [];
        let effectiveTagLocale: LanguageCode = foodNameLocale; // The locale from which tags were actually sourced

        try {
            const tagsForDetectedLocale = i18n.t(fullTagKey, { locale: foodNameLocale, returnObjects: true, defaultValue: null });

            if (Array.isArray(tagsForDetectedLocale) && tagsForDetectedLocale.length > 0) {
                localizedTags = tagsForDetectedLocale;
            } else {
                if (foodNameLocale !== 'en' && definition.tagKey !== 'unknownFood' && definition.tagKey !== 'genericMeal') {
                    const tagsForEnglishFallback = i18n.t(fullTagKey, { locale: 'en', returnObjects: true, defaultValue: [] });
                    if (Array.isArray(tagsForEnglishFallback) && tagsForEnglishFallback.length > 0) {
                        localizedTags = tagsForEnglishFallback;
                        effectiveTagLocale = 'en'; // Mark that we used English fallback tags
                    }
                }
            }
        } catch (e) {
            console.error(`[findBestIcon] ERROR fetching/processing translation for key: ${fullTagKey} in foodNameLocale: ${foodNameLocale}. FoodName: "${foodName}"`, e);
            localizedTags = [];
        }

        if (localizedTags.length === 0 && definition.tagKey !== 'unknownFood' && definition.tagKey !== 'genericMeal') {
            continue;
        }
        
        // if (definition.tagKey === 'redMeat' && normalizedFoodNameQuery.includes(normalizeFoodNameForMatching('×¡×˜×™×™×§'))) {
        //      console.log(`[findBestIcon DEBUG STEEK] Checking 'redMeat' for "${foodName}". Tags sourced from locale '${effectiveTagLocale}': [${localizedTags.join(', ')}]. Query: "${normalizedFoodNameQuery}"`);
        // }

        for (const localizedTag of localizedTags) {
            const lowerLocalizedTag = localizedTag.toLowerCase().trim();
            if (!lowerLocalizedTag) continue;

            if (lowerLocalizedTag === normalizedFoodNameQuery) {
                currentScore = Math.max(currentScore, 100);
                matchFoundInDefinition = true;
                break;
            }

            if (normalizedFoodNameQuery.includes(lowerLocalizedTag)) {
                currentScore = Math.max(currentScore, 70 + lowerLocalizedTag.length);
                matchFoundInDefinition = true;
            }
            
            if (foodNameWords.some(foodWord => foodWord.length > 1 && lowerLocalizedTag.includes(foodWord))) {
                currentScore = Math.max(currentScore, 60);
                matchFoundInDefinition = true;
            }
        }
        
        if (!matchFoundInDefinition && localizedTags.length > 0) {
            for (const localizedTag of localizedTags) {
                const tagWords = localizedTag.toLowerCase().trim().split(/\s+/).filter(tw => tw.length > 1);
                if (tagWords.some(tw => normalizedFoodNameQuery.includes(tw))) {
                    currentScore = Math.max(currentScore, 50);
                    matchFoundInDefinition = true;
                    break;
                }
            }
        }

        if (matchFoundInDefinition) {
            const priority = definition.priority || 0;
            if (!bestMatch || currentScore > bestMatch.score || (currentScore === bestMatch.score && priority > bestMatch.priority)) {
                bestMatch = { icon: definition.icon, score: currentScore, priority };
            }
        }
    }

    if (bestMatch && bestMatch.score > 0) {
        // console.log(`[findBestIcon SUCCESS] For "${foodName}" (FoodNameLocale: ${foodNameLocale}): ${bestMatch.icon} (Score: ${bestMatch.score}, Prio: ${bestMatch.priority})`);
        return bestMatch.icon;
    }

    const genericMealDefinition = foodIconDefinitions.find(def => def.tagKey === 'genericMeal');
    if (genericMealDefinition) {
        const genericMealKey = `foodIconTags.${genericMealDefinition.tagKey}` as TranslationKey;
        // Use foodNameLocale for generic meal tags as well.
        const genericMealTagsResult = i18n.t(genericMealKey, { locale: foodNameLocale, returnObjects: true, defaultValue: [] });
        if (Array.isArray(genericMealTagsResult) && genericMealTagsResult.some(tag => normalizedFoodNameQuery.includes(tag.toLowerCase().trim()))) {
            return genericMealDefinition.icon;
        }
    }
    
    const unknownFoodDefinition = foodIconDefinitions.find(def => def.tagKey === 'unknownFood');
    // console.log(`[findBestIcon NO MATCH] For "${foodName}" (FoodNameLocale: ${foodNameLocale}). Returning unknown icon: ${unknownFoodDefinition ? unknownFoodDefinition.icon : 'ERROR_NO_UNKNOWN_ICON_DEF'}`);
    return unknownFoodDefinition ? unknownFoodDefinition.icon : null;
};
---------- END foodIconMatcher.ts ----------


---------- gradingUtils.ts ----------
// src/utils/gradingUtils.ts
import { Food } from '../types/food';
import { Settings } from '../types/settings';

export type GradeLetter = 'A' | 'B' | 'C' | 'D' | 'F';

export interface FoodGradeResult {
    letter: GradeLetter;
    color: string;
    score: number; // Underlying score for potential adjustments
}

export const gradeColors: Record<GradeLetter, string> = {
    A: '#4CAF50', // Green
    B: '#8BC34A', // Light Green
    C: '#FFC107', // Amber/Yellow
    D: '#FF9800', // Orange
    F: '#F44336', // Red
};

const mapScoreToGradeDetails = (score: number): FoodGradeResult => {
    let letter: GradeLetter;
    const clampedScore = Math.max(0, Math.min(100, Math.round(score))); // Ensure score is 0-100

    if (clampedScore >= 85) letter = 'A';
    else if (clampedScore >= 70) letter = 'B';
    else if (clampedScore >= 55) letter = 'C';
    else if (clampedScore >= 40) letter = 'D';
    else letter = 'F';
    return { letter, color: gradeColors[letter], score: clampedScore };
};

/**
 * Calculates a base grade for a food item (per 100g) based on refined heuristics.
 * @param food The food item (calories, protein, carbs, fat per 100g).
 * @returns FoodGradeResult or null if grading is not possible.
 */
export const calculateBaseFoodGrade = (food: Food): FoodGradeResult | null => {
    if (!food || typeof food.calories !== 'number' || typeof food.protein !== 'number' || typeof food.carbs !== 'number' || typeof food.fat !== 'number') {
        return null;
    }

    const { calories, protein, carbs, fat } = food;
    let score = 70; // Start with a baseline score (e.g., C grade)

    // --- 1. Calorie Density (per 100g) ---
    if (calories < 100) score += 15; // Low density
    else if (calories < 200) score += 7;
    else if (calories > 350) score -= (calories - 350) * 0.08; // Penalize high density
    if (calories > 500) score -= 15; // Further penalty for very high density

    // --- 2. Protein Content (per 100g) ---
    if (protein > 20) score += 20; // Excellent protein
    else if (protein > 10) score += 10; // Good protein
    else if (protein < 5 && calories > 150) score -= 10; // Low protein for moderate/high cal food

    // --- 3. Fat Content & Type (Heuristic for "quality" based on balance) ---
    const caloriesFromFat = fat * 9;
    const percentageCaloriesFromFat = (calories > 0) ? (caloriesFromFat / calories) * 100 : 0;

    if (fat > 25) { // High total fat
        score -= (fat - 25) * 0.5;
        if (protein < fat * 0.5 && protein < 10) { // High fat, low protein suggests less ideal source
            score -= 10;
        }
    } else if (fat < 5 && percentageCaloriesFromFat < 20 && protein > 10) { // Low fat, potentially good if protein is present
        score += 5;
    }
    if (percentageCaloriesFromFat > 50) score -= 15; // More than 50% cals from fat is heavily penalized
    if (percentageCaloriesFromFat > 35 && percentageCaloriesFromFat <= 50) score -= 7;


    // --- 4. Carbohydrate Content & Type (Heuristic) ---
    const caloriesFromCarbs = carbs * 4;
    const percentageCaloriesFromCarbs = (calories > 0) ? (caloriesFromCarbs / calories) * 100 : 0;

    if (carbs > 40) { // High total carbs
        score -= (carbs - 40) * 0.3;
        if (protein < carbs * 0.1 && protein < 7) { // High carb, very low protein suggests refined carbs
            score -= 10;
        }
    }
    if (percentageCaloriesFromCarbs > 60) score -= 15; // More than 60% cals from carbs
    if (percentageCaloriesFromCarbs > 50 && percentageCaloriesFromCarbs <= 60) score -=7;

    // --- 5. Macronutrient Balance (Percentage of Calories) ---
    const caloriesFromProtein = protein * 4;
    const percentageCaloriesFromProtein = (calories > 0) ? (caloriesFromProtein / calories) * 100 : 0;

    // Ideal ranges (approx): Protein 20-30%, Fat 20-30%, Carbs 40-50%
    // Bonus for being within a generally healthy profile
    let balanceBonus = 0;
    if (percentageCaloriesFromProtein >= 15 && percentageCaloriesFromProtein <= 35) balanceBonus += 4;
    if (percentageCaloriesFromFat >= 15 && percentageCaloriesFromFat <= 35) balanceBonus += 4;
    if (percentageCaloriesFromCarbs >= 35 && percentageCaloriesFromCarbs <= 55) balanceBonus += 4;
    if (balanceBonus >=10) score += 10; // Max 10 points for good balance
    else if (balanceBonus >=8) score +=5;

    // Penalty for extreme imbalance if not already heavily penalized
    if (protein < 5 && fat > 20 && carbs > 30 && calories > 200) { // Low protein, high fat & carbs
        score -= 15;
    }

    return mapScoreToGradeDetails(score);
};

/**
 * Calculates a grade for a specific daily entry, considering portion size and daily goals.
 * @param food The food item.
 * @param consumedGrams The amount of the food consumed in grams.
 * @param dailyGoals The user's daily macronutrient goals.
 * @returns FoodGradeResult or null if grading is not possible.
 */
export const calculateDailyEntryGrade = (
    food: Food,
    consumedGrams: number,
    dailyGoals: Settings['dailyGoals']
): FoodGradeResult | null => {
    const baseGradeResult = calculateBaseFoodGrade(food);
    if (!baseGradeResult) return null;
    if (consumedGrams <= 0) return baseGradeResult;

    let currentScore = baseGradeResult.score;

    // Ensure dailyGoals are valid numbers, default to avoid division by zero or nonsensical percentages
    const safeGoals = {
        calories: Math.max(1, dailyGoals.calories || 2000), // Minimum 1 to avoid /0
        protein: Math.max(1, dailyGoals.protein || 100),
        carbs: Math.max(1, dailyGoals.carbs || 200),
        fat: Math.max(1, dailyGoals.fat || 70),
    };

    const factor = consumedGrams / 100;
    const consumedCalories = food.calories * factor;
    const consumedProtein = food.protein * factor;
    const consumedCarbs = food.carbs * factor;
    const consumedFat = food.fat * factor;

    // --- Adjustments based on portion size relative to daily goals ---

    // Penalty for consuming a large percentage of daily calorie allowance in one go
    const caloriePortionPercentage = (consumedCalories / safeGoals.calories) * 100;
    if (caloriePortionPercentage > 50) currentScore -= 20; // >50% of daily cals in one item
    else if (caloriePortionPercentage > 35) currentScore -= 10; // >35%

    // Penalty for consuming a large percentage of daily fat allowance
    const fatPortionPercentage = (consumedFat / safeGoals.fat) * 100;
    if (fatPortionPercentage > 60) currentScore -= 15; // >60% of daily fat
    else if (fatPortionPercentage > 40) currentScore -= 7;

    // Penalty for consuming a large percentage of daily carb allowance
    const carbPortionPercentage = (consumedCarbs / safeGoals.carbs) * 100;
    if (carbPortionPercentage > 60) currentScore -= 10; // >60% of daily carbs
    else if (carbPortionPercentage > 45) currentScore -= 5;

    // Bonus for significant protein contribution if calories are reasonable
    const proteinPortionPercentage = (consumedProtein / safeGoals.protein) * 100;
    if (proteinPortionPercentage > 25 && caloriePortionPercentage < 30) {
        currentScore += 10; // Good protein hit without too many cals
    } else if (proteinPortionPercentage > 15 && caloriePortionPercentage < 20) {
        currentScore += 5;
    }

    // Mitigation for small portions of "F" grade foods
    if (baseGradeResult.letter === 'F' && caloriePortionPercentage < 10) {
        currentScore += 15; // Small "treat" is less impactful
    } else if (baseGradeResult.letter === 'D' && caloriePortionPercentage < 7) {
        currentScore += 7;
    }

    // Slight penalty if a large portion of an "A" grade food makes macros significantly off for the day
    if (baseGradeResult.letter === 'A' &&
        (caloriePortionPercentage > 30 || fatPortionPercentage > 30 || carbPortionPercentage > 30) &&
        consumedGrams > 200 // and it's a large portion
    ) {
        currentScore -= 7;
    }

    return mapScoreToGradeDetails(currentScore);
};
---------- END gradingUtils.ts ----------


---------- iconUtils.ts ----------
// src/utils/iconUtils.ts
import { findBestIcon } from './foodIconMatcher';
import { detectLanguageFromText } from './languageUtils'; // Import new utility
import { LanguageCode } from '../types/settings';

const syncMemoryCache = new Map<string, string | null>();
const MAX_CACHE_SIZE = 300;

/**
 * Synchronously gets the icon identifier (e.g., emoji) for a food item.
 * It first detects the language of the food name, then uses an in-memory cache.
 * Relies on `findBestIcon` which uses localized tags based on the detected language.
 *
 * @param foodName The name of the food item.
 * @returns An icon string (emoji) or null if not found or an error occurred.
 */
export const getFoodIconUrl = (foodName: string): string | null => {
  if (!foodName || foodName.trim() === '') {
    return null;
  }

  const detectedLocale = detectLanguageFromText(foodName);
  const normalizedNameForCache = foodName.toLowerCase().trim();
  const cacheKey = `${detectedLocale}_${normalizedNameForCache}`;

  if (syncMemoryCache.has(cacheKey)) {
    const cachedIcon = syncMemoryCache.get(cacheKey)!;
    // console.log(`[getFoodIconUrl] CACHE HIT for key "${cacheKey}". Food: "${foodName}", Detected Locale: ${detectedLocale}, Icon: ${cachedIcon}`);
    return cachedIcon;
  }
  // console.log(`[getFoodIconUrl] CACHE MISS for key "${cacheKey}". Food: "${foodName}", Detected Locale: ${detectedLocale}. Calling findBestIcon.`);

  const iconIdentifier = findBestIcon(foodName, detectedLocale);

  if (syncMemoryCache.size >= MAX_CACHE_SIZE) {
    const keys = Array.from(syncMemoryCache.keys());
    for (let i = 0; i < Math.floor(MAX_CACHE_SIZE / 4); i++) {
        const randomIndex = Math.floor(Math.random() * keys.length);
        const keyToRemove = keys.splice(randomIndex, 1)[0];
        if(keyToRemove) syncMemoryCache.delete(keyToRemove);
    }
    // console.log(`[getFoodIconUrl] Food icon memory cache partially cleared. New size: ${syncMemoryCache.size}`);
  }
  syncMemoryCache.set(cacheKey, iconIdentifier);
  // console.log(`[getFoodIconUrl] Cached new icon for key "${cacheKey}". Food: "${foodName}", Icon: ${iconIdentifier}`);

  return iconIdentifier;
};

export const clearLocalIconCache = (): void => {
  syncMemoryCache.clear();
  console.log("[clearLocalIconCache] In-memory food icon cache CLEARED.");
};

export const logLocalIconCacheSize = (): void => {
  console.log(`[logLocalIconCacheSize] In-memory food icon cache size: ${syncMemoryCache.size}`);
};
---------- END iconUtils.ts ----------


---------- imageUtils.ts ----------
// src/utils/imageUtils.ts
import * as ImageManipulator from 'expo-image-manipulator';
import { ImagePickerAsset } from 'expo-image-picker';
import { Alert } from 'react-native';
import * as FileSystem from 'expo-file-system';
import { t } from '../localization/i18n'; // Import t

const MAX_IMAGE_DIMENSION = 1024;
const IMAGE_COMPRESSION_QUALITY = 0.7;

export const compressImageIfNeeded = async (
    asset: ImagePickerAsset
): Promise<ImageManipulator.ImageResult | null> => {
    try {
        const actions: ImageManipulator.Action[] = [];
        let needsResize = false;
        if (asset.width > MAX_IMAGE_DIMENSION || asset.height > MAX_IMAGE_DIMENSION) {
            needsResize = true;
            const resizeOptions: ImageManipulator.ActionResize['resize'] = { width: undefined, height: undefined, };
            if (asset.width > asset.height) resizeOptions.width = MAX_IMAGE_DIMENSION;
            else resizeOptions.height = MAX_IMAGE_DIMENSION;
            actions.push({ resize: resizeOptions });
        } else {
            return null;
        }
        if (needsResize) {
            const saveOptions: ImageManipulator.SaveOptions = {
                compress: IMAGE_COMPRESSION_QUALITY, format: ImageManipulator.SaveFormat.JPEG, base64: false,
            };
            const result = await ImageManipulator.manipulateAsync(asset.uri, actions, saveOptions);
            return result;
        } else {
            return null;
        }
    } catch (error) {
        Alert.alert(t('utils.image.alertCompressionError'), t('utils.image.alertCompressionErrorMessage'));
        return null;
    }
};

export async function getBase64FromUri(uri: string): Promise<string> {
    try {
        const base64 = await FileSystem.readAsStringAsync(uri, { encoding: FileSystem.EncodingType.Base64, });
        return base64;
    } catch (error: any) {
        throw new Error(t('utils.image.errorFailedToRead', { error: error.message || 'Unknown error' }));
    }
}
---------- END imageUtils.ts ----------


---------- languageUtils.ts ----------
// src/utils/languageUtils.ts
import { LanguageCode } from '../types/settings';

// Basic script detection character ranges
const HEBREW_REGEX = /[\u0590-\u05FF]/;
const CYRILLIC_REGEX = /[\u0400-\u04FF]/;
// Basic Latin check - very broad, English will be the default for this
const LATIN_REGEX = /[a-zA-Z]/;

/**
 * Detects the dominant language script in a given text.
 * Prioritizes Hebrew, then Cyrillic. If neither is dominant,
 * defaults to 'en' (representing Latin script languages for icon tag purposes).
 * @param text The text to analyze.
 * @returns LanguageCode ('he', 'ru', or 'en' as default).
 */
export const detectLanguageFromText = (text: string): LanguageCode => {
    if (!text || text.trim() === '') {
        return 'en'; // Default if no text
    }

    let hebrewChars = 0;
    let cyrillicChars = 0;
    let latinChars = 0;
    let otherChars = 0;

    for (const char of text) {
        if (HEBREW_REGEX.test(char)) {
            hebrewChars++;
        } else if (CYRILLIC_REGEX.test(char)) {
            cyrillicChars++;
        } else if (LATIN_REGEX.test(char)) {
            latinChars++;
        } else {
            otherChars++;
        }
    }

    // Simple dominance check
    // Give a higher weight or lower threshold for Hebrew/Cyrillic if names are often short
    if (hebrewChars > latinChars / 2 && hebrewChars > cyrillicChars) { // If Hebrew chars are significant
        return 'he';
    }
    if (cyrillicChars > latinChars / 2 && cyrillicChars > hebrewChars) { // If Cyrillic chars are significant
        return 'ru';
    }
    
    // If primarily Latin, or mixed with no clear non-Latin dominance, default to 'en'
    // This 'en' will then correctly use English tags.
    // If the text was, e.g., French and we default to 'en', English tags are a reasonable fallback.
    return 'en';
};
---------- END languageUtils.ts ----------


---------- macros.ts ----------
// src/utils/macros.ts
// src/utils/macros.ts
import * as FileSystem from 'expo-file-system';
import {
    getMacrosForRecipe,
    getMacrosForImageSingle,
    getMacrosForImageMultiple,
    BackendError
} from '../services/backendService';
import { Alert } from 'react-native';
import { Macros, MacrosWithFoodName, EstimatedFoodItem } from '../types/macros';
import { ImagePickerAsset } from 'expo-image-picker';
import { getBase64FromUri } from './imageUtils'; // Corrected import path check
import { t } from '../localization/i18n';

// --- Helper function to determine MIME type ---
export function determineMimeType(asset: {
    uri: string;
    mimeType?: string | null;
    fileName?: string | null;
}): string {
    // 1. Prioritize asset.mimeType
    if (asset.mimeType && asset.mimeType.includes('/')) {
        console.log(`MIME Type: Using provided type: ${asset.mimeType}`);
        return asset.mimeType;
    }

    // 2. Infer from URI extension (fallback)
    const uriParts = asset.uri.split('.');
    const extension = uriParts.pop()?.toLowerCase();
    console.log(`MIME Type: Inferring from extension: .${extension}`);
    switch (extension) {
        case 'jpg': case 'jpeg': return 'image/jpeg';
        case 'png': return 'image/png';
        case 'gif': return 'image/gif';
        case 'webp': return 'image/webp';
        case 'bmp': return 'image/bmp';
        default:
            console.warn(`MIME Type: Could not determine specific type for URI: ${asset.uri}. Defaulting to image/jpeg.`);
            return 'image/jpeg'; // Default
    }
}


// --- Service Interaction Functions (with improved error handling context) ---

// Get macros from recipe text
export async function getMacrosFromText(
    foodName: string,
    ingredients: string
): Promise<Macros> {
    try {
        console.log(`Util: Requesting macros for recipe: "${foodName}"`);
        const macros = await getMacrosForRecipe(foodName, ingredients);
        console.log(`Util: Received macros for recipe: "${foodName}"`);
        return macros;
    } catch (error) {
        console.error(`Util: Error getting macros for recipe "${foodName}":`, error);
        const message = error instanceof BackendError
            ? error.message
            : t('utils.macros.errorGetMacrosRecipe', { error: error instanceof Error ? error.message : String(error) });
        Alert.alert(t('utils.macros.alertAiErrorRecipe'), message);
        throw error; // Re-throw to allow caller to handle
    }
}

// Get macros for a single food item from an image asset
export async function getMacrosForImageFile(asset: ImagePickerAsset): Promise<MacrosWithFoodName> {
    let base64File: string;
    try {
        // Use shared utility for base64 conversion
        base64File = await getBase64FromUri(asset.uri);
    } catch (err) {
        Alert.alert(t('utils.macros.alertImageReadError'), err instanceof Error ? err.message : t('utils.macros.alertImageReadErrorMessage'));
        throw err; // Re-throw error for caller to handle
    }

    const mimeType = determineMimeType(asset);
    console.log(`Util: Requesting single food analysis. MIME: ${mimeType}, Asset URI: ${asset.uri}`);

    try {
        const result = await getMacrosForImageSingle(base64File, mimeType);
        console.log(`Util: Received single food analysis: ${result.foodName}`);
        return result;
    } catch (error) {
        console.error(`Util: Error getting single food macros for image ${asset.uri}:`, error);
        const message = error instanceof BackendError
            ? error.message
            : t('utils.macros.errorImageAnalysis', { error: error instanceof Error ? error.message : String(error) });
        Alert.alert(t('utils.macros.alertAnalysisFailedSingle'), message);
        throw error; // Re-throw error
    }
}

// Get multiple estimated food items from an image asset
export async function getMultipleFoodsFromImage(base64Image: string, mimeType: string): Promise<EstimatedFoodItem[]> {
    console.log(`Util: Requesting multi-food analysis. MIME: ${mimeType}`);

    try {
        const results = await getMacrosForImageMultiple(base64Image, mimeType);
        console.log(`Util: Received ${results.length} estimated items from backend.`);
        if (!Array.isArray(results)) {
            console.error("Util: Backend returned non-array for multiple food items:", results);
            throw new Error(t('utils.macros.errorInvalidResponseMultiple'));
        }
        return results;
    } catch (error) {
        console.error(`Util: Error getting multiple food macros from image:`, error);
         const message = error instanceof BackendError
            ? error.message
            : t('utils.macros.errorCouldNotAnalyze', { error: error instanceof Error ? error.message : String(error) });
        Alert.alert(t('utils.macros.alertQuickAddFailedMulti'), message);
        throw error; // Re-throw error
    }
}

export { BackendError, EstimatedFoodItem, Macros, MacrosWithFoodName };
---------- END macros.ts ----------


---------- units.ts ----------
// src/utils/units.ts
// src/utils/units.ts
import { Alert } from 'react-native';
import { estimateGramsNaturalLanguage, BackendError } from '../services/backendService';
import { t } from '../localization/i18n'; // Import t

export async function getGramsFromNaturalLanguage(
    foodName: string,
    quantityDescription: string
): Promise<number> {
    try {
        const grams = await estimateGramsNaturalLanguage(foodName, quantityDescription);
        return grams;
    } catch (error) {
        const message = error instanceof BackendError
            ? error.message
            : t('utils.units.errorCouldNotEstimateGrams', { error: error instanceof Error ? error.message : String(error) });
        Alert.alert(t('utils.units.alertAiEstimationFailed'), message);
        throw error;
    }
}
---------- END units.ts ----------


---------- validationUtils.ts ----------
// utils/validationUtils.ts

export const isValidNumberInput = (value: string): boolean => {
    return /^[0-9]*(\.[0-9]*)?$/.test(value) && !isNaN(parseFloat(value));
  };
  
  export const isNotEmpty = (value: string): boolean => {
    return value.trim() !== '';
  };
---------- END validationUtils.ts ----------


---------- tsconfig.json ----------
// tsconfig.json
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true,
    "module": "commonjs"
  }
}
---------- END tsconfig.json ----------

