.gitignore
app.json
App.tsx
assets/
  adaptive-icon.png
  favicon.png
  icon.png
  splash-icon.png
components/
  AddEntryModal.tsx
  AddFoodModal.tsx
  ConfirmationModal.tsx
  DailyGoalsInput.tsx
  DailyProgress.tsx
  DataManagementButtons.tsx
  FoodItem.tsx
  StatisticsChart.tsx
  ThemeSwitch.tsx
index.ts
navigation/
  AppNavigator.tsx
package.json
projectToFile.js
screens/
  DailyEntryScreen.tsx
  FoodListScreen.tsx
  SettingsScreen.tsx
services/
  foodService.ts
  storageService.ts
tsconfig.json
types/
  dailyEntry.ts
  food.ts
  settings.ts
utils/
  dateUtils.ts
  validationUtils.ts

---------- .gitignore ----------
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

---------- END .gitignore ----------


---------- app.json ----------
{
  "expo": {
    "name": "MacroTracker",
    "slug": "MacroTracker",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "automatic",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "assetBundlePatterns": ["**/*"],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.yourcompany.macrotracker"
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "package": "com.yourcompany.macrotracker"
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      [
        "expo-document-picker",
        {
          "appleTeamId": "YOUR_TEAM_ID"
        }
      ]
    ]
  }
}

---------- END app.json ----------


---------- App.tsx ----------
// App.tsx (Modified for Reload)
import 'react-native-get-random-values'; // MUST BE FIRST
import React, { useState, useEffect } from 'react';
import AppNavigator from './navigation/AppNavigator';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { ThemeProvider, createTheme } from '@rneui/themed';
import { loadSettings, saveSettings } from './services/storageService';
import { useColorScheme, AppState, AppStateStatus } from 'react-native'; // Import AppState
import { NavigationContainer, DefaultTheme, DarkTheme } from '@react-navigation/native';
import { Colors } from '@rneui/base';
import { Settings } from './types/settings';

declare module '@rneui/themed' {
  export interface Colors {
    text: string;
    card: string; // Added for better card styling
    successLight: string; // Lighter success color
  }
}

interface MyTheme {
  mode: 'light' | 'dark';
  colors: Colors;
}

const lightTheme: MyTheme = {
  mode: 'light',
  colors: {
    primary: '#2e86de',
    secondary: '#6c757d',
    background: '#f8f9fa',
    grey5: '#e9ecef',
    white: '#ffffff',
    grey4: '#ced4da',
    success: '#28a745',
    successLight: '#d4edda',
    black: '#000000',
    text: '#212529',
    card: '#ffffff',
    error: '#dc3545',
    warning: '#ffc107',
    disabled: '#6c757d',
    divider: '#ced4da',
    platform: {
      ios: {
        primary: '',
        secondary: '',
        grey: '',
        searchBg: '',
        success: '',
        error: '',
        warning: ''
      },
      android: {
        primary: '',
        secondary: '',
        grey: '',
        searchBg: '',
        success: '',
        error: '',
        warning: ''
      },
      web: {
        primary: '',
        secondary: '',
        grey: '',
        searchBg: '',
        success: '',
        error: '',
        warning: ''
      },
      default: {
        primary: '',
        secondary: '',
        grey: '',
        searchBg: '',
        success: '',
        error: '',
        warning: ''
      },
    },
    grey0: '', grey1: '', grey2: '', grey3: '', greyOutline: '', searchBg: ''
  },
};

const darkTheme: MyTheme = {
  mode: 'dark',
  colors: {
    primary: '#2e86de',
    secondary: '#adb5bd',
    background: '#121212',
    grey5: '#2c2c2c',
    white: '#ffffff',
    grey4: '#343a40',
    success: '#28a745',
    successLight: '#1f5139',
    black: '#000000',
    text: '#f8f9fa',
    card: '#1e1e1e',
    error: '#dc3545',
    warning: '#ffc107',
    disabled: '#6c757d',
    divider: '#343a40',
    platform: {
       ios: {
         primary: '',
         secondary: '',
         grey: '',
         searchBg: '',
         success: '',
         error: '',
         warning: ''
       },
      android: {
        primary: '',
        secondary: '',
        grey: '',
        searchBg: '',
        success: '',
        error: '',
        warning: ''
      },
      web: {
        primary: '',
        secondary: '',
        grey: '',
        searchBg: '',
        success: '',
        error: '',
        warning: ''
      },
      default: {
        primary: '',
        secondary: '',
        grey: '',
        searchBg: '',
        success: '',
        error: '',
        warning: ''
      },
    },
    grey0: '', grey1: '', grey2: '', grey3: '', greyOutline: '', searchBg: ''
  },
};

const App = () => {
  const [themeMode, setThemeMode] = useState<'light' | 'dark' | 'system'>('system');
  const [loadedSettings, setLoadedSettings] = useState<Settings | null>(null);
  const colorScheme = useColorScheme();
  const [reloadKey, setReloadKey] = useState(0); // Key for forcing remount
  const [appState, setAppState] = useState(AppState.currentState); // AppState


  // Load initial settings
    useEffect(() => {
    const initializeApp = async () => {
      const settings = await loadSettings();
      setThemeMode(settings.theme);
      setLoadedSettings(settings);
    };
    initializeApp();
  }, []);

  // Function to trigger a reload
  const triggerReload = () => {
    setReloadKey((prevKey) => prevKey + 1);
  };

    useEffect(() => {
    const handleAppStateChange = (nextAppState: AppStateStatus) => {
      if (appState.match(/inactive|background/) && nextAppState === 'active') {
        // App has come to the foreground, trigger reload
        triggerReload();
      }
      setAppState(nextAppState);
    };

    const subscription = AppState.addEventListener('change', handleAppStateChange);

    return () => {
      subscription.remove();
    };
  }, [appState]); // Depend on appState


  const updateTheme = (newThemeMode: 'light' | 'dark' | 'system') => {
    const isDark = newThemeMode === 'system' ? colorScheme === 'dark' : newThemeMode === 'dark';
    return isDark ? darkTheme : lightTheme;
  };

  const handleThemeChange = async (newTheme: 'light' | 'dark' | 'system') => {
    setThemeMode(newTheme);
    if (loadedSettings) {
      const updatedSettings: Settings = {
        ...loadedSettings,
        theme: newTheme,
      };
      await saveSettings(updatedSettings);
      setLoadedSettings(updatedSettings);
    }
  };

  const currentTheme = updateTheme(themeMode);

    const navigationTheme = {
    dark: {
        ...DarkTheme,
        colors: {
            ...DarkTheme.colors,
            primary: currentTheme.colors.primary,
            background: currentTheme.colors.background,
            card: currentTheme.colors.card,
            text: currentTheme.colors.text,
            border: currentTheme.colors.divider,
            notification: currentTheme.colors.successLight,
        },
    },
    light: {
        ...DefaultTheme,
        colors: {
            ...DefaultTheme.colors,
            primary: currentTheme.colors.primary,
            background: currentTheme.colors.background,
            card: currentTheme.colors.card,
            text: currentTheme.colors.text,
            border: currentTheme.colors.divider,
            notification: currentTheme.colors.success,
        },
    },
};

  return (
    <ThemeProvider theme={createTheme(currentTheme)} key={themeMode}>
      <SafeAreaProvider>
        <NavigationContainer
          theme={currentTheme.mode === 'dark' ? navigationTheme.dark : navigationTheme.light}
        >
          {/* Pass reloadKey and triggerReload */}
          <AppNavigator onThemeChange={handleThemeChange}  key={reloadKey} onDataOperation={triggerReload}/>
        </NavigationContainer>
      </SafeAreaProvider>
    </ThemeProvider>
  );
};

export default App;
---------- END App.tsx ----------


---------- adaptive-icon.png ----------
(Image file - content not included)
---------- END adaptive-icon.png ----------


---------- favicon.png ----------
(Image file - content not included)
---------- END favicon.png ----------


---------- icon.png ----------
(Image file - content not included)
---------- END icon.png ----------


---------- splash-icon.png ----------
(Image file - content not included)
---------- END splash-icon.png ----------


---------- AddEntryModal.tsx ----------
// components/AddEntryModal.tsx
import React from "react";
import {
  View,
  FlatList,
  KeyboardAvoidingView,
  Platform,
} from "react-native";
import {
  Button,
  Input,
  Text,
  ListItem,
  Overlay,
  SearchBar,
  makeStyles,
  useTheme,
} from "@rneui/themed";
import { Food } from "../types/food";
import { SafeAreaView } from "react-native-safe-area-context";
import { isValidNumberInput } from "../utils/validationUtils";

interface AddEntryModalProps {
  isVisible: boolean;
  toggleOverlay: () => void;
  search: string;
  updateSearch: (search: string) => void;
  filteredFoods: Food[];
  handleSelectFood: (item: Food) => void;
  grams: string;
  setGrams: (grams: string) => void;
  handleAddEntry: () => void;
  selectedFood: Food | null;
}

const AddEntryModal: React.FC<AddEntryModalProps> = ({
  isVisible,
  toggleOverlay,
  search,
  updateSearch,
  filteredFoods,
  handleSelectFood,
  grams,
  setGrams,
  handleAddEntry,
  selectedFood
}) => {

    const { theme } = useTheme();
    const styles = useStyles();

    return (
        <Overlay
            isVisible={isVisible}
            onBackdropPress={toggleOverlay}
            animationType="slide"
            transparent={true}
            statusBarTranslucent={true}
            overlayStyle={styles.overlayStyle} // Apply overlayStyle here
        >
            <SafeAreaView style={styles.modalSafeArea}>
                <KeyboardAvoidingView
                    behavior={Platform.OS === "ios" ? "padding" : "height"}
                    style={styles.keyboardAvoidingView}
                >
                    <View style={styles.overlayContent}>
                        <Text h4 style={styles.overlayTitle}>
                            Add Entry
                        </Text>
                        <SearchBar
                            placeholder="Search Foods..."
                            onChangeText={updateSearch}
                            value={search}
                            platform={Platform.OS === "ios" ? "ios" : "android"}
                            containerStyle={styles.searchBarContainer}
                            inputContainerStyle={styles.searchBarInputContainer}
                            inputStyle={{ color: theme.colors.text }} // Ensure text color
                        />
                        <FlatList
                            data={filteredFoods}
                            keyExtractor={(item) => item.id}
                            renderItem={({ item }) => (
                                <ListItem bottomDivider onPress={() => handleSelectFood(item)} containerStyle={styles.listItemContainer}>
                                    <ListItem.Content>
                                        <ListItem.Title style={{ color: theme.colors.text }}>{item.name}</ListItem.Title>
                                    </ListItem.Content>
                                </ListItem>
                            )}
                            style={styles.foodList}
                        />
                         <Input
                            placeholder="Grams (e.g. 150)"
                            placeholderTextColor={theme.colors.text}
                            keyboardType="numeric"
                            value={grams}
                            onChangeText={setGrams}
                            style={{ color: theme.colors.text }} // Correct text color
                            inputContainerStyle={{ borderBottomColor: theme.colors.text }} // Consistent border color
                            errorMessage={!isValidNumberInput(grams) && grams !== "" ? "Enter a valid number" : ""}
                        />
                        <Button
                            title="Add Entry"
                            onPress={handleAddEntry}
                            disabled={!selectedFood || !isValidNumberInput(grams) || grams === ""}
                            buttonStyle={styles.addButton}
                            titleStyle={{color: theme.colors.white}} //add the correct title color
                        />
                    </View>
                </KeyboardAvoidingView>
            </SafeAreaView>
        </Overlay>
    );
};
const useStyles = makeStyles((theme) => ({
  overlayStyle: {
    backgroundColor: 'rgba(0, 0, 0, 0.5)', // Semi-transparent background
    paddingTop: '33%',
    padding: 20,  // Remove padding from the Overlay itself
    width: '100%',
    height: '100%', //  Control width here
    borderRadius: 10,
    // maxHeight: '80%' No longer needed since it is handled by overlayContent
  },
    modalSafeArea: {
      flex: 1,
      justifyContent: "center",
      alignItems: "center",
      // backgroundColor: "rgba(0, 0, 0, 0)", //  Removed -  Let Overlay handle the background
    },
    keyboardAvoidingView: {
      width: "100%",
      flex: 1, // Important: Allow KeyboardAvoidingView to take up all available space
    },
    overlayContent: {
        backgroundColor: theme.colors.background,
        width: "100%",  // Occupy full width *within* the overlay
        height: "80%",
        borderRadius: 10,
        padding: 20,

    },
    overlayTitle: {
        marginBottom: 20,
        textAlign: "center",
        color: theme.colors.text, // Use theme color
    },
    searchBarContainer: {
        backgroundColor: "transparent",
        borderBottomColor: "transparent",
        borderTopColor: "transparent",
        marginBottom: 10,
        padding: 0,
        width: '100%', // Ensure full width
    },
    searchBarInputContainer: {
        borderRadius: 10,
        backgroundColor: theme.colors.grey5, // Use theme color
    },
    foodList: {
        maxHeight: 200, // Limit height for scrollability
        marginBottom: 10,
        width: "100%",
    },
    listItemContainer:{
      backgroundColor: theme.colors.background
    },
    addButton: {
        marginTop: 10,
        backgroundColor: theme.colors.primary, // Or your desired button color

    },
}));
export default AddEntryModal;
---------- END AddEntryModal.tsx ----------


---------- AddFoodModal.tsx ----------
// components/AddFoodModal.tsx
import React from "react";
import { View, KeyboardAvoidingView, Platform } from "react-native";
import { Button, Input, Text, Overlay, makeStyles, useTheme, Icon } from "@rneui/themed";
import { Food } from "../types/food";
import { SafeAreaView } from "react-native-safe-area-context";
import { MaterialCommunityIcons } from '@expo/vector-icons';

interface AddFoodModalProps {
    isVisible: boolean;
    toggleOverlay: () => void;
    newFood: Omit<Food, "id">;
    editFood: Food | null;
    errors: { [key: string]: string };
    handleInputChange: (key: keyof Omit<Food, "id">, value: string) => void;
    handleCreateFood: () => void;
    handleUpdateFood: () => void;
    validateFood: (food: Omit<Food, "id">) => { [key: string]: string } | null;
}

const AddFoodModal: React.FC<AddFoodModalProps> = ({
    isVisible,
    toggleOverlay,
    newFood,
    editFood,
    errors,
    handleInputChange,
    handleCreateFood,
    handleUpdateFood,
    validateFood
}) => {
    const { theme } = useTheme();
    const styles = useStyles();

    // Helper function to get the value safely
    const getValue = (key: keyof Omit<Food, "id">) => {
        if (editFood) {
            return String(editFood[key] ?? "");
        }
        return String(newFood[key] ?? "");
    };

    // Dynamically determine icon and label color based on theme and errors
    const getIconColor = (error: string | undefined) => {
        return error ? theme.colors.error : theme.colors.grey3;
    };

    const getLabelColor = (error: string | undefined) => {
        return error ? theme.colors.error : theme.colors.grey1;
    };


    return (
        <Overlay
            isVisible={isVisible}
            onBackdropPress={toggleOverlay}
            animationType="slide"
            transparent={true}
            statusBarTranslucent={true}
            overlayStyle={styles.overlayStyle}
        >
            <SafeAreaView style={styles.modalSafeArea}>
                <KeyboardAvoidingView
                    behavior={Platform.OS === "ios" ? "padding" : "height"}
                    style={styles.keyboardAvoidingView}
                >
                    <View style={styles.overlayContent}>
                        <View style={styles.titleContainer}>
                            <Text h4 style={styles.overlayTitle}>
                                {editFood ? "Edit Food" : "Add New Food"}
                            </Text>
                            <Icon
                                name="close"
                                type="material"
                                size={24}
                                color={theme.colors.grey3}
                                onPress={toggleOverlay}
                                containerStyle={styles.closeIcon}
                            />
                        </View>

                        <Input
                            placeholder=""
                            value={getValue("name")}
                            onChangeText={(text) => handleInputChange("name", text)}
                            errorMessage={errors.name}
                            style={styles.input}
                            inputContainerStyle={{ borderBottomColor: theme.colors.text }}
                            placeholderTextColor={theme.colors.grey3}
                            leftIcon={<MaterialCommunityIcons name="food-apple" size={24} color={theme.colors.text} style={styles.inputIcon} />}
                            label="Food Name"
                            labelStyle={[styles.inputLabel, { color: theme.colors.text }]}
                        />
                        <Input
                            placeholder="Calories (per 100g)"
                            keyboardType="numeric"
                            value={getValue("calories")}
                            onChangeText={(text) => handleInputChange("calories", text)}
                            errorMessage={errors.calories}
                            style={styles.input}
                            inputContainerStyle={{ borderBottomColor: theme.colors.text }}
                            placeholderTextColor={theme.colors.grey3}
                            leftIcon={<MaterialCommunityIcons name="fire" size={24} color={theme.colors.text} style={styles.inputIcon} />}
                            label="Calories (per 100g)"
                            labelStyle={[styles.inputLabel, { color: theme.colors.text }]}
                        />
                        <Input
                            placeholder="Protein (per 100g)"
                            keyboardType="numeric"
                            value={getValue("protein")}
                            onChangeText={(text) => handleInputChange("protein", text)}
                            errorMessage={errors.protein}
                            style={styles.input}
                            inputContainerStyle={{ borderBottomColor: theme.colors.text }}
                            placeholderTextColor={theme.colors.grey3}
                            leftIcon={<MaterialCommunityIcons name="food-drumstick" size={24} color={theme.colors.text} style={styles.inputIcon} />}
                            label="Protein (per 100g)"
                            labelStyle={[styles.inputLabel, { color: theme.colors.text }]}
                        />
                        <Input
                            placeholder="Carbs (per 100g)"
                            keyboardType="numeric"
                            value={getValue("carbs")}
                            onChangeText={(text) => handleInputChange("carbs", text)}
                            errorMessage={errors.carbs}
                            style={styles.input}
                            inputContainerStyle={{ borderBottomColor: theme.colors.text }}
                            placeholderTextColor={theme.colors.grey3}
                            leftIcon={<MaterialCommunityIcons name="bread-slice" size={24} color={theme.colors.text} style={styles.inputIcon} />}
                            label="Carbs (per 100g)"
                            labelStyle={[styles.inputLabel, { color: theme.colors.text }]}
                        />
                        <Input
                            placeholder="Fat (per 100g)"
                            keyboardType="numeric"
                            value={getValue("fat")}
                            onChangeText={(text) => handleInputChange("fat", text)}
                            errorMessage={errors.fat}
                            style={styles.input}
                            inputContainerStyle={{ borderBottomColor: theme.colors.text }}
                            placeholderTextColor={theme.colors.grey3}
                            leftIcon={<MaterialCommunityIcons name="bucket" size={24} color={theme.colors.text} style={styles.inputIcon} />}
                            label="Fat (per 100g)"
                            labelStyle={[styles.inputLabel, { color: theme.colors.text }]}
                        />

                        <Button
                            title={editFood ? "Update Food" : "Add Food"}
                            onPress={editFood ? handleUpdateFood : handleCreateFood}
                            disabled={editFood ? (editFood !== null && !!validateFood(editFood)) : !!validateFood(newFood)}
                            buttonStyle={styles.button}
                            titleStyle={{ color: theme.colors.white }}
                        />
                    </View>
                </KeyboardAvoidingView>
            </SafeAreaView>
        </Overlay>
    );
};

const useStyles = makeStyles((theme) => ({
    overlayStyle: {
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        paddingTop: '33%',
        padding: 20,
        width: '100%',
        height: '100%',
        borderRadius: 10,
    },
    modalSafeArea: {
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
    },
    keyboardAvoidingView: {
        width: "100%",
        flex: 1,
    },
    overlayContent: {
        backgroundColor: theme.colors.background,
        width: "100%",
        borderRadius: 10,
        padding: 20,
    },
    titleContainer: {
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: 10,
    },
    overlayTitle: {
        textAlign: "center",
        color: theme.colors.text,
    },
    closeIcon: {
        position: 'absolute',
        top: 0,
        right: 0,
        padding: 5,
    },
    input: {
        color: theme.colors.text,
    },
    inputLabel: {
        color: theme.colors.grey1,  // Default label color
        marginBottom: 5,
        fontSize: 16,
    },
    inputIcon: {
        marginRight: 10,
    },
    button: {
        marginTop: 15,
        backgroundColor: theme.colors.primary,
        borderRadius: 8,
    },
}));

export default AddFoodModal;
---------- END AddFoodModal.tsx ----------


---------- ConfirmationModal.tsx ----------
// components/ConfirmationModal.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Overlay, Button, Input, Text, useTheme } from '@rneui/themed';

interface ConfirmationModalProps {
  isVisible: boolean;
  onCancel: () => void;
  onConfirm: () => void;
  confirmationText: string;
  setConfirmationText: (text: string) => void;
  title?: string; // Optional title
  message?: string;  //Optional message
}

const ConfirmationModal: React.FC<ConfirmationModalProps> = ({
  isVisible,
  onCancel,
  onConfirm,
  confirmationText,
  setConfirmationText,
  title = "Confirm Action", //default title
  message = "Are you sure you want to perform this action?"
}) => {
  const { theme } = useTheme();

  return (
    <Overlay
      isVisible={isVisible}
      onBackdropPress={onCancel}
      overlayStyle={styles.overlay}
      backdropStyle={styles.backdrop} // Add the backdropStyle
    >
      <View style={[styles.container, {backgroundColor: theme.colors.background}]}>
        <Text style={[styles.title, {color: theme.colors.text}]}>{title}</Text>
        <Text style={[styles.message, {color: theme.colors.text}]}>{message}</Text>
        <Input
          placeholder="Enter confirmation text"
          placeholderTextColor={theme.colors.text}
          value={confirmationText}
          onChangeText={setConfirmationText}
          containerStyle={styles.inputContainer}
          inputStyle={{ color: theme.colors.text }}
          inputContainerStyle={{borderBottomColor: theme.colors.text}}
        />
        <View style={styles.buttonContainer}>
          <Button title="Cancel" onPress={onCancel} type="outline" buttonStyle={styles.button} />
          <Button
            title="Confirm"
            onPress={onConfirm}
            color="error"
            buttonStyle={styles.button}
            disabled={confirmationText === ""}  //Disable when empty
          />
        </View>
      </View>
    </Overlay>
  );
};

const styles = StyleSheet.create({
    overlay: {
        borderRadius: 10,
        width: '80%', // Responsive width
        padding: 6,
        backgroundColor: 'rgba(200, 200, 200, 0.5)'
    },
  container: {
    padding: 20,
    borderRadius: 7,
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 10,
    textAlign: 'center', //center align
  },
  message: {
    marginBottom: 15,
    textAlign: 'center'
  },
  inputContainer: {
    marginBottom: 20,
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
  },
  button: {
    width: 100,
    padding: 10,
  },
  backdrop: {  // Add styles for the backdrop
    backgroundColor: 'rgba(0, 0, 0, 0.5)', // Semi-transparent black
  },
});

export default ConfirmationModal;
---------- END ConfirmationModal.tsx ----------


---------- DailyGoalsInput.tsx ----------
// components/DailyGoalsInput.tsx
import React from "react";
import { Input } from "@rneui/themed";
import { MacroType } from "../types/settings";
import { useTheme } from "@rneui/themed";


interface DailyGoalsInputProps {
  dailyGoals: { [key in MacroType]: number };
  onGoalChange: (goalType: MacroType, value: string) => void;
}

const DailyGoalsInput: React.FC<DailyGoalsInputProps> = ({
  dailyGoals,
  onGoalChange,
}) => {

    const { theme } = useTheme();

  return (
    <>
      {["calories", "protein", "carbs", "fat"].map((macro) => (
        <Input
          key={macro}
          label={`${macro.charAt(0).toUpperCase() + macro.slice(1)} Goal`}
          keyboardType="numeric"
          value={dailyGoals?.[macro as MacroType]?.toString() || ""}
          onChangeText={(value) => onGoalChange(macro as MacroType, value)}
          style={{ color: theme.colors.text }}
          inputContainerStyle={{ borderBottomColor: theme.colors.text }}
          labelStyle={{ color: theme.colors.text }}
        />
      ))}
    </>
  );
};

export default DailyGoalsInput;
---------- END DailyGoalsInput.tsx ----------


---------- DailyProgress.tsx ----------
// components/DailyProgress.tsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Text, useTheme } from '@rneui/themed';

interface DailyProgressProps {
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
  goals: {
    calories?: number;
    protein?: number;
    carbs?: number;
    fat?: number;
  };
}

const DailyProgress: React.FC<DailyProgressProps> = ({
  calories,
  protein,
  carbs,
  fat,
  goals,
}) => {
  const { theme } = useTheme();

  const calculateProgress = (current: number, goal?: number) => {
    if (!goal || goal <= 0) return 0; // Avoid division by zero and handle undefined goals
    return Math.min(current / goal, 1); // Cap at 100%
  };

  const renderProgressBar = (label: string, current: number, goal: number | undefined, color: string) => {
      const progress = calculateProgress(current, goal);
      return (
          <View style={styles.macroContainer} key={label}>
              <View style={styles.labelContainer}>
                    <Text style={[styles.macroLabel, {color: theme.colors.text}]}>{label}:</Text>
                    <Text style={[styles.macroValue, {color: theme.colors.text}]}>
                        {`${Math.round(current)} / ${goal || 0}`}
                    </Text>
              </View>
              <View style={styles.progressBarContainer}>
                  <View style={[styles.progressBar, { width: `${progress * 100}%`, backgroundColor: color }]} />
              </View>
          </View>
      )
  }


  return (
    <View style={styles.container}>
        {renderProgressBar('Calories', calories, goals.calories, theme.colors.primary)}
        {renderProgressBar('Protein', protein, goals.protein, 'green')}
        {renderProgressBar('Carbs', carbs, goals.carbs, 'orange')}
        {renderProgressBar('Fat', fat, goals.fat, 'blue')}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: 20,
    padding: 10,
    borderRadius: 8, // Rounded corners for the container
    //backgroundColor: '#f0f0f0', // Light background for contrast Removed for theme consistency
  },
  macroContainer: {
    marginBottom: 10,
  },
  labelContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 5,
  },
  macroLabel: {
    fontWeight: 'bold',
  },
  macroValue: {},
  progressBarContainer: {
      backgroundColor: '#e0e0e0', //Light grey for track
      borderRadius: 5,
      height: 10
  },
  progressBar: {
    height: 10,
    borderRadius: 5,
  },
});

export default DailyProgress;
---------- END DailyProgress.tsx ----------


---------- DataManagementButtons.tsx ----------
// components/DataManagementButtons.tsx (Modified callback)

import React, { useState } from "react";
import { Alert, Platform } from "react-native"; // Import Platform
import { Button } from "@rneui/themed";
import * as DocumentPicker from "expo-document-picker";
import * as FileSystem from "expo-file-system";
import * as Sharing from 'expo-sharing'; // Import Sharing
import { formatDate } from "../utils/dateUtils";
import {
  clearAllData,
  loadDailyEntries,
  saveDailyEntries,
  loadFoods,
  saveFoods,
  loadSettings,
  saveSettings
} from "../services/storageService";
import ConfirmationModal from "./ConfirmationModal";
import { DailyEntry } from "../types/dailyEntry";
import { Food } from "../types/food";
import { Settings } from "../types/settings";
import { useTheme } from "@rneui/themed";


interface DataManagementButtonsProps {
  onDataOperation: () => void; // Changed prop name
}

const DataManagementButtons: React.FC<DataManagementButtonsProps> = ({
    onDataOperation
}) => {
  const [isConfirmationVisible, setIsConfirmationVisible] = useState(false);
  const [confirmationText, setConfirmationText] = useState("");
  const { theme } = useTheme();

  const handleExportData = async () => {
    try {
      const dailyEntries = await loadDailyEntries();
      const foods = await loadFoods();
      const settings = await loadSettings();

      const exportData = {
        dailyEntries,
        foods,
        settings
      };

      const exportDataString = JSON.stringify(exportData);
      const formattedDate = formatDate(new Date()).replace(/\//g, '-'); // Replace slashes
      const fileName = `macro_data_${formattedDate}.json`;
      const fileUri = FileSystem.documentDirectory + fileName;

      await FileSystem.writeAsStringAsync(fileUri, exportDataString, {
        encoding: FileSystem.EncodingType.UTF8,
      });

      // Use expo-sharing to share the file
      if (!(await Sharing.isAvailableAsync())) {
        Alert.alert('Sharing is not available on your platform');
        return;
      }

      await Sharing.shareAsync(fileUri);
      onDataOperation(); // Trigger reload after export

    } catch (error: any) {
      console.error(error);
      Alert.alert(
        "Export Failed",
        error.message || "An error occurred while exporting data."
      );
    }
  };

  const handleImportData = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: ["application/json"], // Only accept JSON files
      });

      if (result.assets && result.assets.length > 0) {
        const file = result.assets[0];

        // Check file extension
        if (!file.name?.toLowerCase().endsWith(".json")) {
          Alert.alert("Invalid File", "Please select a JSON file.");
          return;
        }

        const fileContent = await FileSystem.readAsStringAsync(file.uri, {
          encoding: FileSystem.EncodingType.UTF8,
        });


        try {
          const importedData = JSON.parse(fileContent);

          // Basic structure validation:
          if (
            !importedData.hasOwnProperty("dailyEntries") ||
            !importedData.hasOwnProperty("foods") ||
            !importedData.hasOwnProperty("settings")
          ) {
            Alert.alert(
              "Import Failed",
              "The imported file is missing required data (dailyEntries, foods, or settings)."
            );
            return;
          }


          await saveDailyEntries(importedData.dailyEntries);
          await saveFoods(importedData.foods);
          await saveSettings(importedData.settings)
          Alert.alert("Import Successful", "Data imported and saved.");
          onDataOperation(); //trigger reload

        } catch (parseError) {
          Alert.alert(
            "Import Failed",
            "The imported file is not valid JSON."
          );
          return;
        }


      } else {
        // Explicitly check for cancelled
        if (result.canceled) {
          // User cancelled, do nothing
        } else {
          Alert.alert("Import Failed", "Invalid file selected.");
        }
      }
    } catch (error: any) {
      console.error("Import Error:", error);
      Alert.alert(
        "Import Failed",
        error.message || "An unknown error occurred."
      );
    }
  };

  const handleClearData = () => setIsConfirmationVisible(true);

  const confirmClearData = async () => {
    if (confirmationText === "CLEAR DATA") {
      try {
        await clearAllData();
        Alert.alert("Data Cleared", "All data has been cleared.");
        onDataOperation(); // Trigger reload after clearing
      } catch (error) {
        Alert.alert("Error", "Failed to clear data.");
      } finally {
        setConfirmationText("");
        setIsConfirmationVisible(false);
      }
    } else {
      Alert.alert("Error", "Incorrect confirmation text.");
    }
  };

  return (
    <>
      <Button
        title="Export Data"
        onPress={handleExportData}
        buttonStyle={{ marginBottom: 10, backgroundColor: theme.colors.primary }}
      />
      <Button
        title="Import Data"
        onPress={handleImportData}
        buttonStyle={{ marginBottom: 10, backgroundColor: theme.colors.primary }}
      />
      <Button
        title="Clear All Data"
        onPress={handleClearData}
        color="error"
        buttonStyle={{ marginBottom: 10 }}
      />

      <ConfirmationModal
        isVisible={isConfirmationVisible}
        onCancel={() => setIsConfirmationVisible(false)}
        onConfirm={confirmClearData}
        confirmationText={confirmationText}
        setConfirmationText={setConfirmationText}
        title="Clear All Data?"
        message="This action cannot be undone. Confirmation Text: CLEAR DATA"
      />
    </>
  );
};

export default DataManagementButtons;
---------- END DataManagementButtons.tsx ----------


---------- FoodItem.tsx ----------
// components/FoodItem.tsx
import React from 'react';
import { StyleSheet } from 'react-native';
import { ListItem, Icon, useTheme, Button } from '@rneui/themed';
import { Food } from '../types/food';

interface FoodItemProps {
  food: Food;
  onEdit: (food: Food) => void;
  onDelete: (foodId: string) => void;
}

const FoodItem: React.FC<FoodItemProps> = ({ food, onEdit, onDelete }) => {

    const {theme} = useTheme();
  return (
    <ListItem.Swipeable
      bottomDivider
      leftContent={(reset) => (
        <Button
          title="Edit"
          onPress={() => {
            onEdit(food);
            reset();
          }}
          icon={{ name: 'edit', color: 'white' }}
          buttonStyle={styles.swipeButtonEdit}
        />
      )}
      rightContent={(reset) => (
        <Button
          title="Delete"
          onPress={() => {
            onDelete(food.id);
            reset();
          }}
          icon={{ name: 'delete', color: 'white' }}
          buttonStyle={styles.swipeButtonDelete}
        />
      )}
      containerStyle={[styles.listItemContainer, {backgroundColor: theme.colors.background}]}
    >
      <Icon name="fast-food-outline" type="ionicon" color={theme.colors.text} />
      <ListItem.Content>
        <ListItem.Title style={[styles.title, {color: theme.colors.text}]}>{food.name}</ListItem.Title>
        <ListItem.Subtitle style={{ color: theme.colors.text }}>
          {`Cal: ${food.calories}, P: ${food.protein}g, C: ${food.carbs}g, F: ${food.fat}g`}
        </ListItem.Subtitle>
      </ListItem.Content>
      <ListItem.Chevron />
    </ListItem.Swipeable>
  );
};

const styles = StyleSheet.create({
    listItemContainer: {
      paddingVertical: 15, // Add some vertical padding
      borderRadius: 8,   // Rounded corners
      marginVertical: 5, // Space between list items
      //borderWidth: 1,       // Subtle border //Removed for theme
      //borderColor: '#ddd',
    },
    title: {
      fontWeight: 'bold',
      fontSize: 16,
    },
    swipeButtonEdit: {
        minHeight: '100%',
        backgroundColor: 'orange'
    },
    swipeButtonDelete: {
        minHeight: '100%',
        backgroundColor: 'red'
    }

  });

export default FoodItem;
---------- END FoodItem.tsx ----------


---------- StatisticsChart.tsx ----------
// components/StatisticsChart.tsx
import React from "react";
import { View, StyleSheet } from "react-native";
import { WebView } from "react-native-webview";
import { Statistics, MacroType, macros } from "../types/settings"; // Import types
import { useTheme } from "@rneui/themed";


interface StatisticsChartProps {
  statistics: Statistics;
}

const StatisticsChart: React.FC<StatisticsChartProps> = ({ statistics }) => {

    const { theme } = useTheme();

  const generateChartHTML = () => {
      const chartData = macros.reduce((acc, macro) => {
     // Prepare data for each macro, including goal if applicable
     acc[macro] = statistics[macro].map((series) =>
       series.map((item) => [item.x / 1000, item.y])
     );
     return acc;
   }, {} as { [key in MacroType]: number[][][] });

   const textColor = theme.colors.text;
   const gridColor = theme.colors.grey5; // Lighter grid
   const axisColor = theme.colors.grey3; // Slightly darker axis
   const fontFamily = "Helvetica, Arial, sans-serif";

   // Define color palette for the lines, using theme colors if possible
   const lineColors = {
     calories: theme.colors.primary,
     protein: theme.colors.success,
     carbs: theme.colors.warning,
     fat: theme.colors.error,
   };

   return `
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="utf-8">
        <title>Macro Charts</title>
        <style>
           body { font-family: ${fontFamily}; margin: 0; padding: 0; background-color: ${theme.colors.background}; color: ${textColor};}
            .chart-container { width: 95%; height: 250px; margin: 10px auto; }
        </style>
        <link rel="stylesheet" href="https://unpkg.com/uplot@1.6.27/dist/uPlot.min.css">
        <script src="https://unpkg.com/uplot@1.6.27/dist/uPlot.iife.min.js"></script>
    </head>
    <body>
        ${macros
          .map((macro) => {
            const isCalories = macro === "calories";
            const seriesCount = isCalories ? 2 : 1; // Two series for calories (intake, goal)
            const seriesConfig = isCalories
              ? `[
                  {},
                  {
                    stroke: "${lineColors[macro] || theme.colors.primary}",
                    width: 2,
                    label: "Intake",
                    points: { show: false }
                  },
                  {
                    stroke: "red",
                    width: 1,
                    dash: [5, 5],
                    label: "Goal",
                    points: { show: false }
                  }
                ]`
              : `[
                  {},
                  {
                    stroke: "${lineColors[macro] || theme.colors.primary}",
                    width: 2,
                    label: "${macro.charAt(0).toUpperCase() + macro.slice(1)}",
                    points: { show: false }
                  }
                ]`;

            const uPlotData =
              seriesCount === 2
                ? `[data[0].map(d => d[0]), data[0].map(d => d[1]), data[1].map(d => d[1])]`
                : `[data[0].map(d => d[0]), data[0].map(d => d[1])]`;

            return `
            <div id="${macro}-chart" class="chart-container"></div>
            <script>
                const data = ${JSON.stringify(chartData[macro])};
                const opts = {
                    title: "${macro.charAt(0).toUpperCase() + macro.slice(1)}",
                    width: window.innerWidth * 0.95,
                    height: 250,
                    scales: {
                        x: { time: true },
                        y: { },
                    },
                    axes: [
                        {
                            stroke: "${textColor}",
                            font: "14px ${fontFamily}",
                           grid: {
                                stroke: "${gridColor}",
                                width: 1
                            },
                            ticks: {
                                stroke: "${gridColor}",
                                width: 1
                            }
                        },
                        {
                            stroke: "${textColor}",
                            font: "14px ${fontFamily}",
                            grid: {
                                stroke: "${gridColor}",
                                width: 1
                            },
                            ticks: {
                                stroke: "${gridColor}",
                                width: 1
                            }
                        }
                    ],
                    series: ${seriesConfig},
                    cursor: {
                        drag: { setScale: false },
                        points: {
                            size: 6,
                            fill: (self, i) => self.series[i]._stroke,
                            stroke: (self, i) => self.series[i]._stroke,
                        }
                    }
                };
                new uPlot(opts, ${uPlotData}, document.getElementById('${macro}-chart'));
            </script>
        `;
          })
          .join("")}
    </body>
    </html>
    `;
  };

  return (
    <View style={styles.webViewContainer}>
      <WebView
        originWhitelist={["*"]}
        source={{ html: generateChartHTML() }}
        style={styles.webView}
        scalesPageToFit={false}
        scrollEnabled={false}
      />
    </View>
  );
};

const styles = StyleSheet.create({
    webViewContainer: {
        height: 'auto',
        width: "100%",
        marginTop: 10,
    },
    webView: {
        height: 340, // Explicit height, adjust as needed.
    },
});

export default StatisticsChart;
---------- END StatisticsChart.tsx ----------


---------- ThemeSwitch.tsx ----------
// components/ThemeSwitch.tsx (Corrected)
import React from "react";
import { ListItem, Switch } from "@rneui/themed";
import { useTheme } from "@rneui/themed";

interface ThemeSwitchProps {
  currentTheme: 'light' | 'dark' | 'system'; // Use theme string
  onToggle: (theme: 'light' | 'dark' | 'system') => void; // Pass the theme string
}

const ThemeSwitch: React.FC<ThemeSwitchProps> = ({ currentTheme, onToggle }) => {
  const { theme } = useTheme();

  return (
    <ListItem
      bottomDivider
      containerStyle={{ backgroundColor: theme.colors.background }}
    >
      <ListItem.Content>
        <ListItem.Title style={{ color: theme.colors.text }}>
          Dark Mode
        </ListItem.Title>
      </ListItem.Content>
      <Switch
        value={currentTheme === 'dark'} // Correctly reflect theme
        onValueChange={(newValue) => {
          onToggle(newValue ? 'dark' : 'light'); // Toggle between 'light' and 'dark'
        }}
      />
    </ListItem>
  );
};

export default ThemeSwitch;
---------- END ThemeSwitch.tsx ----------


---------- index.ts ----------
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);

---------- END index.ts ----------


---------- AppNavigator.tsx ----------
// navigation/AppNavigator.tsx (Modified to accept onDataOperation)
import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { Icon, useTheme } from '@rneui/themed';
import DailyEntryScreen from '../screens/DailyEntryScreen';
import FoodListScreen from '../screens/FoodListScreen';
import SettingsScreen from '../screens/SettingsScreen';

const Tab = createBottomTabNavigator();

interface AppNavigatorProps {
  onThemeChange: (theme: 'light' | 'dark' | 'system') => void;
  onDataOperation: () => void; // Add this prop
}

const AppNavigator: React.FC<AppNavigatorProps> = ({ onThemeChange, onDataOperation }) => {
  const { theme } = useTheme();

  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        tabBarIcon: ({ focused, color, size }) => {
          let iconName: string = '';
          let type: string = '';

          if (route.name === 'Daily Entry') {
            iconName = focused ? 'calendar' : 'calendar-outline';
            type = 'ionicon';
          } else if (route.name === 'Foods') {
            iconName = focused ? 'fast-food' : 'fast-food-outline';
            type = 'ionicon'; // Consistent icon set
          } else if (route.name === 'Settings') {
            iconName = focused ? 'settings' : 'settings-outline';
            type = 'ionicon';
          }

          return <Icon name={iconName} type={type} size={size} color={color} />;
        },
        tabBarActiveTintColor: theme.colors.primary,
        tabBarInactiveTintColor: theme.colors.secondary, // Use secondary color
        headerShown: false,
        tabBarStyle: {
          backgroundColor: theme.colors.background,
          borderTopColor: theme.colors.divider, // Add a subtle border
        },
        tabBarLabelStyle: {
          fontWeight: 'bold', // Make labels more prominent
        }
      })}
    >
      <Tab.Screen name="Daily Entry" component={DailyEntryScreen} />
      <Tab.Screen name="Foods" component={FoodListScreen} />
      <Tab.Screen name="Settings">
        {/* Pass onDataOperation to SettingsScreen */}
        {() => <SettingsScreen onThemeChange={onThemeChange} onDataOperation={onDataOperation} />}
      </Tab.Screen>
    </Tab.Navigator>
  );
};

export default AppNavigator;
---------- END AppNavigator.tsx ----------


---------- package.json ----------
{
  "name": "macrotracker",
  "license": "0BSD",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@react-native-async-storage/async-storage": "^2.1.2",
    "@react-native-community/datetimepicker": "8.2.0",
    "@react-navigation/bottom-tabs": "^7.3.1",
    "@react-navigation/native": "^7.0.17",
    "@rneui/base": "^4.0.0-rc.7",
    "@rneui/themed": "^4.0.0-rc.8",
    "@types/d3-scale": "^4.0.9",
    "d3-scale": "^4.0.2",
    "date-fns": "^4.1.0",
    "expo": "~52.0.40",
    "expo-document-picker": "^13.0.3",
    "expo-file-system": "^18.0.12",
    "expo-status-bar": "~2.0.1",
    "react": "18.3.1",
    "react-native": "0.76.7",
    "react-native-get-random-values": "^1.11.0",
    "react-native-reanimated": "~3.16.1",
    "react-native-safe-area-context": "^4.14.1",
    "react-native-screens": "^4.9.2",
    "react-native-svg": "^15.11.2",
    "react-native-webview": "^13.13.4",
    "uuid": "^11.1.0",
    "expo-sharing": "~13.0.1"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/react": "~18.3.12",
    "@types/react-native": "^0.73.0",
    "@types/react-native-svg-charts": "^5.0.16",
    "@types/uuid": "^10.0.0",
    "typescript": "^5.3.3",
    "victory": "^37.3.6"
  },
  "private": true
}

---------- END package.json ----------


---------- projectToFile.js ----------
const fs = require('fs');
const path = require('path');

async function generateProjectStructureAndContent(projectRoot, outputFile) {
    const excludedDirs = ['node_modules', '.git', '.expo', 'android', 'ios', '__tests__', 'dist', 'build', '.vscode'];
    const excludedFiles = ['.DS_Store', 'package-lock.json', 'yarn.lock', 'bun.lockb', 'metro.config.js', 'babel.config.js'];
    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.webp', '.ico']; // Add more if needed

    let fileStructureTree = '';  // For the initial tree structure
    let fileContents = '';      // For the file contents

    async function traverseDirectory(dir, indent = '') {
        const entries = await fs.promises.readdir(dir, { withFileTypes: true });

        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);

            if (excludedDirs.includes(entry.name)) {
                continue;
            }

            if (entry.isDirectory()) {
                fileStructureTree += `${indent}${entry.name}/\n`;
                await traverseDirectory(fullPath, indent + '  ');
            } else if (entry.isFile()) {
                if (excludedFiles.includes(entry.name)) {
                    continue;
                }
                fileStructureTree += `${indent}${entry.name}\n`;
                const fileExtension = path.extname(entry.name).toLowerCase();

                if (!imageExtensions.includes(fileExtension)) {
                    fileContents += `\n---------- ${entry.name} ----------\n`;
                    try {
                        const fileContent = await fs.promises.readFile(fullPath, 'utf-8');
                        fileContents += `${fileContent}\n`;
                    } catch (readError) {
                        fileContents += `ERROR READING FILE: ${readError.message}\n`;
                    }
                    fileContents += `---------- END ${entry.name} ----------\n\n`;
                } else {
                     fileContents += `\n---------- ${entry.name} ----------\n`;
                     fileContents += `(Image file - content not included)\n`;
                     fileContents += `---------- END ${entry.name} ----------\n\n`;
                }
            }
        }
    }

    try {
        await traverseDirectory(projectRoot);
        const fullOutput = fileStructureTree + fileContents;

        await fs.promises.writeFile(outputFile, fullOutput);
        console.log(`Project structure and content written to ${outputFile}`);

    } catch (error) {
        console.error('An error occurred:', error);
        process.exit(1);
    }
}

// --- Main execution ---

const projectRoot = process.cwd(); // Use the current working directory
const outputFile = 'project_structure.txt';

// Check if the projectRoot exists.
fs.stat(projectRoot, (err, stats) => {
    if (err) {
        console.error(`Error: Project root directory "${projectRoot}" not found or not accessible.`);
        process.exit(1);
    }

    if (!stats.isDirectory()) {
        console.error(`Error: "${projectRoot}" is not a directory.`);
        process.exit(1);
    }

    generateProjectStructureAndContent(projectRoot, outputFile);
});
---------- END projectToFile.js ----------


---------- DailyEntryScreen.tsx ----------
//screens/DailyEntryScreen.tsx
// Import necessary modules and components
import React, { useState, useEffect, useCallback } from "react";
import { View, FlatList, Alert, Platform } from "react-native";
import { DailyEntry, DailyEntryItem } from "../types/dailyEntry";
import { Food } from "../types/food";
import { getFoods } from "../services/foodService";
import {
  saveDailyEntries,
  loadDailyEntries,
  loadSettings,
} from "../services/storageService";
import {
  formatDate,
  formatDateReadable,
  getTodayDateString,
} from "../utils/dateUtils";
import { isValidNumberInput } from "../utils/validationUtils";
import DailyProgress from "../components/DailyProgress";
import {
  Button,
  Text,
  ListItem,
  FAB,
  SearchBar,
  makeStyles,
  useTheme,
  Divider,
} from "@rneui/themed";
import DateTimePicker from "@react-native-community/datetimepicker";
import { addDays, subDays, parseISO } from "date-fns";
import { Icon } from "@rneui/base";
import { SafeAreaView } from "react-native-safe-area-context";
import AddEntryModal from "../components/AddEntryModal"; // Import
import "react-native-get-random-values";
import { v4 as uuidv4 } from "uuid";

// Define the DailyGoals interface
interface DailyGoals {
  calories: number;
  protein: number;
  carbs: number;
  fat: number;
}

// DailyEntryScreen Component
const DailyEntryScreen: React.FC = () => {
  // State variables
  const [dailyEntries, setDailyEntries] = useState<DailyEntry[]>([]);
  const [selectedDate, setSelectedDate] = useState<string>(
    getTodayDateString()
  );
  const [foods, setFoods] = useState<Food[]>([]);
  const [selectedFood, setSelectedFood] = useState<Food | null>(null);
  const [grams, setGrams] = useState("");
  const [isOverlayVisible, setIsOverlayVisible] = useState(false);
  const [search, setSearch] = useState("");
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [dailyGoals, setDailyGoals] = useState<DailyGoals>({
    calories: 2000,
    protein: 50,
    carbs: 200,
    fat: 70,
  });

  // Get theme and styles
  const { theme } = useTheme();
  const styles = useStyles();

  // Load data function (using useCallback for memoization)
  const loadData = useCallback(async () => {
    const loadedFoods = await getFoods();
    const loadedEntries = await loadDailyEntries();
    const loadedSettings = await loadSettings();

    if (loadedSettings.dailyGoals) {
      setDailyGoals((prevGoals) => ({
        ...prevGoals,
        ...loadedSettings.dailyGoals,
      }));
    }

    setFoods(loadedFoods);
    setDailyEntries(loadedEntries);
  }, []);

  // Load data on component mount
  useEffect(() => {
    loadData();
  }, [loadData]);

  // Function to get the current entry for the selected date
  const getCurrentEntry = (): DailyEntry => {
    return (
      dailyEntries.find((entry) => entry.date === selectedDate) || {
        date: selectedDate,
        items: [],
      }
    );
  };

  // Function to update and save entries
  const updateAndSaveEntries = async (updatedEntries: DailyEntry[]) => {
    await saveDailyEntries(updatedEntries);
    setDailyEntries(updatedEntries);
  };

  // Function to handle adding a new entry
  const handleAddEntry = async () => {
    if (!selectedFood || !isValidNumberInput(grams) || parseFloat(grams) <= 0) {
      Alert.alert(
        "Invalid Input",
        "Please select a food and enter a valid, positive number for grams."
      );
      return;
    }

    const newEntryItem: DailyEntryItem = {
      food: selectedFood,
      grams: parseFloat(grams),
    };
    const currentEntry = getCurrentEntry();
    const updatedItems = [...currentEntry.items, newEntryItem];
    const updatedEntry = { ...currentEntry, items: updatedItems };

    const updatedEntries = dailyEntries.filter(
      (entry) => entry.date !== selectedDate
    );
    updatedEntries.push(updatedEntry);

    await updateAndSaveEntries(updatedEntries);
    setSelectedFood(null);
    setGrams("");
    setIsOverlayVisible(false);
  };

  // Function to handle removing an entry
  const handleRemoveEntry = async (index: number) => {
    const currentEntry = getCurrentEntry();
    const updatedItems = currentEntry.items.filter((_, i) => i !== index);
    const updatedEntry = { ...currentEntry, items: updatedItems };

    const updatedEntries = dailyEntries.filter(
      (entry) => entry.date !== selectedDate
    );
    if (updatedItems.length > 0) {
      updatedEntries.push(updatedEntry);
    }

    await updateAndSaveEntries(updatedEntries);
  };

  // Toggle the visibility of the overlay
  const toggleOverlay = () => {
    setIsOverlayVisible(!isOverlayVisible);
    if (isOverlayVisible) {
      // Corrected condition
      setSearch("");
      setSelectedFood(null);
    }
  };

  // Update search text
  const updateSearch = (search: string) => setSearch(search);

  // Filter foods based on search text
  const filteredFoods = foods.filter((food) =>
    food.name.toLowerCase().includes(search.toLowerCase())
  );

  // Handle date change
  const handleDateChange = (event: any, selectedDateVal?: Date) => {
    setShowDatePicker(false);
    if (event.type === "set" && selectedDateVal) {
      setSelectedDate(formatDate(selectedDateVal));
    }
  };

  // Navigate to previous day
  const handlePreviousDay = () =>
    setSelectedDate(formatDate(subDays(parseISO(selectedDate), 1)));

  // Navigate to next day
  const handleNextDay = () =>
    setSelectedDate(formatDate(addDays(parseISO(selectedDate), 1)));

  // Handle food selection
  const handleSelectFood = (item: Food) => {
    setSelectedFood(item);
    setSearch("");
  };

  // Calculate total macros for the selected date
  const calculateTotals = () => {
    const currentEntry = getCurrentEntry();
    let [totalCalories, totalProtein, totalCarbs, totalFat] = [0, 0, 0, 0];

    currentEntry.items.forEach((item) => {
      totalCalories += (item.food.calories / 100) * item.grams;
      totalProtein += (item.food.protein / 100) * item.grams;
      totalCarbs += (item.food.carbs / 100) * item.grams;
      totalFat += (item.food.fat / 100) * item.grams;
    });

    return {
      totalCalories: Math.round(totalCalories),
      totalProtein: Math.round(totalProtein),
      totalCarbs: Math.round(totalCarbs),
      totalFat: Math.round(totalFat),
    };
  };

  // Destructure calculated totals
  const { totalCalories, totalProtein, totalCarbs, totalFat } =
    calculateTotals();

  // Return the JSX for the DailyEntryScreen
  return (
    <SafeAreaView style={styles.container}>
      {/* Date Navigation */}
      <View style={styles.dateNavigation}>
        <Button
          type="clear"
          onPress={handlePreviousDay}
          icon={
            <Icon name="arrow-back" type="ionicon" color={theme.colors.text} />
          }
        />
        <Text style={styles.dateText} onPress={() => setShowDatePicker(true)}>
          {formatDateReadable(selectedDate)}
        </Text>
        <Button
          type="clear"
          onPress={handleNextDay}
          icon={
            <Icon
              name="arrow-forward"
              type="ionicon"
              color={theme.colors.text}
            />
          }
        />
      </View>

      {/* Date Picker (conditional rendering) */}
      {showDatePicker && (
        <DateTimePicker
          value={parseISO(selectedDate)}
          mode="date"
          display="default"
          onChange={handleDateChange}
        />
      )}

      {/* Daily Progress Component */}
      <DailyProgress
        calories={totalCalories}
        protein={totalProtein}
        carbs={totalCarbs}
        fat={totalFat}
        goals={dailyGoals}
      />
      <Divider style={styles.divider} />

      {/* Entries Section */}
      <Text h4 style={[styles.sectionTitle, { color: theme.colors.text }]}>
        Entries:
      </Text>
      <FlatList
        data={getCurrentEntry().items}
        keyExtractor={(_, index) => index.toString()}
        renderItem={({ item, index }) => (
          <ListItem
            bottomDivider
            containerStyle={{ backgroundColor: theme.colors.background }}
          >
            <Icon
              name="nutrition-outline"
              type="ionicon"
              color={theme.colors.text}
            />
            <ListItem.Content>
              <ListItem.Title style={{ color: theme.colors.text }}>
                {item.food.name}
              </ListItem.Title>
              <ListItem.Subtitle
                style={{ color: theme.colors.text }}
              >{`${item.grams}g`}</ListItem.Subtitle>
            </ListItem.Content>
            <Button
              type="clear"
              onPress={() => handleRemoveEntry(index)}
              icon={<Icon name="trash" type="ionicon" color="red" />}
            />
          </ListItem>
        )}
      />

      {/* Add Entry FAB */}
      <FAB
        icon={<Icon name="add" color="white" />}
        color={theme.colors.primary}
        onPress={toggleOverlay}
        placement="right"
        title="Add"
      />

      {/* Add Entry Modal */}
      <AddEntryModal
        isVisible={isOverlayVisible}
        toggleOverlay={toggleOverlay}
        search={search}
        updateSearch={updateSearch}
        filteredFoods={filteredFoods}
        handleSelectFood={handleSelectFood}
        grams={grams}
        setGrams={setGrams}
        handleAddEntry={handleAddEntry}
        selectedFood={selectedFood}
      />
    </SafeAreaView>
  );
};

// StyleSheet using makeStyles
const useStyles = makeStyles((theme) => ({
  container: {
    flex: 1,
    backgroundColor: theme.colors.background,
  },
  dateNavigation: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    marginVertical: 10,
    paddingHorizontal: 10,
  },
  dateText: {
    fontSize: 18,
    fontWeight: "bold",
    color: theme.colors.text,
  },
  divider: {
    marginVertical: 10,
  },
  sectionTitle: {
    marginBottom: 10,
    paddingHorizontal: 10,
  },
}));

// Export the component
export default DailyEntryScreen;

---------- END DailyEntryScreen.tsx ----------


---------- FoodListScreen.tsx ----------
// screens/FoodListScreen.tsx (Corrected with keyof Omit)
import React, { useState, useEffect } from "react";
import { View, FlatList, Alert, Platform } from "react-native";
import { createFood, getFoods, updateFood, deleteFood } from "../services/foodService";
import { Food } from "../types/food";
import { isValidNumberInput, isNotEmpty } from "../utils/validationUtils";
import FoodItem from "../components/FoodItem";
import { Button, SearchBar, useTheme, makeStyles } from "@rneui/themed";
import { FAB } from "@rneui/base";
import { SafeAreaView } from "react-native-safe-area-context";
import AddFoodModal from "../components/AddFoodModal";

const FoodListScreen: React.FC = () => {
 const [foods, setFoods] = useState<Food[]>([]);
 const [isOverlayVisible, setIsOverlayVisible] = useState(false);
 const [search, setSearch] = useState("");
 const [newFood, setNewFood] = useState<Omit<Food, "id">>({
     name: "",
     calories: 0,
     protein: 0,
     carbs: 0,
     fat: 0,
 });
 const [editFood, setEditFood] = useState<Food | null>(null);
 const [errors, setErrors] = useState<{ [key: string]: string }>({});
 const { theme } = useTheme();
 const styles = useStyles();

 const loadFoodData = async () => {
     const loadedFoods = await getFoods();
     setFoods(loadedFoods);
 };

 useEffect(() => {
     loadFoodData();
 }, []);

 const validateFood = (food: Omit<Food, "id">) => {
     const newErrors: { [key: string]: string } = {};
     if (!isNotEmpty(food.name || '')) newErrors.name = "Name is required";
     if (!isValidNumberInput(String(food.calories))) newErrors.calories = "Invalid input";
     if (!isValidNumberInput(String(food.protein))) newErrors.protein = "Invalid input";
     if (!isValidNumberInput(String(food.carbs))) newErrors.carbs = "Invalid input";
     if (!isValidNumberInput(String(food.fat))) newErrors.fat = "Invalid input";

     return Object.keys(newErrors).length === 0 ? null : newErrors;
 };

 const handleCreateFood = async () => {
     const validationErrors = validateFood(newFood);
     if (validationErrors) {
         setErrors(validationErrors);
         return;
     }
     setErrors({});
     try {
         const createdFood = await createFood(newFood);
         setFoods([...foods, createdFood]);
         setNewFood({ name: "", calories: 0, protein: 0, carbs: 0, fat: 0 });
         setIsOverlayVisible(false);
     } catch (error) {
         Alert.alert("Error", "Failed to create food.");
     }
 };

 const handleUpdateFood = async () => {
     if (!editFood) return;
     const validationErrors = validateFood(editFood);
     if (validationErrors) {
         setErrors(validationErrors);
         return;
     }
     setErrors({});
     try {
         const updated = await updateFood(editFood);
         setFoods(foods.map((f) => (f.id === updated.id ? updated : f)));
         setEditFood(null);
         setIsOverlayVisible(false);
     } catch (error) {
         Alert.alert("Error", "Failed to update food.");
     }
 };

 const handleDeleteFood = async (foodId: string) => {
     await deleteFood(foodId);
     setFoods(foods.filter((f) => f.id !== foodId));
 };

 const toggleOverlay = (food?: Food) => {
     if (food) {
       setEditFood(food);
       setNewFood({ name: "", calories: 0, protein: 0, carbs: 0, fat: 0 });
     } else {
         setEditFood(null);
         setNewFood({ name: "", calories: 0, protein: 0, carbs: 0, fat: 0 });
     }
     setErrors({});
     setIsOverlayVisible(!isOverlayVisible);
 };

 const updateSearch = (search: string) => setSearch(search);
 const filteredFoods = foods.filter((food) => food.name.toLowerCase().includes(search.toLowerCase()));

 const handleInputChange = (key: keyof Omit<Food, "id">, value: string) => { // Corrected type
     const updatedFood = editFood
         ? { ...editFood, [key]: key === "name" ? value : parseFloat(value) || 0 }
         : { ...newFood, [key]: key === "name" ? value : parseFloat(value) || 0 };

     if (editFood) {
         setEditFood(updatedFood as Food);
     } else {
         setNewFood(updatedFood);
     }
 };

 return (
     <SafeAreaView style={styles.container}>
         <SearchBar
             placeholder="Search Foods..."
             onChangeText={updateSearch}
             value={search}
             platform={Platform.OS === "ios" ? "ios" : "android"}
             containerStyle={styles.searchBarContainer}
             inputContainerStyle={[styles.searchBarInputContainer, { backgroundColor: theme.colors.grey5 }]}
             inputStyle={{ color: theme.colors.text }}
         />
         <FlatList
             data={filteredFoods}
             keyExtractor={(item) => item.id}
             renderItem={({ item }) => (
                 <FoodItem food={item} onEdit={toggleOverlay} onDelete={handleDeleteFood} />
             )}
         />

         <FAB
             icon={{ name: "add", color: "white" }}
             color={theme.colors.primary}
             onPress={() => toggleOverlay()}
             placement="right"
             title="Add"
         />

         <AddFoodModal
             isVisible={isOverlayVisible}
             toggleOverlay={toggleOverlay}
             newFood={newFood}
             editFood={editFood}
             errors={errors}
             handleInputChange={handleInputChange}
             handleCreateFood={handleCreateFood}
             handleUpdateFood={handleUpdateFood}
             validateFood={validateFood}
         />
     </SafeAreaView>
 );
};

const useStyles = makeStyles((theme) => ({
 container: {
     flex: 1,
     backgroundColor: theme.colors.background,
 },
 searchBarContainer: {
     backgroundColor: "transparent",
     borderBottomColor: "transparent",
     borderTopColor: "transparent",
     marginBottom: 10,
     padding: 0,
 },
 searchBarInputContainer: {
     borderRadius: 10,
 },
}));

export default FoodListScreen;
---------- END FoodListScreen.tsx ----------


---------- SettingsScreen.tsx ----------
// screens/SettingsScreen.tsx (Modified to use onDataOperation)
import React, { useState, useEffect, useCallback } from "react";
import { View, ScrollView, Alert } from "react-native";
import { Text, makeStyles } from "@rneui/themed";
import DailyGoalsInput from "../components/DailyGoalsInput";
import DataManagementButtons from "../components/DataManagementButtons";
import ThemeSwitch from "../components/ThemeSwitch";
import StatisticsChart from "../components/StatisticsChart";
import { loadSettings, saveSettings, loadDailyEntries } from "../services/storageService";
import {
Settings,
Statistics,
MacroType,
MacroData
} from "../types/settings"; // Import types from settings

import { parseISO, isBefore } from "date-fns";
import { formatDate } from "../utils/dateUtils";
import { useTheme } from "@rneui/themed";
import { DailyEntry } from "../types/dailyEntry";


interface SettingsScreenProps {
  onThemeChange: (theme: 'light' | 'dark' | 'system') => void;
    onDataOperation: () => void; // Add this
}


const SettingsScreen: React.FC<SettingsScreenProps> = ({ onThemeChange, onDataOperation }) => {
    const [settings, setSettings] = useState<Settings>({
        theme: "system",
        dailyGoals: {
          calories: 2000,
          protein: 50,
          carbs: 200,
          fat: 70,
        },
    });

  const [statistics, setStatistics] = useState<Statistics>({
    calories: [],
    protein: [],
    carbs: [],
    fat: [],
  });
  const [settingsHistory, setSettingsHistory] = useState<
    { date: string; settings: Settings }[]
  >([]);

  const { theme } = useTheme();
  const styles = useStyles();

  const loadInitialSettings = useCallback(async () => {
    const loadedSettings = await loadSettings();
    const loadedSettingsHistory = loadedSettings?.settingsHistory || []; // Handle potentially undefined settingsHistory

    setSettings((prevSettings) => ({
      ...prevSettings,
      ...loadedSettings,
      dailyGoals: {
        ...prevSettings.dailyGoals,
        ...(loadedSettings?.dailyGoals || {}),
      },
    }));
    setSettingsHistory(loadedSettingsHistory);
  }, []);

  useEffect(() => {
    loadInitialSettings();
  }, [loadInitialSettings]);


    const handleGoalChange = (goalType: MacroType, value: string) => {
      const numericValue = parseFloat(value) || 0;
      const updatedGoals = { ...settings.dailyGoals, [goalType]: numericValue };

      setSettings((prevSettings) => {
        const updatedSettings: Settings = {
          ...prevSettings,
          dailyGoals: updatedGoals,
        };

        // Update settings history
        const newSettingsHistory = [
          ...settingsHistory,
          { date: formatDate(new Date()), settings: updatedSettings },
        ];
        saveSettings({ ...updatedSettings, settingsHistory: newSettingsHistory }); // Save history
        setSettingsHistory(newSettingsHistory);

        return updatedSettings;
      });
  };

    const handleDataCleared = async () => {
        // try {
        //   await loadInitialSettings(); // Reload settings and clear inputs
        //   // Reset statistics, *then* reload entries (to avoid double loading)
        //   setStatistics({
        //     calories: [],
        //     protein: [],
        //     carbs: [],
        //     fat: [],
        //   });
        //   setSettingsHistory([]);
        //   const loadedEntries = await loadDailyEntries(); // Reload to get empty entries
        //   updateStatistics(loadedEntries, settingsHistory)
        // } catch (error) {
        //   Alert.alert("Error", "Failed to clear data.");
        // }
        onDataOperation();
    };

      const getStatisticsData = useCallback((
        dailyEntries: DailyEntry[],
        macro: MacroType,
        settingsHistory: { date: string; settings: Settings }[]
      ) => {
        const intakeData = dailyEntries
          .map((entry) => {
            const entryDate = parseISO(entry.date);
            // Find the settings that were in effect *on that date*
            const relevantSettings = settingsHistory
              .filter((sh) => !isBefore(entryDate, parseISO(sh.date))) // Filter out future settings
              .sort((a, b) => parseISO(b.date).getTime() - parseISO(a.date).getTime())[0]?.settings ?? settings; // Get most recent, fallback to current

            const intakeValue = entry.items.reduce(
              (total, item) => total + (item.food[macro] / 100) * item.grams,
              0
            );
            const goalValue = relevantSettings.dailyGoals?.[macro] ?? 0; // Default to 0 if undefined

            return {
              x: entryDate.getTime(), // Convert date to timestamp
              y: intakeValue,
              goal: goalValue,
            };
          })
          .sort((a, b) => a.x - b.x);

          const intakeSeries: MacroData[] = intakeData.map(item => ({ x: item.x, y: item.y }));

          if (macro === "calories") {
              const goalSeries: MacroData[] = intakeData.map(item => ({ x: item.x, y: item.goal }));
              return [intakeSeries, goalSeries]; // Return *both* series
            } else {
              return [intakeSeries]; // Only intake for other macros
            }
      }, [settings]);


  const updateStatistics = useCallback((loadedEntries: DailyEntry[], settingsHistory: { date: string; settings: Settings }[]) => {
        setStatistics({
            calories: getStatisticsData(loadedEntries, "calories", settingsHistory),
            protein: getStatisticsData(loadedEntries, "protein", settingsHistory),
            carbs: getStatisticsData(loadedEntries, "carbs", settingsHistory),
            fat: getStatisticsData(loadedEntries, "fat", settingsHistory),
        });
    }, [getStatisticsData]);

  useEffect(() => {
        const loadStatistics = async () => {
            const loadedEntries = await loadDailyEntries();
            updateStatistics(loadedEntries, settingsHistory);
        };
        loadStatistics();
  }, [settingsHistory, updateStatistics]);


 return (
    <ScrollView style={styles.container}>
      <Text h3 style={[styles.sectionTitle, { color: theme.colors.text }]}>
        General
      </Text>
      <ThemeSwitch
        currentTheme={settings.theme} // Pass the current theme mode
        onToggle={onThemeChange} // Directly pass onThemeChange
      />

      <Text h3 style={[styles.sectionTitle, { color: theme.colors.text }]}>
        Daily Goals
      </Text>
      <DailyGoalsInput
        dailyGoals={settings.dailyGoals}
        onGoalChange={handleGoalChange}
      />

      <Text h3 style={[styles.sectionTitle, { color: theme.colors.text }]}>
        Statistics
      </Text>
      <StatisticsChart statistics={statistics} />

      <Text h3 style={[styles.sectionTitle, { color: theme.colors.text }]}>
        Data Management
      </Text>
      {/* Pass onDataOperation to DataManagementButtons */}
      <DataManagementButtons onDataOperation={onDataOperation} />
    </ScrollView>
  );
};

const useStyles = makeStyles((theme) => ({
    container: {
        flex: 1,
        padding: 10,
        backgroundColor: theme.colors.background
    },
    sectionTitle: {
        marginTop: 20,
        marginBottom: 10,
    },
    button: {
        marginBottom: 10,
    },
}));

export default SettingsScreen;
---------- END SettingsScreen.tsx ----------


---------- foodService.ts ----------
// services/foodService.ts (No significant changes)
import { Food } from '../types/food';
import { saveFoods, loadFoods } from './storageService';
import 'react-native-get-random-values';
import { v4 as uuidv4 } from 'uuid';

export const createFood = async (foodData: Omit<Food, 'id'>): Promise<Food> => {
  const newFood: Food = {
    id: uuidv4(),
    ...foodData,
  };
  const foods = await loadFoods();
  foods.push(newFood);
  await saveFoods(foods);
  return newFood;
};

export const getFoods = async (): Promise<Food[]> => {
  return loadFoods();
};

export const updateFood = async (updatedFood: Food): Promise<Food> => {
  const foods = await loadFoods();
  const index = foods.findIndex((f) => f.id === updatedFood.id);
  if (index === -1) {
    throw new Error('Food not found');
  }
  foods[index] = updatedFood;
  await saveFoods(foods);
  return updatedFood;
};

export const deleteFood = async (foodId: string): Promise<void> => {
  const foods = await loadFoods();
  const filteredFoods = foods.filter((f) => f.id !== foodId);
  await saveFoods(filteredFoods);
};
---------- END foodService.ts ----------


---------- storageService.ts ----------
// services/storageService.ts
import AsyncStorage from '@react-native-async-storage/async-storage';
import { DailyEntry } from '../types/dailyEntry';
import { Food } from '../types/food';
import { Settings } from '../types/settings'; // Import Settings from types


const DAILY_ENTRIES_KEY = 'dailyEntries';
const FOODS_KEY = 'foods';
const SETTINGS_KEY = 'settings';

export const saveDailyEntries = async (entries: DailyEntry[]): Promise<void> => {
  try {
    await AsyncStorage.setItem(DAILY_ENTRIES_KEY, JSON.stringify(entries));
  } catch (error) {
    console.error('Error saving daily entries:', error);
    throw error;
  }
};

export const loadDailyEntries = async (): Promise<DailyEntry[]> => {
  try {
    const entriesJson = await AsyncStorage.getItem(DAILY_ENTRIES_KEY);
    return entriesJson ? JSON.parse(entriesJson) : [];
  } catch (error) {
    console.error('Error loading daily entries:', error);
    return [];
  }
};

export const saveFoods = async (foods: Food[]): Promise<void> => {
  try {
    await AsyncStorage.setItem(FOODS_KEY, JSON.stringify(foods));
  } catch (error) {
    console.error('Error saving foods:', error);
    throw error;
  }
};

export const loadFoods = async (): Promise<Food[]> => {
  try {
    const foodsJson = await AsyncStorage.getItem(FOODS_KEY);
    return foodsJson ? JSON.parse(foodsJson) : [];
  } catch (error) {
    console.error('Error loading foods:', error);
    return [];
  }
};

// export interface Settings {  // REMOVE THIS DUPLICATE INTERFACE
//   theme: 'light' | 'dark' | 'system';
//   dailyGoals?: {
//     calories?: number;
//     protein?: number;
//     carbs?: number;
//     fat?: number;
//   };
//   settingsHistory?: { date: string; settings: Settings }[]; // Add this line
// }

export const saveSettings = async (settings: Settings): Promise<void> => {
  try {
    await AsyncStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
  } catch (error) {
    console.error('Error saving settings:', error);
    throw error;
  }
};

export const loadSettings = async (): Promise<Settings> => {
  try {
    const settingsJson = await AsyncStorage.getItem(SETTINGS_KEY);
const loadedSettings = settingsJson ? JSON.parse(settingsJson) : {};

// Apply defaults and ensure structure
const defaultSettings: Settings = {
  theme: 'system',
  dailyGoals: { calories: 2000, protein: 50, carbs: 200, fat: 70 },
  settingsHistory: [] // Ensure settingsHistory exists
};


return {
  ...defaultSettings, // Start with defaults
    ...loadedSettings, // Override with loaded values
    dailyGoals: {
       ...defaultSettings.dailyGoals,  //ensure no fields missing from daily goals
        ...(loadedSettings.dailyGoals || {}) // And override *those* with any loaded dailyGoals
    }
}

  } catch (error) {
    console.error('Error loading settings:', error);
// Return defaults if loading fails
return {
  theme: 'system',
  dailyGoals: { calories: 2000, protein: 50, carbs: 200, fat: 70 },
  settingsHistory: [] // Ensure settingsHistory exists in default
};
  }
};

export const clearAllData = async (): Promise<void> => {
  try {
    await AsyncStorage.clear();
  } catch (error) {
    console.error('Error clearing data:', error);
    throw error;
  }
};
---------- END storageService.ts ----------


---------- tsconfig.json ----------
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true

  }
}
---------- END tsconfig.json ----------


---------- dailyEntry.ts ----------
// types/dailyEntry.ts
import { Food } from "./food";

export interface DailyEntryItem {
  food: Food;
  grams: number;
}

export interface DailyEntry {
  date: string; // YYYY-MM-DD format
  items: DailyEntryItem[];
  goals?: {  // Optional goals
    calories?: number;
    protein?: number;
    carbs?: number;
    fat?: number;
  };
}

export interface FoodItem {
    id: string;
    name: string;
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
  }
---------- END dailyEntry.ts ----------


---------- food.ts ----------
// types/food.ts
export interface Food {
    id: string;
    name: string;
    calories: number;
    protein: number;
    carbs: number;
    fat: number;
  }
---------- END food.ts ----------


---------- settings.ts ----------
// types/settings.ts

import { DailyEntry } from "./dailyEntry";

export const macros = ["calories", "protein", "carbs", "fat"] as const;
export type MacroType = (typeof macros)[number];

export interface MacroData {
  x: number; // Timestamp
  y: number; // Macro value
}

export interface Statistics {
  calories: MacroData[][];
  protein: MacroData[][];
  carbs: MacroData[][];
  fat: MacroData[][];
}

export interface Settings {
  theme: "light" | "dark" | "system";
  dailyGoals: {
    [key in MacroType]: number;
  };
  settingsHistory?: { date: string; settings: Settings }[]; // Make settingsHistory optional
}


export interface SettingsScreenProps {
  onThemeChange: (theme: "light" | "dark" | "system") => void;
}
---------- END settings.ts ----------


---------- dateUtils.ts ----------
// utils/dateUtils.ts
import { format, parseISO } from 'date-fns';

export const formatDate = (date: Date | string): string => {
  if (typeof date === 'string') {
    date = parseISO(date);
  }
  return format(date, 'yyyy-MM-dd');
};

export const formatDateReadable = (date: Date | string): string => {
    if (typeof date === 'string') {
        date = parseISO(date);
    }
    return format(date, 'MMMM dd, yyyy');
}

export const getTodayDateString = (): string => {
  return formatDate(new Date());
};
---------- END dateUtils.ts ----------


---------- validationUtils.ts ----------
// utils/validationUtils.ts

export const isValidNumberInput = (value: string): boolean => {
    return /^[0-9]*(\.[0-9]*)?$/.test(value) && !isNaN(parseFloat(value));
  };
  
  export const isNotEmpty = (value: string): boolean => {
    return value.trim() !== '';
  };
---------- END validationUtils.ts ----------

